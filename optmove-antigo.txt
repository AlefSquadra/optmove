

===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/UDModuleMP.h =====
//---------------------------------------------------------------------------
#ifndef UDModuleMPH
#define UDModuleMPH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <DB.hpp>
//#include <Data.SqlExpr.hpp>
#include <Data.FMTBcd.hpp>
#include <System.DateUtils.hpp>
#include <USmartPointer.h>
#include <Data.DBXOracle.hpp>
#include <Vcl.Forms.hpp>
//#include "UFAguarde.h"
//#include "UUTeis.h"
#include "UTPEnums.h"
#include <Data.SqlExpr.hpp>
//#include "FTimerInfo.h"
#define BEGIN_TRAN \
BeginTransaction();
#define COMMIT \
Commit();
#define   ROLLBACK \
Rollback();
#ifndef BOOST_THREAD_USE_LIB
#define BOOST_THREAD_USE_LIB

extern "C"
{
	 namespace boost
	 {
			void tss_cleanup_implemented( void )
			{
				 /*
				 This function's sole purpose is to cause a link error in cases where
				 automatic tss cleanup is not implemented by Boost.Threads as a
				 reminder that user code is responsible for calling the necessary
				 functions at the appropriate times (and for implementing an a
				 tss_cleanup_implemented() function to eliminate the linker's
				 missing symbol error).

				 If Boost.Threads later implements automatic tss cleanup in cases
				 where it currently doesn't (which is the plan), the duplicate
				 symbol error will warn the user that their custom solution is no
				 longer needed and can be removed.*/
			}
	 }
}
#endif
 namespace boost {
    class thread_group;
		namespace asio {
				class io_service;


		}
}
 class TTheadResultado;
  class CriticalSection
  {
  public:
      CriticalSection()
      {
          ::InitializeCriticalSection(&m_cs);
      }

      ~CriticalSection()
      {
          ::DeleteCriticalSection(&m_cs);
      }

      void acquire()
      {
          ::EnterCriticalSection(&m_cs);
      }

      void release()
      {
          ::LeaveCriticalSection(&m_cs);
      }

  private:
      CriticalSection(const CriticalSection&);
      CriticalSection& operator=(const CriticalSection&);

      CRITICAL_SECTION m_cs;
  };
 class TDModuleSQLQuery : public TSQLQuery
 {
   public:
   __fastcall  TDModuleSQLQuery(System::Classes::TComponent* AOwner);
   __fastcall virtual ~TDModuleSQLQuery(void);
 };
 class TDModuleStoredProc : public TSQLStoredProc
  {
  public:
    __fastcall TDModuleStoredProc(System::Classes::TComponent* AOwner) : TSQLStoredProc(AOwner)
    {
    }
    __fastcall virtual ~TDModuleStoredProc(void);
  };
typedef Ptr<TDModuleSQLQuery> PtrQuery;
typedef Ptr<TDModuleStoredProc> PtrStoredProc;
//---------------------------------------------------------------------------
// variavel instanciada no .cpp
extern  CriticalSection InitDMLock;
class TDModuleMP : public TDataModule
{
__published:	// IDE-managed Components
  TSQLConnection *db;
  TSQLMonitor *SQLMonitor1;
  TSQLConnection *dbAQ;
  void __fastcall dbAfterConnect(TObject *Sender);
  void __fastcall dbAQAfterConnect(TObject *Sender);
//---------------------------------------------------------------------------
private:	// User declarations
  int transactionLevel;
  int transactionLevelAQ;
//  TTransactionDesc TD;
//  TTransactionDesc TDAQ;
Data::Dbxcommon::TDBXTransaction* TD;
Data::Dbxcommon::TDBXTransaction* TDAQ;
  	__fastcall TDModuleMP(TComponent* Owner);
//
//  static TDModuleMP * instance;
//---------------------------------------------------------------------------
public:		// User declarations
  __fastcall ~TDModuleMP(void);
  void ActivateUserDB(bool pDBAQ = false);
  void ReconectDB(String DB_SCHEMA, String DB_INSTANCE,String DB_PWD_CORE, String DB_USR_SRV);
  void BeginTransaction(bool pDBAQ = false);
  void Commit(bool pDBAQ = false);
  void Rollback(bool pDBAQ = false);
  void __fastcall TDBXErrorEvent(TDBXError *erro);
  static TDModuleMP* getInstance(TComponent* Owner);
  String dmUser;
  String dmDB;
  String dmPWD;
  String dmAmbiente;
  TStringList* GlobalRota_;
};
extern  BeginTransaction(bool pDBAQ);
extern  Commit(bool pDBAQ);
extern  Rollback(bool pDBAQ);
//---------------------------------------------------------------------------
PtrQuery newQuery(bool pDBAQ = false);
PtrStoredProc newStoredProc(bool pDBAQ = false);
void KillConnection(bool pDBAQ = false);
//---------------------------------------------------------------------------
void Informacao(String informacao);
bool Confirme(String pergunta);
int ConfirmeCancelar(String pergunta);
void Alerta(String alerta);
//void StartAguarde(String mensagem);
void Aguarde(String mensagem, bool isModal = true, int timeESC = 0);
void AguardeSetMensagem(String mensagem);
void AguardeSetAllowCancelUserRequest(bool pValor);
bool AguardeGetAllowCancelUserRequest();
void AguardeSetCancelUserRequest(bool pValor);
bool AguardeGetCancelUserRequest();
void AguardeSetEnableCancelUserRequestByTime(int pValor);
void StopAguarde(String mensagem = EmptyStr);
void workerThreadClient(boost::asio::io_service* service, TTheadResultado* result);
void CloseAguarde();
void AguardeSetProgress(double pValor);
TTPResultTimerInfo InformacaoTimer(String informacao, String acao);
//---------------------------------------------------------------------------
extern PACKAGE TDModuleMP *DModuleMP;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/OptMove.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop
#include <tchar.h>
#include "UDModuleMP.h"

#include <Midas.hpp>
#pragma comment(lib, "midas.lib")

#pragma warn -8022
#include <gdiplus.h>
#pragma warn .8022
#pragma comment (lib,"Gdiplus.lib")
#pragma comment (lib,"ServerLib")
extern "C" __stdcall DllGetDataSnapClassObject(REFCLSID, REFIID, void **);

#include <DSIntf.hpp>
// ---------------------------------------------------------------------------
#define  NO_STRICT
//---------------------------------------------------------------------------
USEFORM("Classes\Forms\UFPriorizacaoMovimentos.cpp", FormPriorizacaoMovimentos);
USEFORM("Classes\Forms\UFPrincipal.cpp", FormPrincipal);
USEFORM("Classes\Forms\UFPontosFila.cpp", FormPontosFila);
USEFORM("Classes\Forms\UFParametrosSistema.cpp", FormParametrosSistema);
USEFORM("Classes\Forms\UFPaineis.cpp", formPaineis);
USEFORM("Classes\Forms\UFPriorizarDestino.cpp", FormPriorizarDestinos);
USEFORM("Classes\Forms\UFTestes.cpp", formTestes);
USEFORM("Classes\Forms\UFResultadoProcessos.cpp", FormResultadoProcessos);
USEFORM("Classes\Forms\UFRestricao.cpp", FormRestricao);
USEFORM("UDModuleMP.cpp", DModuleMP); /* TDataModule: File Type */
USEFORM("Classes\Forms\FWidgetBase.cpp", FormWidgetBase);
USEFORM("Classes\Forms\FTV.cpp", FormTV);
USEFORM("Classes\Forms\FTP.cpp", FormTP);
USEFORM("Classes\Forms\FTimerInfo.cpp", formTimerInfo);
USEFORM("Classes\Forms\FSelecionarOficializacao.cpp", FormSelecionarOficializacao);
USEFORM("Classes\Forms\FWidgetDebug.cpp", FormWidgetDebug);
USEFORM("Classes\Forms\FWidgetGridGradeTrens.cpp", FormWidgetGridGradeTrens);
USEFORM("Classes\Forms\FWidgetGridBase.cpp", FormWidgetGridBase);
USEFORM("Classes\Forms\FWidgetGridAtividadesAlteradas.cpp", FormWidgetGridAtividadesAlteradas);
USEFORM("Classes\Forms\FWidgetGanttOcupacao.cpp", FormWidgetGanttOcupacao);
USEFORM("Classes\Forms\FWidgetFarolIntrajornada.cpp", FormWidgetFarolIntrajornada);
USEFORM("Classes\Forms\FGridBase.cpp", FormGridBase);
USEFORM("Classes\Forms\FDebugConflito.cpp", Form1);
USEFORM("Classes\Forms\FWidgetGridMonitoramentoEntrePlanos.cpp", FormWidgetGridDiferencasEntrePlanos);
USEFORM("Classes\Forms\UFGatilhos.cpp", formGatilhos2);
USEFORM("Classes\Forms\UFFilasViewer.cpp", FormFilasViewer);
USEFORM("Classes\Forms\UFFilas.cpp", FormFilas);
USEFORM("Classes\Forms\UFFichaTrem.cpp", FormFichaTrem);
USEFORM("Classes\Forms\UFEditarMovimento.cpp", FormEditarMovimento);
USEFORM("Classes\Forms\UFGradeTrens.cpp", FormGradeTrens);
USEFORM("Classes\Forms\UFOrdemTremViewer.cpp", FormOrdemTremViewer);
USEFORM("Classes\Forms\UFOrdemTrem.cpp", formOrdemTrem);
USEFORM("Classes\Forms\UFMovimentosTrem.cpp", FormMovimentosTrem);
USEFORM("Classes\Forms\UFDetalharPontosFila.cpp", FormDetalharPontosFila);
USEFORM("Classes\Forms\UFAlertaTrensTabelaBusca.cpp", FormAlertaTrensTabelaBusca);
USEFORM("Classes\Forms\UFAguarde.cpp", FormAguarde);
USEFORM("Classes\Forms\MDIParent.cpp", MDIParentForm);
USEFORM("Classes\Forms\MDIChild.cpp", MDIChildForm);
USEFORM("Classes\Forms\FWidgetTrem.cpp", FormWidgetTrem);
USEFORM("Classes\Forms\UFAtividadesTrem.cpp", FormAtividadesTrem);
USEFORM("Classes\Forms\UFDadosLoginReconexao.cpp", FDadosLoginReconexao);
USEFORM("Classes\Forms\UFCriarTrem.cpp", FormCriarTrem);
USEFORM("Classes\Forms\UFCriarAtividadeTrem.cpp", FormCriarAtividadeTrem);
USEFORM("Classes\Forms\UFControleLogsIntegracao.cpp", FormControleLogs);
USEFORM("Classes\Forms\UFControleAcesso.cpp", FormControleAcesso);
//---------------------------------------------------------------------------
int WINAPI _tWinMain(HINSTANCE, HINSTANCE, LPTSTR, int)
{
  using namespace Gdiplus;
  try
  {
   // #pragma startup InitMidas 254
     RegisterMidasLib(DllGetDataSnapClassObject);

     HMODULE hw = GetModuleHandleA("GdiPlus.dll");
     if (!hw)
     {
      // while( FreeLibrary(hw));
      hw = LoadLibrary(L"R:\\OptMove\\Desenvol\\Dependencias\\gdiplus.dll");
      if(!hw)
      {
        throw Exception("No foi possvel carregar GdiPlus.dll");
      }
      int para =0;
     }
     Gdiplus::GdiplusStartupInput gdiplusStartupInput;
     ULONG_PTR gdiplusToken;
      // Initialize GDI+.
     Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

     Application->CreateForm(__classid(TformPaineis), &formPaineis);
		Application->Run();
  }
  catch (Exception &exception)
  {
    Application->ShowException(&exception);
  }
  catch (...)
  {
    try
    {
      throw Exception("");
    }
    catch (Exception &exception)
    {
      Application->ShowException(&exception);
    }
  }
  return 0;
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/UDModuleMP.cpp =====
// ---------------------------------------------------------------------------

#include <iostream>
#pragma hdrstop
#pragma warn -8012
#include <boost/thread.hpp>
#include <boost/asio.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/bind.hpp>
#pragma warn .8012
#include "UDModuleMP.h"
#include "UFAguarde.h"
#include "UFormsManager.h"
#include "FTimerInfo.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)
//#pragma classgroup "System.Classes.TPersistent"
#pragma comment(lib, "DBXDevartOracleDriver290.lib")
#pragma link "DbxDevartOracle"
#pragma resource "*.dfm"


#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

//criando a instancia do .h
CriticalSection InitDMLock;
TDModuleMP *DModuleMP = 0;
__fastcall TDModuleMP::TDModuleMP(TComponent* Owner) : TDataModule(Owner)
		

{
  try
  {
    transactionLevel  = 0;
  
		FormAguarde = new TFormAguarde(Owner, "Iniciando DataModule.");
		FormAguarde->Show();
    FormAguarde->Hide();

  }
  catch (Exception& e)
  {
    std::wcout << "Erro TdataModuleJobLog - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
    system("pause");
#endif
    throw;
  }

}
TDModuleMP * TDModuleMP::getInstance (TComponent* Owner)
{
  if(NULL == DModuleMP)
  {
    InitDMLock.acquire();

    if(NULL == DModuleMP)
    {
      DModuleMP=new TDModuleMP(Owner);
    }
    InitDMLock.release();

  }

  return DModuleMP;
}
__fastcall  TDModuleMP::~TDModuleMP(void)
{
  try
  {
    InitDMLock.acquire();
    if (DModuleMP->db)
    {
      if (DModuleMP->db->Connected)
      {
        DModuleMP->db->CloseDataSets();

        DModuleMP->db->LoginPrompt = false;
        DModuleMP->db->Connected   = false;
        DModuleMP->db->Params->Clear();
        DModuleMP->db->Close();

      }
      delete DModuleMP->db;
      DModuleMP->db = NULL;
    }
    if (DModuleMP->dbAQ) {

      if (DModuleMP->dbAQ->Connected)
      {
        DModuleMP->dbAQ->CloseDataSets();

        DModuleMP->dbAQ->LoginPrompt = false;
        DModuleMP->dbAQ->Connected   = false;
        DModuleMP->dbAQ->Params->Clear();
        DModuleMP->dbAQ->Close();
      }
      delete DModuleMP->dbAQ;
      DModuleMP->dbAQ = NULL;
    }
//   ESTA LIMPEZA  FEITA AUTOMATICO AO FECHAR APLICACAO com este codigo descomentado apresenta erro ao fechar.
//    if (FormAguarde)
//    {
//      delete FormAguarde;
//    FormAguarde = NULL;
//    }
  }
  __finally
  {
    try {

        InitDMLock.release();
      } catch (...) {
    }

  }
}
// ---------------------------------------------------------------------------
void TDModuleMP::ActivateUserDB(bool pDBAQ)
{
using namespace algorithm;
  try
  {
    if (!pDBAQ)
    {
      if (DModuleMP->db->Connected)
      {
        return;
      }

      String senha;
      DModuleMP->db->Connected   = false;
      DModuleMP->db->LoginPrompt = false;
      DModuleMP->db->Params->Clear();

      String usuario = algorithm::CoreTMPlanner::getInstance()->DB_USR_GHP;
      dmDB           = algorithm::CoreTMPlanner::getInstance()->DB_INSTANCE;
      dmAmbiente     = algorithm::CoreTMPlanner::getInstance()->DB_SCHEMA;
      senha          = algorithm::CoreTMPlanner::getInstance()->DB_PWD_GHP;

      DModuleMP->db->Params->Add("Database=" + dmDB);
      DModuleMP->db->Params->Add("User_Name=" + usuario);
      DModuleMP->db->Params->Add("Password=" + senha);

      DModuleMP->db->Params->Add("RowsetSize=20");
      DModuleMP->db->Params->Add("BlobSize=-1");
      DModuleMP->db->Params->Add("ErrorResourceFile=");
      DModuleMP->db->Params->Add("LocaleCode=0000");
      DModuleMP->db->Params->Add("Oracle TransIsolation=ReadCommited");
      DModuleMP->db->Params->Add("Reconnect=false");
      DModuleMP->db->ConnectionName = "ORACLECONNECTION";

      DModuleMP->db->DriverName    = "DevartOracle";
      DModuleMP->db->LibraryName   = "dbexpoda41.dll";
      DModuleMP->db->GetDriverFunc = "getSQLDriverORA";

      /*
       DModuleMP->db->DriverName = "Oracle";
       DModuleMP->db->LibraryName = "dbxora.dll";
       DModuleMP->db->GetDriverFunc = "getSQLDriverORACLE";
       */

      DModuleMP->db->VendorLib = "oci.dll";

      DModuleMP->db->Connected = true;
      DModuleMP->db->DBXConnection->OnErrorEvent = &this->TDBXErrorEvent;
    }
    else
    {
      if (DModuleMP->dbAQ->Connected)
      {
        return;
      }

      DModuleMP->dbAQ->Connected = false;
      DModuleMP->dbAQ->LoginPrompt = false;
      DModuleMP->dbAQ->Params->Clear();
      String DBAq  = algorithm::CoreTMPlanner::getInstance()->DB_INSTANCE_SNC;
      String DBUSR = algorithm::CoreTMPlanner::getInstance()->DB_USR_SNC;
      String senha = algorithm::CoreTMPlanner::getInstance()->DB_PWD_SNC;

      DModuleMP->dbAQ->Params->Add("Database=" + DBAq);
      DModuleMP->dbAQ->Params->Add("User_Name=" + DBUSR);
      DModuleMP->dbAQ->Params->Add("Password=" + senha);
      DModuleMP->dbAQ->Params->Add("RowsetSize=20");
      DModuleMP->dbAQ->Params->Add("BlobSize=-1");
      DModuleMP->dbAQ->Params->Add("ErrorResourceFile=");
      DModuleMP->dbAQ->Params->Add("LocaleCode=0000");
      DModuleMP->dbAQ->Params->Add("Oracle TransIsolation=ReadCommited");

      DModuleMP->dbAQ->ConnectionName = "ORACLECONNECTION";

      DModuleMP->dbAQ->DriverName    = "DevartOracle";
      DModuleMP->dbAQ->LibraryName   = "dbexpoda40.dll";
      DModuleMP->dbAQ->GetDriverFunc = "getSQLDriverORA";

      DModuleMP->dbAQ->VendorLib = "oci.dll";

      DModuleMP->dbAQ->Connected = true;
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro ActivateUserDB - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }

  /*
   ////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////////


   //Desenvolvimento
   AnsiString Parte2 = "94";
   AnsiString Parte1 = "52";
   AnsiString Parte4 = "";
   AnsiString Parte3 = "70";
   AnsiString Parte0 = "IG";
   AnsiString Parte5 = "45";
   AnsiString Parte6 = "70";
   AnsiString Parte7 = "29";
   AnsiString JoinPartesD = Parte1 + Parte2 + Parte3 + Parte4;

   //Producao
   Parte2 = "R1";
   Parte1 = "m@";
   Parte4 = "07";
   Parte3 = "N3";
   Parte0 = "ST";
   Parte5 = "25";
   Parte6 = "83";
   Parte7 = "33";
   AnsiString JoinPartesP = Parte1 + Parte2 + Parte3 + Parte4;

   //Producao Login Automatico
   Parte2 = "js";
   Parte1 = "ui";
   Parte4 = "mo";
   Parte3 = "ke";
   Parte5 = "lz";
   Parte6 = "sw";

   AnsiString JoinPartesPA = Parte1 + Parte2 + Parte3 + Parte4 + Parte5 + Parte6;

   PtrQuery qrRole = newQuery();
   if( banco.UpperCase() == "ORAJFD12") {
   qrRole->SQL->Text = "SET ROLE R_TOM IDENTIFIED BY \"" + JoinPartesD + "\" ";
   } else {
   #ifdef LOGIN_AUTO_GP
   qrRole->SQL->Text = "SET ROLE R_TOM_SELECT IDENTIFIED BY \"" + JoinPartesPA +  "\" ";
   #else
   qrRole->SQL->Text = "SET ROLE R_TOM IDENTIFIED BY \"" + JoinPartesP +  "\" ";
   #endif
   }
   qrRole->ExecSQL();
   */
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////

}

  void TDModuleMP::ReconectDB(String DB_SCHEMA, String DB_INSTANCE,String DB_PWD_CORE, String DB_USR_SRV)
  {

    String senha;

    DModuleMP->db->CloseDataSets();
    DModuleMP->db->LoginPrompt = false;
    DModuleMP->db->Connected   = false;

    DModuleMP->db->Params->Clear();
    DModuleMP->db->Close();

    //delete DModuleMP->db;
    //DModuleMP->db = new TSQLConnection(this);

    String usuario = DB_USR_SRV;
    dmDB           = DB_INSTANCE;
    dmAmbiente     = DB_SCHEMA;
    senha          = DB_PWD_CORE;

    DModuleMP->db->Params->Add("Database=" + dmDB);
    DModuleMP->db->Params->Add("User_Name=" + usuario);
    DModuleMP->db->Params->Add("Password=" + senha);

    DModuleMP->db->Params->Add("RowsetSize=20");
    DModuleMP->db->Params->Add("BlobSize=-1");
    DModuleMP->db->Params->Add("ErrorResourceFile=");
    DModuleMP->db->Params->Add("LocaleCode=0000");
    DModuleMP->db->Params->Add("Oracle TransIsolation=ReadCommited");
    DModuleMP->db->Params->Add("Reconnect=false");
    DModuleMP->db->ConnectionName = "ORACLECONNECTION";

    DModuleMP->db->DriverName    = "DevartOracle";
    DModuleMP->db->LibraryName   = "dbexpoda40.dll";
    DModuleMP->db->GetDriverFunc = "getSQLDriverORA";

    /*
     DModuleMP->db->DriverName = "Oracle";
     DModuleMP->db->LibraryName = "dbxora.dll";
     DModuleMP->db->GetDriverFunc = "getSQLDriverORACLE";
     */

    DModuleMP->db->VendorLib = "oci.dll";

    DModuleMP->db->Connected = true;
    DModuleMP->db->DBXConnection->OnErrorEvent = &this->TDBXErrorEvent;
  }

// ---------------------------------------------------------------------------
__fastcall TDModuleSQLQuery::TDModuleSQLQuery(System::Classes::TComponent* AOwner): TSQLQuery(AOwner)
{
}
__fastcall TDModuleSQLQuery::~TDModuleSQLQuery()
{

  try
    {
      this->CloseCursor();
      this->CloseStatement();
    }
     catch (Exception &e)
    {

      String err = "Erro ao encerrar a query: ";
      err += e.Message;
      // OutputDebugString(err.c_str());
    }
    catch (...)
    {

      DWORD dwLastError = GetLastError();
      String err        = "Erro ao encerrar a query: erro code ";
      err += AnsiString(dwLastError);
      // OutputDebugString(err.c_str());
    }
}
PtrQuery newQuery(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      TDModuleSQLQuery* t_qr     = new TDModuleSQLQuery(NULL);
      t_qr->SQLConnection = DModuleMP->db;
      return PtrQuery(t_qr);
    }
    else
    {
      TDModuleSQLQuery* t_qr     = new TDModuleSQLQuery(NULL);
      t_qr->SQLConnection = DModuleMP->dbAQ;

      return PtrQuery(t_qr);
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro newQuery - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }
}

// ---------------------------------------------------------------------------
__fastcall TDModuleStoredProc::~TDModuleStoredProc()
{

  while (this->Params->Count > 0)
  {
    TParam * p = this->Params->Items[0];
    p->Clear();
    p->Free();

  }
}
PtrStoredProc newStoredProc(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      TDModuleStoredProc* t_sp = new TDModuleStoredProc(DModuleMP);
      t_sp->SQLConnection  = DModuleMP->db;
      return PtrStoredProc(t_sp);
    }
    else
    {
      TDModuleStoredProc* t_sp = new TDModuleStoredProc(DModuleMP);
      t_sp->SQLConnection  = DModuleMP->dbAQ;
      return PtrStoredProc(t_sp);
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro newStoredProc - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }
}

// ---------------------------------------------------------------------------
void KillConnection(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      DModuleMP->db->Close();
      DModuleMP->db->Connected   = false;
      DModuleMP->db->LoginPrompt = false;
      DModuleMP->db->Params->Clear();
    }
    else
    {
      DModuleMP->dbAQ->Close();
      DModuleMP->dbAQ->Connected   = false;
      DModuleMP->dbAQ->LoginPrompt = false;
      DModuleMP->dbAQ->Params->Clear();
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro KillConnection - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }
}

// ---------------------------------------------------------------------------
void TDModuleMP::BeginTransaction(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      if (!db->InTransaction)
      {
        TD = db->BeginTransaction();
        transactionLevel = 1;
      }
      else
      {
        transactionLevel++;
      }
    }
    else
    {
      if (!dbAQ->InTransaction)
      {
        TDAQ = dbAQ->BeginTransaction();
        transactionLevelAQ = 1;
      }
      else
      {
        transactionLevelAQ++;
      }
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro BeginTransaction - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }

}

// ---------------------------------------------------------------------------
void TDModuleMP::Commit(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      if (db->InTransaction)
      {
        if (--transactionLevel == 0)
        {
          db->CommitFreeAndNil(TD); // commit the changes
        }
      }
    }
    else
    {
      if (dbAQ->InTransaction)
      {
        if (--transactionLevelAQ == 0)
        {
          dbAQ->CommitFreeAndNil(TD); // commit the changes
        }
      }
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro Commit - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }
}

// ---------------------------------------------------------------------------
void TDModuleMP::Rollback(bool pDBAQ)
{
  try
  {
    if (!pDBAQ)
    {
      if (db->InTransaction)
      {
        db->RollbackFreeAndNil(TD); // undo the changes
        transactionLevel = 0;
      }
    }
    else
    {
      if (dbAQ->InTransaction)
      {
        dbAQ->RollbackFreeAndNil(TDAQ); // undo the changes
        transactionLevelAQ = 0;
      }
    }
  }
  catch (Exception& e)
  {
    try
    {
      std::wcout << "Erro Rollback - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    throw;
  }
}

// ---------------------------------------------------------------------------
void workerThreadClient(boost::asio::io_service* service, TTheadResultado *result)
{
  try
  {
    service->run();
  }
  catch(Exception &e)
	{
    result->Resultado = e.Message;
    result->Status = terErro;
  }
  catch (boost::system::system_error & e)
  {
    result->Resultado = e.what();
    result->Status = terErro;
  }
  catch(...)
  {
    result->Resultado = "Erro indeterminado";
    result->Status = terErro;
  }
}

// ---------------------------------------------------------------------------
void Informacao(String informacao)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspTeste)
    return;
  Application->MessageBox(informacao.c_str(), Application->Title.c_str(), MB_OK | MB_ICONINFORMATION | MB_SYSTEMMODAL);
}

// ---------------------------------------------------------------------------
bool Confirme(String pergunta)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspTeste)
    return true;
  return Application->MessageBox(pergunta.c_str(), Application->Title.c_str(),
    MB_YESNO | MB_ICONQUESTION | MB_SYSTEMMODAL) == IDYES;
}
// ---------------------------------------------------------------------------
int ConfirmeCancelar(String pergunta)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspTeste)
    return 1;
  return Application->MessageBox(pergunta.c_str(), Application->Title.c_str(),
    MB_YESNOCANCEL | MB_ICONQUESTION | MB_SYSTEMMODAL);
}
// ---------------------------------------------------------------------------
void Alerta(String alerta)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspTeste)
    return;
  Application->MessageBox(alerta.c_str(), Application->Title.c_str(), MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
}

// ---------------------------------------------------------------------------
void Aguarde(String mensagem, bool isModal, int timeESC)
{
  try
  {
    if (FormAguarde)
    {
      // aguarde = new TFormAguarde(NULL, mensagem);
      FormAguarde->PopupMode   = pmExplicit;
      FormAguarde->PopupParent = NULL;
      if(timeESC > 0)
      {
        AguardeSetEnableCancelUserRequestByTime(timeESC);
      }
      else
      {
        FormAguarde->SetAllowCancelUserRequest(false);
      }
      if(isModal)
      {
        if(FormAguarde->Visible)
          FormAguarde->Visible = false;
        TUteis::gravarLog("--X Set Mensagem");
        FormAguarde->SetMensagem(mensagem);
        TUteis::gravarLog("--X Incio Show MODAL");
        FormAguarde->ShowModal();
//        aguarde->BringToFront();
        TUteis::gravarLog("--X Fim Show");
      }
      else
      {
        //if(!aguarde->Visible)
        //	aguarde->Visible = true;
        TUteis::gravarLog("--X Set Mensagem ShowLikeModal");
        FormAguarde->SetMensagem(mensagem);
        TUteis::gravarLog("--X Incio Show");
        FormAguarde->ShowLikeModal();
      }
      //
      // delete aguarde;
      // aguarde = NULL;
      }
    }
  catch(...)
  {
    Aguarde(mensagem, isModal);
  }
}

// ---------------------------------------------------------------------------
void AguardeSetMensagem(String mensagem)
{
  if (FormAguarde)
  {
    FormAguarde->SetMensagem(mensagem);
  }
}

// ---------------------------------------------------------------------------
void CloseAguarde()
{
 FormAguarde->Visible = false;
}

void StopAguarde(String mensagem)
{
  if (FormAguarde)
  {
    if (mensagem.Length() > 0)
    {
      FormAguarde->SetMensagem(mensagem);
      FormAguarde->Refresh();
    }
#ifdef MODO_MULT_THREAD
    while (!FormAguarde->isShow)
    {
      Sleep(100);
    }
#endif
    FormAguarde->Cancelar();
    FormAguarde->Close();
  }

  int parar = 0;
}

// ---------------------------------------------------------------------------
void AguardeSetAllowCancelUserRequest(bool pValor)
{
  if (FormAguarde)
    FormAguarde->AllowCancelUserRequest = pValor;
}

// ---------------------------------------------------------------------------
void AguardeSetCancelUserRequest(bool pValor)
{
  if (FormAguarde)
  {
    FormAguarde->CancelUserRequest = pValor;
  }
}

// ---------------------------------------------------------------------------
bool AguardeGetCancelUserRequest()
{
  if (FormAguarde)
    return FormAguarde->CancelUserRequest;
  else
    return false;
}

// ---------------------------------------------------------------------------
void AguardeSetProgress(double pValor)
{
   if (FormAguarde)
    FormAguarde->SetProgressUpdate(pValor);
}
// ---------------------------------------------------------------------------
bool AguardeGetAllowCancelUserRequest()
{
  if (FormAguarde)
  {
    return FormAguarde->AllowCancelUserRequest;
  }

  return true; //netto
}

// ---------------------------------------------------------------------------
void AguardeSetEnableCancelUserRequestByTime(int pValor)
{
  if (FormAguarde)
  {
    FormAguarde->SetEnableCancelUserRequestByTime(pValor);
  }
}

// ---------------------------------------------------------------------------

void __fastcall TDModuleMP::TDBXErrorEvent(TDBXError *erro)
{
  try
  {
    String msgerro = erro->Message.SubString(0,9) ;
    if  (msgerro == "ORA-00028" || msgerro == "ORA-01041" || msgerro == "ORA-02396" || msgerro == "ORA-03114"
      || msgerro == "ORA-01000" || msgerro == "ORA-01001" || msgerro == "ORA-00604"
      || msgerro == "ORA-01012" || msgerro == "ORA-03113" || msgerro == "ORA-01033"
      || msgerro == "ORA-04061" || msgerro == "ORA-04065"
      || msgerro == "ORA-01034" || msgerro == "ORA-02701"|| msgerro == "ORA-00060")
    {
    db->Connected = false;
    db->Connected = true;
//      this-> CheckConnection(eReconnect);
    }
  }
  catch(Exception &e )
  {
#ifdef DEBUG_DBPOOL
    String msg =L"ERRO CheckConnection  " + e.Message;
      OutputDebugString(msg.c_str());
#endif
  }
}
// ---------------------------------------------------------------------------
void __fastcall TDModuleMP::dbAfterConnect(TObject *Sender)
{
  db->DBXConnection->OnErrorEvent = &this->TDBXErrorEvent;
  PtrQuery qrSession   = newQuery();
  qrSession->SQL->Text = "alter session set nls_date_format = 'dd/mm/yyyy hh24:mi:ss'";
  qrSession->ExecSQL();

  qrSession->SQL->Text = "alter session set nls_numeric_characters = ',.'";
  qrSession->ExecSQL();

  qrSession->SQL->Text = "ALTER SESSION SET CURRENT_SCHEMA=" + dmAmbiente;
  qrSession->ExecSQL();

}
// ---------------------------------------------------------------------------

void __fastcall TDModuleMP::dbAQAfterConnect(TObject *Sender)
{
  PtrQuery qrSession   = newQuery(true);
  qrSession->SQL->Text = "alter session set nls_date_format = 'dd/mm/yyyy hh24:mi:ss'";
  qrSession->ExecSQL();

  qrSession->SQL->Text = "alter session set nls_numeric_characters = ',.'";
  qrSession->ExecSQL();
}
// ---------------------------------------------------------------------------

TTPResultTimerInfo InformacaoTimer(String informacao, String acao)
{
 TformTimerInfo* formInfoTimer =  new  TformTimerInfo(0,informacao,acao);

 formInfoTimer->ShowModal();
 TTPResultTimerInfo resultado = formInfoTimer->Result;
 delete formInfoTimer;
 return resultado;

}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/pchOptmovePrj.h =====
/*
  This precompiled header include file was generated on 27/11/2024 22:35:10 by 
  the RAD Studio Precompiled Header Wizard with the following settings:

  Project: C:\Users\CT002642\Documents\Repos\Optmove\Desenvolvimento\TP_GHP\OptMove.cbproj
  AllowUnguarded = 0
  ExcludeProjectFiles = 0
  IncludePathsOn = -1
  IncludePaths = 
  ExcludePaths = 
  IncludeCount = 20
  ManageHeader = -1
  Excluded = $(BDS)\include\windows\sdk\gdiplus.h
  Included = Classes\Forms\FTP.h
  Included = Classes\Forms\UFControleLogsIntegracao.h
  Included = C:\Program Files (x86)\DevExpress\VCL\Library\RS29\Cxcontrols.hpp
  Included = $(BDS)\include\windows\sdk\windows.h
  Included = Classes\Model\UMPPAT.h
  Included = Classes\Model\USB.h
  Included = Classes\Series\UTPTremSeries.h
*/

#ifndef pchOptmovePrj_H
#define pchOptmovePrj_H
#define D2D_USE_C_DEFINITIONS
#define __UIA_OtherConstants_MODULE_DEFINED__
#include <vcl.h>
#include "UDModuleMP.h"
#include "Classes\Forms\UFormsManager.h"
//#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "Classes\Model\UTPItinerarioTrem.h"
#include "Classes\Model\UTPSB.h"
#include "Classes\Model\UTPRestricao.h"
#include "Classes\Model\UTPMovimento.h"
//#include <cxGridDBTableView.hpp>
//#include "Classes\Forms\FTP.h"
//#include "Classes\Forms\UFControleLogsIntegracao.h"
//#include <VCLTee.Chart.hpp>
//#include "Classes\Series\UTPMovimentoSeries.h"
#include <Vcl.Buttons.hpp>
#include <schannel.h>

#include <cxContainer.hpp>
#include <cxEdit.hpp>
#include <Cxtextedit.hpp>
#include <Cxhint.hpp>
#include <dxScreenTip.hpp>
#include <Vcl.Imaging.GIFImg.hpp>
#include <Cxcontrols.hpp>
#include <Cxdata.hpp>
#include <Cxdbdata.hpp>
#include <Cxgrid.hpp>
#include <Cxgridbandedtableview.hpp>
#include <cxDataControllerConditionalFormattingRulesManagerDialog.hpp>
#include <windows.h>
#include <sstream>
#include <stdlib.h>
//#include <boost/thread/mutex.hpp>
#include <list>
#include "Classes\Model\UMPPAT.h"
#include "Classes\Model\USB.h"
#include <map>
#include <VCLTee.series.hpp>
//#include "Classes\Series\UTPChartShapeBase.h"
#include <Cxcalendar.hpp>
#include <Cxcheckbox.hpp>
#include <Cxbuttons.hpp>
//#include "Classes\Series\UTPTremSeries.h"
#include <Cxdropdownedit.hpp>



#include <System.hpp>
#include <SysInit.hpp>
#include <Winapi.Windows.hpp>
#include <Winapi.Messages.hpp>
#include <System.SysUtils.hpp>
#include <System.Classes.hpp>
#include <System.Generics.Collections.hpp>
#include <System.UITypes.hpp>
#include <System.Generics.Defaults.hpp>
#include <System.Types.hpp>
#include <Vcl.ExtCtrls.hpp>
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/UTPEnums.cpp =====
//---------------------------------------------------------------------------

#pragma hdrstop

#include "UTPEnums.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/UTPEnums.h =====
//---------------------------------------------------------------------------

#ifndef UTPEnumsH
#define UTPEnumsH
//---------------------------------------------------------------------------
enum EnumSentidoGrafico
{
    strDescendo = 0,
    strSubindo = 1,
};

enum TTPTipoLegendaSB { tlpControlador = 0, tlpPlanejador, tlpPatio };

enum TTPTipoFormatacaoCampoDataHora{ tfdData = 1, tfdHora = 2, tfdDuracao = 3 };

enum TTPSentidoHint {shSubindo = -1, shDescendo = 0};

enum TTPTipoLog {tplNormal = 0, tplAlerta = 1, tplGrave = 2, tplCritico = 3};

enum TTPResultTimerInfo{ rtiRestart = 1, rtiCancel= 2 };

enum TTPTipoSerie
{
  tsDesconhecido = 0, tsMovimento, tsObservacao, tsRestricao, tsPrefixo, tsSB, tsLinhaDupla, tsLinhaTempo, tsConflito,
  tsAderenciaFila, tsPointer
};

enum TTPTipoSelecao
{
  tselSemSelecao = 0, tselTrem, tselMovimento, tselRestricao
};
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPCriarTremSeries.h =====
//---------------------------------------------------------------------------

#ifndef UTPCriarTremSeriesH
#define UTPCriarTremSeriesH
//---------------------------------------------------------------------------
#include <VCLTee.Series.hpp>

class TTPCriaTremSeries : public TLineSeries
{
private:
  void ConfigurarSerie();
  TColor CorSerie_;
  bool Arrastou_;
  bool Arrastando_;

protected:
  TDateTime DataHoraInicio_;
  TDateTime DataHoraFim_;
  double LocalizacaoInicio_;
  double LocalizacaoFim_;

public:
  __fastcall TTPCriaTremSeries(System::Classes::TComponent* AOwner, double pX, double pY);
  void __fastcall DrawValue(int ValueIndex);
  void __fastcall DoSeriesMouseMove(System::Classes::TShiftState Shift, int X, double Y);
  void __fastcall DoSeriesMouseUp(Controls::TMouseButton Button, System::Classes::TShiftState Shift, int X, double Y);
  void Arrastar(double X, double Y);
  bool GetArrastou();
  void setDataHoraIncio(TDateTime pDataHora);
  TDateTime getDataHoraIncio();
  void setLocalizacaoInicio(double pLocalizacao);
  int getLocalizacaoInicio();
  void setDataHoraFim(TDateTime pDataHora);
  TDateTime getDataHoraFim();
  void setLocalizacaoFim(double pLocalizacao);
  int getLocalizacaoFim();

};
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPHintSeries.h =====
// ---------------------------------------------------------------------------

#ifndef UTPHintSeriesH
#define UTPHintSeriesH
#include "cxClasses.hpp"
#include "cxHint.hpp"
#include "dxCustomHint.hpp"
#include "dxScreenTip.hpp"
#include "dxScreenTip.hpp"
#include <VCLTee.Series.hpp>
#include "UTPObservacaoSeries.h"
#include "UTPMovimentoSeries.h"
#include "UTPRestricaoSeries.h"

#define FAROL_VERDE "ParametrosAtivos"
#define FAROL_AMARELO "ParametrosDesativadosExpiracao"
#define FAROL_VERMELHO "ParametrosDesativados"

// ---------------------------------------------------------------------------

class TTPHintSeries
{

private:
TChartSeries* SeriesHint_;

public:

  TTPHintSeries(TcxHintStyleController *hintStyleController, TdxScreenTipRepository *screenTipRepository, bool isVisualizador);
	void PreencheHint(TChartSeries* CustomSeries);
  void PreencheHintFarolParametros(String pTipoHint, TObject* pControl);
	void PreencheHint();
	void reloadDefaults();
	void ReloadHint();
  TdxScreenTipRepository *t_screenTipRepository;
  TcxHintStyleController *t_hintStyleController;
  void TTPHintSeries::clearHint(TChartSeries* CustomSeries);
  TTPTrem* trem_;
	bool isVisualizador_;
   ~TTPHintSeries();
		__property TChartSeries *SeriesHint  = {read=SeriesHint_, write =SeriesHint_};

  //observacao - 0
  //movimento - 1
  //restricao - 2
  String tituloDefaultObservacao_;
  String corpoDefaultObservacao_;
  String tituloDefaultMovimento_;
  String corpoDefaultMovimento_;
  String tituloDefaultRestricao_;
  String corpoDefaultRestricao_;
  String tituloDefaultFarol_;
  String corpoDefaultFarol_;

  String formatoDataPadrao_ ;
  String prefixoPai_;
  String pidPai;
  TDateTime previsaoFimPai_;
  TDateTime dataTremPronto_;
  String stringDataTremPronto_;
  TDateTime dataChegada_;
  String stringDataChegada_ ;
   TDateTime dataSaida_;
  String stringDataSaida_ ;
  String stringPrevisaoFimPai_;
  TDateTime atividadeDataFim_;
  String stringAtividadeDataFim_;
  int tempoPermanenciaTerminal_;
  String tremTabela_;
  TDateTime restricaoDataInicio_;
  String stringRestricaoDataInicio_;
  TDateTime restricaoDataFim_;
  String stringRestricaoDataFim_;
  String duracaoFormatadaFim_;
  String stringRestricaoDataMaxFim_;
  TDateTime restricaoDataMaxFim_;
  String stringRestricaoDataMinIni_;
  TDateTime restricaoDataMinIni_;

};

#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPPrefixoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPPrefixoSeriesH
#define UTPPrefixoSeriesH

#include <classes.hpp>

#include <VCLTee.series.hpp>
//#include "UTPTrem.h"
//#include "UTPMovimento.h"
#include "UTPDefs.h"

#include "UTPMovimentoSeries.h"

enum TTPTipoDeslocamentoPrefixo { tdpBaixo, tdpCima };
enum TTPPosicaoPrefixo { ppInicio, ppFim, ppZoom };

//---------------------------------------------------------------------------
class TTPPrefixoSeries : public TPointSeries
{
private:
   TTPTipoDeslocamentoPrefixo TipoDeslocamento_;
   bool IsVisualizador_;
   TTPPosicaoPrefixo Posicao_;
   TTPTrem* Trem_;
	 TTPMovimento* movimento_;
   bool VisivelParaImpressao_;
   void SetTremSelecionado(bool pSelecionado);
   bool GetTremSelecionado();
   //bool TemCercaEletronica_;
   bool ExibeBitola_;

public:
   __property TTPTrem* Trem = {read=Trem_};
   __property TTPTipoDeslocamentoPrefixo TipoDeslocamentoPrefixo = {read=TipoDeslocamento_};
   __fastcall TTPPrefixoSeries(System::Classes::TComponent* AOwner, TTPTrem* pTrem, bool pIsVisualizador, double pX, double pY, TTPTipoDeslocamentoPrefixo pTipoDeslocamento, TTPPosicaoPrefixo pPosicao, bool pExibeBitola, TTPMovimento* pMovimentoRef);
	 __property TTPMovimentoSeries* PrimeiraSerieTrecho = {read=GetPrimeiraSerieTrecho,write=SetPrimeiraSerieTrecho};
	 __property bool TremSelecionado = {read=GetTremSelecionado,write=SetTremSelecionado};
   __property bool VisivelParaImpressao = {read=VisivelParaImpressao_,write=VisivelParaImpressao_};
	 __property TTPPosicaoPrefixo Posicao = {read=Posicao_};
	 void ConfigurarSerie(bool layoutImpressao = false);
	 inline __fastcall virtual ~TTPPrefixoSeries(void);

protected:
	 virtual void __fastcall DrawMark(int ValueIndex, const String St, Teengine::TSeriesMarkPosition* APosition);
	 TTPMovimentoSeries* GetPrimeiraSerieTrecho();
	 void SetPrimeiraSerieTrecho(TTPMovimentoSeries* pSerie);

};
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPMovimentoSeries.cpp =====
// ---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPMovimentoSeries.h"
#include "UTPAtividade.h"
#include "UTPObservacaoSeries.h"
#include "UTPSBSeries.h"
#include "UUteis.h"
#include <stdio.h>
#include <boost/thread.hpp>
#include "UTPTrem.h"
#include "UTPTipoTrem.h"
#include "UTPFichaTrem.h"
#include "FichaTrem.h"
#include "UTPUtilsIntersection.h"
#include "UTPRestricaoSeries.h"
#include "UTPHintSeries.h"
#include "UTPEnums.h"
#include "../domain/SegmentoTremOficializado.h"
#include <../domain/MetaMalha.h>
#include <../domain/TrechoEquipagemMalha.h>
#include <../domain/TrechoEquipagemTrem.h>
#include <../domain/TremMalha.h>
#include <../domain/Equipagem.h>
#include <../domain/RamalMalha.h>
#include "UFormsManager.h"
#include "UTPItinerarioTrem.h"
#include "UTPMovimento.h"
#include "UTPSB.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)
// ---------------------------------------------------------------------------


const double LINHA_SELECIONADA = 2;
const int CLICK_TOLERANCE = 3;

// ---------------------------------------------------------------------------
__fastcall TTPPointerSeries::~TTPPointerSeries()
{
  // isFree = true;
  // TTPFormsManager::getInstance()->contPD++;
  // TTPFormsManager::getInstance()->saldoP--;

  serieMovimento->Pointer = NULL;
}

// ---------------------------------------------------------------------------
__fastcall TTPPointerSeries::TTPPointerSeries(TChart* chart, TTPMovimentoSeries* pSerieMovimento) : TPointSeries(chart)
{
  isFree = false;
  // TTPFormsManager::getInstance()->contP++;
  // TTPFormsManager::getInstance()->saldoP++;
  chart->AddSeries(this);
  serieMovimento = pSerieMovimento;
  this->OnDblClick = DoSeriesMouseDblClick;
  this->Tag = tsPointer;
}

// ---------------------------------------------------------------------------
void __fastcall TTPPointerSeries::DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
          TShiftState Shift, int X, int Y)
{
  if (serieMovimento)
  {
    serieMovimento->SetTremSelecionado(true);
    TTPFormsManager::getInstance()->SetMovimentoTremSelecionado(serieMovimento->Trem);
  }
}

// ---------------------------------------------------------------------------
__fastcall TTPMovimentoSeries::~TTPMovimentoSeries()
{
  try
  {
    if (!inDelete_)
    {
      inDelete_ = true;
      if (this->hint)
        this->hint->clearHint(this);

      if (serieSelecao_)
      {
        serieSelecao_->ParentChart->RemoveSeries(serieSelecao_);
        delete serieSelecao_;
        serieSelecao_= NULL;
      }
      if (seriePrincipal_)
      {
        if (seriePrincipal_->serieSelecao_ == this)
        {
          seriePrincipal_->serieSelecao_ =NULL;
        }

      }

        if (YValueMovimentos_)
        {
          while( YValueMovimentos_->Count > 0)
          {
            double* ValuesYPos = (double*)YValueMovimentos_->Objects[0];

            YValueMovimentos_->Delete(0);
            delete [] ValuesYPos;
          }
          delete this->YValueMovimentos_ ;
          this->YValueMovimentos_ = NULL;
        }


        if (XValueMovimentos_)
        {
          while( XValueMovimentos_->Count > 0)
          {
            double* ValuesYPos = (double*)XValueMovimentos_->Objects[0];

            XValueMovimentos_->Delete(0);
            delete [] ValuesYPos;
          }
          delete this->XValueMovimentos_ ;
          this->XValueMovimentos_ = NULL;
        }


      
      if (ListaOportunidades)
      {
        for(int r=0; r< ListaOportunidades->Count; r++)
        {
          TTPMovimentoSeries *serieSelecaoOportunidade = (TTPMovimentoSeries *)ListaOportunidades->Objects[r];
          serieSelecaoOportunidade->ParentChart->RemoveSeries(serieSelecaoOportunidade);
        }
        delete ListaOportunidades;
        ListaOportunidades = NULL;
      }

      if (Pointer)
      {
        if (Pointer->ParentChart)
          Pointer->ParentChart->RemoveSeries(Pointer);
        delete Pointer;
      }

      if (TTPFormsManager::getInstance()->MovimentosSerieMouseOver == this)
        TTPFormsManager::getInstance()->MovimentosSerieMouseOver = NULL;
      if (owners_)
      {
        owners_->Clear();
        delete owners_;
        owners_ = NULL;
      }

      if (serieAderencia_)
      {
        if (serieAderencia_->ParentChart)
          serieAderencia_->ParentChart->RemoveSeries(serieAderencia_);
        delete serieAderencia_;
        serieAderencia_ = NULL;
      }

      if (seriesObservacao_)
      {
        while (this->seriesObservacao_->Count > 0)
        {
          TTPObservacaoSeries *serieObservacao = (TTPObservacaoSeries*)this->seriesObservacao_->Objects[0];
          try
          {
            if (serieObservacao->ParentChart)
              serieObservacao->ParentChart->RemoveSeries(serieObservacao);

            serieObservacao->MovimentoSerie = NULL;
            delete serieObservacao;
          }
          catch (...)
          {

          }
          this->seriesObservacao_->Delete(0);
        }
      }
      delete seriesObservacao_;

      if (movimentos_)
      {
        for (int i = 0; i < movimentos_->Count; i++)
        {
          TTPMovimento* tMovimento = (TTPMovimento*) movimentos_->Objects[i];
          // int indexS = 	tMovimento->Series->IndexOf(this);

          // tMovimento->Series->Delete()
          if (tMovimento)
          {
            tMovimento->Serie = NULL;
            if (tMovimento->Series)
              tMovimento->Series->Clear();
          }
        }

        movimentos_->Clear();
        delete movimentos_;
        movimentos_ = NULL;
      }

      TTPFormsManager::getInstance()->contMD++;
      TTPFormsManager::getInstance()->saldoM--;
    }
  }
  catch (...)
  {
    int i = 0;
  }
}

// ---------------------------------------------------------------------------
__fastcall TTPMovimentoSeries::TTPMovimentoSeries(TChart* chart, TTPTrem* pTrem, TTPMovimento* pMovimento, TTPHintSeries* t_hint, bool pIsOportunidadeSelecionada) : TFastLineSeries(chart)
{
  // Srie Movimento Seleo
  isMovimentoSelecao_ = true;
  chart->AddSeries(this);
   inDelete_ = false;
  this->hint = t_hint;

  this->YValues->Order = loNone;
  this->XValues->Order = loNone;
  isOportunidadeSelecionada_ = pIsOportunidadeSelecionada;
  this->Color =  isOportunidadeSelecionada_ ? COR_OPORTUNIDADE_SELECIONADA : COR_MOVIMENTO_SELECIONADO;

  this->Visible = true;

  ClickTolerance = 0;

  serieSelecao_ = NULL;
  ListaOportunidades = NULL;
  seriePrincipal_ = NULL;
  Pointer = new TTPPointerSeries(chart, this);

  trem_ = pTrem;

  this->movimentos_ = new TXStringList();
  this->seriesObservacao_ = new TXStringList();
  this->movimentos_->Duplicates = System::Types::dupAccept;

  this->YValueMovimentos_ = new TXStringList();
  this->XValueMovimentos_ = new TXStringList();
  this->YValueMovimentos_->Duplicates = System::Types::dupAccept;
  this->XValueMovimentos_->Duplicates = System::Types::dupAccept;

  // hint_ = TTPFormsManager::getInstance()->Hint;
  // if (movimento_)
  ///		isArrastavel_ = !trem_->IsSuprimido && (movimento_->SB->TipoVisao == "LD" || (movimento_->SB->Linhas > 1 && movimento_->SB->TipoVisao != "PD"));
  // Ptio Desvio - Ptio que contm duas linhas, mas que se conectam em seguimentos diferentes

  serieAderencia_ = NULL;
  movimento_ = pMovimento;

  ConfigurarSerie(false);

  this->OnDblClick = DoSeriesMouseDblClick;

}

// ---------------------------------------------------------------------------
__fastcall TTPMovimentoSeries::TTPMovimentoSeries(TChart* chart, TTPTrem* pTrem, TTPMovimento* pMovimento, TTPHintSeries* t_hint) : TFastLineSeries(chart)
{
  this->hint = t_hint;
  inDelete_ = false;
  isSimulado_ = false;
  isMovimentoSelecao_ = false;
  isOportunidadeSelecionada_ = false;

  TTPFormsManager::getInstance()->contM++;
  TTPFormsManager::getInstance()->saldoM++;

  seriePrincipal_ = NULL;

  trem_ = pTrem;
  movimento_ = pMovimento;

  this->serieSelecao_ = new TTPMovimentoSeries(chart, pTrem, movimento_, t_hint, false);
  ListaOportunidades = new TStringList();

  serieSelecao_->seriePrincipal_ = this;

  chart->AddSeries(this);

  TStringList *RGB = new TStringList();
  RGB->Delimiter = ',';
  RGB->CommaText = pTrem->TipoTrem->RGBCores;

  fCorSerie_.Red = RGB->Strings[0].ToInt();
  fCorSerie_.Green = RGB->Strings[1].ToInt();
  fCorSerie_.Blue = RGB->Strings[2].ToInt();

  if (pMovimento->Serie != NULL)
    delete pMovimento->Serie;


  this->YValues->Order = loNone;
  this->XValues->Order = loNone;

  this->Color = TGIFColorMap::RGB2Color(fCorSerie_);

  ColorEachPoint = true;

  // if(!pMovimento->IsRealizado)
  Pointer = new TTPPointerSeries(chart, this);
  chart->AddSeries(this->Pointer);
  // else
  // Pointer = NULL;

  ConfigurarSerie(false);

  this->Visible = true;

  this->OnMouseEnter = DoSeriesMouseEnter;
  this->OnMouseLeave = DoSeriesMouseLeave;
  this->OnDblClick = DoSeriesMouseDblClick;

  Pointer->ClickTolerance = 0;

  isTransposicao_ = false;

  indexSelected_ = -1;

  delete RGB;

  owners_ = new TXStringList();

  // serieMovimentoAnterior_ = NULL;
  // serieMovimentoPosterior_ = NULL;
  serieMovimentoSimulado_ = NULL;

  this->movimentos_ = new TXStringList();
  this->movimentos_->Duplicates = System::Types::dupAccept;

  this->YValueMovimentos_ = new TXStringList();
  this->XValueMovimentos_ = new TXStringList();
  this->YValueMovimentos_->Duplicates = System::Types::dupAccept;
  this->XValueMovimentos_->Duplicates = System::Types::dupAccept;

  this->seriesObservacao_ = new TXStringList();
  // this->Shadow->Visible = false;
  // this->Dark3D = false;
  if (this->Pointer)
  {
    this->Pointer->Shadow->Visible = false;
    this->Pointer->Dark3D = false;
  }

  // LinePen->Width = 5;
  // hint_ = TTPFormsManager::getInstance()->Hint;
  if (movimento_)
    isArrastavel_ = !trem_->IsSuprimido && (movimento_->SB->TipoVisao == "LD" || (movimento_->SB->Linhas > 1 && movimento_->SB->TipoVisao != "PD"));
  // Ptio Desvio - Ptio que contm duas linhas, mas que se conectam em seguimentos diferentes

  serieAderencia_ = NULL;
}

// ---------------------------------------------------------------------------
void TTPMovimentoSeries::ConfigurarSerie(bool layoutImpressao)
{
  indexUltimoRealizadoAntesLinhaTempo = -1;
  // Configurar Srie
  FastPen = true;
  //this->DrawAllPoints = false;
  this->IgnoreNulls = false;
  this->TreatNulls = tnDontPaint;
#ifdef _DEBUG
  // if(!isValidarConflito_ && movimento_ && !movimento_->IsRealizado && !isSimulado_ )
  // this->Pointer->Pen->Color = clFuchsia;
#endif

  this->Tag = tsMovimento;

  if (!trem_->IsSuprimido && this->Pointer)
  {
    this->Pointer->Pointer->Style = psNothing;
    this->Pointer->Visible = true;
    this->Pointer->Pointer->VertSize = 1.5;
    this->Pointer->Pointer->HorizSize = 1.5;
    this->Pointer->Pointer->Pen->Width = 0.5;

    this->ExchangePointer();
  }

  if (this->Pointer)
  {
    if(this->Pointer->Visible)
      this->Pointer->Visible = !trem_->IsSuprimido;
    if (!isMovimentoSelecao_)
    {
      this->Pointer->Pen->Color = TGIFColorMap::RGB2Color(fCorSerie_);
      this->Pointer->Color = TGIFColorMap::RGB2Color(fCorSerie_);
      this->Pointer->Pointer->Color = TGIFColorMap::RGB2Color(fCorSerie_);
      this->Pointer->LinePen->Color = TGIFColorMap::RGB2Color(fCorSerie_);
      LinePen->Style = (movimento_ != NULL && movimento_->IsRealizado ? psSolid : psDash);
    }
    else
    {
      TColor corSelecao = isOportunidadeSelecionada_ ? COR_OPORTUNIDADE_SELECIONADA : COR_MOVIMENTO_SELECIONADO;
      this->Pointer->Pen->Color = corSelecao;
      this->Pointer->Color = corSelecao;
      this->Pointer->Pointer->Color = corSelecao;
      this->Pointer->LinePen->Color = corSelecao;
      this->LinePen->Style = isOportunidadeSelecionada_ ? psDash: psSolid;
    }
    this->Pointer->Pen->Style = psDot;
    this->Pointer->Shadow->Visible = false;
  }

  ColorEachPoint = true;
  XValues->DateTime = true;
  ShowInLegend = true;
  VertAxis = aBothVertAxis;
  AllowSinglePoint = true;

  // Para reconhecer o segmento qdo o incio est no dia anterior
  CalcVisiblePoints = false;

  espessuraRealizado_ = 2;
  espessuraTremLongo_ = 2;
  espessuraPlanejado_ = 1;
  espessuraSimulado_ = 2;

  espessuraLinha_ = this->LinePen->Width;

  //this->DrawAllPoints = !movimento_->IsRealizado;
  this->DrawStyle = flAll;
  // LinePen->Style =  psSolid;
  // this->Transparency = (movimento_!= NULL && movimento_->IsRealizado ? 1:50);
  Cursor = (TCursor)crHandPoint;
  if (this->Pointer)
  {
    // this->XValues->Order = clNone;
    this->Pointer->Visible = true;
    this->Pointer->Pointer->Style = psCircle;
    this->Pointer->Pointer->Size = 3.5;
    this->Pointer->Visible = false;
    this->Pointer->ClickableLine = false;
    this->ExchangePointer();
    // FIM - Configurar Srie
  }

  this->ClickTolerance = CLICK_TOLERANCE;

  // this->TreatNulls = tnIgnore;

}

// ---------------------------------------------------------------------------
void TTPMovimentoSeries::PlotarPontos(TTPMovimento* pMovimento, double X1, double Y1, double X2, double Y2, double X3, double Y3)
{
  pontosPlotados_ = 2;
  TTPMovimento* MovimentoAnterior = NULL;
  if (movimentos_->Count > 0 && movimentos_->IndexOf(pMovimento->PID) == -1)
  {
    MovimentoAnterior = (TTPMovimento*) movimentos_->Objects[movimentos_->Count - 1];

    if (MovimentoAnterior && (MovimentoAnterior->DataChegada > pMovimento->DataChegada || MovimentoAnterior->IsRealizado != pMovimento->IsRealizado))
    {
      AddPontoNull();
    }
  }

  if (movimentos_->IndexOf(pMovimento->PID) == -1)
  {
    movimentos_->AddObject(pMovimento->PID, (TObject*)pMovimento);
    movimento_ = (TTPMovimento*) movimentos_->Objects[movimentos_->Count - 1];

    double *NewYValues = new double[3];
    NewYValues[0] = Y1;
    NewYValues[1] = Y2;
    NewYValues[2] = Y3;

    double *NewXValues = new double[3];
    NewXValues[0] = X1;
    NewXValues[1] = X2;
    NewXValues[2] = X3;

    YValueMovimentos_->AddObject(pMovimento->PID, (TObject*)NewYValues);
    XValueMovimentos_->AddObject(pMovimento->PID, (TObject*)NewXValues);

  }

  this->AddXY(X1, Y1, "", TGIFColorMap::RGB2Color(fCorSerie_));
  this->AddXY(X2, Y2, "", TGIFColorMap::RGB2Color(fCorSerie_));

  bool movimentoPosteiorIsSimulado = false;

  if(pMovimento->MovimentoPosterior && pMovimento->MovimentoPosterior->DataChegada <
     TTPFormsManager::getInstance()->Data && pMovimento->MovimentoPosterior->DataSaida < TTPFormsManager::getInstance()->Data)
    movimentoPosteiorIsSimulado = true;

  if (!this->IsSimulado || (this->IsSimulado && movimentoPosteiorIsSimulado))
    this->AddXY(X3, Y2, "", TGIFColorMap::RGB2Color(fCorSerie_));
  else
    this->AddXY(X3, Y3, "", TGIFColorMap::RGB2Color(fCorSerie_));

  if (this->Pointer && this->Pointer->XValues->Count == 0)
  {
    this->Pointer->AddXY(X1, Y1, "", TGIFColorMap::RGB2Color(fCorSerie_));
    this->Pointer->AddXY(X2, Y2, "", TGIFColorMap::RGB2Color(fCorSerie_));
    this->Pointer->AddXY(X3, Y3, "", TGIFColorMap::RGB2Color(fCorSerie_));
  }

  if(this->Pointer && 	this->Pointer->Visible)
  {
    this->Pointer->Visible =	!trem_->IsSuprimido;
  }


  if(TTPFormsManager::getInstance()->VerificaShowIntrajornada() && movimento_->ServerSegTremOficializado)
  {
     using namespace domain;

    domain::FichaTrem* t_fichaTremSrv = movimento_->ServerSegTremOficializado->getFichaTrem();
    if(t_fichaTremSrv && t_fichaTremSrv->listaEquipagensFicha)
    {
      TremMalha* trem = movimento_->ServerSegTremOficializado->getTrem();
      domain::TrechoEquipagemTrem* trechoAtivo = NULL;

      trechoAtivo = trem->getTrechoEquipagemAtivo((SegmentoTremBase*)movimento_->ServerSegTremOficializado);
      if(trechoAtivo)
      {
        TStringList* lEquipagemMovimento;
        lEquipagemMovimento = t_fichaTremSrv->listaEquipagensFicha;

        for(int i  = 0; i< trem->listaEquipagensTrem->Count ;  i++)
        {
          Equipagem* equipe = (Equipagem*) trem->listaEquipagensTrem->Objects[i];

          TStringList* tListaEquipagem = trechoAtivo->listaPatiosAtvdOportunidadesDetectadas;

          if(tListaEquipagem)
          {
            for(int g = 0; g < tListaEquipagem->Count; g++)
            {
              if(equipe->PID == tListaEquipagem->Strings[g])
              {
                SegmentoTremBase* segmentoTrem = ( SegmentoTremBase*)tListaEquipagem->Objects[g];
                if(segmentoTrem == (SegmentoTremBase*)movimento_->ServerSegTremOficializado ||
                   segmentoTrem == (SegmentoTremBase*)movimento_->ServerSegTremPlanejado ||
                   segmentoTrem == (SegmentoTremBase*)movimento_->ServerSegTremRealizado )
                {
                  addMovimentoSelecaoOportunidade(movimento_);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }

  // this->Color = TGIFColorMap::RGB2Color(fCorSerie_);
  /*
   #ifdef _DEBUG
   if (!movimento_->IsRealizado && !isSimulado_)
   {
   this->ValueColor[0] = isValidarConflito_ ? TGIFColorMap::RGB2Color(fCorSerie_) : clFuchsia;
   this->ValueColor[1] = isValidarConflito_ ? TGIFColorMap::RGB2Color(fCorSerie_) : clFuchsia;

   if (pontosPlotados_ == 3)
   this->ValueColor[2] = isValidarConflito_ ? TGIFColorMap::RGB2Color(fCorSerie_) : clFuchsia;

   this->Color = isValidarConflito_ ? TGIFColorMap::RGB2Color(fCorSerie_) : clFuchsia;
   }
   #endif

   UpdatePontosSerie(X1,Y1,X2,Y2,X3,Y3); */

   RedrawTrain();

}
// ---------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::DrawValue(int ValueIndex)
{
  DrawValue(ValueIndex, false);
}
void __fastcall TTPMovimentoSeries::DrawValue(int ValueIndex, bool isRedraw)
{
  if (!this->movimentos_)
  {
    return;
  }

  if (!this->ParentChart)
  {
    return;
  }

  if(!TTPFormsManager::getInstance()->DrawAllSeries)
  {
     int indexAnt = ValueIndex==0?0:ValueIndex-1;
     int indexPos = ValueIndex == this->XValues->Count-1?this->XValues->Count-1:ValueIndex+1;
     int pos = this->CalcXPos(ValueIndex)+this->ParentChart->Left;
     int posAnt = this->CalcXPos(indexAnt)+this->ParentChart->Left;
     int posPos = this->CalcXPos(indexPos)+this->ParentChart->Left;
     if((pos<0 && posPos<0)|| (pos>this->ParentChart->Parent->Width && posAnt>this->ParentChart->Parent->Width))
     {

       int aaa= 0;
       return;
     }
  }



  this->IgnoreNulls = false;
  this->TreatNulls = tnDontPaint;

  if (ValueIndex == 0)
    this->ClickTolerance = 0;


  if (TTPFormsManager::getInstance()->VerificaShowIntrajornada() && movimento_->ServerSegTremOficializado)
  {

    String origemIntra = movimento_->ServerSegTremOficializado->getSegmentoOcupado()->ramal->IndicadorSistemaOrigemIntraJornada;
    String origemOf = movimento_->ServerSegTremOficializado->oficializacao->getCodigoOrigemOficializacao();
    if(origemOf != origemIntra || TTPFormsManager::getInstance()->Data > movimento_->DataSaida )
    {
      this->ClickTolerance = 0;
      return;
    }
  }





  if (!TTPFormsManager::getInstance()->ExibeTremFiltroViewer(this->trem_->Prefixo))
  {
    this->ClickTolerance = 0;
    this->XValue[ValueIndex] = -100;
    this->YValue[ValueIndex] = -100;

    return;
  }
  else if (ValueIndex > 0)
  {
    this->ClickTolerance = CLICK_TOLERANCE;
  }


  if (ValueIndex / PONTOS_SERIE < this->movimentos_->Count)
  {

    TTPMovimento* tMovimento = ((TTPMovimento*) this->movimentos_->Objects[ValueIndex / PONTOS_SERIE]);

    // LinePen->Width = espessuraSimulado_;

    if (tMovimento)
    {
      /*
       if (serieSelecao_ && serieSelecao_->movimentos_ && serieSelecao_->movimentos_->IndexOf(tMovimento->PID) > -1)
       {
       //TFastLineSeries::DrawValue(ValueIndex);
       //return;
       }
       */
      bool isRealizado = tMovimento->IsRealizado;

      if (TTPFormsManager::getInstance()->ShowVisualizador && isRealizado)
      {
        // se o movimento real tiver tempo de termino maior que a linha do tempo puxa ele at a linha do tempo
        int index = this->GetIndexSerieFromMovimento(tMovimento);
        if (index > -1)
        {
          double* ValuesYPos = (double*)this->YValueMovimentos_->Objects[this->YValueMovimentos_->IndexOf(tMovimento->PID)];
          double* ValuesXPos = (double*)this->XValueMovimentos_->Objects[this->XValueMovimentos_->IndexOf(tMovimento->PID)];

          this->XValue[index] =  ValuesXPos[0];
          this->XValue[index+1]= ValuesXPos[0];//(TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && tMovimento->DataFimCurso > TTPFormsManager::getInstance()->Data)?(double)TTPFormsManager::getInstance()->Data : (double)ValuesXPos[1];
          this->XValue[index+2]=(TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && tMovimento->DataSaida > TTPFormsManager::getInstance()->Data)?(double)TTPFormsManager::getInstance()->Data : (double)ValuesXPos[2];

          if(tMovimento->SentidoGrafico == strSubindo)
          {
            this->YValue[index] = ValuesYPos[0];
            this->YValue[index + 1] = ValuesYPos[1];
            this->YValue[index + 2] = ValuesYPos[1];
          }
          else
          {
            this->YValue[index] = ValuesYPos[0];
            this->YValue[index + 1] = ValuesYPos[2];
            this->YValue[index + 2] = ValuesYPos[2];
          }
        }

        if (!TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer)
        {
          // zera os valores de x pra no chamar os eventos de mouseover
          this->XValue[index] = this->XValue[0];
          this->XValue[index + 1] = this->XValue[0];
          this->XValue[index + 2] = this->XValue[0];

          this->YValue[index] = -100;
          this->YValue[index + 1] = -100;
          this->YValue[index + 2] = -100;

          return;
        }

        if (TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && TTPFormsManager::getInstance()->Data < tMovimento->DataChegada)
        {
          // zera os valores de x pra no chamar os eventos de mouseover
          if(indexUltimoRealizadoAntesLinhaTempo>-1)
          {
            this->XValue[index] = (double)TTPFormsManager::getInstance()->Data;
            this->XValue[index + 1] = (double)TTPFormsManager::getInstance()->Data;
            this->XValue[index + 2] = (double)TTPFormsManager::getInstance()->Data;

            this->YValue[index] = this->YValue[indexUltimoRealizadoAntesLinhaTempo+2];
            this->YValue[index + 1] = this->YValue[indexUltimoRealizadoAntesLinhaTempo+2];
            this->YValue[index + 2] = this->YValue[indexUltimoRealizadoAntesLinhaTempo+2];

            return;
          }
          else
          {
            // zera os valores de x pra no chamar os eventos de mouseover
            this->XValue[index] = -100;
            this->XValue[index + 1] = -100;
            this->XValue[index + 2] =-100;

            this->YValue[index] = -100;
            this->YValue[index + 1] = -100;
            this->YValue[index + 2] = -100;
          }
        }
        else
        {
          indexUltimoRealizadoAntesLinhaTempo = index;
        }
      }

      if (TTPFormsManager::getInstance()->ShowVisualizador && !isRealizado)
      {
        int index = this->GetIndexSerieFromMovimento(tMovimento);
        if (index > -1)
        {
          double* ValuesYPos = (double*)this->YValueMovimentos_->Objects[this->YValueMovimentos_->IndexOf(tMovimento->PID)];
          double* ValuesXPos = (double*)this->XValueMovimentos_->Objects[this->XValueMovimentos_->IndexOf(tMovimento->PID)];

          this->XValue[index]   = ValuesXPos[0];
          this->XValue[index+1] = ValuesXPos[1];//(TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && tMovimento->DataFimCurso > TTPFormsManager::getInstance()->Data)?(double)TTPFormsManager::getInstance()->Data : (double)ValuesXPos[1];
          this->XValue[index+2] = ValuesXPos[2];

          this->YValue[index]   = ValuesYPos[0];
          this->YValue[index+1] = ValuesYPos[1];
          this->YValue[index+2] = ValuesYPos[2];
        }
      }
      // LinePen->Color = ValueColor[ValueIndex];

      // LinePen->Visible = true;     ]

      if(isRealizado && this->XValue[ValueIndex] > (double)TTPFormsManager::getInstance()->Data)
      {
           int aaaa = 0;
      }

      if(this->Movimento && this->Movimento->Trem->CheckTremLongo())
      {
        this->LinePen->Width = this->espessuraTremLongo_;
      }
      else
      {
        if (this->isSimulado_ || (TTPFormsManager::getInstance()->ShowVisualizador && isRealizado))
        {
          this->LinePen->Width = this->espessuraSimulado_;
        }
        else
        {
          this->LinePen->Width = isRealizado ? this->espessuraRealizado_ : this->espessuraPlanejado_;
        }
      }

      // LinePen->Width = espessuraSimulado_;
      //this->LinePen->Style = isRealizado || this->isMovimentoSelecao_ ? psSolid : psDash;

      if ((double)dataOflzSelecionada_ == 0)
        this->Color = !this->trem_->IsSelecionado ? TGIFColorMap::RGB2Color(this->fCorSerie_) : COR_MOVIMENTO_SELECIONADO;
      else
        this->Color = this->trem_->IsSelecionado && tMovimento->DataHoraBaseCarregamento == this->dataOflzSelecionada_ ? COR_MOVIMENTO_SELECIONADO : TGIFColorMap::RGB2Color(this->fCorSerie_);

      this->espessuraLinha_ = this->LinePen->Width;
      if (this->trem_->IsSuprimido && tMovimento && !tMovimento->IsRealizado)
      {
        this->XValue[ValueIndex] = this->XValue[0];
        this->YValue[ValueIndex] = this->YValue[0];
      }

      if (this->Pointer && (!this->Pointer->ParentChart || this->Pointer->ParentChart != this->ParentChart))
      {
        this->ParentChart->AddSeries(this->Pointer);
      }

      if (this->serieSelecao_ && (!this->serieSelecao_->ParentChart || this->serieSelecao_->ParentChart != this->ParentChart))
      {
        this->ParentChart->AddSeries(this->serieSelecao_);
      }

      if(ListaOportunidades)
      {
        for(int r=0; r< ListaOportunidades->Count; r++)
        {
          TTPMovimentoSeries *serieSelecaoOportunidade = (TTPMovimentoSeries *)ListaOportunidades->Objects[r];
          if (serieSelecaoOportunidade && (!serieSelecaoOportunidade->ParentChart || serieSelecaoOportunidade->ParentChart != this->ParentChart))
          {
            this->ParentChart->AddSeries(serieSelecaoOportunidade);
          }
        }
      }


      if (this->isMovimentoSelecao_)
      {
        if(this->isOportunidadeSelecionada_)
        {
          this->LinePen->Color = COR_OPORTUNIDADE_SELECIONADA;
        }
        else
        {
          this->LinePen->Color = COR_MOVIMENTO_SELECIONADO;
        }
        this->LinePen->Width = this->espessuraRealizado_;
      }
      else
      {
        if (this->serieSelecao_)
        {
          int indexSerieSelecao = this->ParentChart->SeriesList->IndexOf(this->serieSelecao_);
          int indexSerie = this->ParentChart->SeriesList->IndexOf(this);
          if (indexSerieSelecao < indexSerie)
          {
            this->ParentChart->ExchangeSeries(indexSerieSelecao, indexSerie);
          }
        }

        if(ListaOportunidades)
        {
          for(int r=0; r< ListaOportunidades->Count; r++)
          {
            TTPMovimentoSeries *serieSelecaoOportunidade = (TTPMovimentoSeries *)ListaOportunidades->Objects[r];
            int indexSerieSelecao = this->ParentChart->SeriesList->IndexOf(serieSelecaoOportunidade);
            int indexSerie = this->ParentChart->SeriesList->IndexOf(this);
            if (indexSerieSelecao < indexSerie)
            {
              this->ParentChart->ExchangeSeries(indexSerieSelecao, indexSerie);
            }
          }
        }
      }

      this->espessuraLinha_ = this->LinePen->Width;


      if (this->Pointer)
      {
        this->Pointer->Pointer->Size = 3.5;
        this->Pointer->Pointer->Style = psCircle;

			}
      if(!isRedraw)
        TFastLineSeries::DrawValue(ValueIndex);
      else
        TFastLineSeries::RefreshSeries();
		  }
    }
	}

// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::DoSeriesMouseEnter(System::TObject* Sender)
{
  try
  {
    /* Selecionar movimentos */
    if (!this->movimentos_)
    {
      return;
    }
    if (!this->movimento_)
      return;

    if (!this->movimento_->SB)
      return;

    if (!this->ParentChart)
      return;

    if (!TTPFormsManager::getInstance()->ExibeTremFiltroViewer(trem_->Prefixo))
      return;

    TObject* serieHintAtual = this;
    /*
     if (serieHintAtual)
     {
     // se a srie que esta no top do hint atual no tiver o mesmo chart
     // que a nova serie do hint, limpa a lista com as series
     //			if (((TTPRestricaoSeries*)serieHintAtual)->ParentChart != this->ParentChart)
     //			{
     //				hint_->Clear();
     //			}
     }
     */
    TPoint mousePosition = ParentChart->GetCursorPos();
    // hint_->SerieAtual = (TObject*)this;
    try
    {
      indexSelected_ = Clicked(mousePosition);
    }
    catch (...)
    {
      int i = 0;
    }
    if (indexSelected_ < 0 || movimentos_->Count == 0 || indexSelected_/PONTOS_SERIE >= movimentos_->Count)
    {
      if(TTPFormsManager::getInstance()->MovimentosSerieMouseOver == this)
      {
        ParentChart->AutoRepaint = false;
        Pointer->Visible = false;
        ParentChart->AutoRepaint = true;
      }
      return;
    }

    indexSelected_ =	indexSelected_ / PONTOS_SERIE ;
    int tIndex = indexSelected_ * PONTOS_SERIE;
    int movimentoIndex = getIndexMovimentoFromIndexSerie(tIndex);

    if (movimentoIndex == -1)
      return;
    this->movimento_ = (TTPMovimento*) movimentos_->Objects[movimentoIndex];

    if (!this->movimento_)
      return;

    // tirar mouse move de movimentos realizados no viewer nos casos que os mesmos no devem ser exibidos
    if (TTPFormsManager::getInstance()->ShowVisualizador && this->movimento_->IsRealizado)
    {

      if (!TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer)
        return;

      if (TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && ((double)TTPFormsManager::getInstance()->Data < (double)this->movimento_->DataChegada))
        return;
    }

    if (TTPFormsManager::getInstance()->MovimentosSerieMouseOver && TTPFormsManager::getInstance()->MovimentosSerieMouseOver != this)
    {
      int indexSerieSelecao = ParentChart->SeriesList->IndexOf(TTPFormsManager::getInstance()->MovimentosSerieMouseOver);
      int indexSerie = ParentChart->SeriesList->IndexOf(this);
        if (indexSerieSelecao > indexSerie && TTPFormsManager::getInstance()->MovimentosSerieMouseOver->Pointer && TTPFormsManager::getInstance()->MovimentosSerieMouseOver->Pointer->Visible)
      {
        TTPFormsManager::getInstance()->MovimentosSerieMouseOver->Pointer->Visible = false;
      }

    }

    TTPFormsManager::getInstance()->MovimentosSerieMouseOver = this;
    String tRamal = this->movimento_->SB->Ramal;
    bool tShiftPressionado = ParentChart->Tag == 1;

    // DrawValue(++tIndex);
    // DrawValue(++tIndex);
    // DrawValue(++tIndex);
    /* Selecionar movimentos */

    // return;
    this->hint->PreencheHint(this);
    if (labelPrefixo_ != NULL) // && labelPrefixo_->Tag == 0)
    {
      if (!isTransposicao_)
      {
        using namespace domain;

        String tPrefixoTrem = trem_->Prefixo;
        String tTipoTrem = trem_->TipoTrem->Nome;
        String tChegada = this->movimento_->SB->NomeVia + " - " + FormatDateTime("dd/mm/yyyy hh:mm", this->movimento_->DataChegada.DateTimeString());
        String tSaida = "";
        String tDataSaida = "";
        String tPesoTrem = "";
        String tComprimentoTrem = "";
        String tEquipagem = this->movimento_->getEquipagem();

        if (movimento_->ServerSegTremPlanejado)
        {
          tComprimentoTrem = " | Comprimento = " + FloatToStr(movimento_->ServerSegTremPlanejado->fichaTrem->comprimentoTrem);
          tPesoTrem = + " | Peso = " + FloatToStr(movimento_->ServerSegTremPlanejado->fichaTrem->pesoTBTrem);
        }

        if (this->TemParada)
        {
          tSaida = this->movimento_->SB->NomeVia + " - " + FormatDateTime("dd/mm/yyyy hh:mm", this->movimento_->DataSaida.DateTimeString());
          tDataSaida = FormatDateTime("dd/mm/yyyy hh:mm", this->movimento_->DataSaida.DateTimeString());
        }
        else
        {
          tSaida = this->movimento_->SB->NomeVia + " " + " - " + FormatDateTime("dd/mm/yyyy hh:mm", this->movimento_->DataSaida.DateTimeString());
          tDataSaida = FormatDateTime("dd/mm/yyyy hh:mm", this->movimento_->DataSaida.DateTimeString());

        }

        String tDestinoTrem = trem_->ItinerarioTrem->Movimentos->operator[](trem_->ItinerarioTrem->Movimentos->count() - 1)->SB->CodigoSegmento;

        if (trem_->Tabela.Length() > 0)
        {
          tDestinoTrem += " (" + trem_->Tabela + ")";
        }

        labelPrefixo_->Caption = tPrefixoTrem + " (" + tTipoTrem + tPesoTrem + tComprimentoTrem + ")" + " | Chegada: " + tChegada + " | Sada: " + tSaida + " Destino: " +
            tDestinoTrem;
      }
      else
        labelPrefixo_->Caption = "Movimento transposio";
    }

    if ((double)this->Movimento->DataAderenciaFila > 0 && this->SerieAderenciaFila)
    {
      TTPAderenciaFilaSeries* aderenciaFila = this->SerieAderenciaFila;

      aderenciaFila->XValue[0] = this->Movimento->DataFimCurso;
      aderenciaFila->XValue[1] = this->Movimento->DataAderenciaFila;
    }
  }
  catch(Exception &e ){
    int i = 0;
  }

}

// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::DoSeriesMouseLeave(System::TObject* Sender)
{
  if (this->hint)
    this->hint->clearHint(this);
  else
  {
    int i = 0;
    return;
  }

  if (!TTPFormsManager::getInstance()->ExibeTremFiltroViewer(trem_->Prefixo))
    return;

  try
  {
    if (labelPrefixo_ != NULL) // && labelPrefixo_->Tag == 0)
    {
      labelPrefixo_->Caption = "";
    }

    if (this->movimento_->IsArrastavel && Pointer->Visible)
    {
      ParentChart->AutoRepaint = false;
      Pointer->Visible = false;
      ParentChart->AutoRepaint = true;
    }
    else if(Pointer->Visible)
    {
      ParentChart->AutoRepaint = false;
      Pointer->Visible = false;
      ParentChart->AutoRepaint = true;
    }

    if (TTPFormsManager::getInstance()->MovimentosSerieMouseOver == this)
      TTPFormsManager::getInstance()->MovimentosSerieMouseOver = NULL;

    // TTPMovimentoSeries* t_serieAnterior  = (TTPMovimentoSeries*) serieMovimentoAnterior_;
    // TTPMovimentoSeries* t_seriePosterior = (TTPMovimentoSeries*) serieMovimentoPosterior_;
    // return;
    // while (t_serieAnterior)
    // {
    // if(t_serieAnterior->Pointer)
    // t_serieAnterior->Pointer->Visible = false;
    // t_serieAnterior = t_serieAnterior->SerieMovimentoAnterior;
    // }
    //
    // while (t_seriePosterior)
    // {
    // if(t_seriePosterior->Pointer)
    // t_seriePosterior->Pointer->Visible = false;
    // t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior;
    // }
    //
    // if(this->Pointer)
    // this->Pointer->Visible = false;

    // this->RefreshSeries();
    int index = indexSelected_;
    indexSelected_ = -1;

    // for (int i = index; i > index + 3; i++)
    // DrawValue(index);

    if (this->Movimento && (double)this->Movimento->DataAderenciaFila > 0)
    {
      TTPAderenciaFilaSeries* aderenciaFila = this->SerieAderenciaFila;

      aderenciaFila->XValue[0] = this->Movimento->DataChegada;
      aderenciaFila->XValue[1] = this->Movimento->DataChegada;
    }
    /*
     Selecionar movimentos
     */
    // verifica se no hint existe alguma srie de Restrio pra ser exibido o hint
    // TObject* serie = hint_->GetTopSerie();
    // hint_->SerieAtual = NULL;
    // apos remover a serie da lista verifica se tem alguma outra srie na lista e pega a mais
    // no topo
    // if (serie)
    // {
    // // executa o mouse enter da mesma para preencher o hint
    // ((TTPRestricaoSeries*)serie)->DoSeriesMouseEnter(serie);
    // }

  }
  catch(...){}
  // MarcarFimTrem();
}

// ------------------------------------------------------------------------------
void TTPMovimentoSeries::SetMovimentoSelecionado(bool pSelecionado)
{
#pragma warn -aus   // evita warning de varialvel nao utilizada.
  try
  {
    // Cpias do trem no podem ser selecionadas
    // if(trem_->TipoTrem->Nome != "C")

    // if(Movimento->MovimentoSelecionado==pSelecionado)
    // return;
    if (pSelecionado)
      addMovimentoSelecionado(Movimento);
    else
      clearMovimentoSelecionado();
    movimentoSelecionado_ = pSelecionado;
    Movimento->MovimentoSelecionado = pSelecionado;
    TColor t_corMovimento = movimentoSelecionado_ ? COR_MOVIMENTO_SELECIONADO : TGIFColorMap::RGB2Color(fCorSerie_);
    double tEspessuraLinha = movimentoSelecionado_ ? LINHA_SELECIONADA : espessuraLinha_;
    // ((TChart*)Owner)->Hint = MovimentoSelecionado_ ? Trem_->Prefixo : (UnicodeString)"";

    // LinefrfPen->Width = ( layoutImpressao ? 2.5 : (Movimento_->IsRealizado ? 3.5 : 2.0) );
    // this->Color = t_corMovimento;
    if (serieSelecao_)
    {
      for (int i = 0; i < serieSelecao_->XValues->Count; i++)
      {
        serieSelecao_->DrawValue(i,true);
      }
    }
  }
  catch (Exception& e)
  {

    int val1 = serieSelecao_->ParentChart->SeriesList->IndexOf(serieSelecao_);
    int val2 = serieSelecao_->ParentChart->SeriesList->IndexOf(serieSelecao_->Pointer);

      if (val1 <0 || val2 <0 ) {
                             int parar = 0;
      }

    int teste = 0;
  }
}
// ------------------------------------------------------------------------------

void __fastcall TTPMovimentoSeries::DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
          TShiftState Shift, int X, int Y)
{
  if (TTPFormsManager::getInstance()->ShowVisualizador && Shift.Contains(ssCtrl))
    SetTremSelecionado(true, movimento_->DataHoraBaseCarregamento);
  else
    SetTremSelecionado(true);
  TTPFormsManager::getInstance()->SetMovimentoTremSelecionado(this->trem_);

//  printPoints();
}

// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::SetTremSelecionado(bool selecionar, TDateTime dtOfclz)
{
  // Cpias do trem no podem ser selecionadas
  // if(trem_->TipoTrem->Nome != "C")
  // return;

  if (!movimentos_)
    return;

  if (labelPrefixo_)
  {
    if (selecionar)
      labelPrefixo_->Tag = (selecionar ? 1 : 0);

    labelPrefixo_->Caption = (selecionar ? trem_->Prefixo + " (" + trem_->TipoTrem->Nome + ")" : String(""));
  }
  // SetMovimentoSelecionado(false);

  if (serieSelecao_)
    clearMovimentoSelecionado();

  TTPMovimento* t_movimentoAnterior = Movimento->MovimentoAnterior;
  TTPMovimento* t_movimentoPosterior = Movimento->MovimentoPosterior;

  if (trem_->IsSelecionado != selecionar)
  {

    trem_->IsSelecionado = selecionar;
    TTPMovimento* t_movimentoAtual = Movimento;
    while (t_movimentoAnterior)
    {
      if (t_movimentoAnterior->Serie && t_movimentoAnterior->Serie != t_movimentoAtual->Serie)
        t_movimentoAnterior->Serie->SetTremSelecionado(selecionar, dtOfclz);

      t_movimentoAtual = t_movimentoAnterior;
      t_movimentoAnterior = t_movimentoAnterior->MovimentoAnterior;
    }

    t_movimentoAtual = Movimento;
    while (t_movimentoPosterior)
    {
      if (t_movimentoPosterior->Serie && t_movimentoPosterior->Serie != t_movimentoAtual->Serie)
        t_movimentoPosterior->Serie->SetTremSelecionado(selecionar, dtOfclz);

      t_movimentoAtual = t_movimentoPosterior;
      t_movimentoPosterior = t_movimentoPosterior->MovimentoPosterior;
    }

  }

  if (dataOflzSelecionada_ != dtOfclz)
  {
    dataOflzSelecionada_ = dtOfclz;

    for (int i = 0; i < XValues->Count; i++)
    {
      DrawValue(i);
    }
  }

  RedrawTrain();
}

// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::RedrawTrain()
{
  if(this->Movimento!= NULL && this->Movimento->Trem->CheckTremLongo())
  {
    this->LinePen->Width = this->espessuraTremLongo_;
    this->LinePen->Style = (movimento_ != NULL && movimento_->IsRealizado ? psSolid : psDot);
    // psSolid, psDash, psDot, psDashDot, psDashDotDot, psClear, psInsideFrame, psUserStyle, psAlternate
  }
}
// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::SetTremSelecionado(bool selecionar, bool forcarSelecionar)
{
  // Cpias do trem no podem ser selecionadas
	// if(trem_->TipoTrem->Nome != "C")
	try
  {
    if (!movimentos_)
      return;

    dataOflzSelecionada_ = 0;

    if (labelPrefixo_)
    {
      if (selecionar)
        labelPrefixo_->Tag = (selecionar ? 1 : 0);

      labelPrefixo_->Caption = (selecionar ? trem_->Prefixo + " (" + trem_->TipoTrem->Nome + ")" : String(""));
    }

    if (serieSelecao_)
      clearMovimentoSelecionado();

    if(	trem_->IsSelecionado == selecionar)
      return;

    TTPMovimento* t_movimentoAnterior = Movimento->MovimentoAnterior;
    TTPMovimento* t_movimentoPosterior = Movimento->MovimentoPosterior;

    if (trem_->IsSelecionado != selecionar || forcarSelecionar)
    {

      trem_->IsSelecionado = selecionar;
      TTPMovimento* t_movimentoAtual = Movimento;
      RedrawSerie();
      while (t_movimentoAnterior)
      {
        if (t_movimentoAnterior->Serie && t_movimentoAnterior->Serie != t_movimentoAtual->Serie)
          {
            t_movimentoAnterior->Serie->SetTremSelecionado(selecionar);
            t_movimentoAnterior->Serie->RedrawSerie();
          }

        t_movimentoAtual = t_movimentoAnterior;
        t_movimentoAnterior = t_movimentoAnterior->MovimentoAnterior;
      }

      t_movimentoAtual = Movimento;
      while (t_movimentoPosterior)
      {
        if (t_movimentoPosterior->Serie && t_movimentoAtual
              && t_movimentoPosterior->Serie != t_movimentoAtual->Serie)
          {
            t_movimentoPosterior->Serie->SetTremSelecionado(selecionar);
            t_movimentoPosterior->Serie->RedrawSerie();
          }

        t_movimentoAtual = t_movimentoPosterior;
        t_movimentoPosterior = t_movimentoPosterior->MovimentoPosterior;
			}

    }

    // TTPMovimento* t_serieAnterior  = SerieMovimentoAnterior(movimento_);
    // TTPMovimento* t_seriePosterior = SerieMovimentoPosterior(movimento_);
    //
    // SetMovimentoSelecionado(selecionar);

    // while (t_serieAnterior)
    // {
    // t_serieAnterior->SetMovimentoSelecionado(selecionar);
    // t_serieAnterior = t_serieAnterior->SerieMovimentoAnterior;
    // }
    //
    // while (t_seriePosterior)
    // {
    // t_seriePosterior->SetMovimentoSelecionado(selecionar);
    // t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior;
    // }
    RedrawTrain();
	}

  catch(Exception &e)
	{
		TTPFormsManager::getInstance()->gravarLog("Erro TTPMovimentoSeries::SetTremSelecionado - " + e.Message);
	}
}

// ------------------------------------------------------------------------------

void __fastcall TTPMovimentoSeries::MarcarFimTrem()
{
  /*
   TTPMovimentoSeries* t_serieAtual = this;
   TTPMovimentoSeries* t_serieAnterior = this;
   TTPMovimentoSeries* t_seriePosterior = SerieMovimentoPosterior;

   while (t_serieAnterior)
   {
   t_serieAnterior->Pointer->Style = psNothing;
   t_serieAnterior = t_serieAnterior->SerieMovimentoAnterior;
   }

   while (t_seriePosterior)
   {
   t_serieAtual = t_seriePosterior;
   t_serieAtual->Pointer->Style = psNothing;
   t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior;
   }

   if (t_serieAtual->Movimento_->PID == Trem_->ItinerarioTrem->Movimentos->operator [](Trem_->ItinerarioTrem->Movimentos->count() - 1)->PID) {
   t_serieAtual->Pointer->Style = psDiagCross;
   t_serieAtual->Pointer->Size = 4.5;
   t_serieAtual->Pointer->Pen->Width = 1.5;
   t_serieAtual->Pointer->Visible = true;
   }
   */
}

// ------------------------------------------------------------------------------
// FAbiano - 18/05/15 Por enquanto, no est sendo utilizado, s uma ideia..
void __fastcall TTPMovimentoSeries::AddOwner(String pRamal, TChart* pOwner)
{
  if (!owners_)
    owners_ = new TXStringList();
  owners_->AddObject(pRamal, pOwner);
}
// ------------------------------------------------------------------------------

bool __fastcall TTPMovimentoSeries::TemAtividade()
{
  bool result = false;
if (
  (movimento_->ServerSegTremPlanejado &&   !movimento_->ServerSegTremPlanejado->atividade)
  ||
  (movimento_->ServerSegTremOficializado &&  !movimento_->ServerSegTremOficializado->getAtividade())
  ||
  (movimento_->ServerSegTremRealizado)
     )
    return result;

   domain::AtividadePlanejamento  *atvServer = movimento_->ServerSegTremPlanejado ?
                                               movimento_->ServerSegTremPlanejado->atividade:
      movimento_->ServerSegTremOficializado->getAtividade();

  for (int i = 0; i < trem_->Atividades->count(); i++)
  {
    if (atvServer == trem_->Atividades->operator[](i)->AtividadeServer)
    {
      if (movimento_ != NULL)
        if (trem_->Atividades->operator[](i)->SBs->count() == 0)
        {
          if (trem_->Atividades->operator[](i)->SBAtual->CodigoSegmento == movimento_->SB->CodigoSegmento)
          {
            result = true;
            if (trem_->Atividades->operator[](i)->HasFila)
            {
              atividadeFila_ = true;
              TDateTime DataFila = trem_->Atividades->operator[](i)->DataFimFila;
              TDateTime DataFim = trem_->Atividades->operator[](i)->DataFim;
              TDateTime DataFimDuracao = movimento_->DataChegada + (trem_->Atividades->operator[](i)->Duracao / 24 / 60);

              if (DataFila < DataFim || DataFila < DataFimDuracao)
              {
                atividadeFilaIrrelevante_ = true;
              }
              else
              {
                atividadeFilaIrrelevante_ = false;
              }
            }
            else
            {
              atividadeFila_ = false;
              atividadeFilaIrrelevante_ = false;
            }

            return result;

          }
        }
        else
        {
          for (int j = 0; j < trem_->Atividades->operator[](i)->SBs->count(); j++)
          {
            if (trem_->Atividades->operator[](i)->SBs->get(j)->CodigoSegmento == movimento_->SB->CodigoSegmento)
            {
              result = true;
              if (trem_->Atividades->operator[](i)->HasFila)
              {
                atividadeFila_ = true;
                TDateTime DataFila = trem_->Atividades->operator[](i)->DataFimFila;
                TDateTime DataFim = trem_->Atividades->operator[](i)->DataFim;
                TDateTime DataFimDuracao = movimento_->DataChegada + (trem_->Atividades->operator[](i)->Duracao / 24 / 60);

                if (DataFila < DataFim || DataFila < DataFimDuracao)
                {
                  atividadeFilaIrrelevante_ = true;
                }
                else
                {
                  atividadeFilaIrrelevante_ = false;
                }
              }
              else
              {
                atividadeFila_ = false;
                atividadeFilaIrrelevante_ = false;
              }

              return result;

            }
          }
        }
    }
  }

  return result;
}

// ---------------------------------------------------------------------------------------------------
POINT2* TTPMovimentoSeries::intersection(POINT2 p1, POINT2 p2, POINT2 p3, POINT2 p4)
{
  using namespace std;

  double x1 = p1.x, x2 = p2.x, x3 = p3.x, x4 = p4.x;
  double y1 = p1.y, y2 = p2.y, y3 = p3.y, y4 = p4.y;

  double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  // se deu zero as retas nao se cruzam.
  if (d == 0)
    return NULL;

  // calculando
  double pre = (x1 * y2 - y1 * x2), post = (x3 * y4 - y3 * x4);
  double x = (pre * (x3 - x4) - (x1 - x2) * post) / d;
  double y = (pre * (y3 - y4) - (y1 - y2) * post) / d;

  // valida se o calculo ta na reta
  if (x < min(x1, x2) || x > max(x1, x2) || x < min(x3, x4) || x > max(x3, x4))
    return NULL;
  if (y < min(y1, y2) || y > max(y1, y2) || y < min(y3, y4) || y > max(y3, y4))
    return NULL;

  POINT2* ret = new POINT2();
  ret->x = x;
  ret->y = y;

  return ret;
}

// ---------------------------------------------------------------------------------------------------
void TTPMovimentoSeries::SetUltimoMovimentoPainel()
{
  /*
   if(Movimento_->IsUltimoPainel)
   {
   this->Pointer->Style = psRectangle;
   this->Pointer->Size = 3.5;
   this->Pointer->Pen->Width = 1.5;
   }
   else
   */
  /*
   {
   Pointer->Style = psNothing;
   Pointer->Visible = true;
Pointer->VertSize = 1.5;
   Pointer->HorizSize = 1.5;
   Pointer->Pen->Width = 0.5;
   }
   */
}

// ---------------------------------------------------------------------------------------------------
void TTPMovimentoSeries::SetMovimentoTremSuprimido()
{
  if (this->Pointer)
  {
    this->Pointer->Visible = true;
    this->Pointer->Pointer->Style = psCross;
    this->Pointer->Pointer->Size = 5;
  }
  Repaint();
}

// ---------------------------------------------------------------------------------------------------
void TTPMovimentoSeries::TesteMouseEnter()
{

  String tRamal = this->movimento_->SB->Ramal;
  bool tShiftPressionado = false;

  if (owners_)
  {
    int indexOf = owners_->IndexOf(tRamal);
    if (indexOf > -1)
    {
      TChart* chart = (TChart*)owners_->Objects[owners_->IndexOf(tRamal)];
      if (chart->Tag == 1)
        tShiftPressionado = true;
    }
  }

  // TTPMovimentoSeries* t_serieAnterior  = SerieMovimentoAnterior;
  // TTPMovimentoSeries* t_seriePosterior = SerieMovimentoPosterior;
  //
  // while (t_serieAnterior)
  // {
  //
  // if(tRamal != t_serieAnterior->movimento_->SB->Ramal)
  // break;
  //
  // if(t_serieAnterior->IsArrastavel && !tShiftPressionado)
  // if(t_serieAnterior->Pointer)
  // {
  // t_serieAnterior->Pointer->Visible = true;
  // this->ExchangePointer(t_serieAnterior);
  // }
  // else if(!t_serieAnterior->IsArrastavel && tShiftPressionado)
  // if(t_serieAnterior->Pointer)
  // {
  // t_serieAnterior->Pointer->Visible = true;
  // this->ExchangePointer(t_serieAnterior);
  // }
  // t_serieAnterior = t_serieAnterior->SerieMovimentoAnterior;
  // }
  //
  // while (t_seriePosterior)
  // {
  // if(tRamal != t_seriePosterior->movimento_->SB->Ramal)
  // break;
  //
  // if(t_seriePosterior->IsArrastavel && !tShiftPressionado)
  // if(t_seriePosterior->Pointer)
  // {
  // t_seriePosterior->Pointer->Visible = true;
  // this->ExchangePointer(t_seriePosterior);
  // }
  // else if(!t_seriePosterior->IsArrastavel && tShiftPressionado)
  // if(t_seriePosterior->Pointer)
  // {
  // t_seriePosterior->Pointer->Visible = true;
  // this->ExchangePointer(t_seriePosterior);
  // }
  // t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior;
  // }
  //
  // if(this->IsArrastavel && this->Pointer)
  // {
  // this->Pointer->Visible = true;
  // this->ExchangePointer();
  // }
  // /* Selecionar movimentos */
}
// ----------------------------------------------------------------------------------\d-----------------
// void TTPMovimentoSeries::SetMovimentoAnterior(TTPMovimentoSeries* pSerie)
// {
// if (!movimento_)
// return;
//
// serieMovimentoAnterior_ = pSerie;
//
// if (pSerie != NULL)
// {
// // this->movimento_->MovimentoAnterior = pSerie->movimento_;
// }
// else
// {
// this->movimento_->MovimentoAnterior = NULL;
// }
// }
//// ---------------------------------------------------------------------------------------------------
// void TTPMovimentoSeries::SetMovimentoPosterior(TTPMovimentoSeries* pSerie)
// {
// if (!movimento_)
// return;
// serieMovimentoPosterior_ = pSerie;
//
// if (pSerie != NULL)
// {
// // this->movimento_->MovimentoPosterior = pSerie->movimento_;
// }
// else
// {
// this->movimento_->MovimentoPosterior = NULL;
// }
//
// }

// ---------------------------------------------------------------------------------------------------
void TTPMovimentoSeries::SetAtividadeFilaAtiva(bool ativa)
{
  for (int i = 0; i < this->Trem->Atividades->count(); i++)
  {
    for (int j = 0; j < this->Trem->Atividades->operator[](i)->SBs->count(); j++)
    {
      if (this->Trem->Atividades->operator[](i)->SBs->get(j)->CodigoSegmento == this->movimento_->SB->CodigoSegmento)
      {
        this->Trem->Atividades->operator[](i)->ISFiltaAtiva = ativa;
        break;
      }
    }
  }
}
// ---------------------------------------------------------------------------------------------------

void TTPMovimentoSeries::SetFimFila(TDateTime dataHoraFimFila)
{
  for (int i = 0; i < this->Trem->Atividades->count(); i++)
  {
    for (int j = 0; j < this->Trem->Atividades->operator[](i)->SBs->count(); j++)
    {
      if (this->Trem->Atividades->operator[](i)->SBs->get(j)->CodigoSegmento == this->movimento_->SB->CodigoSegmento)
      {
        this->Trem->Atividades->operator[](i)->DataFimFila = dataHoraFimFila;
      }
    }
  }
}
// ---------------------------------------------------------------------------------------------------

int __fastcall TTPMovimentoSeries::IndiceAtividade(TTPMovimento* pMovimento)
{

  TTPMovimento* tMovimento_anterior = movimento_;
  int result = -1;

  try
  {
    if (pMovimento != NULL)
      movimento_ = pMovimento;
    domain::AtividadePlanejamento  *atvServer = NULL;
    if(movimento_->ServerSegTremPlanejado)
    {
      atvServer = movimento_->ServerSegTremPlanejado->atividade;
    }
    else if(movimento_->ServerSegTremOficializado)
    {
      atvServer = movimento_->ServerSegTremOficializado->getAtividade();
    }

    for (int i = 0; i < trem_->Atividades->count(); i++)
    {
      if (movimento_ != NULL)
        if (trem_->Atividades->operator[](i)->AtividadeServer == atvServer &&
            trem_->Atividades->operator[](i)->SBs->count() == 0)
        {
          if (trem_->Atividades->operator[](i)->SBAtual.isNull())
            int parar = 0;
          if (trem_->Atividades->operator[](i)->SBAtual->CodigoSegmento == movimento_->SB->CodigoSegmento)
          {
            result = i;
          }
        }
        else
        {
          for (int j = 0; j < trem_->Atividades->operator[](i)->SBs->count(); j++)
          {
            if (trem_->Atividades->operator[](i)->AtividadeServer == atvServer &&
                trem_->Atividades->operator[](i)->SBs->get(j)->CodigoSegmento == movimento_->SB->CodigoSegmento)
            {
              result = i;
              break;
            }
          }
        }
    }
  }
  __finally
  {
    movimento_ = tMovimento_anterior;
  }
  return result;
}

// ---------------------------------------------------------------------------------------------------
TTPAderenciaFilaSeries* TTPMovimentoSeries::getSerieAderenciaFila()
{
  // if (owners_)
  // {
  // TChart* chart = (TChart*)owners_->Objects[owners_->IndexOf(movimento_->SB->Ramal)];
  if (serieAderencia_)
  {
    return serieAderencia_;
  }
  else if ((double)movimento_->DataAderenciaFila > 0)
  {
    serieAderencia_ = new TTPAderenciaFilaSeries((TChart*)this->Owner,&this->onDeleteSerieAderencia );
  }
  // }
  return serieAderencia_;
}
void TTPMovimentoSeries::onDeleteSerieAderencia(TTPAderenciaFilaSeries* serie)
{
  if (serieAderencia_ && serieAderencia_ == serie)
    serieAderencia_ = NULL; // a classe filha j foi limpa pelo teechart
}
// ---------------------------------------------------------------------------------------------------
__fastcall TTPAderenciaFilaSeries::~TTPAderenciaFilaSeries()
{
  //
  if (onDeleteMetlhod)//notifica outra classe que ele foi deletado;
    onDeleteMetlhod(this);
}

// ---------------------------------------------------------------------------
__fastcall TTPAderenciaFilaSeries::TTPAderenciaFilaSeries(TChart* chart,clbkOnDelete ptrf) : TLineSeries(chart)
{
  fCorSerie_.Red = 255;
  fCorSerie_.Green = 0;
  fCorSerie_.Blue = 0;
 onDeleteMetlhod =ptrf;
  ConfigurarSerie();

  this->OnMouseEnter = DoSeriesMouseEnter;
  this->OnMouseLeave = DoSeriesMouseLeave;

}

// ---------------------------------------------------------------------------------------------------
void TTPAderenciaFilaSeries::PlotarPontos(double X1, double Y1, double X2, double Y2, bool update)
{
  if (!update)
  {
  double xValues[2] = { X2, X1};
  double yValues[2] = { Y2, Y1 };
    this->AddArray(xValues, 1, yValues, 1);
    this->ValueColor[0] = TGIFColorMap::RGB2Color(fCorSerie_);
    this->ValueColor[1] = TGIFColorMap::RGB2Color(fCorSerie_);
  }
  else
  {
    this->XValue[0] = X1;
    this->XValue[1] = X2;
  }
}

// ---------------------------------------------------------------------------
void TTPAderenciaFilaSeries::ConfigurarSerie()
{
  if (this->Pointer)
  {
    this->Pointer->Pen->Color = TGIFColorMap::RGB2Color(fCorSerie_);
    this->Pointer->Pen->Style = psDot;
    this->Pointer->Shadow->Visible = false;
  }

  this->Tag = tsAderenciaFila;

  ColorEachPoint = true;
  XValues->DateTime = true;
  ShowInLegend = true;
  VertAxis = aBothVertAxis;
  AllowSinglePoint = true;

  // Para reconhecer o segmento qdo o incio est no dia anterior
  CalcVisiblePoints = false;

  // LinePen->Width = 2.0;
  LinePen->Style = (psDash);
  Cursor = (TCursor)crHandPoint;
  if (this->Pointer)
  {
    this->Pointer->Visible = true;
    this->Pointer->Style = psDownTriangle;
    this->Pointer->Size = 5.0;
  }
  // // FIM - Configurar Srie

}

// ---------------------------------------------------------------------------
void __fastcall TTPAderenciaFilaSeries::DoSeriesMouseEnter(System::TObject* Sender)
{

  try
  {
    /* Selecionar movimentos */
    int parar = 0;

  }
  catch(...){}
}

// ------------------------------------------------------------------------------
void __fastcall TTPAderenciaFilaSeries::DoSeriesMouseLeave(System::TObject* Sender)
{

  try
  {
    int parar = 0;
  }
  catch (...)
  {
  }
  // MarcarFimTrem();
}

// ------------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::ConfigurarSerieArrasto(bool confMovAdjacentes)
{

  if (pontosPlotados_ == 2)
  {
    double X3 = this->XValues->Last();
    double Y3 = this->YValues->Last();

    this->AddXY(X3, Y3, "", this->ValueColor[0]);
    // if(Pointer)
    // Pointer->AddXY(X3,Y3,"",this->ValueColor[0]);

    pontosPlotados_ = 3;
  }
  if (confMovAdjacentes)
  {
    // TTPMovimentoSeries* t_serieAnterior  = SerieMovimentoAnterior;
    // TTPMovimentoSeries* t_seriePosterior = SerieMovimentoPosterior;
    //
    // if(t_serieAnterior)
    // t_serieAnterior->ConfigurarSerieArrasto(false);
    //
    // if(t_seriePosterior)
    // t_seriePosterior->ConfigurarSerieArrasto(false);
  }
}

// ---------------------------------------------------------------------------
bool __fastcall TTPMovimentoSeries::VerificarTemParada()
{
  int index = GetIndexSerieFromMovimento(movimento_);

  return this->XValue[index + 1] != this->XValue[index + 2];


}

// ---------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::UpdatePontosSerie(TTPMovimento* pMovimento, double X1, double Y1, double X2, double Y2, double X3, double Y3)
{
  int index = GetIndexSerieFromMovimento(pMovimento);
  if (index > -1)
  {
    this->XValue[index] = pMovimento->DataChegada;
    this->XValue[index + 1] = pMovimento->DataFimCurso;
    this->XValue[index + 2] = pMovimento->DataSaida;

    this->YValue[index] = Y1;
    this->YValue[index + 1] = Y2;
    this->YValue[index + 2] = Y3;
  }
}

////---------------------------------------------------------------------------
// double __fastcall TTPMovimentoSeries:: GetxValue(int ValueIndex)
// {
// return this->XValuesDef[ValueIndex];
// }
//
////---------------------------------------------------------------------------
// double __fastcall TTPMovimentoSeries:: GetyValue(int ValueIndex)
// {
// return this->YValuesDef[ValueIndex];
// }

// ---------------------------------------------------------------------------
bool TTPMovimentoSeries::SendPointToIntersectionOfLimits(int indexMin, int indexMax)
{
  using namespace intersection;
  double minB = ParentChart->BottomAxis->Minimum,
   maxB = ParentChart->BottomAxis->Maximum,
   minL = ParentChart->LeftAxis->Minimum,
   maxL = ParentChart->LeftAxis->Maximum,
      ultimoPonto = pontosPlotados_ - 1;

  if(   (this->XValue[indexMin] < minB && this->XValue[indexMax] < minB)
     || (this->XValue[indexMin] > maxB && this->XValue[indexMax] > maxB)
     || (this->YValue[indexMin] < minL && this->YValue[indexMax] < minL)
     || (this->YValue[indexMin] > maxL && this->YValue[indexMax] > maxL))
  {
    return false;
  }

  bool ajustouFimCurso = false;

  if(XValue[indexMin] < minB || XValue[indexMin] > maxB || YValue[indexMin] < minL || YValue[indexMin] > maxL ||
     XValue[indexMax] < minB || XValue[indexMax] > maxB || YValue[indexMax] < minL || YValue[indexMax] > maxL)
  {
    intersection::Vector p0(XValue[indexMin], YValue[indexMin]);
    intersection::Vector p1(XValue[indexMax], YValue[indexMax]);

    intersection::Vector pLeftDown(minB, minL);
    intersection::Vector pLeftUp(minB, maxL);

    intersection::Vector pRightDown(maxB, minL);
    intersection::Vector pRightUp(maxB, maxL);

    intersection::Vector result;

    if (TTPUtilsIntersection::ExistsIntersection(p0, p1, pLeftUp, pLeftDown))
    {
      result = (TTPUtilsIntersection::DoLineSegmentIntersection(p0, p1, pLeftUp, pLeftDown));

      this->TFastLineSeries::YValue[indexMin] = result.y_;
      this->TFastLineSeries::XValue[indexMin] = result.x_;

    }
    if (TTPUtilsIntersection::ExistsIntersection(p0, p1, pRightUp, pRightDown))
    {
      result = (TTPUtilsIntersection::DoLineSegmentIntersection(p0, p1, pRightUp, pRightDown));

      this->TFastLineSeries::YValue[indexMax] = result.y_;
      this->TFastLineSeries::XValue[indexMax] = result.x_;

      ajustouFimCurso = true;

    }
    if (TTPUtilsIntersection::ExistsIntersection(p0, p1, pRightDown, pLeftDown))
    {
      result = (TTPUtilsIntersection::DoLineSegmentIntersection(p0, p1, pRightDown, pLeftDown));

      if (p0.y_ < pRightDown.y_)
      {
        this->TFastLineSeries::YValue[indexMin] = result.y_;
        this->TFastLineSeries::XValue[indexMin] = result.x_;
      }
      else
      {
        this->TFastLineSeries::YValue[indexMax] = result.y_;
        this->TFastLineSeries::XValue[indexMax] = result.x_;

        ajustouFimCurso = true;
      }
    }
    if (TTPUtilsIntersection::ExistsIntersection(p0, p1, pRightUp, pLeftUp))
    {
      result = (TTPUtilsIntersection::DoLineSegmentIntersection(p0, p1, pRightUp, pLeftUp));

      if (p0.y_ > pRightUp.y_)
      {
        this->TFastLineSeries::YValue[indexMin] = result.y_;
        this->TFastLineSeries::XValue[indexMin] = result.x_;
      }
      else
      {
        this->TFastLineSeries::YValue[indexMax] = result.y_;
        this->TFastLineSeries::XValue[indexMax] = result.x_;

        ajustouFimCurso = true;
      }
    }
  }

  return ajustouFimCurso;
}

// ---------------------------------------------------------------------------
void __fastcall TTPMovimentoSeries::ExchangePointer(TTPMovimentoSeries* pSerie)
{
  if (pSerie)
  {
    if (pSerie->ParentChart)
    {
      // int indexOfP = pSerie->ParentChart->SeriesList->IndexOf(pSerie->Pointer);
      // int indexOfS = pSerie->ParentChart->SeriesList->IndexOf(pSerie);
      // if(indexOfP < indexOfS)
      // pSerie->ParentChart->ExchangeSeries(pSerie, pSerie->Pointer);
      // pSerie->Pointer->ClickTolerance = CLICK_TOLERANCE;
      // pSerie->Pointer->Repaint();
      // this->Repaint();
    }
  }
  else
  {
    if (this->ParentChart)
    {
      // |int indexOfP = this->ParentChart->SeriesList->IndexOf(this->Pointer);
      // int indexOfS = this->ParentChart->SeriesList->IndexOf(this);
      // if(indexOfP < indexOfS)
      // this->ParentChart->ExchangeSeries(this, this->Pointer);
      // this->Pointer->ClickTolerance = CLICK_TOLERANCE;
      // this->Pointer->Repaint();
      // this->Repaint();
    }
  }
}
// ---------------------------------------------------------------------------

int __fastcall TTPMovimentoSeries::getIndexMovimentoFromIndexSerie(int indexSerie)
{
  int index = indexSerie / 3;
  /*
   for (int i = 0; i < movimentos_->Count; i++)
   {
   TTPMovimento* tMovimento = (TTPMovimento*) movimentos_->Objects[i];
   if(tMovimento && (double)tMovimento->DataChegada   == XValue[indexSerie-indexSerie%PONTOS_SERIE]   &&
   ((double)tMovimento->DataFimCurso == XValue[indexSerie-indexSerie%PONTOS_SERIE+1] ||
   (double)tMovimento->DataSaida     == XValue[indexSerie-indexSerie%PONTOS_SERIE+2] ))
   {
   index = i;
   break;
   }
   }

   if (index == -1)
   int i = 0; */
  return index;
}

int __fastcall TTPMovimentoSeries::Clicked(TPoint mousePosition, bool selecionar)
{
#pragma warn -aus   // evita warning de varialvel nao utilizada.
  try
  {
    int index = TFastLineSeries::Clicked(mousePosition);

    if (selecionar)
    {
      indexSelected_ = index / PONTOS_SERIE;
      if (index > -1)
      {
        int movimentoIndex = getIndexMovimentoFromIndexSerie(index);

        if (movimentoIndex == -1)
          return -1;

        if (movimentoIndex > 0 && movimentos_->Count > 1)
          this->movimento_ = (TTPMovimento*) movimentos_->Objects[movimentoIndex];

        int indexMovimento = GetIndexSerieFromMovimento(this->movimento_);
        // Pointer->operator[](ValueIndex)->Visible = indexSelected_ == ValueIndex / PONTOS_SERIE;
        if (indexMovimento > -1 && !trem_->IsSuprimido)
        {
          //ParentChart->AutoRepaint = true;
          this->Pointer->XValue[0] = this->XValue[indexMovimento];
          this->Pointer->YValue[0] = this->YValue[indexMovimento];

          this->Pointer->XValue[1] = this->XValue[1 + indexMovimento];
          this->Pointer->YValue[1] = this->YValue[1 + indexMovimento];

          this->Pointer->XValue[2] = this->XValue[2 + indexMovimento];
          this->Pointer->YValue[2] = this->YValue[2 + indexMovimento];

          // this->Pointer->Pointer->Color =  (!Movimento->MovimentoSelecionado)? TGIFColorMap::RGB2Color(fCorSerie_):COR_MOVIMENTO_SELECIONADO;
          TColor tColor = Movimento->MovimentoSelecionado || trem_->IsSelecionado ? COR_MOVIMENTO_SELECIONADO : TGIFColorMap::RGB2Color(fCorSerie_);

          this->Pointer->Pen->Color = tColor;
          this->Pointer->Color = tColor;
          this->Pointer->Pointer->Color = tColor;
          this->Pointer->LinePen->Color = tColor;

          if (TTPFormsManager::getInstance()->MovimentosSerieMouseOver == this && this->movimento_->IsArrastavel && !this->movimento_->Trem->IsSuprimido)
          {
            //if(!Pointer->Visible)
            {
              if (this->movimento_->IsArrastavel )
              {
                ParentChart->AutoRepaint = false;
                this->Pointer->Visible = true;
                ParentChart->AutoRepaint = true;
              // this->Pointer->DrawValue removido pois causava acess violation

              }

            }
            }
          else
          {

            if(this->Pointer->Visible)
            {
             ParentChart->AutoRepaint = false;
              this->Pointer->Visible = false;
             this-> ParentChart->AutoRepaint = true;

             // this->Pointer->DrawValue removido pois causava acess violation
            }
          }
        }
      }
    }

    return index;
  }
  catch (Exception& Ex)
  {

    if (this->ParentChart ) {

    int val1 = this->ParentChart->SeriesList->IndexOf(this);
    int val2 = this->ParentChart->SeriesList->IndexOf(this->Pointer);

      if (val1 <0 || val2 <0 ) {
                             int parar = 0;
      }
    }
    else
     int parar =0;
    return -1;

  }
}

// TTPMovimento* TTPMovimentoSeries::MovimentoAnterior(TTPMovimento* pMovimento)
// {
// TTPMovimento* tReturn = NULL;
// if (pMovimento == NULL)
// pMovimento = movimento_;
//
// int index = movimentos_->IndexOf(pMovimento->PID);
// if (index > 0)
// {
// return (TTPMovimento*) movimentos_->Objects[(index - 1)];
// }
//
//
// return NULL;
// }
// TTPMovimento* TTPMovimentoSeries::MovimentoPosterior(TTPMovimento* pMovimento)
// {
// TTPMovimento* tReturn = NULL;
// if (pMovimento == NULL)
// pMovimento = movimento_;
//
// if (pMovimento != NULL)
// {
// int index = movimentos_->IndexOf(pMovimento->PID);
// if (index > -1 && index < movimentos_->Count - 1)
// {
// tReturn = (TTPMovimento*) movimentos_->Objects[(index + 1)];
// }
// }
//
// return tReturn;
// }

TTPMovimento* TTPMovimentoSeries::GetMovimentoIndex(int index)
{
  TTPMovimento* tReturn = NULL;

  if (index > -1 && index < movimentos_->Count)
  {
    tReturn = (TTPMovimento*) movimentos_->Objects[index];
  }

  return tReturn;
}

TTPMovimento* TTPMovimentoSeries::GetUltimoMovimentoIndex()
{
  return GetMovimentoIndex(movimentos_->Count - 1);
}

TTPMovimento* TTPMovimentoSeries::MovimentoOrigem(bool selecionar)
{
  TTPMovimento* tReturn = &*Trem->ItinerarioTrem->Movimentos->operator[](0);

  if (selecionar && tReturn->Serie)
    tReturn->Serie->movimento_ = tReturn;

  return tReturn;

}

TPoint TTPMovimentoSeries::getCoord(int index)
{
  TPoint tReturn;
  if (index > -1 && index < XValues->Count - 1)
  {
    tReturn.x = XValue[index];
    tReturn.y = YValue[index];
  }

  return tReturn;
}

TPoint TTPMovimentoSeries::getUltimaChegadaCoord()
{
  return getCoord(XValues->Count - PONTOS_SERIE);
}

TPoint TTPMovimentoSeries::getUltimaCoord()
{
  return getCoord(XValues->Count - 1);
}

int TTPMovimentoSeries::GetIndexSerieFromMovimento(TTPMovimento* pMovimento)
{
  if (!pMovimento)
  {
    if (this->movimento_ == NULL)
      return 0;  //return -1
    pMovimento = this->movimento_;
  }
  int index = this->movimentos_->IndexOf(pMovimento->PID);

  return index*PONTOS_SERIE;
}

void TTPMovimentoSeries::SetObservacoesVisible(bool visible)
{
  for (int i = 0; i < this->seriesObservacao_->Count; i++)
  {
    TTPObservacaoSeries *serieObservacao = (TTPObservacaoSeries*)this->seriesObservacao_->Objects[i];
    serieObservacao->Visible = visible;
  }
}

void TTPMovimentoSeries::RemoverMovimento(TTPMovimento* pMovimento)
{
  if (this && movimentos_)
  {
    int index = movimentos_->IndexOf(pMovimento->PID);

    if (index > -1)
    {
      movimentos_->Delete(index);
      pMovimento->Serie = NULL;
    }

    index = YValueMovimentos_->IndexOf(pMovimento->PID);
    if (index > -1)
    {
      double* ValuesYPos = (double*)YValueMovimentos_->Objects[index];
      this->YValues->Delete(this->YValues->Locate(ValuesYPos[0]));
      this->YValues->Delete(this->YValues->Locate(ValuesYPos[1]));
      this->YValues->Delete(this->YValues->Locate(ValuesYPos[2]));

      YValueMovimentos_->Delete(index);
      delete[] ValuesYPos;
    }

    index = XValueMovimentos_->IndexOf(pMovimento->PID);
    if (index > -1)
    {
      double* ValuesXPos = (double*)XValueMovimentos_->Objects[index];
      this->XValues->Delete(this->XValues->Locate(ValuesXPos[0]));
      this->XValues->Delete(this->XValues->Locate(ValuesXPos[1]));
      this->XValues->Delete(this->XValues->Locate(ValuesXPos[2]));
      XValueMovimentos_->Delete(index);
      delete[] ValuesXPos;
    }

    index = seriesObservacao_->IndexOf(pMovimento->PID);
    if (index > -1)
    {
      TTPObservacaoSeries *serieObservacao = (TTPObservacaoSeries*)this->seriesObservacao_->Objects[index];
      try
      {
        if (serieObservacao->ParentChart)
          serieObservacao->ParentChart->RemoveSeries(serieObservacao);

        serieObservacao->MovimentoSerie = NULL;
        delete serieObservacao;
      }
      catch (...)
      {

      }
      this->seriesObservacao_->Delete(index);
    }

  }
}

void TTPMovimentoSeries::AddPontoNull(bool addMovimento)
{
  if (this->XValues->Count > 0)
  {
    if (addMovimento)
      movimentos_->AddObject("NULL", NULL);

    double X = this->XValue[this->XValues->Count - 1];
    double Y = this->YValue[this->YValues->Count - 1];
    this->AddNullXY(X, Y);
    this->AddNullXY(X, Y);
    this->AddNullXY(X, Y);
  }
}

TTPMovimento* TTPMovimentoSeries::GetMovimento()
{
  if (inDelete_)
  {
     return NULL;
  }
  if (movimento_ == NULL)
  {

    if (movimentos_ && movimentos_->Count > 0)
      movimento_ = (TTPMovimento*) movimentos_->Objects[0];
    else if (seriePrincipal_)
    {
      movimento_ = seriePrincipal_->movimento_;
      this->Visible = false;
    }

  }
  return movimento_;

}

void TTPMovimentoSeries::SetMovimento(TTPMovimento *pMovimento)
{
  movimento_ = pMovimento;
}

void TTPMovimentoSeries::addMovimentoSelecionado(TTPMovimento *pMovimento)
{
  if (this->serieSelecao_)
  {
    this->ParentChart->AutoRepaint = true;
    pMovimento->MovimentoSelecionado = true;

    double* ValuesYPos = (double*)this->YValueMovimentos_->Objects[this->YValueMovimentos_->IndexOf(pMovimento->PID)];
    double* ValuesXPos = (double*)this->XValueMovimentos_->Objects[this->XValueMovimentos_->IndexOf(pMovimento->PID)];

    this->serieSelecao_->PlotarPontos(pMovimento, ValuesXPos[0], ValuesYPos[0], ValuesXPos[1], ValuesYPos[1], ValuesXPos[2], ValuesYPos[2]);
    this->serieSelecao_->movimentos_->AddObject(pMovimento->PID, (TObject*)pMovimento);
    this->serieSelecao_->Movimento = pMovimento;
// removido pois estava causando acess violation ao chamar o this->serieSelecao_->DrawValue pois  o this->serieSelecao_->Visible = true; faz um draw value

    this->serieSelecao_->Visible = true;

    int indexOf = -1;
    int t_primeiraSerieMovimento = this->ParentChart->SeriesCount() - 1;
    indexOf = this->ParentChart->SeriesList->IndexOf(this->serieSelecao_);
    if (indexOf > -1)
      this->ParentChart->ExchangeSeries(indexOf, t_primeiraSerieMovimento);
    RedrawTrain();
  }
}


void TTPMovimentoSeries::addMovimentoSelecaoOportunidade(TTPMovimento *pMovimento)
{
  if (this->ListaOportunidades)
  {
    TTPMovimentoSeries* serieSelecaoOportunidade = new TTPMovimentoSeries((TChart*)this->ParentChart, this->trem_, this->movimento_, this->hint, true);
    ListaOportunidades->AddObject("",(TObject*) serieSelecaoOportunidade);
    ((TChart*)this->ParentChart)->AddSeries(serieSelecaoOportunidade);

  //  this->ParentChart->AutoRepaint = false;

    double* ValuesYPos = (double*)this->YValueMovimentos_->Objects[this->YValueMovimentos_->IndexOf(pMovimento->PID)];
    double* ValuesXPos = (double*)this->XValueMovimentos_->Objects[this->XValueMovimentos_->IndexOf(pMovimento->PID)];

    serieSelecaoOportunidade->PlotarPontos(pMovimento, ValuesXPos[0], ValuesYPos[0], ValuesXPos[1], ValuesYPos[1], ValuesXPos[2], ValuesYPos[2]);
    serieSelecaoOportunidade->movimentos_->AddObject(pMovimento->PID, (TObject*)pMovimento);
    serieSelecaoOportunidade->Movimento = pMovimento;
//No pode chamar o DrawValue seno da acess Violation na GDIPLUS, e como esta serie  desenhada somente uma vez no h necessidade.
//    serieSelecaoOportunidade->DrawValue(serieSelecaoOportunidade->XValues->Count - 1);
//    serieSelecaoOportunidade->DrawValue(serieSelecaoOportunidade->XValues->Count - 2);
//    serieSelecaoOportunidade->DrawValue(serieSelecaoOportunidade->XValues->Count - 3);

    serieSelecaoOportunidade->Visible = true;
  //  this->ParentChart->AutoRepaint = true;
  //  this->ParentChart->AutoRepaint = false;
  }
}

void TTPMovimentoSeries::clearMovimentoSelecionado()
{
  if (serieSelecao_ && this->serieSelecao_->Visible)
  {
    for (int i = 0; i < movimentos_->Count; i++)
    {
      TTPMovimento* tMovimento = (TTPMovimento*) movimentos_->Objects[i];
      tMovimento->MovimentoSelecionado = false;
    }
    if (serieSelecao_)
    {

      serieSelecao_->XValues->Delete(0, serieSelecao_->XValues->Count);
      serieSelecao_->YValues->Delete(0, serieSelecao_->XValues->Count);
      serieSelecao_->Movimentos->Clear();
      serieSelecao_->AddPontoNull();


      this->serieSelecao_->Visible = false;
      this->serieSelecao_->Pointer->Visible = false;

    }
     this->Pointer->Visible = false;
  }
  // ReplotarSerie();
}

void TTPMovimentoSeries::ReplotarSerie()
{
  int x = this->XValues->Count;
  this->XValues->Delete(0, this->XValues->Count);
  this->YValues->Delete(0, this->XValues->Count);

  x = this->XValues->Count;
  this->ParentChart->AutoRepaint = false;
  for (int i = 0; i < movimentos_->Count; i++)
  {
    TTPMovimento* tMovimento = (TTPMovimento*) movimentos_->Objects[i];
    if (tMovimento == NULL)
    {
      this->AddPontoNull(false);
    }
    else
    {
      if (serieSelecao_ && serieSelecao_->movimentos_ && serieSelecao_->movimentos_->IndexOf(tMovimento->PID) > -1)
      {
        this->AddPontoNull(false);
      }
      else
      {
        double* ValuesYPos = (double*)YValueMovimentos_->Objects[YValueMovimentos_->IndexOf(tMovimento->PID)];
        this->PlotarPontos(tMovimento, 0, ValuesYPos[0], 0, ValuesYPos[1], 0, ValuesYPos[2]);
      }
    }
  }
  x = this->XValues->Count;
  this->ParentChart->AutoRepaint = true;
}

bool TTPMovimentoSeries::isValidClick()
{
  try
  {
    TPoint mousePosition = ParentChart->GetCursorPos();
    // hint_->SerieAtual = (TObject*)this;

    indexSelected_ = Clicked(mousePosition, false);
  }
  catch (...)
  {
    return false;
  }
  if (indexSelected_ < 0 || movimentos_->Count == 0 || indexSelected_/PONTOS_SERIE >= movimentos_->Count)
    return false;
  indexSelected_ = indexSelected_ / PONTOS_SERIE;
  int tIndex = indexSelected_ * PONTOS_SERIE;
  int movimentoIndex = getIndexMovimentoFromIndexSerie(tIndex);

  if (movimentoIndex == -1)
    return false;
  this->movimento_ = (TTPMovimento*) movimentos_->Objects[movimentoIndex];

  if (!this->movimento_)
    return false;

  // tirar mouse move de movimentos realizados no viewer nos casos que os mesmos no devem ser exibidos
  if (TTPFormsManager::getInstance()->ShowVisualizador && this->movimento_->IsRealizado)
  {

    if (!TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer)
      return false;

    if (TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && ((double)TTPFormsManager::getInstance()->Data < (double)this->movimento_->DataChegada))
      return false;
  }

  return true;
}

void TTPMovimentoSeries::RedrawSerie(bool pAltoRepaint)
{
  String msg = "";
  double linhaTempo = (double)TTPFormsManager::getInstance()->Data;
  if (!this->movimentos_)
      return;
  if(!this->ParentChart)
   return;

   int i = 0;
  this->ParentChart->AutoRepaint = pAltoRepaint;
  try
  {
    for (i = 0; i < this->XValues->Count; i++)
    {
      this->DrawValue(i, true);
    }

    if(GetMovimento() && GetMovimento()->IsRealizado && TTPFormsManager::getInstance()->ShowVisualizador)
    {
    for (i = 0; i < this->XValues->Count; i++)
    {

      if(indexUltimoRealizadoAntesLinhaTempo==-1 || !TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer)
      {
     // zera os valores de x pra no chamar os eventos de mouseover
        this->XValue[i] = -100;
        this->YValue[i] = -100;
      }
      else if (i>indexUltimoRealizadoAntesLinhaTempo && TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo)
      {
        if(this->XValue[i]>=linhaTempo)
        {
          this->XValue[i] = linhaTempo;
          this->YValue[i] = this->YValue[indexUltimoRealizadoAntesLinhaTempo+1];
        }
      }

      if(i / PONTOS_SERIE >= movimentos_->Count)
      {
        if(this->XValue[i]>=linhaTempo)
        {
          int lastValue =  (movimentos_->Count-1)*PONTOS_SERIE;
          this->XValue[i] = this->XValue[lastValue];
          this->YValue[i] = this->YValue[lastValue];
        }
      }
    }

    }
  }
  catch(Exception &e)
  {
    TTPFormsManager::getInstance()->AntialiasONOFF(true);
    String prefixo = "";
    if (this->trem_)
      prefixo = this->trem_->Prefixo;

    msg = "Erro ao Redesenhar a srie do trem: "+prefixo+
                  " no ndice: "+IntToStr(i)+" de "+IntToStr(XValues->Count)+
                  "\nReferente ao movimento :"+IntToStr(i/3)+" de "+IntToStr(movimentos_->Count)+
                  "\nMsg Erro:"+ e.Message;
  }
  if(msg!="")
    throw Exception(msg);
}


int  TTPMovimentoSeries::GetIndexPoint(TPoint mousePosition)
{
//for(int i = 0; i< this->XValues->Count-1; i++)
// {
//  float a = (YValues[i] - YValues[i+1]);
//  float b = (XValues[i] - XValues[i+1]);
// }

  return 0;
}
int __fastcall TTPMovimentoSeries::Clicked(int xVal, int yVal)
{
   return TFastLineSeries::Clicked(xVal,yVal);
}

void TTPMovimentoSeries::printPoints()
{
  TStringList * lista =  new TStringList();
  lista->Add(IntToStr(this->XValues->Count)+"  "+movimentos_->Count+"");
   for (int i = 0; i < this->XValues->Count; i++)
   {

     int index = i/3;

     if(index<movimentos_->Count)
     {
       TTPMovimento* tMovimento = (TTPMovimento*) movimentos_->Objects[index];

       lista->Add( tMovimento->SB->NomeVia+" "+"i:"+FloatToStr(this->XValues->operator [](i))+" - "+this->YValue[i]);
     }
     else
     {
       lista->Add("i:"+IntToStr(i)+" "+FloatToStr(this->XValues->operator [](i))+" - "+this->YValue[i]);
     }
   }

   lista->SaveToFile("c:\\prefixos\\"+this->movimento_->SB->Ramal+"-"+trem_->Prefixo+".txt");
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPChartShapeBase.h =====
//---------------------------------------------------------------------------

#ifndef UTPChartShapeBaseH
#define UTPChartShapeBaseH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Series.hpp>
#include <TeeShape.hpp>

class TTPHintSeries;


class TTPChartShapeBase : public TChartShape
{
 protected:

  TLabel* labelStatus;
  TTPHintSeries* hint__;
  TLabel* labelStatus_;

  int PERCENTUAL_TRANSPARENCIA;

  public:
  __fastcall TTPChartShapeBase(System::Classes::TComponent* AOwner) ;
};



#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPLinhaTempoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPLinhaTempoSeriesH
#define UTPLinhaTempoSeriesH
//---------------------------------------------------------------------------

#include <VCLTee.Series.hpp>
#include <VCLTee.TeeShape.hpp>

enum TTPTipoLinhaTempo { tltHoraAtual, tslZeroHoras, tslZerarParada };
//---------------------------------------------------------------------------
class TTPLinhaTempoSeries : public TLineSeries
{
  TDateTime FDataHora_;
  TDateTime FDataHoraCongelada_;
  TTPTipoLinhaTempo FTipoLinhaTempo_;
  bool serieCongelar_;
  bool Arrastou_;
  bool Arrastando_;


public:
   double YValuesDef[2];

   __fastcall virtual ~TTPLinhaTempoSeries();
   __fastcall TTPLinhaTempoSeries(System::Classes::TComponent* AOwner, double pX, int NumPatios, TDateTime dataHora, TTPTipoLinhaTempo tipoLinhaTempo = tslZeroHoras, bool serieCongelar = false);
   void ConfigurarSerie(bool layoutImpressao = false);
   String getHintString();

   __property bool   Arrastando    = {read=Arrastando_, write=Arrastando_};
   __property bool   Arrastou      = {read=Arrastou_, write=Arrastou_};
   __property TDateTime   DataCongelada = {read=FDataHoraCongelada_, write=FDataHoraCongelada_};

   virtual void __fastcall DrawValue(int ValueIndex);
   void Arrastar(double X, bool pPosicaoInicio = false);
   void __fastcall DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button, System::Classes::TShiftState Shift, int X, int Y);
};

//---------------------------------------------------------------------------
#endif


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPHintSeries.cpp =====
// ---------------------------------------------------------------------------

#pragma hdrstop

#include "UTPHintSeries.h"
#include "FTP.h"
#include "UTPAtividade.h"
#include "UTPTipoAtividade.h"
#include "UTPMovimento.h"
#include "UTPItinerarioTrem.h"
#include "UTPTremSeries.h"
#include "UTPSB.h"
#include "UTPTipoRestricao.h"
#include <System.hpp>
#include <stdio.h>
//#include "../domain/SegmentoTremOficializado.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"


// ---------------------------------------------------------------------------
#pragma package(smart_init)

TTPHintSeries::TTPHintSeries(TcxHintStyleController *hintStyleController,
	TdxScreenTipRepository *screenTipRepository, bool isVisualizador)
{
  this->t_screenTipRepository = screenTipRepository;
  this->t_hintStyleController = hintStyleController;
  formatoDataPadrao_ = "dd/mm/yyyy hh:mm";

  // preenchendo as variaveis de preenchimento padrao
  // observacao - 0
  // movimento - 1
  // restricao - 2
  tituloDefaultObservacao_ = this->t_screenTipRepository->Items->operator[](0)->Header->Text;
  corpoDefaultObservacao_ = this->t_screenTipRepository->Items->operator[](0)->Description->Text;
  tituloDefaultMovimento_ = this->t_screenTipRepository->Items->operator[](1)->Header->Text; ;
  corpoDefaultMovimento_ = this->t_screenTipRepository->Items->operator[](1)->Description->Text;
  tituloDefaultRestricao_ = this->t_screenTipRepository->Items->operator[](2)->Header->Text;
  corpoDefaultRestricao_ = this->t_screenTipRepository->Items->operator[](2)->Description->Text;
  tituloDefaultFarol_= this->t_screenTipRepository->Items->operator[](3)->Header->Text;
  corpoDefaultFarol_ = this->t_screenTipRepository->Items->operator[](3)->Description->Text;

	isVisualizador_ = isVisualizador;

	SeriesHint_ = NULL;
}
TTPHintSeries::~TTPHintSeries()
{
  int teste =0;
}

void TTPHintSeries::ReloadHint()
{
	if(SeriesHint_!=NULL)
	{
		PreencheHint(SeriesHint_);
	}
}

void TTPHintSeries::PreencheHint(TChartSeries* CustomSeries)
{
   if (CustomSeries == SeriesHint_) {
     return;
   }
	clearHint(NULL);
	SeriesHint_ =  CustomSeries;
	#ifdef BENCHMARK_
	TTPBenchmark::getInstance()->StartBenchmark("HintChart", GetTickCount());
	#endif
	if (dynamic_cast<TTPObservacaoSeries*>(CustomSeries))
	{

		// declarando o objeto do tipo observacao
		TTPObservacaoSeries* observacaoSeries = (TTPObservacaoSeries*) CustomSeries;

		// definindo o hitn style(aquele que controla os diferentes tips)
		TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
		t_hintStyle->ScreenTipLinks->operator[](0)->Control = observacaoSeries->ParentChart;
		// setando para o segundo item da lista de tips (o tip da observacao)
		t_hintStyle->ScreenTipLinks->operator[](0)->ScreenTip =
				(TdxScreenTip*) this->t_screenTipRepository->Items->operator[](0);

  }

  else if (dynamic_cast<TTPMovimentoSeries*>(CustomSeries) || dynamic_cast<TTPTremSeries*>(CustomSeries))
	{
		TTPMovimentoSeries* movimentoSeries = (TTPMovimentoSeries*) CustomSeries;
    // definindo o hitn style(aquele que controla os diferentes tips)
    TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
    t_hintStyle->ScreenTipLinks->operator[](0)->Control = CustomSeries->ParentChart;
    // setando para o segundo item da lista de tips (o tip do movimento)
    t_hintStyle->ScreenTipLinks->operator[](0)->ScreenTip =
        (TdxScreenTip*) this->t_screenTipRepository->Items->operator[](1);

  }

  else if (dynamic_cast<TTPRestricaoSeries*>(CustomSeries))
	{
    // declarando o objeto do tipo restrio
    TTPRestricaoSeries* restricaoSeries = (TTPRestricaoSeries*) CustomSeries;
    // definindo o hitn style(aquele que controla os diferentes tips)
    TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
    t_hintStyle->ScreenTipLinks->operator[](0)->Control = restricaoSeries->ParentChart;
    // setando para o terceiro item da lista de tips (o tip da restricao)
    t_hintStyle->ScreenTipLinks->operator[](0)->ScreenTip =
				(TdxScreenTip*) this->t_screenTipRepository->Items->operator[](2);

  }
  else
  {

    //SeriesHint_ =  NULL;
		 TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
  t_hintStyle->ScreenTipLinks->operator[](0)->Control = NULL;
  reloadDefaults();
  }

}

void TTPHintSeries::PreencheHint()
{
  String strTL = TTPFormsManager::getInstance()->DescricaoTremLongo;
	SeriesHint_ =  SeriesHint_;
	if (dynamic_cast<TTPObservacaoSeries*>(SeriesHint_))
	{

		// le os padroes e os seta nos hints
		reloadDefaults();
		// for do movimento
    // declarando o objeto do tipo observacao
		TTPObservacaoSeries* observacaoSeries = (TTPObservacaoSeries*) SeriesHint_;

		for (int x = 0; x < observacaoSeries->Movimento->Trem->Atividades->count(); x++)
		{
			TTPAtividadePtr atividade = observacaoSeries->Movimento->Trem->Atividades->operator[](x);

			domain::AtividadePlanejamento  *atvServer = observacaoSeries->Movimento->ServerSegTremRealizado? NULL:
																									observacaoSeries->Movimento->ServerSegTremPlanejado ?
																									observacaoSeries->Movimento->ServerSegTremPlanejado->atividade:
																									observacaoSeries->Movimento->ServerSegTremOficializado->getAtividade();

			if (atividade->AtividadeServer == atvServer && !atividade->SBAtual.isNull()
					&& atividade->SBAtual->NomeVia == observacaoSeries->Movimento->SB->NomeVia)
			{


				// prefixo: &
        String prefixo = (isVisualizador_ ? observacaoSeries->Movimento->Trem->GetPrefixoVisualizador() : observacaoSeries->Movimento->Trem->Prefixo);
        if(observacaoSeries->Movimento->Trem->CheckTremLongo() || observacaoSeries->Movimento->checkTremLongo())
          prefixo += strTL;
				this->t_screenTipRepository->Items->operator[](0)->Header->Text =
						ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Header->Text, "&", prefixo );

        // pronto: $
        // formatando a data
       // dataTremPronto_ =   observacaoSeries->Movimento->Trem->DataTremPronto;
       // DateTimeToString(stringDataTremPronto_,formatoDataPadrao_, dataTremPronto_);

        this->t_screenTipRepository->Items->operator[](0)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Description->Text, "$",
            "");

        // sb : !
        this->t_screenTipRepository->Items->operator[](0)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Description->Text, "!",
            atividade->SBAtual->NomeVia);
        // tipo de atividade : %
        this->t_screenTipRepository->Items->operator[](0)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Description->Text, "%",
            atividade->Tipo->Nome);
        // inicio atividade fim: @


        if (atividade->Duracao > 0)
        {
          duracaoFormatadaFim_ = atividade->DuracaoFormatada;}
        else
        {
        duracaoFormatadaFim_ = "";
        }

        if (atividade->DataFim > TDateTime(0))
        {
          // formata a data fim a atividade
          atividadeDataFim_ = atividade->DataFim;
          DateTimeToString(stringAtividadeDataFim_, formatoDataPadrao_, atividadeDataFim_);

          this->t_screenTipRepository->Items->operator[](0)->Description->Text =
              ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Description->Text, "@",

              stringAtividadeDataFim_ + "(" + duracaoFormatadaFim_ + ")");
        }

        else
        {
          this->t_screenTipRepository->Items->operator[](0)->Description->Text =
              ReplaceStr(this->t_screenTipRepository->Items->operator[](0)->Description->Text, "@","(" + duracaoFormatadaFim_ + ")");
        }


        // fim do atividade fim

      }
		}

	}

	else if (dynamic_cast<TTPMovimentoSeries*>(SeriesHint_) || dynamic_cast<TTPTremSeries*>(SeriesHint_) )
	{
		// le os padroes e os seta nos hints
		reloadDefaults();
    TTPMovimento *movimento;
    // declarando o objeto do tipo movimento
    if(dynamic_cast<TTPMovimentoSeries*>(SeriesHint_))
    {
      TTPMovimentoSeries* movimentoSeries = (TTPMovimentoSeries*) SeriesHint_;
      movimento =  movimentoSeries->Movimento;
    }
    else
    {
      TTPTremSeries* tremSeries = (TTPTremSeries*) SeriesHint_;
      movimento =  tremSeries->Movimento;
    }
    trem_ = movimento->Trem;
		// variaveis para caso o trem tenha pai
		if(movimento->ServerSegTremOficializado && movimento->ServerSegTremOficializado->oficializacao->prefixoTremPaiOficializado!="")
			prefixoPai_ = movimento->ServerSegTremOficializado->oficializacao->prefixoTremPaiOficializado;
		else
			prefixoPai_ = movimento->Trem->PrefixoPai;
		pidPai = movimento->Trem->PIDPai;
		previsaoFimPai_ = movimento->Trem->PrevisaoFimPai;

		if (prefixoPai_ != "")
    {

      // PREFIXO
      String prefixo = (isVisualizador_ ? movimento->Trem->GetPrefixoVisualizador() : movimento->Trem->Prefixo);
      if(movimento->Trem->CheckTremLongo() || movimento->checkTremLongo())
        prefixo += strTL;

      this->t_screenTipRepository->Items->operator[](1)->Header->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Header->Text, "&", prefixo);

      // PRONTO
       // formatando a data
			dataTremPronto_ = movimento->Trem->DataTremPronto;
      DateTimeToString(stringDataTremPronto_,formatoDataPadrao_, dataTremPronto_);

      tempoPermanenciaTerminal_  = movimento->Trem->TempoPermanenciaTerminal;
      //verificando o tempo de permanencia no terminal
			if((double)movimento->Trem->DataTremPronto>0)
			{
					this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "$",
					stringDataTremPronto_ + "(" + tempoPermanenciaTerminal_ + ")");
			 }
			 else
			 {
					this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "$",
					"");
			 }


      // SB
      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "!",
          movimento->SB->NomeVia);

      if(movimento->IsCancelarOcupacao)
      {
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "\\cf1\\fs20\\par\r\n\\fs16 In\\'edcio........:\\cf2\\fs18 #\\cf1\\fs20\\par\r\n\\fs16",
          "\\par\r\n\\cf1Canc. Oc.:\\cf2 Sim\\cf1\\fs20\\par\r\n\\fs16 In\\'edcio........:\\cf2\\fs18 #\\cf1\\fs20\\par\r\n\\fs16");
      }

      // INCIO
      // formatando data chegada
	  dataChegada_ = movimento->DataChegada;
      DateTimeToString(stringDataChegada_,formatoDataPadrao_, dataChegada_);

      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "#",
          stringDataChegada_);
      // FIM
      // formatando data saida
      dataSaida_ = movimento->DataSaida;
      DateTimeToString(stringDataSaida_, formatoDataPadrao_, dataSaida_);

      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "@",
          stringDataSaida_);

			// DESTINO
			if(movimento->ServerSegTremOficializado && movimento->ServerSegTremOficializado->oficializacao->tabelaTremOficializado!="")
				tremTabela_ = movimento->ServerSegTremOficializado->oficializacao->tabelaTremOficializado;
			else
				tremTabela_ = movimento->Trem->Tabela;

      String tDestinoTrem = trem_->ItinerarioTrem->Movimentos->operator[]
          (trem_->ItinerarioTrem->Movimentos->count() - 1)->SB->CodigoSegmento;

			if (tremTabela_ > 0)
      {
        tDestinoTrem += " (" + tremTabela_+ ")";
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "*",
            tDestinoTrem );
      }
      else
      {
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "*",
            tDestinoTrem);
      }


      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "*",
          movimento->Trem->Destino);

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "+",
					prefixoPai_ + "     TP(" +(String) movimento->Trem->DeltaPermanenciaTerminalPai + ")");

			// PREVISAO ....verifica se  uma data valida
			if ((double)previsaoFimPai_ > 0)
      {

        // formatando previsaofimpau
        DateTimeToString(stringPrevisaoFimPai_,formatoDataPadrao_, previsaoFimPai_);
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "[",
						stringPrevisaoFimPai_);

      }
      else
      {
					// PREVISAO

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "[", "");

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
					"Prev.Fim..:\\cf2 \\par\r\n", "");
			}
	}
    else
	{

			// REMOVE AS STRINGS DO TREM PAI E DA PREVISAO

			// PAI  prefixoPai_
			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "+", "");

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
					"Pai............:\\cf2 \\cf3\\par\r\n", "");

			// PREVISAO

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "[", "");

			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
					ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
					"Prev.Fim..:\\cf2 \\par\r\n", "");

	  // PREFIXO

      String prefixo = (isVisualizador_ ?  movimento->Trem->GetPrefixoVisualizador() : movimento->Trem->Prefixo);
      #ifdef BAIXADA_SANTISTA
      if (movimento->Trem->PrefixoAnotherRailway != "")
      {
        prefixo = (isVisualizador_ ?  movimento->Trem->GetPrefixoVisualizador() + " [ " + movimento->Trem->PrefixoAnotherRailway +" ]" : movimento->Trem->Prefixo + " [ " + movimento->Trem->PrefixoAnotherRailway +" ]" );
      }

      #endif
      if(movimento->Trem->CheckTremLongo() || movimento->checkTremLongo())
        prefixo += strTL;

      this->t_screenTipRepository->Items->operator[](1)->Header->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Header->Text, "&", prefixo);

	  // PRONTO
      // formatando datatrepronto
      dataTremPronto_ = movimento->Trem->DataTremPronto;
      DateTimeToString(stringDataTremPronto_, formatoDataPadrao_, dataTremPronto_);

        tempoPermanenciaTerminal_  = movimento->Trem->TempoPermanenciaTerminal;
			//verificando o tempo de permanencia no terminal
			if((double)movimento->Trem->DataTremPronto>0)
			{
				this->t_screenTipRepository->Items->operator[](1)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "$",
				stringDataTremPronto_ + "(" + tempoPermanenciaTerminal_ + ")");
			}
			else
			{
				this->t_screenTipRepository->Items->operator[](1)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "$",
				"");
			}


      // SB
      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "!",
          movimento->SB->NomeVia);

      if(movimento->IsCancelarOcupacao)
      {
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "\\cf1\\fs20\\par\r\n\\fs16 In\\'edcio........:\\cf2\\fs18 #\\cf1\\fs20\\par\r\n\\fs16",
          "\\par\r\n\\cf1Canc. Oc.:\\cf2 Sim\\cf1\\fs20\\par\r\n\\fs16 In\\'edcio........:\\cf2\\fs18 #\\cf1\\fs20\\par\r\n\\fs16");
      }

      // INCIO
      // formatando data chegada
	  dataChegada_ = movimento->DataChegada;
	  DateTimeToString(stringDataChegada_, formatoDataPadrao_, dataChegada_);

      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "#",
		  stringDataChegada_);
	  // FIM
      // formatando data saida
      dataSaida_ = movimento->DataSaida;
	  DateTimeToString(stringDataSaida_, formatoDataPadrao_, dataSaida_);

      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
          ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "@",
          stringDataSaida_);



      	// DESTINO
			if(movimento->ServerSegTremOficializado && movimento->ServerSegTremOficializado->oficializacao->tabelaTremOficializado!="")
				tremTabela_ = movimento->ServerSegTremOficializado->oficializacao->tabelaTremOficializado;
			else
				tremTabela_ = movimento->Trem->Tabela;

      String tDestinoTrem = trem_->ItinerarioTrem->Movimentos->operator[]
		  (trem_->ItinerarioTrem->Movimentos->count() - 1)->SB->CodigoSegmento;

			if (tremTabela_.Length() > 0)
      {
				tDestinoTrem += " (" + tremTabela_ + ")";
        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "*",
            tDestinoTrem );
      }
      else
      {
				this->t_screenTipRepository->Items->operator[](1)->Description->Text =
			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "*",
            tDestinoTrem);
	  }

	}

	if(((double)movimento->DataHoraBaseCarregamento) > 0)
	{
		TDateTime dataOficializacao_ = movimento->DataHoraBaseCarregamento;
		String stringDataOficializacao_ = "";
		DateTimeToString(stringDataOficializacao_, formatoDataPadrao_, dataOficializacao_);

		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
				"]", stringDataOficializacao_ );
	}
	else
	{
//		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
//			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
//		"]", "");
//
//		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
//			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
//			"DataBase..:", "");

		TDateTime dataCarregamento_ = movimento->Trem->DataCarregamento;
		String stringDataCarregamento_= "";
		DateTimeToString(stringDataCarregamento_, formatoDataPadrao_, dataCarregamento_);

		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
				"]", stringDataCarregamento_ );
	}

	if(movimento->ServerSegTremOficializado && !movimento->ServerSegTremOficializado->oficializacao->dataHoraBaseAtualizacao.is_not_a_date_time() )
	{
		TDateTime dataAtualizacao = movimento->ServerSegTremOficializado->oficializacao->dataHoraBaseAtualizacao.asDateTime();
		String stringDataAtualizacao= "";
		DateTimeToString(stringDataAtualizacao, formatoDataPadrao_, dataAtualizacao);

		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
				"%", stringDataAtualizacao );
	}
	else
	{
			this->t_screenTipRepository->Items->operator[](1)->Description->Text =
			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
		"%", "");

		this->t_screenTipRepository->Items->operator[](1)->Description->Text =
			ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text,
			"\\par\r\n\\cf1 Carregamento..:\\cf2 \\cf4\\par\r\n", "");
  }
      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "&",
            movimento->getEquipagem());

    #ifndef BAIXADA_SANTISTA
    this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "99999999",
            movimento->getResumoPosicaoEquipamentos());

    #endif
    #ifdef BAIXADA_SANTISTA

    String stringDataNecessidade= "";
    //movimento->Trem->DataNecessidadePorto = Now();
    if (movimento->Trem->DataNecessidadePorto >=  EncodeDate(2024, 1, 1))
    {
      DateTimeToString(stringDataNecessidade, formatoDataPadrao_, movimento->Trem->DataNecessidadePorto);

      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "\\par\r\n\\cf1 LXA..........:\\cf2 99999999\\cf4\\fs18\\par\r\n",
            "\r\n \\lang1046 \\f0 \\fs18 \\cf1 Dt.Porto...: \\cf2 \\fs18 " + stringDataNecessidade.SubString(1, 16)   + " \\par\r\n");

      if (isVisualizador_)
      {
//        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
//            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "LXA..........: ",
//            "Dt.Porto..:");
//             //\\par\r\n\\cf1 LXA..........:\\cf2 99999999\\

        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "LXA..........:\\cf2 99999999",
            "Dt.Porto..:\\cf2 " + stringDataNecessidade.SubString(1, 16));

      }

    }
    else
    {
      this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "\\par\r\n\\cf1 LXA..........:\\cf2 99999999\\cf4\\fs18\\par\r\n",
            "\r\n \\lang1046 \\f0 \\fs18 \\cf1 Dt.Porto...: \\cf2 No encontrada \\par\r\n");

      if (isVisualizador_)
      {
//        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
//            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "LXA..........: ",
//            "Dt.Porto..:");
//             //\\par\r\n\\cf1 LXA..........:\\cf2 99999999\\

        this->t_screenTipRepository->Items->operator[](1)->Description->Text =
            ReplaceStr(this->t_screenTipRepository->Items->operator[](1)->Description->Text, "LXA..........:\\cf2 99999999",
            "Dt.Porto..:\\cf2 No encontrada");

      }
    }



    #endif
	}

	else if (dynamic_cast<TTPRestricaoSeries*>(SeriesHint_))
  {
		// le os padroes e os seta nos hints
		reloadDefaults();
		// declarando o objeto do tipo restrio
		TTPRestricaoSeries* restricaoSeries = (TTPRestricaoSeries*) SeriesHint_;

    // vendo se  restricao ou interdicao
		String t_tipo = "";
    if(!restricaoSeries->Restricao->Tipo->ISPararTrem)
      t_tipo = "Restrio";
    else if(restricaoSeries->Restricao->Tipo->ISPararTrem && !restricaoSeries->Restricao->Tipo->ISPermiteOcupacao)
      t_tipo = "Interdio";
    else if(restricaoSeries->Restricao->Tipo->ISPararTrem && restricaoSeries->Restricao->Tipo->ISPermiteOcupacao)
      t_tipo = "Reteno";

    // setando o cabecalho
    this->t_screenTipRepository->Items->operator[](2)->Header->Text =
        ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Header->Text, "&", t_tipo);

    // pegando o inicio e o fim da restricao
    String inicio = restricaoSeries->Restricao->GetSBInicio()->NomeVia;
    String fim = restricaoSeries->Restricao->GetSBFim()->NomeVia;
    this->t_screenTipRepository->Items->operator[](2)->Description->Text =
        ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "!",
        inicio + " " + fim);
    // INCIO
    //formatando a data
    restricaoDataInicio_ = restricaoSeries->Restricao->DataInicio;
    DateTimeToString(stringRestricaoDataInicio_, formatoDataPadrao_, restricaoDataInicio_);

    this->t_screenTipRepository->Items->operator[](2)->Description->Text =
        ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "#",
        stringRestricaoDataInicio_);
    // FIM
    //formatando a data
    restricaoDataFim_ = restricaoSeries->Restricao->DataFim;
    DateTimeToString(stringRestricaoDataFim_, formatoDataPadrao_, restricaoDataFim_);
    this->t_screenTipRepository->Items->operator[](2)->Description->Text =
        ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "@",
        stringRestricaoDataFim_);

    restricaoDataMinIni_ = restricaoSeries->Restricao->DataMinInicio;
    DateTimeToString(stringRestricaoDataMinIni_, formatoDataPadrao_, restricaoDataMinIni_);

    restricaoDataMaxFim_ = restricaoSeries->Restricao->DataMaxFim;
    DateTimeToString(stringRestricaoDataMaxFim_, formatoDataPadrao_, restricaoDataMaxFim_);

		if((restricaoDataMinIni_ > TDateTime(0)))
		{
			this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "$",
				stringRestricaoDataMinIni_ );
				this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "%",
				stringRestricaoDataMaxFim_);
		}else
		{
				this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "$",
				"");
				this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "%",
				"");
				this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text,"Dt.Min.Inicio:",
				"");
				this->t_screenTipRepository->Items->operator[](2)->Description->Text =
				ReplaceStr(this->t_screenTipRepository->Items->operator[](2)->Description->Text, "Dt.Max.Fim...:",
				"");
		}
	}
	else
	{
		//SeriesHint_ =  NULL;
		 TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
	t_hintStyle->ScreenTipLinks->operator[](0)->Control = NULL;
	reloadDefaults();

	}

}

void TTPHintSeries::clearHint(TChartSeries* CustomSeries)
{
	if(CustomSeries == SeriesHint_ || CustomSeries == NULL)
	{

	TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;
	t_hintStyle->ScreenTipLinks->operator[](0)->Control = NULL;
  reloadDefaults();
		SeriesHint_ = NULL;
	}

}

void TTPHintSeries::reloadDefaults()

{
  for (int i = 0; i <= 2; i++)
  {
    this->t_screenTipRepository->Items->operator[](i)->Header->Text = "";
    this->t_screenTipRepository->Items->operator[](i)->Description->Text = "";
  }

  this->t_screenTipRepository->Items->operator[](0)->Header->Text = tituloDefaultObservacao_;
  this->t_screenTipRepository->Items->operator[](0)->Description->Text = corpoDefaultObservacao_;
  this->t_screenTipRepository->Items->operator[](1)->Header->Text = tituloDefaultMovimento_;
  this->t_screenTipRepository->Items->operator[](1)->Description->Text = corpoDefaultMovimento_;
  this->t_screenTipRepository->Items->operator[](2)->Header->Text = tituloDefaultRestricao_;
  this->t_screenTipRepository->Items->operator[](2)->Description->Text = corpoDefaultRestricao_;

  this->t_screenTipRepository->Items->operator[](3)->Header->Text = tituloDefaultFarol_;
  this->t_screenTipRepository->Items->operator[](3)->Description->Text = corpoDefaultFarol_;
}

void TTPHintSeries::PreencheHintFarolParametros(String pTipoHint, TObject* pControl)
{
  clearHint(NULL);
  //TTPFormsManager::getInstance()->PreencherResumoFilas();
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  TdxScreenTip*  ScreenTip =   (TdxScreenTip*)  this->t_screenTipRepository->Items->operator[](3);
  TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) this->t_hintStyleController->HintStyle;

  t_hintStyle->ScreenTipLinks->operator[](0)->ScreenTip = ScreenTip;
  t_hintStyle->ScreenTipLinks->operator[](0)->Control = (TControl *)pControl;

  ScreenTip->Description->Text = corpoDefaultFarol_;
  ScreenTip->Header->Text = tituloDefaultFarol_;

  String tagItemLista = "{\\*\\pn\\pnlvlblt\\pnf1\\pnindent0{\\pntxtb\\'B7}}\\fi-200\\li200 ";

  ScreenTip->Width = 0;

  if(pTipoHint == FAROL_VERDE)
  {
    ScreenTip->Header->Text = ReplaceStr(ScreenTip->Header->Text, "&","Parmetros Ativos");
    //ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&","Capacidade de Terminais \n & \\par");

    if(TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais)
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Capacidade de Terminais \\par \\pard &");
    }

    if(!TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio)
    {
       ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Cadenciamento dos Vazios \\par \\pard &");
       //ScreenTip->Width =100;
    }
    if(core->getIsCarregarOrdemGatilho())
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Respeitar Ordem de Sada  \\par \\pard &");
    }
    if(TTPFormsManager::getInstance()->ResumoFilasAtivas!="")
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+TTPFormsManager::getInstance()->ResumoFilasAtivas+" \\par \\pard &");
    }

  }
  else if(pTipoHint == FAROL_AMARELO)
  {
    ScreenTip->Header->Text = ReplaceStr(ScreenTip->Header->Text, "&","Parmetros Inativos com tempo de durao");
    if(TTPFormsManager::getInstance()->ResumoFilasInativasExpiracao!="")
    {
      String resumo = ReplaceStr(TTPFormsManager::getInstance()->ResumoFilasInativasExpiracao, "@",tagItemLista);
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",resumo+" \\par \\pard &");
    }
  }
  else if(pTipoHint == FAROL_VERMELHO)
  {
    ScreenTip->Header->Text = ReplaceStr(ScreenTip->Header->Text, "&","Parmetros Inativos");
    if(!TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais)
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Capacidade de Terminais \\par \\pard &");
    }

    if(TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio)
    {
       ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Cadenciamento dos Vazios \\par \\pard &");
       //ScreenTip->Width =100;
    }
    if(!core->getIsCarregarOrdemGatilho())
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+"Respeitar Ordem de Sada \\par \\pard &");
    }
    if(TTPFormsManager::getInstance()->ResumoFilasInativas!="")
    {
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&",tagItemLista+TTPFormsManager::getInstance()->ResumoFilasInativas+" \\par \\pard &");
    }

  }

  if(ScreenTip)
  {
    ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, " \\par \\pard &", "");
    ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "&", "");

    if(ScreenTip->Description->Text.Pos("@")>-1)
    {
      ScreenTip->Width = 300;
      ScreenTip->Description->Text = ReplaceStr(ScreenTip->Description->Text, "@", "");
    }
    else
       ScreenTip->Width = 250;
  }
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPObservacaoSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPObservacaoSeries.h"
#include "UTPTrem.h"
#include "UTPAtividade.h"
#include "UTPTipoAtividade.h"
#include "UFormsManager.h"
#include "UTPMovimento.h"
#include "UTPMovimentoSeries.h"
#include "UTPHintSeries.h"
#include "UTPEnums.h"
#include <../domain/Segmento.h>
#include <../domain/RamalMalha.h>
#include <../domain/SegmentoTrem.h>
#include <../domain/SegmentoTremOficializado.h>


//---------------------------------------------------------------------------
#pragma package(smart_init)

//---------------------------------------------------------------------------
const int CLICK_TOLERANCE_MARKS = 13;

__fastcall TTPObservacaoSeries::TTPObservacaoSeries(System::Classes::TComponent* AOwner, TTPMovimento* pMovimento, double pX, double pY, TTPTipoSerieObservacao tipoSerieObservacao,TTPHintSeries* t_hint) : TPointSeries(AOwner)
{

  this->hint = t_hint;
  TipoSerieObservacao_ = tipoSerieObservacao;
	movimento_      = pMovimento;
	movimentoSerie_ = pMovimento->Serie;

  AddXY(pX, pY  , "  ", clWhite);
	ConfigurarSerie();

  this->ClickableLine     = true;
  this->OnMouseEnter      = DoSeriesMouseEnter;
	this->OnMouseLeave      = DoSeriesMouseLeave;

	indexSerie_  =  -1;
	indexThis_   = -1;

}
//---------------------------------------------------------------------------
void TTPObservacaoSeries::ConfigurarSerie(bool layoutImpressao)
{
  int hintIndex_ = 0;
	ClickTolerance = CLICK_TOLERANCE_MARKS;
  Pointer->Visible = true;
  Pointer->Size=0;
  Pointer->Transparency=100;
  ColorEachPoint = true;
  XValues->DateTime = true;
  ShowInLegend = false;
  VertAxis = aRightAxis;
  // Para reconhecer o segmento qdo o incio est no dia anterior
  CalcVisiblePoints = false;
  Marks->Style = smsLabel;
  Marks->Clip = true;
  Marks->Arrow->Width = 0;

  Marks->Arrow->Visible = false;
  Marks->Arrow->Color = clRed;
  Marks->Shadow->Visible = false;
  Marks->Shadow->Transparency = 100;

  this->Tag = tsObservacao;

  if(TipoSerieObservacao_ == tsoComentario )
  {
    TPngImage* image = TTPFormsManager::getInstance()->getIconeAtividade("", ICONE_COR_INCONSISTENCIA);
	  Marks->Picture->Graphic = image;

    delete image;

    if (Marks->Picture->Graphic && Marks->Picture->Graphic->Width == 0)
        Marks->Picture = NULL;

    Marks->ArrowLength = ( layoutImpressao ? 3 : 5 );
    Marks->Visible = true;
    Marks->BackColor = (layoutImpressao ? clInfoBk : clYellow );
  }
  else if(TipoSerieObservacao_ == tsoPAT )
  {
		TTPTrem* t_trem           = movimento_->Trem;
		TTPAtividadePtr atividade = t_trem->Atividades->operator[](movimento_->Serie->IndiceAtividade(movimento_));

    bool isAlertaGrafico = atividade->CodigoAlertaGrafico != "";
    String codigoCorIconeAtividade = ICONE_COR_DEF;

    if(atividade->ISMeta && atividade->DataHoraMaximaSaida  > TDateTime(0))
    {
      if(atividade->ISForaRangeGrade)
        if(isAlertaGrafico)
          codigoCorIconeAtividade = ICONE_COR_FORAGRADE_COM_ALERTA;
        else
         codigoCorIconeAtividade = ICONE_COR_FORAGRADE_SEM_ALERTA;
      else
        if(!isAlertaGrafico)
          codigoCorIconeAtividade = ICONE_COR_DENTROGRADE_SEM_ALERTA;
    }
    else if  (atividade->DataHoraFimNecessidadeTerminal  > TDateTime(0) )
    {
      codigoCorIconeAtividade = ICONE_COR_FILA;
    }
    TPngImage* image = TTPFormsManager::getInstance()->getIconeAtividade(atividade->Tipo->PID, codigoCorIconeAtividade);
    Marks->Picture->Graphic = image;

    delete image;

    if(Marks->Picture->Graphic && Marks->Picture->Graphic->Width == 0)
        Marks->Picture = NULL;

      Marks->ArrowLength = (layoutImpressao ? 3 : 5);
      Marks->Visible     = true;
      Marks->BackColor   = (TColor)(layoutImpressao ? clInfoBk : RGB(255, 170, 50));
      //Marks->Frame->Visible = false;
  }
  else if(TipoSerieObservacao_ == tsoAtividadeFilaAtiva )
  {
		TTPTrem* t_trem           = movimento_->Trem;
		TTPAtividadePtr atividade = t_trem->Atividades->operator[](movimento_->Serie->IndiceAtividade(movimento_));

    TPngImage* image = TTPFormsManager::getInstance()->getIconeAtividade(atividade->Tipo->PID, ICONE_COR_FILA);
    Marks->Picture->Graphic = image;

    delete image;

    if(Marks->Picture->Graphic && Marks->Picture->Graphic->Width == 0)
        Marks->Picture = NULL;

      Marks->ArrowLength = ( layoutImpressao ? 3 : 5 );
      Marks->Visible = true;
      Marks->BackColor = (TColor)(layoutImpressao ? clInfoBk : RGB(80,255,70) );
  }
  else if(TipoSerieObservacao_ == tsoAtividadeFilaInativa )
  {
		TTPTrem* t_trem           = movimento_->Trem;
		TTPAtividadePtr atividade = t_trem->Atividades->operator[](movimento_->Serie->IndiceAtividade(movimento_));

    TPngImage* image = TTPFormsManager::getInstance()->getIconeAtividade(atividade->Tipo->PID, ICONE_COR_FILA_DESATIVADA);
    Marks->Picture->Graphic = image;

    delete image;

    if(Marks->Picture->Graphic && Marks->Picture->Graphic->Width == 0)
        Marks->Picture = NULL;

		Marks->ArrowLength = ( layoutImpressao ? 3 : 5 );
    Marks->Visible = true;
    Marks->BackColor = (TColor)(layoutImpressao ? clInfoBk : RGB(255,250,50) );
  }
  else if(TipoSerieObservacao_ == tsoInconsistencia )
  {
	  TPngImage* image = TTPFormsManager::getInstance()->getIconeAtividade("", ICONE_COR_OBSERVACAO);
    Marks->Picture->Graphic = image;

    delete image;

	  if (Marks->Picture->Graphic && Marks->Picture->Graphic->Width == 0)
       Marks->Picture = NULL;

      Marks->Visible     = (layoutImpressao ? false : true);
      Marks->ArrowLength = (layoutImpressao ? -11 : -13);
      Marks->BackColor = clRed;
  }

  if(layoutImpressao)
  {
    if (Marks->Picture->Graphic)
    {
      if(Marks->Picture->Graphic && Marks->Picture->Graphic->Width != 0   && Marks->Picture->Graphic->Width > 100)
      {
      Marks->Frame->Width = 0.1;
          Marks->Font->Size   = 2;
        }
        else
        {
      Marks->Frame->Width = 0.5;
          Marks->Font->Size   = 4;
        }
    }
    else
    {
      Marks->Frame->Width = 0.1;
      Marks->Font->Size   = 2;
    }
  }
  else
  {
    if (Marks->Picture->Graphic && Marks->Picture->Graphic->Width != 0 && Marks->Picture->Graphic->Width > 100)
    {
      Marks->Frame->Width = 2;
      Marks->Font->Size   = 8;
    }
    else
    {
      Marks->Frame->Width = 1.5;
      Marks->Font->Size   = 6;
    }
  }

  if (!Marks->Picture->Graphic || Marks->Picture->Graphic->Width == 0)
  {
    Marks->Font->Color = clBlack;
    Marks->Frame->Color = clBlack;
    Marks->Frame->Visible = true;
  }
  else
  {
    Marks->Frame->Visible = false;
    Marks->ArrowLength = 2;
  }

}
//---------------------------------------------------------------------------
void TTPObservacaoSeries::SetTrechoSelecionado(bool pSelecionado)
{
//	if(movimento_)
//  {
//		SerieMovimento_->MovimentoSelecionado = pSelecionado;
//  }
}
//---------------------------------------------------------------------------
bool TTPObservacaoSeries::GetTrechoSelecionado()
{
//	if(SerieMovimento_)
//  {
//    return SerieMovimento_->MovimentoSelecionado;
//  }
//  else
//  {
//    return false;
//	}
  return false; //netto - ninguem mais usa
}
//----------------------------------------------------------------------------
void __fastcall TTPObservacaoSeries::DoSeriesMouseEnter(System::TObject* Sender)
{
   if (!TTPFormsManager::getInstance()->ExibeTremFiltroViewer(movimento_->Trem->Prefixo))
		return;

	 this->hint->PreencheHint(this);
	 RefreshSeries();


	 if(movimentoSerie_ && ParentChart && indexSerie_==-1 && indexThis_ == -1)
   {
		 indexSerie_  = ParentChart->SeriesList->IndexOf(movimentoSerie_);
		 indexThis_   = ParentChart->SeriesList->IndexOf(this);

		 if(indexSerie_<indexThis_ && indexSerie_>-1)
     {
				ParentChart->ExchangeSeries(indexThis_, indexSerie_-1);
     }
   }
}
//----------------------------------------------------------------------------
void __fastcall TTPObservacaoSeries::DoSeriesMouseLeave(System::TObject* Sender)
{
  //if(SerieMovimento_ != NULL)
  //  SerieMovimento_->LabelPrefixo->Caption = "";
	 this->hint->clearHint(this);
}
//----------------------------------------------------------------------------
__fastcall TTPObservacaoSeries::~TTPObservacaoSeries(void)
{
 // delete Marks->Picture->Graphic;
 if(movimentoSerie_)
	 movimentoSerie_->SeriesObservacao->Delete(movimentoSerie_->SeriesObservacao->IndexOf(movimento_->PID));

 if (this->hint)
 	 this->hint->clearHint(this);
}
//----------------------------------------------------------------------------}
 void __fastcall TTPObservacaoSeries::DrawValue(int ValueIndex)
 {
  if (movimento_ )
  {
    if ( TTPFormsManager::getInstance()->VerificaShowIntrajornada() && movimento_->ServerSegTremOficializado)
    {

      String origemIntra = movimento_->ServerSegTremOficializado->getSegmentoOcupado()->ramal->IndicadorSistemaOrigemIntraJornada;
      String origemOf = movimento_->ServerSegTremOficializado->oficializacao->getCodigoOrigemOficializacao();
      if(origemOf != origemIntra || TTPFormsManager::getInstance()->Data > movimento_->DataSaida)
      {
        Marks->Visible = false;
        return;
      }
    }
    Marks->Visible = TTPFormsManager::getInstance()->ExibeTremFiltroViewer(movimento_->Trem->Prefixo);
    if(!TTPFormsManager::getInstance()->ExibeTremFiltroViewer(movimento_->Trem->Prefixo))
      return;
    int index = -1;
    if (movimento_->Serie != NULL)
      index =  movimento_->Serie->GetIndexSerieFromMovimento(movimento_);
    if (index > -1)
    {
      double pontoEixoXObservacao = (movimento_->Serie->XValue[index + 1] + ((movimento_->Serie->XValue[index + 2]-movimento_->Serie->XValue[index + 1]) / 2.0));
      double pontoEixoYObservacao = (movimento_->Serie->YValue[index + 1] + ((movimento_->Serie->YValue[index + 2]-movimento_->Serie->YValue[index + 1]) / 2.0));
      this->XValue[0] = pontoEixoXObservacao;
      this->YValue[0] = pontoEixoYObservacao;
    }
  }
  //Marks->Visible = this->Visible;
  this->ClickTolerance = Marks->Visible? CLICK_TOLERANCE_MARKS:0;
  TPointSeries::DrawValue(ValueIndex);
 }

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPSBConflitoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPSBConflitoSeriesH
#define UTPSBConflitoSeriesH
//---------------------------------------------------------------------------

#include <Series.hpp>
#include <TeeShape.hpp>

class TTPSBConflitoSeries : public TChartShape
{
  private:

  public:
   __fastcall TTPSBConflitoSeries(System::Classes::TComponent* AOwner, double pX0, double pX1, double pY0, double pY1);
   void ConfigurarSerie(bool layoutImpressao = false);
};
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPRestricaoSeries.h =====
// ---------------------------------------------------------------------------
#ifndef UTPRestricaoSeriesH
#define UTPRestricaoSeriesH
// ---------------------------------------------------------------------------

#include "UTPChartShapeBase.h"
#include "UTPRestricao.h"
#include "UUteis.h"



// ---------------------------------------------------------------------------
class TTPRestricaoSeries : public TTPChartShapeBase
{
private:

  int hintIndex_;
  TTPRestricaoPtr Restricao_;
  bool selecionado_;
  bool mouseOver_;

  void SetSelecionado(bool pSelecionado);
  void SetMouseOver(bool pMouseOver);

  bool ExibirRetanguloTransparente_;
  TColor corPadrao;


  bool movendo_;      // Movendo interdio inteira
  bool mover_;        // Movendo interdio inteira
  bool arrastando_;   // Resize direito ou esquerdo
  bool resizeEsquerdo_;
  bool resizeDireito_;
  TRect rectResizeEsquerdo_;
  TRect rectResizeDireito_;
  TRect rectMovendoCentro_;
  double largura_;
  double posicao_;
  //THint* hint_;
  TColor COR_RESTRICAO_PLAN;
  TColor COR_RESTRICAO_INIC;
  TColor COR_RESTRICAO_ENCE;


  TStringList* textoRestricaoPrefixo_;

public:
    double XDefs[2];
  __property TTPRestricaoPtr Restricao =
  {read                                = Restricao_};
  __fastcall TTPRestricaoSeries(System::Classes::TComponent* AOwner, TTPRestricaoPtr pRestricao, double pX0, double pX1,
    double pY0, double pY1, TLabel* pLabelStatus,TTPHintSeries* t_hint);
  __property bool Selecionado =
  {read                       = selecionado_, write = SetSelecionado};
  __property bool MouseOver   =
  {read                       = mouseOver_, write = SetMouseOver};

  __property bool Arrastando     =
  {read                          = arrastando_, write = arrastando_};
  __property bool ResizeEsquerdo =
  {read                          = resizeEsquerdo_, write = resizeEsquerdo_};
  __property bool ResizeDireito  =
  {read                          = resizeDireito_, write = resizeDireito_};
  __property bool Movendo        =
  {read                          = movendo_, write = movendo_};
  __property bool Mover          =
  {read                          = mover_, write = mover_};
  __property double Largura      =
  {read                          = largura_, write = largura_};
  __property double Posicao      =
  {read                          = posicao_, write = posicao_};

  void ConfigurarSerie();
  virtual void __fastcall DrawValue(int ValueIndex);
  __fastcall virtual ~TTPRestricaoSeries(void);

  void __fastcall DoSeriesMouseEnter(System::TObject* Sender);
  void __fastcall DoSeriesMouseLeave(System::TObject* Sender);

  void __fastcall DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button,
    System::Classes::TShiftState Shift, int X, int Y);
  void __fastcall DoSeriesMouseUp(Controls::TMouseButton Button, System::Classes::TShiftState Shift, int X, int Y);
  bool PointInRect(TPoint P, TRect R);
  bool CheckArrasto(int X, int Y);
  void SincronizarFlags(TTPRestricaoSeries* pRestricaoSeries);
};

// ---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPArrastoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPArrastoSeriesH
#define UTPArrastoSeriesH
#include <VCLTee.Series.hpp>
#include <VCLTee.TeeShape.hpp>
//#include "UTPMovimentoSeries.h"
//#include "UTPSBSeries.h"
class TTPMovimentoSeries;
class TTPSBSeries;
//---------------------------------------------------------------------------
class TTPArrastoSeries : public TPointSeries
{
private:
  void ConfigurarSerie(bool layoutImpressao = false);
  TTPMovimentoSeries* movimentoSelecionado_;
  TTPSBSeries* FSerieSBs_;
public:
  __fastcall TTPArrastoSeries(System::Classes::TComponent* AOwner, double pX, double pY, TTPSBSeries* pSerieSB);
   virtual void __fastcall DrawValue(int ValueIndex);
   __property TTPMovimentoSeries* SerieMovimento = {read=movimentoSelecionado_,write=movimentoSelecionado_};
	 __property TTPSBSeries* SerieSBs = {read=FSerieSBs_};
	 void RedrawSerie()
{


	for (int i = 0; i < XValues->Count; i++)
	{
		DrawValue(i);
	}
}
};
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPRestricaoSeries.cpp =====
// ---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPRestricaoSeries.h"
#include "DateTimeNull.h"
#include <System.math.hpp> //Round
#include "UFormsManager.h"
#include <System.DateUtils.hpp>
#include "UTPTrem.h"
#include "UTPEnums.h"
#include "UTPHintSeries.h"
#include "UTPTipoRestricao.h"
#include "UTPSB.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)

const TColor COR_RESTRICAO_SELECIONADA = clAqua;
const TColor COR_RESTRICAO_MOUSE_OVER  = clBlue;

const TColor COR_RESTRICAO_TEMP_SELECIONADA = clAqua;
const TColor COR_RESTRICAO_TEMP_MOUSE_OVER  = clBlue;

const TColor COR_RESTRICAO_INCONSISTENTE                   = clAqua;
const int PERCENTUAL_TRANSPARENCIA_RESTRICAO_INCONSISTENTE = 40;

const int PERCENTUAL_TRANSPARENCIA_MOUSE_OVER = 50;

const int MINUTOS_MINIMOS_RESTRICAO  = 10;
const float LARGURA_MINIMA_RESTRICAO = 0.00625; // largura equivalente a 9 minutos (9/(24*60))

// ---------------------------------------------------------------------------
__fastcall TTPRestricaoSeries::TTPRestricaoSeries(System::Classes::TComponent* AOwner, TTPRestricaoPtr pRestricao, double pX0,
  double pX1, double pY0, double pY1, TLabel* pLabelStatus,TTPHintSeries* t_hint) : TTPChartShapeBase(AOwner)
{
  this->hint__ = t_hint;
  Restricao_   = pRestricao;
  labelStatus_ = pLabelStatus;

  if (pY0 < pY1)
  {
    // Inverte Y Inicial e Y Final para no plotar a srie invertida
    double t_Y = pY0;
    pY0        = pY1;
    pY1        = t_Y;
  }

  this->COR_RESTRICAO_PLAN    = (TColor)ColorToRGB((TColor)pRestricao->Tipo->CorPlanejado.Color);
  this->COR_RESTRICAO_INIC    = (TColor)pRestricao->Tipo->CorIniciado.Color;
  this->COR_RESTRICAO_ENCE    = (TColor)pRestricao->Tipo->CorFinalizado.Color;
  this->PERCENTUAL_TRANSPARENCIA = pRestricao->Tipo->CorPlanejado.A/1.75;

  textoRestricaoPrefixo_ = NULL;

  textoRestricaoPrefixo_ = new TStringList();
  ConfigurarSerie();

  int multiplicador = (Y0 > Y1 ? -1 : 1);
  XDefs[0]          = pX0;
  XDefs[1]          = pX1;
  X0                = pX0;
  X1                = pX1;
  Y0                = pY0 + (0.05 * multiplicador);
  Y1                = pY1 - (0.05 * multiplicador);

  Posicao = X0;
  Largura = X1 - X0;

  this->OnMouseEnter = DoSeriesMouseEnter;
  this->OnMouseLeave = DoSeriesMouseLeave;
  this->OnClick      = DoSeriesClick;

	//hint_ = TTPFormsManager::getInstance()->Hint;

}

// ---------------------------------------------------------------------------
void TTPRestricaoSeries::ConfigurarSerie()
{

  ParentChart  = (TChart*)Owner;
  Style        = chasRectangle;
  Transparency = PERCENTUAL_TRANSPARENCIA;

  ExibirRetanguloTransparente_ = true;

  Pen->Style   = psSolid;
  Pen->Visible = true;
  Pen->Width   = 2;
  Brush->Style = bsSolid;

  this->Tag = tsRestricao;

  if (Restricao_->exibirBordas)
  {
    if (Restricao_->fechaMovimento)
      Pen->Style = psSolid;
    if (Restricao_->interdicaoTunel)
      Pen->Style = psDash;
  }

  // Restrio Inconsistente tem um tratamento diferenciado
  if (Restricao_->ISRestricaoInconsistente)
  {
    corPadrao    = COR_RESTRICAO_INCONSISTENTE;
    Pen->Style   = psClear;
    Transparency = PERCENTUAL_TRANSPARENCIA_RESTRICAO_INCONSISTENTE;
  }
  else if (Restricao_->ISIniciada())
  {
    corPadrao = this->COR_RESTRICAO_INIC;
  }
  else if (Restricao_->ISEncerrada())
  {
    corPadrao = this->COR_RESTRICAO_ENCE;
  }
  else //Planejada
  {
    corPadrao = this->COR_RESTRICAO_PLAN;
  }

  if (Restricao_->ISRestricaoInconsistente)
  {
    Pen->Color = (selecionado_ ? COR_RESTRICAO_TEMP_SELECIONADA : COR_RESTRICAO_INCONSISTENTE);
    Color      = (selecionado_ ? COR_RESTRICAO_TEMP_SELECIONADA : COR_RESTRICAO_INCONSISTENTE);
  }
  else
  {
    Pen->Color = (selecionado_ ? COR_RESTRICAO_SELECIONADA : corPadrao);
    Color      = (selecionado_ ? COR_RESTRICAO_SELECIONADA : corPadrao);
  }

  this->Font->Size = 9;

  this->Color = corPadrao;
  this->Brush->Style = bsSolid;
}

// ---------------------------------------------------------------------------
void TTPRestricaoSeries::SetSelecionado(bool pSelecionado)
{
	selecionado_ = pSelecionado;
  Pen->Color = (selecionado_ ? COR_RESTRICAO_SELECIONADA : corPadrao);
  RefreshSeries();
}

// ---------------------------------------------------------------------------
void TTPRestricaoSeries::SetMouseOver(bool pMouseOver)
{
  if (pMouseOver == mouseOver_ || Brush->Style == bsClear)
    return; // layoutImpressao
  // bool isTemporariaVelocidade = (Restricao_->TipoRestricao == trsTemporariaVelocidade);
  if (selecionado_)
  {
    mouseOver_         = false;
    this->Color        = corPadrao;
    this->Transparency = PERCENTUAL_TRANSPARENCIA;
  }
  else
  {
    mouseOver_         = pMouseOver;
    this->Transparency = 0; // mouseOver_ ? PERCENTUAL_TRANSPARENCIA_MOUSE_OVER : PERCENTUAL_TRANSPARENCIA;

    if (Restricao_->Tipo->ISReducaoVelocidade)
    {
      Pen->Color   = (mouseOver_ ? COR_RESTRICAO_TEMP_MOUSE_OVER : corPadrao);
      Brush->Color = (mouseOver_ ? COR_RESTRICAO_MOUSE_OVER : corPadrao);
      this->Color  = (mouseOver_ ? COR_RESTRICAO_MOUSE_OVER : corPadrao);
    }
    else
    {
      Pen->Color   = (mouseOver_ ? COR_RESTRICAO_MOUSE_OVER : corPadrao);
      Brush->Color = (mouseOver_ ? COR_RESTRICAO_MOUSE_OVER : corPadrao);
      this->Color  = (mouseOver_ ? COR_RESTRICAO_MOUSE_OVER : corPadrao);
    }
  }

	RefreshSeries();
}

// ---------------------------------------------------------------------------
void __fastcall TTPRestricaoSeries::DrawValue(int ValueIndex)
{
  double minB = ParentChart->BottomAxis->Minimum,
   maxB = ParentChart->BottomAxis->Maximum,
   minL = ParentChart->LeftAxis->Minimum,
   maxL = ParentChart->LeftAxis->Maximum;
   X0 = XDefs[0];
   X1 = XDefs[1];
  if(!movendo_ && !mover_ && !arrastando_ && !resizeEsquerdo_ && !resizeDireito_)
  {
    if ((XDefs[0] < minB && XDefs[1] < minB) ||
      (XDefs[0] > maxB && XDefs[1] > maxB) ||
      (Y0 < minL && Y1 < minL) ||
      (Y0 > maxL && Y1 > maxL))
      return;
  }

  if((XDefs[0]< minB || XDefs[1]> maxB))
  {
    if(XDefs[0]< minB)
      X0 = minB;

    if(XDefs[1]> maxB)
      X1 = maxB;

   // TChartShape::DrawValue(ValueIndex);
   // return;
  }

  if(Restricao_->Trem != NULL)
  {
    if(textoRestricaoPrefixo_->Count == 0)
      textoRestricaoPrefixo_->Add(Restricao_->Trem->Prefixo);
    this->Text = textoRestricaoPrefixo_;
    this->Brush-> Style = bsFDiagonal;
	  this->Brush->Color = clWebCoral;
  }
  else
  {
    textoRestricaoPrefixo_->Clear();
    this->Text = textoRestricaoPrefixo_;
    this->Color = corPadrao;
    this->Brush->Style = bsSolid;
  }

  if(Restricao_->ListaTrensDesconsiderar->Count>0)
  {
    this->Brush-> Style = bsDiagCross;
    this->Brush->Color = clWebCrimson;
  }

  if (XDefs[1] - XDefs[0] < LARGURA_MINIMA_RESTRICAO)
  {
    if (resizeEsquerdo_)
    {
      Restricao_->DataInicio = XDefs[1];
      Restricao_->DataInicio = IncMinute(Restricao_->DataInicio, -MINUTOS_MINIMOS_RESTRICAO);
      XDefs[0]               = Restricao_->DataInicio;
    }
    else if (resizeDireito_)
    {
      Restricao_->DataFim = XDefs[0];
      Restricao_->DataFim = IncMinute(Restricao_->DataFim, MINUTOS_MINIMOS_RESTRICAO);
      XDefs[1]            = Restricao_->DataFim;
    }

    Largura = XDefs[1] - XDefs[0];
    Posicao = XDefs[0];
  }

  if (ValueIndex == 0)
  {
    if(ParentChart)
    {
      this->XDefs[0] = Posicao;
      this->XDefs[1] = Posicao + Largura;
      TChartShape::DrawValue(ValueIndex);

      int y0v = ParentChart->Series[0]->CalcYPosValue(Y0);
      int y1v = ParentChart->Series[0]->CalcYPosValue(Y1);
      int x0v = ParentChart->Series[0]->CalcXPosValue(XDefs[0]);
      int x1v = ParentChart->Series[0]->CalcXPosValue(XDefs[1]);

      if (selecionado_)
      {
        ParentChart->Canvas->Pen->Style   = psClear;
        ParentChart->Canvas->Brush->Color = clBlack;

        rectResizeEsquerdo_ = TRect(x0v, y0v, x0v + 5, y1v);
        rectResizeDireito_  = TRect(x1v - 5, y0v, x1v, y1v);

        int difX           = (x1v - x0v) / 5;
        int difY           = (y1v - y0v) / 5;
        rectMovendoCentro_ = TRect(x0v + difX, y0v + difY, x1v - difX, y1v - difY);

        if (arrastando_)
        {
          ParentChart->Canvas->Brush->Color = clInfoBk;
          ParentChart->Canvas->Brush->Style = bsSolid;
          ParentChart->Canvas->Pen->Color   = clBlack;
          ParentChart->Canvas->Pen->Width   = 0.1;
          ParentChart->Canvas->FillRect(TRect((resizeEsquerdo_ ? x0v : x1v) + 10, y0v - 30,
            (resizeEsquerdo_ ? x0v : x1v) + 54, y0v - 10));
          ParentChart->Canvas->Rectangle((resizeEsquerdo_ ? x0v : x1v) + 10, y0v - 30, (resizeEsquerdo_ ? x0v : x1v) + 54,
            y0v - 10);

          ParentChart->Canvas->Font->Color = clBlack;
          ParentChart->Canvas->Font->Name  = "MS Sans Serif";
          ParentChart->Canvas->Font->Size  = 9;
          ParentChart->Canvas->Font->Style = TFontStyles() << fsBold;
          ParentChart->Canvas->Pen->Style  = psSolid;

          UnicodeString horario = TDateTime(resizeEsquerdo_ ? XValue[ValueIndex] : this->X1).FormatString("hh:nn");
          ParentChart->Canvas->TextOutW((resizeEsquerdo_ ? x0v : x1v) + 10, y0v - 27, horario);
        }
        else if (movendo_)
        {
          ParentChart->Canvas->Brush->Color = clInfoBk;
          ParentChart->Canvas->Brush->Style = bsSolid;
          ParentChart->Canvas->Pen->Color   = clBlack;
          ParentChart->Canvas->Pen->Width   = 0.1;
          ParentChart->Canvas->FillRect(TRect(x0v + 10, y0v - 30, x0v + 54, y0v - 10));
          ParentChart->Canvas->Rectangle(x0v + 10, y0v - 30, x0v + 54, y0v - 10);

          ParentChart->Canvas->Font->Color = clBlack;
          ParentChart->Canvas->Font->Name  = "MS Sans Serif";
          ParentChart->Canvas->Font->Size  = 9;
          ParentChart->Canvas->Font->Style = TFontStyles() << fsBold;
          ParentChart->Canvas->Pen->Style  = psSolid;

          UnicodeString horario = TDateTime(XValue[ValueIndex]).FormatString("hh:nn");
          ParentChart->Canvas->TextOutW(x0v + 10, y0v - 27, horario);
        }
      }
    }
//    else
//    {
//      OutputDebugString(AnsiString("SEM PAI").c_str());
//    }

  }
  // XDefs[0] = X0;
  // XDefs[1] = X1;
}

// ---------------------------------------------------------------------------
__fastcall TTPRestricaoSeries::~TTPRestricaoSeries(void)
{
//	if(hint_->CountSeries()>0)
//    hint_->Clear();
	delete textoRestricaoPrefixo_;

  if (this->hint__)
		this->hint__->clearHint(this);

  }

// ---------------------------------------------------------------------------
void __fastcall TTPRestricaoSeries::DoSeriesMouseEnter(System::TObject* Sender)
{
  this->hint__->PreencheHint(this);
	//TObject* serieHintAtual = hint_->GetTopSerie();
//	if(serieHintAtual)
//  {
//   //se a srie que esta no top do hint atual no tiver o mesmo chart
//   //que a nova serie do hint, limpa a lista com as series
//   if(((TTPRestricaoSeries*)serieHintAtual)->ParentChart!=this->ParentChart)
//   {
//     hint_->Clear();
//   }
//  }

  //se ao adicionar a serie do hint ela no for a top retorna
//	if (!hint_->AddSerie(this->ParentChart->SeriesList->IndexOf(this),(TObject*)this))
//   return;

	//hint_->SerieAtual = (TObject*)this;
  if (labelStatus_->Tag == 0)
  {
    String SBInicio = "";
    String SBFim    = "";
    if (!Restricao_->GetSBInicio().isNull())
      SBInicio = Restricao_->GetSBInicio()->NomeVia;

    if (!Restricao_->GetSBFim().isNull())
      SBFim = Restricao_->GetSBFim()->NomeVia;

    String t_tipo  = (Restricao_->Tipo->ISPararTrem ? "Interdio: " : "Restrio (");
//		hint_->prefixo = (Restricao_->Tipo->ISPararTrem ? "Interdio" : "Restrio");
//    hint_->sb      = SBInicio + " - " + SBFim;
//
//		hint_->inicio      = FormatDateTime("dd/mm/yyyy hh:mm", Restricao_->DataInicio);
//    hint_->fim         = FormatDateTime("dd/mm/yyyy hh:mm", Restricao_->DataFim);
//    hint_->previsaoPai = "";
//    hint_->pai         = "";
//    hint_->deltaPai    = "";

    if (!Restricao_->Tipo->ISPararTrem)
      t_tipo += ("Velocidade): ");

    labelStatus_->Caption = t_tipo + FormatDateTime("dd/mm/yyyy hh:mm", Restricao_->DataInicio) + " - " +
      FormatDateTime("dd/mm/yyyy hh:mm", Restricao_->DataFim) + " | " + SBInicio + " - " + SBFim;
  }
}

// ------------------------------------------------------------------------------
void __fastcall TTPRestricaoSeries::DoSeriesMouseLeave(System::TObject* Sender)
{
	 this->hint__->clearHint(this);
  //verifica se a serie no TOP  igual a atual
//	if(hint_->isTopSerie((TObject*)this))
//  {
//   hint_->Remove((TObject*)this);
//   hint_->SerieAtual = NULL;
//   TObject* serie = hint_->GetTopSerie();
//   //apos remover a serie da lista verifica se tem alguma outra srie na lista e pega a mais
//   //no topo
//   if(serie)
//   {
//    //executa o mouse enter da mesma para preencher o hint
//    ((TTPRestricaoSeries*)serie)->DoSeriesMouseEnter(serie);
//   }
//   //se no limpa o label status
//   else
if (labelStatus_->Tag == 0)
    {
      labelStatus_->Caption = "";
    }

	else
  {
	 // se no  a serie do top apenas remove da lista
	 // hint_->Remove((TObject*)this);
    return;
  }
}

// ------------------------------------------------------------------------------
void __fastcall TTPRestricaoSeries::DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button,
  System::Classes::TShiftState Shift, int X, int Y)
{
  if (selecionado_)
  {
    if (Button == mbLeft)
    {
      CheckArrasto(X, Y);
    }
  }
}

// ------------------------------------------------------------------------------
void __fastcall TTPRestricaoSeries::DoSeriesMouseUp(Controls::TMouseButton Button, System::Classes::TShiftState Shift,
  int X, int Y)
{
  resizeEsquerdo_ = false;
  resizeDireito_  = false;
  arrastando_     = false;
  mover_          = false;
  movendo_        = false;
  // hartShape::DoSeriesMouseUp(Button, Shift, X, Y);
}

// ---------------------------------------------------------------------------
bool TTPRestricaoSeries::PointInRect(TPoint P, TRect R)
{
  return (P.x >= R.Left) && (P.x <= R.Right) && (P.y >= R.Top) && (P.y <= R.Bottom);
}

// ---------------------------------------------------------------------------
bool TTPRestricaoSeries::CheckArrasto(int X, int Y)
{
  if (PointInRect(TPoint(X, Y), rectResizeDireito_) && !Restricao_->ISIniciada() && !Restricao_->ISEncerrada())
  {
    resizeDireito_  = true;
    resizeEsquerdo_ = false;
    mover_          = false;
    return true;
  }
  else if (PointInRect(TPoint(X, Y), rectResizeEsquerdo_) && !Restricao_->ISIniciada() && !Restricao_->ISEncerrada()&& Restricao_->Trem == NULL)
  {
    resizeEsquerdo_ = true;
    resizeDireito_  = false;
    mover_          = false;
    return true;
  }
  else if (PointInRect(TPoint(X, Y), rectMovendoCentro_) && !Restricao_->ISIniciada() && !Restricao_->ISEncerrada()&& Restricao_->Trem == NULL)
  {
    resizeEsquerdo_ = false;
    resizeDireito_  = false;
    mover_          = true;
    return true;
  }
  else
  {
    resizeEsquerdo_ = false;
    resizeDireito_  = false;
		mover_          = false;
    return false;
  }
}
// ---------------------------------------------------------------------------
void TTPRestricaoSeries::SincronizarFlags(TTPRestricaoSeries* pRestricaoSeries)
{
  resizeEsquerdo_ = pRestricaoSeries->ResizeEsquerdo;
  resizeDireito_  = pRestricaoSeries->ResizeDireito;
}
// ---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPMovimentoSeries.h =====
 //---------------------------------------------------------------------------
#ifndef UTPMovimentoSeriesH
#define UTPMovimentoSeriesH
//---------------------------------------------------------------------------
#include <VCLTee.Series.hpp>

//#include "UFormsManager.h"
//
//#include "TeeComma.hpp"
//#include "TeEngine.hpp"
//#include "TeeProcs.hpp"
////#include "TeeGDIPlus.hpp"
//#include "TeeSpline.hpp"
//#include <TeeTools.hpp>
#include <TXStringList.h>
    #include "UTPDefs.h"
  #include <Vcl.Imaging.GIFImg.hpp>
//#include "UTPMovimento.h"
//#include "UTPPrefixoSeries.h"
#define PONTOS_SERIE 3
const TColor COR_MOVIMENTO_SELECIONADO = clAqua;
const TColor COR_OPORTUNIDADE_SELECIONADA = clWebOrange;
class TTPHintSeries;

class TTPObservacaoSeries;
class TTPSBSeries;
class TTPMovimentoSeries;
class TTPMovimento;
class TTPPrefixoSeries;
//class TGIFColor;
//---------------------------------------------------------------------------
enum TTPTipoArrasto { taSemArrasto = 0, taChegada, taFimCurso, taSaida, taItinerarioChegada, taItinerarioSaida, taRestricaoInicio, taRestricaoFim };
//---------------------------------------------------------------------------
class POINT2
{
  public:
    double x, y;
};

class TTPPointerSeries : public TPointSeries
{
  public:



		__fastcall TTPPointerSeries(TChart* chart, TTPMovimentoSeries* pSerieMovimento);
    virtual __fastcall ~TTPPointerSeries();
		bool isFree;
		TTPMovimentoSeries* serieMovimento;
    void __fastcall DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
					TShiftState Shift, int X, int Y);
		 virtual void __fastcall DrawValue(int ValueIndex)
		 {
			 TPointSeries::DrawValue(ValueIndex);
		 };

};
class TTPAderenciaFilaSeries;
typedef void (__closure *clbkOnDelete)(TTPAderenciaFilaSeries* serie);
class TTPAderenciaFilaSeries : public TLineSeries
{

private:
		 TGIFColor    fCorSerie_;
     clbkOnDelete onDeleteMetlhod;

public:
  virtual __fastcall ~TTPAderenciaFilaSeries();
  __fastcall TTPAderenciaFilaSeries(TChart* chart,clbkOnDelete ptrf = NULL);
  void ConfigurarSerie();
  void PlotarPontos(double X1, double Y1, double X2, double Y2, bool update = false);
  void __fastcall DoSeriesMouseEnter(System::TObject* Sender);
  void __fastcall DoSeriesMouseLeave(System::TObject* Sender);
};
//---------------------------------------------------------------------------

class TTPMovimentoSeries : public TFastLineSeries
{
private:
   TTPHintSeries* hint;
	 TTPMovimento*       movimento_;
	 TXStringList*       movimentos_;
	 TXStringList*       YValueMovimentos_;
	 TXStringList*       XValueMovimentos_;
   TTPTrem*           trem_;
	 TTPAderenciaFilaSeries *serieAderencia_;
	 bool isMovimentoSelecao_;

//   TTPMovimentoSeries*  serieMovimentoAnterior_;
//   TTPMovimentoSeries*  serieMovimentoPosterior_;
   TTPMovimentoSeries*  serieMovimentoSimulado_;
   double               espessuraLinha_;
   TTPTipoArrasto       tipoArrasto_;

   TTPSBSeries* fSerieSBs_;
   TGIFColor    fCorSerie_;

	 int indexSelected_;

   bool          arrastando_;
   bool          movimentoSelecionado_;
   bool          isTransposicao_;
   bool          isPlotada_;
   bool          isSimulado_;
   bool          isOportunidadeSelecionada_;
   TLabel*       labelPrefixo_;
   TXStringList* owners_;
   TChart*       chartZoom_;
	 TXStringList* seriesObservacao_;
   TTPPrefixoSeries* seriePrefixo_;
   bool          isValidarConflito_;
   double        linhaTempo_;
   bool          isArrastavel_;
   //THint*        hint_;
   bool          atividadeFila_;
   bool          atividadeFilaIrrelevante_; // quando houver atividade de fila, mas a data fim/durao do PAT forem maiores, o pirulito deve ficar no modo padro
   int           pontosPlotados_;
	 double        XValuesDef[3];
	 double        YValuesDef[3];

   int espessuraRealizado_;
   int espessuraPlanejado_;
	 int espessuraSimulado_;
   int espessuraTremLongo_;

	 bool inDelete_;

	 TTPMovimentoSeries *serieSelecao_;
	 TTPMovimentoSeries *seriePrincipal_;

   TStringList *ListaOportunidades;

   int indexUltimoRealizadoAntesLinhaTempo;


	 void clearMovimentoSelecionado();
	 void ReplotarSerie();
   String getEquipagem();
   void onDeleteSerieAderencia(TTPAderenciaFilaSeries* serie);

	 TDateTime dataOflzSelecionada_;

public:

		 TTPPointerSeries *Pointer;
      int hintIndex_;
		 virtual __fastcall ~TTPMovimentoSeries();
   __property TTPTrem* Trem                                  = {read=trem_};
   __property TTPTipoArrasto TipoArrasto                     = {read=tipoArrasto_,write=tipoArrasto_};
	 //__property TTPMovimentoSeries *SerieMovimentoAnterior     = {read=serieMovimentoAnterior_,write=SetMovimentoAnterior};
	 //__property TTPMovimentoSeries *SerieMovimentoPosterior    = {read=serieMovimentoPosterior_,write=SetMovimentoPosterior};
   __property TTPSBSeries* SerieSBs                          = {read=fSerieSBs_};
   __property TLabel* LabelPrefixo                           = {write=labelPrefixo_, read=labelPrefixo_};
   __property TTPPrefixoSeries*  SeriePrefixo                = {write=seriePrefixo_, read=seriePrefixo_};
	 __property bool TemParada                                 = {read = VerificarTemParada};
	 __property bool inDelete                                  = {read=inDelete_};
	 /*
   __property bool isMovimentoRealizado = {read=GetIsMovimentoRealizado};
   __property bool isMovimentoPatioAtual = {read=IsMovimentoPatioAtual_};
   */
	 __property TTPMovimento* Movimento   = {read=GetMovimento , write=SetMovimento};
	 __property TTPMovimentoSeries* SerieMovimentoSelecionado = {read = serieSelecao_};
	 __property TXStringList* Movimentos  = {read=movimentos_};

   //__property bool MovimentoSelecionado = {read=movimentoSelecionado_,write=SetMovimentoSelecionado};
   __property bool Arrastando           = {read=arrastando_,write=arrastando_};
   __property bool IsTransposicao       = {read=isTransposicao_,write=isTransposicao_};
   __property bool IsPlotada            = {read=isPlotada_,write=isPlotada_};
   __property bool IsSimulado           = {read=isSimulado_,write=isSimulado_};

   __property bool IsValidarConflito    = {read=isValidarConflito_,write=isValidarConflito_};
   __property double LinhaTempo         = {read=linhaTempo_, write=linhaTempo_};
   __property bool IsArrastavel         = {read=isArrastavel_, write=isArrastavel_};

   __property int PontosPlotados        =  {read = pontosPlotados_};

	 __property TXStringList* SeriesObservacao = {read=seriesObservacao_, write=seriesObservacao_};

   __property TTPAderenciaFilaSeries* SerieAderenciaFila       = {read=getSerieAderenciaFila};

   __fastcall TTPMovimentoSeries(TChart* chart, TTPTrem* pTrem, TTPMovimento* pMovimento, TTPHintSeries* t_hint, bool pIsOportunidadeSelecionada);
   __fastcall TTPMovimentoSeries(TChart* chart, TTPTrem* pTrem, TTPMovimento* pMovimento, TTPHintSeries* t_hint);

   void ConfigurarSerie(bool layoutImpressao = false);
	 void PlotarPontos(TTPMovimento* pMovimento, double X1, double Y1, double X2, double Y2, double X3, double Y3);
	 void __fastcall DoSeriesMouseEnter(System::TObject* Sender);
   void __fastcall DoSeriesMouseLeave(System::TObject* Sender);
   void __fastcall DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
          TShiftState Shift, int X, int Y);
   virtual void __fastcall DrawValue(int ValueIndex, bool isRedraw);
   virtual void __fastcall DrawValue(int ValueIndex);
   virtual int __fastcall Clicked(TPoint mousePosition, bool selecionar = true);
   int __fastcall Clicked(int xVal, int yVal);

	 int __fastcall getIndexMovimentoFromIndexSerie(int indexSerie);

	// virtual double __fastcall GetxValue(int ValueIndex);
	// virtual double __fastcall GetyValue(int ValueIndex);

   void SetMovimentoSelecionado(bool pSelecionado);
	 void __fastcall SetTremSelecionado(bool selecionar = true, bool forcarSelecionar = false);
   void __fastcall SetTremSelecionado(bool selecionar, TDateTime dtOfclz);
   void __fastcall RedrawTrain();
   void __fastcall MarcarFimTrem();
   void __fastcall AddOwner(String pRamal, TChart* owner);
   bool __fastcall TemAtividade();
   void SetUltimoMovimentoPainel();
   void SetMovimentoTremSuprimido();
   POINT2* intersection(POINT2 p1, POINT2 p2, POINT2 p3, POINT2 p4);
   void TesteMouseEnter();
//	 void SetMovimentoAnterior(TTPMovimentoSeries* pSerie);
//   void SetMovimentoPosterior(TTPMovimentoSeries* pSerie);

   __property bool  AtividadeFila = {read=atividadeFila_};
	 __property bool  AtividadeFilaIrrelevante = {read=atividadeFilaIrrelevante_};
	 __property bool  IsMovimentoSelecao = {read=isMovimentoSelecao_};
   __property bool  IsOportunidadeSelecionada = {read=isOportunidadeSelecionada_,write=isOportunidadeSelecionada_};        ;

   void SetAtividadeFilaAtiva(bool ativa);
   void SetFimFila(TDateTime dataHoraFimFila);
	 int __fastcall IndiceAtividade(TTPMovimento* pMovimento=NULL);
   TTPAderenciaFilaSeries* getSerieAderenciaFila();

   void __fastcall ConfigurarSerieArrasto(bool confMovAdjacentes = true);

   bool __fastcall VerificarTemParada();

	 void __fastcall UpdatePontosSerie(TTPMovimento* pMovimento, double X1, double Y1, double X2, double Y2, double X3, double Y3);
   bool SendPointToIntersectionOfLimits(int indexMin, int indexMax);
   void __fastcall ExchangePointer(TTPMovimentoSeries* pSerie = NULL);

//	 TTPMovimento* MovimentoAnterior(TTPMovimento* pMovimento );
//	 TTPMovimento* MovimentoPosterior(TTPMovimento* pMovimento);
	 TTPMovimento* GetMovimentoIndex(int index);
	 TTPMovimento* GetUltimoMovimentoIndex();
	 TTPMovimento* MovimentoOrigem(bool selecionar = true);
	 TPoint getCoord(int index);
	 TPoint getUltimaChegadaCoord();
	 TPoint getUltimaCoord();

	 int TTPMovimentoSeries::GetIndexSerieFromMovimento(TTPMovimento* pMovimento = NULL);

	 void SetObservacoesVisible(bool visible);

	 void RemoverMovimento(TTPMovimento* pMovimento);

	 void AddPontoNull(bool addMovimento = false);

	 TTPMovimento *GetMovimento();
	 void SetMovimento(TTPMovimento *pMovimento);

	 void addMovimentoSelecionado(TTPMovimento *pMovimento);

	 bool TTPMovimentoSeries::isValidClick();

	 void RedrawSerie(bool pAltoRepaint = true);
	 int  GetIndexPoint(TPoint mousePosition);
   void addMovimentoSelecaoOportunidade(TTPMovimento *pMovimento);

   void printPoints();

};

//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPLinhaDuplaSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPLinhaDuplaSeriesH
#define UTPLinhaDuplaSeriesH

#include <VCLTee.Series.hpp>
#include <VCLTee.TeeShape.hpp>

//---------------------------------------------------------------------------
class TTPLinhaDuplaSeries : public TChartShape
{
public:
   __fastcall TTPLinhaDuplaSeries(System::Classes::TComponent* AOwner, double pX0, double pX1, double pY0, double pY1, bool pPatio = false);
   void ConfigurarSerie(bool isPatio = false);
   virtual void __fastcall DrawValue(int ValueIndex);
	 void MyDrawShape(const System::Types::TRect &R);
	 virtual int __fastcall Clicked(int x, int y)/* overload */;
   void alterY1Serie(double pY1);
};
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPPrefixoSeries.cpp =====
// ---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPPrefixoSeries.h"
#include "UTPMovimentoSeries.h"
#include "UTPEnums.h"
#include "UTPTrem.h"
#include "UTPMovimento.h"
#include "UFormsManager.h"
#include <../domain/Segmento.h>
#include <../domain/RamalMalha.h>
#include <../domain/SegmentoTremOficializado.h>



// ---------------------------------------------------------------------------
__fastcall TTPPrefixoSeries::TTPPrefixoSeries(System::Classes::TComponent* AOwner, TTPTrem* pTrem, bool pIsVisualizador,
  double pX, double pY, TTPTipoDeslocamentoPrefixo pTipoDeslocamento, TTPPosicaoPrefixo pPosicao, bool pExibeBitola =
  false, TTPMovimento* pMovimentoRef = NULL) : TPointSeries(AOwner)
{
  Posicao_               = pPosicao;
  VisivelParaImpressao_  = false;
  TipoDeslocamento_      = pTipoDeslocamento;
  Trem_                  = pTrem;
  IsVisualizador_ 		 = pIsVisualizador;
  ExibeBitola_           = pExibeBitola;
  ConfigurarSerie();
  // TemCercaEletronica_ = !Trem_->StatusEquipamentoCercaEletronica.IsEmpty() && Trem_->StatusEquipamentoCercaEletronica != "N";
  AnsiString tPrefixo = Trem_->Prefixo;
  /*
  if(IsVisualizador_ && Trem_->PrefixosOficializados->Count > 1 && pMovimentoRef != NULL)
  {
	tPrefixo = Trem_->GetPrefixoVisualizador();
  }
  */
  this->Title         = tPrefixo;
  AddXY(pX, pY, "", Trem_->CorTipoTrem);
}

// ---------------------------------------------------------------------------
void TTPPrefixoSeries::ConfigurarSerie(bool layoutImpressao)
{
  Pointer->Visible  = false;
  ColorEachPoint    = false;
  XValues->DateTime = true;
  ShowInLegend      = false;
  VertAxis          = aRightAxis;
  // Para reconhecer o segmento qdo o incio est no dia anterior
  CalcVisiblePoints      = false;
  Marks->Style           = smsSeriesTitle;
  Marks->Clip            = true;
  Marks->Shadow->Visible = false;

  this->Tag = tsPrefixo;

  // Definir a distncia entre o Texto e o Ponto
  if (TipoDeslocamento_ == tdpCima)
  {
    Marks->ArrowLength = (layoutImpressao ? 5 : 5);
  }
  else if (TipoDeslocamento_ == tdpBaixo)
  {
    Marks->ArrowLength = (layoutImpressao ? -5 : -5);
  }

  Marks->Visible = true;
  Marks->BackColor  = clWhite;
  Marks->Pen->Style = psClear;

  if (layoutImpressao)
  {
    Marks->Font->Color = Trem_->CorTipoTrem;
  }
  else
  {
    // Marks->Font->Color = TGHTUtils::ClarearCor(Trem_->CorTipoTrem);
  }

  if (layoutImpressao)
  {
    Marks->Font->Name = "Courier New";
    Marks->Font->Size = 4;
  }
  else
  {
    Marks->Font->Name = "Arial";
    Marks->Font->Size = 7;
  }
  /*
   #ifdef GHT_CONTINGENCIA
   Marks->Transparent = true;
   Marks->Arrow->Visible = false;
   #endif
   */

  /*
   if(Trem_->isAcimaPercentualVagaoIsolado && Trem_->isTremAfetado && VisualizarOcorrencias_)
   {
   Marks->BackColor = clYellow;
   Marks->Frame->Color = clRed;
   Marks->Frame->Visible = true;
   Marks->Frame->Width = (layoutImpressao?0:2);
   }
   else if(Trem_->isAcimaPercentualVagaoIsolado && VisualizarOcorrencias_)
   {
   Marks->BackColor = clYellow;
   Marks->Frame->Color = clYellow;
   Marks->Frame->Visible = true;
   }
   else if(Trem_->isTremAfetado && VisualizarOcorrencias_)
   {
   Marks->Frame->Color = clRed;
   Marks->Frame->Visible = true;
   Marks->Frame->Width = (layoutImpressao?0:2);
   }
   else
   {
   Marks->Frame->Visible = false;
   }
   */
}

// ---------------------------------------------------------------------------
void TTPPrefixoSeries::SetTremSelecionado(bool pSelecionado)
{
	if (PrimeiraSerieTrecho)
  {
    // PrimeiraSerieTrecho->TremSelecionado = pSelecionado;
  }
}

// ---------------------------------------------------------------------------
bool TTPPrefixoSeries::GetTremSelecionado()
{
  if (PrimeiraSerieTrecho)
  {
    return true; // PrimeiraSerieTrecho->TremSelecionado;
  }
  else
  {
    return false;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TTPPrefixoSeries::DrawMark(int ValueIndex, const String St, Teengine::TSeriesMarkPosition* APosition)
{

  if (movimento_ && TTPFormsManager::getInstance()->VerificaShowIntrajornada() && movimento_->ServerSegTremOficializado)
  {

    String origemIntra = movimento_->ServerSegTremOficializado->getSegmentoOcupado()->ramal->IndicadorSistemaOrigemIntraJornada;
    String origemOf = movimento_->ServerSegTremOficializado->oficializacao->getCodigoOrigemOficializacao();
    if(origemOf != origemIntra || TTPFormsManager::getInstance()->Data > movimento_->DataSaida)
    {
      Marks->Visible = false;
      return;
    }
  }

  bool isRealizado = movimento_->IsRealizado;

  if (TTPFormsManager::getInstance()->ShowVisualizador && isRealizado)
  {
    if (TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo && TTPFormsManager::getInstance()->Data < movimento_->DataChegada)
    {
       Marks->Visible = false;
       this->ClickTolerance = 0;
       return;
    }
  }

  this->Visible = TTPFormsManager::getInstance()->ExibeTremFiltroViewer(movimento_->Trem->Prefixo);
	 Marks->Visible = this->Visible;

	TPointSeries::DrawMark(ValueIndex, St, APosition);

  if (Trem_->IsForaOrdemFila)
  {
    TColor tCor                       = clRed;
    ParentChart->Canvas->Brush->Color = tCor;
    ParentChart->Canvas->Pen->Color   = tCor;
    int y                             = APosition->LeftTop.y;
    int x                             = APosition->LeftTop.x-7;
    int altura                        = APosition->Bounds().BottomRight().y - APosition->Bounds().TopLeft().y;
    altura                            = altura * 0.7;
    y += altura * 0.3;
    x += altura * 0.3;
    TRect r(x + altura, y, x, y + altura);
    ParentChart->Canvas->Rectangle(r);
  }

  /*
   if ( TemCercaEletronica_ )
   {
   TColor tCor = clWhite;

   String statusEquip = Trem_->StatusEquipamentoCercaEletronica;

   if(statusEquip == "D")          //DESLIGADO
   {
   tCor = clGray;
   }
   else if(statusEquip == "L")     //LIGADO
   {
   tCor = clGreen;
   }
   else if(statusEquip == "P")     //MODO PERMISSIVO
   {
   tCor = clPurple;
   }

   ParentChart->Canvas->Brush->Color = tCor;
   ParentChart->Canvas->Pen->Color = tCor;
   int y = APosition->LeftTop.y;
   int x = APosition->LeftTop.x;
   int altura = APosition->Bounds().BottomRight().y - APosition->Bounds().TopLeft().y;
   altura = altura*0.7;
   y += altura*0.3;
   x += altura*0.3;
   TRect r(x+altura,y,x,y+altura);
   ParentChart->Canvas->Rectangle(r);
   }

   if ((ExibeBitola_) && (Trem_->Bitola != "")) {

   ParentChart->Canvas->Font->Style = TFontStyles() << fsBold;
   ParentChart->Canvas->Font->Color = clBlack;

   int y = APosition->LeftTop.y;
   int x = APosition->LeftTop.x;
   int altura = APosition->Bounds().BottomRight().y - APosition->Bounds().TopLeft().y;
   altura = altura*0.7;
   y += altura*0.1;
   x += altura*0.3;
   x += ParentChart->Canvas->TextWidth(St) + 16;

   String texto = "";

   if (Trem->Bitola == "1.60") {
   texto = "(L)";
   }
   else if(Trem->Bitola == "METRICA"){
   texto = "(E)";
   }
   else if(Trem->Bitola == "MISTA"){
   texto = "(M)";
   }

   ParentChart->Canvas->TextOutW(x,y,texto);
   }
   */
}

// ------------------------------------------------------------------------------
__fastcall TTPPrefixoSeries::~TTPPrefixoSeries(void)
{
  ((TChart*)this->Owner)->RemoveSeries(this);
}
// ------------------------------------------------------------------------------

TTPMovimentoSeries* TTPPrefixoSeries::GetPrimeiraSerieTrecho()
{
	 return  movimento_->Serie;
}
// ------------------------------------------------------------------------------
void TTPPrefixoSeries::SetPrimeiraSerieTrecho(TTPMovimentoSeries* pSerie)
{
  if(pSerie != NULL)
	movimento_ = pSerie->GetMovimentoIndex(0);
  else if(movimento_!= NULL)
	movimento_->Serie = NULL;
}
// ------------------------------------------------------------------------------

#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPConflitoSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPConflitoSeries.h"
#include <System.math.hpp> //Round
#include "UTPEnums.h"

//---------------------------------------------------------------------------
__fastcall TTPConflitoSeries::TTPConflitoSeries(System::Classes::TComponent* AOwner, double pX, double pY) : TPointSeries(AOwner)
{
  ConfigurarSerie(false);
  this->AddXY(pX,pY,"");
  /*
  X0 = pX - 0.004;
  X1 = pX + 0.004;
  Y0 = pY - 0.3;
  Y1 = pY + 0.3;
  */
}

// ---------------------------------------------------------------------------
void TTPConflitoSeries::ConfigurarSerie(bool layoutImpressao)
{
  ParentChart = (TChart*)Owner;
  this->Tag = tsConflito;
//  Style = chasCircle;
  //Brush->Style = bsSolid;
  //Brush->Color = clRed;
  //Pen->Color = clRed;
  //Pen->Width = 1;
  //Transparent = true;
  Cursor = (TCursor)crHandPoint;
}
//---------------------------------------------------------------------------
void __fastcall TTPConflitoSeries::DrawValue(int ValueIndex)
{
  if(ValueIndex == 0)
  {
    this->
    ParentChart->Canvas->Brush->Style = bsClear;
    ParentChart->Canvas->Pen->Color = clRed;
    ParentChart->Canvas->Pen->Width = 1;

    double x = this->CalcXPosValue(this->XValue[0]);
    double y = this->CalcYPosValue(this->YValue[0]);

    ParentChart->Canvas->Rectangle(x-10,y-10,x+10,y+10);
  }
}
//---------------------------------------------------------------------------

#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPSBConflitoSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPSBConflitoSeries.h"
#include "UTPEnums.h"
//---------------------------------------------------------------------------
__fastcall TTPSBConflitoSeries::TTPSBConflitoSeries(System::Classes::TComponent* AOwner, double pX0, double pX1, double pY0, double pY1)
 : TChartShape(AOwner)
 {
  if(pY0 < pY1)
  {
    // Inverte Y Inicial e Y Final para no plotar a srie invertida
    double t_Y = pY0;
    pY0 = pY1;
    pY1 = t_Y;
  }
  this->Tag = tsConflito;
  ConfigurarSerie();

  int multiplicador = (Y0>Y1?-1:1);
  X0 = pX0 ;
  X1 = pX1;
  Y0 = (pY0+(0.05*multiplicador));
  Y1 = (pY1-(0.05*multiplicador));

 }
//---------------------------------------------------------------------------
void TTPSBConflitoSeries::ConfigurarSerie(bool layoutImpressao)
{
  ParentChart = (TChart*)Owner;
  Style = chasRectangle;
  //Transparency = 65;

  //Canvas->Brush->Style = bsClear
  Pen->Color = clRed;
  Pen->Style = psSolid;
  Pen->Visible = true;
  Pen->Width = layoutImpressao ? 1 : 2;

  Brush->Style = (layoutImpressao?bsDiagCross:bsDiagCross);
  this->Color = clRed;
  this->Brush->Style = bsClear; //(layoutImpressao ? bsClear : bsSolid);
}
//---------------------------------------------------------------------------
#pragma package(smart_init)




================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPTremSeries.h =====
//---------------------------------------------------------------------------

#ifndef UTPTremSeriesH
#define UTPTremSeriesH

#include "UTPChartShapeBase.h"
#include "UTPTrem.h"
#include "UUteis.h"
#include "UTPHintSeries.h"
//---------------------------------------------------------------------------

typedef void __fastcall (__closure *TDelegateRefresh)();

class TTPTremSeries : public TTPChartShapeBase
{
   private:
   TTPTremPtr trem_;
   TTPTremSeries *TremRealizado, *TremPAT;
   TTPChartShapeBase *SeriePrefixo, *SeriePAT, *SerieContorno;

   TColor cor_, line_;

   TTPMovimento* movimento_;

   public:
   TDelegateRefresh delegateRefresh;
   __property TTPTremPtr Trem = {read = trem_};

   double XDefs[2];
  __fastcall TTPTremSeries(System::Classes::TComponent* AOwner, TTPTremPtr pTrem, TTPMovimento* pMovimentoRealizado,
                          TTPMovimento* pMovimentoPrevisto, TTPMovimento* pMovimentoOficializado, double pY0, double pY1,
                          TLabel* pLabelStatus,TTPHintSeries* t_hint);
   __fastcall virtual ~TTPTremSeries();

    void __fastcall DoSeriesMouseEnter(System::TObject* Sender);
    void __fastcall DoSeriesMouseLeave(System::TObject* Sender);

    TGIFColor fCorSerie_;

    void ConfigurarSerie();

    __property TTPMovimento* Movimento = {read = movimento_};

     virtual void __fastcall DrawValue(int ValueIndex);
    virtual void __fastcall DrawValue(int ValueIndex, bool isRedraw = false);

     void __fastcall DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button,
    System::Classes::TShiftState Shift, int X, int Y);

    void __fastcall DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
          TShiftState Shift, int X, int Y);

    void __fastcall Redraw();
    void __fastcall dummyDelegate(){};
};
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPSBSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPSBSeries.h"
//#include <boost/regex.hpp>
#include "UTPSB.h"
#include "UFormsManager.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
//------------------------------------------------------------------------------
__fastcall TTPSBSeries::TTPSBSeries(System::Classes::TComponent* AOwner) : TFastLineSeries(AOwner)
{
  SBsPainel_ = TTPSBListPtr(new TTPSBList());
  SBsOrdenadas_ = new TStringList();
  SBsOrdenadasAux_= new TStringList();
  ConfigurarSerie();
}
//------------------------------------------------------------------------------
__fastcall TTPSBSeries::~TTPSBSeries()
{
  delete SBsOrdenadas_;
  delete  SBsOrdenadasAux_;
}
//------------------------------------------------------------------------------
void TTPSBSeries::ConfigurarSerie(bool layoutImpressao)
{
 // Pointer->Visible = false;
  //Pointer->Style = psNothing;
  ColorEachPoint = false;
  XValues->DateTime = true;
  ShowInLegend = false;
   FastPen = true;
  this->Brush->Style = bsSolid;
  LinePen->Width = 5;

  this->Tag = tsSB;

  VertAxis = aBothVertAxis;
  HorizAxis = aBothHorizAxis;

  // Para reconhecer o segmento qdo o incio est no dia anterior
  CalcVisiblePoints = false;    /*

  //MaiorLabel_ = "";             */

}
//------------------------------------------------------------------------------
void TTPSBSeries::AdicionarSB(TTPSBPtr pSB, bool isGannt)
{

  SBsPainel_->add(pSB->NomeLinha + "I", pSB);
  SBsPainel_->add(pSB->NomeLinha + "S", pSB);
  TTPSB* tSB = &*pSB ;
  SBsOrdenadasAux_->AddObject(FloatToStr(pSB->IndexGraficoI), (TObject*)tSB);
  SBsOrdenadas_->AddObject(FloatToStr(pSB->IndexGraficoI), (TObject*)tSB);

  String label;

  if(TipoLegenda == tlpControlador && !isGannt)
  {
    label = pSB->CodigoSegmento.SubString(1,3) + "-L" + pSB->NumeroLinha;
  }
  else if(TipoLegenda == tlpPlanejador || isGannt)
  {
    label = pSB->NomeVia;
  }
  else
    if(pSB->CodigoSegmento.Length() == 3)
      label = pSB->CodigoSegmento;

   //if(label.Length() > MaiorLabel_.Length()) MaiorLabel_ = label;
   /*
   std::string strNumeroLinha = "";
   boost::cmatch numeroLinha;
   std::string regexNumeroLinha = "[9]{*}";
   boost::regex getNumeroLinha(regexNumeroLinha);
   if(boost::regex_search(label.c_str(), numeroLinha, getNumeroLinha))
   {
     std::string strNumeroLinha = nomePatio[0].str().c_str();
   }
   */

  AddNullXY(0, pSB->IndexGraficoI, (TipoLegenda < 2 ? label + ".": String("")));
  AddNullXY(0, pSB->IndexGraficoS, (TipoLegenda < 2 ? label + "": String("")));
  double posicaoLabel = pSB->IndexGraficoI + ((pSB->IndexGraficoS - pSB->IndexGraficoI)/2);
  if(TipoLegenda == 2 && label.Length() <= 4)
    AddXY(0, posicaoLabel, label);

  /*
    this->XLabel[pIndex] = pLabel;
    AddNullXY(0, pIndexGrafico, pLabel);
  */

}
//------------------------------------------------------------------------------
TTPSBPtr TTPSBSeries::GetSB(double pIndex)
{
  return SBsPainel_->get(pIndex);
}
//------------------------------------------------------------------------------
void TTPSBSeries::DistribuiSeries()
{
  YValues->Sort();
  if(TTPFormsManager::getInstance()->OrdemVisualizaoSBsPatio == ordNormal)
  {
    SBsOrdenadasAux_->CustomSort(SortSbs);
    SBsOrdenadas_->CustomSort(SortSbs);
  }
  else
  {
    SBsOrdenadasAux_->CustomSort(SortSbsLinhas);
    SBsOrdenadas_->CustomSort(SortSbsLinhas);
  }
  double total = YValues->MaxValue - YValues->MinValue;
  double min = YValues->MinValue;

  PosicaoSBs_ = new double[YValues->Count];

  for(int i = 0; i < YValues->Count; i++)
  {
    TTPSB* pSB = (TTPSB*)SBsOrdenadas_->Objects[i/2];
    String nomeVia = pSB->NomeVia.SubString0(0,7);
    XLabel[i] = nomeVia;
    YValue[i] = i*(total/(double)YValues->Count) + min;
    PosicaoSBs_[i] = YValue[i];
    i++;
    XLabel[i] = nomeVia;
    YValue[i] = YValue[i-1];
    PosicaoSBs_[i] = YValue[i];
  }

  /*for(int i = 0; i < SBsOrdenadasAux_->Count; i++)
  {
    int indexOf =SBsOrdenadasAux_->IndexOf(SBsOrdenadas_->operator [](i));
    xvale[indexOf*2] = PosicaoSBs_[i*2];
    YValue[indexOf*2+1] = PosicaoSBs_[i*2+1];
  }   */

  //
}

int TTPSBSeries::getOrdemSB(TTPSBPtr pSB)
{
  //multiplica por 2 pois cada srie de SB  criada 2 vezes
  return SBsOrdenadas_->IndexOf(FloatToStr(pSB->IndexGraficoI))*2;
}

int __fastcall SortSbs(TStringList* List, int Index1, int Index2)
{
  float pos1 = StrToFloat(List->operator [](Index1));
  float pos2 = StrToFloat(List->operator [](Index2));
  if (pos1 < pos2)
    return -1;
  if (pos2 < pos1)
    return 1;

  return 0;
}

int __fastcall SortSbsLinhas(TStringList* List, int Index1, int Index2)
{

  TTPSB* SB1 = (TTPSB*)List->Objects[Index1];
  TTPSB* SB2 = (TTPSB*)List->Objects[Index2];

  if(SB1->NumeroLinha > SB2->NumeroLinha)
      return -1;
  if(SB2->NumeroLinha > SB1->NumeroLinha)
      return 1;

  float pos1 = StrToFloat(List->operator [](Index1));
  float pos2 = StrToFloat(List->operator [](Index2));
  if (pos1 < pos2)
    return -1;
  if (pos2 < pos1)
    return 1;

  return 0;

  /*
  if(SB1->NomeVia == SB2->NomeVia)
  {
    if(SB1->NumeroLinha < SB2->NumeroLinha)
      return -1;
    if(SB2->NumeroLinha < SB1->NumeroLinha)
      return 1;
    return 0;
  }
  else
  {
    if(SB1->NumeroLinha == SB2->NumeroLinha && SB1->IndexGraficoI < SB2->IndexGraficoI )
    {
       return -1;
    }
    if(SB1->NumeroLinha == SB2->NumeroLinha && SB1->IndexGraficoI > SB2->IndexGraficoI )
    {
       return 1;
    }
    if(SB1->NumeroLinha < SB2->NumeroLinha)
    {
      return -1;
    }
    if(SB1->NumeroLinha > SB2->NumeroLinha)
    {
      return 1;
    }
    return 0;

  } */
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPConflitoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPConflitoSeriesH
#define UTPConflitoSeriesH

#include <VCLTee.Series.hpp>
#include <VCLTee.TeeShape.hpp>


//---------------------------------------------------------------------------
class TTPConflitoSeries : public TPointSeries
{
private:
  void ConfigurarSerie(bool layoutImpressao = false);
  double y1_, y2_;
public:
  __fastcall TTPConflitoSeries(System::Classes::TComponent* AOwner, double pX, double pY);
   virtual void __fastcall DrawValue(int ValueIndex);
};

#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPLinhaDuplaSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPLinhaDuplaSeries.h"
#include <Vcl.Imaging.GIFImg.hpp>
#include "UTPEnums.h"

//---------------------------------------------------------------------------
__fastcall TTPLinhaDuplaSeries::TTPLinhaDuplaSeries(System::Classes::TComponent* AOwner, double pX0, double pX1, double pY0, double pY1, bool pPatio) : TChartShape(AOwner)
{
  X0 = pX0;
  X1 = pX1;
  Y0 = pY0;
  Y1 = pY1;
  ParentChart = (TChart*)Owner;
  ConfigurarSerie(pPatio);
}
//---------------------------------------------------------------------------
void TTPLinhaDuplaSeries::ConfigurarSerie(bool isPatio)
{
	Style = chasRectangle;
	Pen->Style = psSolid;
	Pen->Color = TColor((210 * 65536) + (212 * 256) + 214);
  TGIFColor RGB;

  this->Tag = tsLinhaDupla;

  //Utilizando o flag de impresso para detectar ptio
  if(isPatio)
  {
    RGB.Red   = 235;
    RGB.Green = 225;
    RGB.Blue  = 225;
    Brush->Style = bsDiagCross;
  }
  else
  {
    RGB.Red   = 210;
    RGB.Green = 200;
    RGB.Blue  = 200;
  }

  Color = TGIFColorMap::RGB2Color(RGB); //TColor((225 * 65536) + (226 * 256) + 229);
	Pen->Visible = false;
	Pen->Width = 0.1;
  Transparency = 0;
  /*
  Brush->Color = TColor((221 * 65536) + (230 * 256) + 230);
  Brush->BackColor = clWhite;
  */

	//Cursor = (TCursor)crNone;
}
//---------------------------------------------------------------------------

void __fastcall TTPLinhaDuplaSeries::DrawValue(int ValueIndex)
{
   double minB = ParentChart->BottomAxis->Minimum,
   maxB = ParentChart->BottomAxis->Maximum,
   minL = ParentChart->LeftAxis->Minimum,
   maxL = ParentChart->LeftAxis->Maximum;
   X0 = minB;
   X1 = maxB;


 if ((Y0 < minL && Y1 < minL) ||
    (Y0 > maxL && Y1 > maxL))
    return;

   TChartShape::DrawValue(ValueIndex);
}
   /*
  if ( (Count() == 2) && (ValueIndex == 0) )
  {
    TRect R = GetShapeRectangle();
    MyDrawShape(R);
  }
}
*/
//---------------------------------------------------------------------------
void TTPLinhaDuplaSeries::MyDrawShape(const System::Types::TRect &R)
{
  //ParentChart->Canvas->FillRect(R);
  /*
	ParentChart->Canvas->Pen->Assign(Pen);
	for(int i = R.Left-10; i < R.Right; i += 4)
	{
		ParentChart->Canvas->Line(i,R.Bottom,i+10,R.Top);  // Desenha Linha Diagonal
	}
  */
}
//---------------------------------------------------------------------------
int __fastcall TTPLinhaDuplaSeries::Clicked(int x, int y)
{
  return -1;
}
//---------------------------------------------------------------------------

void TTPLinhaDuplaSeries::alterY1Serie(double pY1)
{
 this->Y1 = pY1;
}
#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPArrastoSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPArrastoSeries.h"
#include "UTPSB.h"
#include "UTPMovimentoSeries.h"
#include "UTPSBSeries.h"
#include "UTPMovimento.h"
//---------------------------------------------------------------------------
__fastcall TTPArrastoSeries::TTPArrastoSeries(System::Classes::TComponent* AOwner, double pX, double pY, TTPSBSeries* pSerieSB) : TPointSeries(AOwner)
{

  FSerieSBs_ = pSerieSB;
  ConfigurarSerie(false);
	this->AddXY(pX,pY," ");
  /*
  X0 = pX - 0.004;
  X1 = pX + 0.004;
  Y0 = pY - 0.3;
  Y1 = pY + 0.3;
	*/

	ClickTolerance = 0;
	//this->Labels->
}

// ---------------------------------------------------------------------------
void TTPArrastoSeries::ConfigurarSerie(bool layoutImpressao)
{
  ParentChart = (TChart*)Owner;

//  Style = chasCircle;
  //Brush->Style = bsSolid;
  //Brush->Color = clRed;
  //Pen->Color = clRed;
  //Pen->Width = 1;
  //Transparent = true;
  Cursor = (TCursor)crHandPoint;
}
//---------------------------------------------------------------------------
void __fastcall TTPArrastoSeries::DrawValue(int ValueIndex)
{
  //if(ValueIndex == 0)
  {
    /*
    bool alterandoItinerario = ((movimentoSelecionado_->TipoArrasto == taItinerarioChegada)
                || (movimentoSelecionado_->TipoArrasto == taItinerarioSaida));
    */

	  double xLinha = ParentChart->Series[0]->CalcXPosValue(XValue[ValueIndex]);
	  double yLinha = ParentChart->Series[0]->CalcYPosValue(YValue[ValueIndex]);

    this->
    ParentChart->Canvas->Brush->Style = bsSolid;
    ParentChart->Canvas->Brush->Color = clRed;
    ParentChart->Canvas->Pen->Color = clRed;
    ParentChart->Canvas->Pen->Width = 1;
    double x = this->CalcXPos(0);
    double y = this->CalcYPos(0);
    ParentChart->Canvas->Ellipse(x-4,y-4,x+4,y+4);

		TRect chartRect = ParentChart->ChartRect;

		if(movimentoSelecionado_)
		{

			String sb = "FORA DO PAINEL";
			if(movimentoSelecionado_->TipoArrasto == taItinerarioChegada
					|| movimentoSelecionado_->TipoArrasto == taItinerarioSaida)
			{
			if(!FSerieSBs_->GetSB(YValue[ValueIndex]).isNull())
			{
			sb = FSerieSBs_->GetSB(YValue[ValueIndex])->NomeVia;
			}
		}
		else
		{
			if ( (movimentoSelecionado_->Movimento) &&
				 !movimentoSelecionado_->Movimento->SB.isNull() )
			{
				sb = movimentoSelecionado_->Movimento->SB->NomeVia;
			}
		}

			ParentChart->Canvas->Brush->Color = clInfoBk;
			ParentChart->Canvas->Brush->Style = bsSolid;
			ParentChart->Canvas->Pen->Color = clBlack;
			ParentChart->Canvas->Pen->Width = 0.1;
			ParentChart->Canvas->FillRect(TRect(xLinha+10, yLinha-30, xLinha+118+sb.Length(), yLinha-10));
			ParentChart->Canvas->Rectangle(xLinha+10, yLinha-30, xLinha+118+sb.Length(), yLinha-10);

			ParentChart->Canvas->Font->Color = clBlack;
			ParentChart->Canvas->Font->Name = "MS Sans Serif";
			ParentChart->Canvas->Font->Size = 9;
			ParentChart->Canvas->Font->Style = TFontStyles() << fsBold;
			ParentChart->Canvas->Pen->Style = psSolid;
			UnicodeString horario = TDateTime(XValue[ValueIndex]).FormatString("hh:nn");


			ParentChart->Canvas->TextOutW(xLinha +15, yLinha - 29, sb + " | " + horario);
	 }

				}
/*
  		String sb = "FORA DO PAINEL";
      if( ! movimentoSelecionado_->SerieSBs->GetSB(YValue[ValueIndex]).isNull())
      {
		sb = movimentoSelecionado_->SerieSBs->GetSB(YValue[ValueIndex])->NomeVia;
      }
      ParentChart->Canvas->Font->Color = clBlack;
      ParentChart->Canvas->Font->Name = "MS Sans Serif";
      ParentChart->Canvas->Font->Size = 9;
      ParentChart->Canvas->Font->Style = TFontStyles() << fsBold;

      int width = ParentChart->Canvas->TextWidth(sb);
      ParentChart->Canvas->Brush->Color = clInfoBk;
      ParentChart->Canvas->Brush->Style = bsSolid;
      ParentChart->Canvas->Pen->Color = clBlack;
      ParentChart->Canvas->FillRect(TRect(xLinha+10, yLinha-30, xLinha+width+22, yLinha-10));
      ParentChart->Canvas->Rectangle(xLinha+10, yLinha-30, xLinha+width+22, yLinha-10);

      ParentChart->Canvas->Pen->Style = psClear;
      ParentChart->Canvas->Brush->Color = clWhite;
      ParentChart->Canvas->Brush->Style = bsClear;

      UnicodeString horario = TDateTime(XValue[ValueIndex]).FormatString("hh:nn");

      ParentChart->Canvas->TextOutW( xLinha +25, yLinha - 27, sb + " - " + horario);
      */

  //}
}
//---------------------------------------------------------------------------

#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPLinhaTempoSeries.cpp =====
//---------------------------------------------------------------------------
#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop
#include "UTPLinhaTempoSeries.h"
#include "UTPEnums.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------
__fastcall TTPLinhaTempoSeries::TTPLinhaTempoSeries(System::Classes::TComponent* AOwner, double pX, int NumPatios, TDateTime dataHora, TTPTipoLinhaTempo tipoLinhaTempo, bool serieCongelar )
: FTipoLinhaTempo_(tipoLinhaTempo), TLineSeries(AOwner)
{
  ParentChart = (TChart*)Owner;
  FDataHora_ = dataHora;
  FDataHoraCongelada_ = FDataHora_;
  ConfigurarSerie();
  YValuesDef[0] = -1;
  YValuesDef[1] =  NumPatios + 10;
  AddXY(pX, -1,"", LinePen->Color);
  AddXY(pX, NumPatios + 10,"", LinePen->Color);
  serieCongelar_  = serieCongelar;
  this->OnClick   = DoSeriesClick;
  Arrastou_   = false;
  Arrastando_ = false;
}
//---------------------------------------------------------------------------
void TTPLinhaTempoSeries::ConfigurarSerie(bool layoutImpressao)
{
  ParentChart = (TChart*)Owner;
  Pointer->Visible = false;
  this->Tag = tsLinhaTempo;

  if(FTipoLinhaTempo_ == tltHoraAtual)
  {
    LinePen->Style = psSolid;
    LinePen->Color = TColor((0 * 65536) + (196 * 256) + 0);
  }
  else if(FTipoLinhaTempo_ == tslZerarParada)
  {
    LinePen->Style = psSolid;
    LinePen->Color = TColor((14 * 65536) + (201 * 256) + 255);
  }
  else
  {
    LinePen->Style = psSolid;
    LinePen->Color = clSilver;
  }
  LinePen->Visible = layoutImpressao ? false : true;
  LinePen->Width = 3.5;
  if(serieCongelar_)
  {
    this->Pointer->Style    = psTriangle;
    this->Pointer->Size     = 4;
    this->Pointer->Visible  = true;
  }
  //Cursor = (TCursor)crHSplit;
  ClickableLine = true;
}
//---------------------------------------------------------------------------
String TTPLinhaTempoSeries::getHintString()
{
  return "Linha do Tempo: " + FDataHora_.DateTimeString();
}
//---------------------------------------------------------------------------
void TTPLinhaTempoSeries::Arrastar(double X, bool pPosicaoInicio)
{
  if(this->XValues->Count > 0)
  {
    if(X >= FDataHora_)
    {
      this->XValue[0] = X;
      this->XValue[1] = X;
    }
    else
    {
      this->XValue[0] = FDataHora_;
      this->XValue[1] = FDataHora_;
    }

    FDataHoraCongelada_ = X;

    if(!pPosicaoInicio)
    {
      Arrastou_ = true;
      Arrastando_ = true;
    }
  }
}
//---------------------------------------------------------------------------
void __fastcall TTPLinhaTempoSeries::DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button, System::Classes::TShiftState Shift, int X, int Y)
{
  Arrastando_ = true;
}
//---------------------------------------------------------------------------


void __fastcall TTPLinhaTempoSeries::DrawValue(int ValueIndex)
{
   double minB = ParentChart->BottomAxis->Minimum,
   maxB = ParentChart->BottomAxis->Maximum,
   minL = ParentChart->LeftAxis->Minimum,
   maxL = ParentChart->LeftAxis->Maximum;
   this->YValue[0] = YValuesDef[0];
   this->YValue[1] = YValuesDef[1];


 if ((this->XValue[0] < minB && this->XValue[1] < minB) ||
    (this->XValue[0] > maxB && this->XValue[1] > maxB))
    return;

  if (this->YValue[0] < minL) this->YValue[0] = minL;
  if (this->YValue[1] > maxL) this->YValue[1] = maxL;

   TLineSeries::DrawValue(ValueIndex);
}

__fastcall TTPLinhaTempoSeries::~TTPLinhaTempoSeries()
{
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPCriarTremSeries.cpp =====
//---------------------------------------------------------------------------
#pragma hdrstop
#include "UTPCriarTremSeries.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------
__fastcall TTPCriaTremSeries::TTPCriaTremSeries(System::Classes::TComponent* AOwner, double pX, double pY) : TLineSeries(AOwner)
{
  ConfigurarSerie();
  Arrastou_ = false;
  Arrastando_ = false;
  AddXY(pX, pY, "", CorSerie_);
  AddXY(pX, pY, "", CorSerie_);
}
//---------------------------------------------------------------------------
void TTPCriaTremSeries::ConfigurarSerie()
{
  Pointer->Visible = true;

  Pointer->VertSize = 4;
  Pointer->HorizSize = 4;
  Pointer->Pen->Width = 1;

  Pointer->Pen->Style = psSolid;
  Pointer->Style = psCross;
  Pointer->Visible = true;

  ColorEachPoint = true;
  XValues->DateTime = true;
  ShowInLegend = true;
  VertAxis = aBothVertAxis;
  AllowSinglePoint = true;

  LinePen->Width = 1.0 ;
  LinePen->Style = psDot;

  //verificar qual ser a cor
  CorSerie_ = clHighlight;

  ParentChart = (TChart*)Owner;
}

// ---------------------------------------------------------------------------
void __fastcall TTPCriaTremSeries::DoSeriesMouseMove(System::Classes::TShiftState Shift, int X, double Y)
{

   double XValue = ParentChart->Series[0]->XScreenToValue(X);
   DataHoraFim_ = XValue;
   LocalizacaoFim_ = Y;

  // TLineSeries::DoSeriesMouseMove(Shift,X,Y);

}

//----------------------------------------------------------------------------
void TTPCriaTremSeries::Arrastar(double X, double Y)
{
  if ( X > this->XValue[0] )
  {
    this->XValue[1] = X;
  }
  else
  {
    this->XValue[1] = this->XValue[0];
  }
  this->YValue[1] = Y;

  Arrastou_ = true;
  Arrastando_ = true;
}

// ---------------------------------------------------------------------------
bool TTPCriaTremSeries::GetArrastou()
{
  return Arrastou_;
}

// ---------------------------------------------------------------------------
void __fastcall TTPCriaTremSeries::DrawValue(int ValueIndex)
{
  if (Arrastando_)
  {

    //desenhando linhas vermelhas
    //int x0v = ParentChart->Series[0]->CalcXPosValue(this->XValue[0]);
    int x1v = ParentChart->Series[0]->CalcXPosValue(this->XValue[1]);

    //int xLinha = (ResizeEsquerdo_ ? x0v : x1v );
    TRect chartRect = ParentChart->ChartRect;
    ParentChart->Canvas->Pen->Color = clRed;
    ParentChart->Canvas->Pen->Style = psSolid;
    ParentChart->Canvas->Pen->Width = 1;
    //ParentChart->Canvas->MoveTo(x0v,chartRect.Top);
    //ParentChart->Canvas->LineTo(x0v,chartRect.Bottom);
    ParentChart->Canvas->MoveTo(x1v,chartRect.Top);
    ParentChart->Canvas->LineTo(x1v,chartRect.Bottom);

    //escrevendo o horrio no topo das linhas
    ParentChart->Canvas->Font->Name = "Arial";
    //ParentChart->Canvas->Font->Size = 7;
    ParentChart->Canvas->Font->Color = clRed;
    ParentChart->Canvas->Font->Height = 12;
    ParentChart->Canvas->Pen->Style = psClear;
    ParentChart->Canvas->Brush->Color = clWhite;
    ParentChart->Canvas->Brush->Style = bsClear;

    ParentChart->Canvas->TextOutW( x1v +5, chartRect.Top + 1, TDateTime(XValue[1]).FormatString("hh:nn"));
	ParentChart->Canvas->TextOutW( x1v +5, chartRect.Bottom - 12, TDateTime(XValue[1]).FormatString("hh:nn") );

    //desenhando linhas vermelhas horizontais
    {
      //int yLinha0 = ParentChart->Series[0]->CalcYPosValue(YValue[0]);
      int yLinha1 = ParentChart->Series[0]->CalcYPosValue(YValue[1]);
      TRect chartRect = ParentChart->ChartRect;
      ParentChart->Canvas->Pen->Color = clRed;
      ParentChart->Canvas->Pen->Style = psSolid;
      ParentChart->Canvas->Pen->Width = 1;
      //ParentChart->Canvas->MoveTo(chartRect.Left,yLinha0);
      //ParentChart->Canvas->LineTo(chartRect.RiMP,yLinha0);
      ParentChart->Canvas->MoveTo(chartRect.Left,yLinha1);
      ParentChart->Canvas->LineTo(chartRect.Right,yLinha1);
    }
  }
  else
  {
    ParentChart->Canvas->Pen->Style = psClear;
    ParentChart->Canvas->Brush->Style = bsClear;
  }

  TLineSeries::DrawValue(ValueIndex);
}

// ---------------------------------------------------------------------------
void __fastcall TTPCriaTremSeries::DoSeriesMouseUp(Controls::TMouseButton Button, System::Classes::TShiftState Shift, int X, double Y)
{

  Arrastando_ = false;
  //TLineSeries::DoSeriesMouseUp(Button, Shift, X, Y);

}

//---------------------------------------------------------------------------
void TTPCriaTremSeries::setDataHoraIncio(TDateTime pDataHora)
{
  DataHoraInicio_ = pDataHora;
}

// ---------------------------------------------------------------------------
TDateTime TTPCriaTremSeries::getDataHoraIncio()
{
  return DataHoraInicio_;
}

// ---------------------------------------------------------------------------
void TTPCriaTremSeries::setLocalizacaoInicio(double pLocalizacao)
{
  LocalizacaoInicio_ = pLocalizacao;
}

// ---------------------------------------------------------------------------
int TTPCriaTremSeries::getLocalizacaoInicio()
{
  return LocalizacaoInicio_;
}

// ---------------------------------------------------------------------------
void TTPCriaTremSeries::setDataHoraFim(TDateTime pDataHora)
{
  DataHoraFim_ = pDataHora;
}

// ---------------------------------------------------------------------------
TDateTime TTPCriaTremSeries::getDataHoraFim()
{
  return DataHoraFim_;
}

// ---------------------------------------------------------------------------
void TTPCriaTremSeries::setLocalizacaoFim(double pLocalizacao)
{
  LocalizacaoFim_ = pLocalizacao;
}

// ---------------------------------------------------------------------------
int TTPCriaTremSeries::getLocalizacaoFim()
{
  return LocalizacaoFim_;
}

// ---------------------------------------------------------------------------

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPChartShapeBase.cpp =====
//---------------------------------------------------------------------------

#pragma hdrstop

#include "UTPChartShapeBase.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

__fastcall TTPChartShapeBase::TTPChartShapeBase(System::Classes::TComponent* AOwner) : TChartShape(AOwner)
{

}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPTremSeries.cpp =====
//---------------------------------------------------------------------------

#pragma hdrstop

#include "UTPTremSeries.h"
#include "UTPTipoTrem.h"
#include "UTPMovimentoSeries.h"
#include "UTPMovimento.h"
#include "UTPAtividade.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

#include "../domain/SegmentoTremRealizado.h"
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/SegmentoTrem.h"
#include "UFormsManager.h"

__fastcall TTPTremSeries::TTPTremSeries(System::Classes::TComponent* AOwner, TTPTremPtr pTrem, TTPMovimento* pMovimentoRealizado,
                          TTPMovimento* pMovimentoPrevisto, TTPMovimento* pMovimentoOficializado, double pY0, double pY1,
                          TLabel* pLabelStatus,TTPHintSeries* t_hint) : TTPChartShapeBase(AOwner)
{
  using namespace domain;

  delegateRefresh = dummyDelegate;
  SeriePAT = new TTPChartShapeBase(AOwner);
  SeriePrefixo = new TTPChartShapeBase(AOwner);
  SerieContorno = new TTPChartShapeBase(AOwner);

  this->hint__ = t_hint;
  trem_ = pTrem;
  labelStatus_ = pLabelStatus;

  TStringList *RGB = new TStringList();
  RGB->Delimiter = ',';
  RGB->CommaText = pTrem->TipoTrem->RGBCores;

  fCorSerie_.Red = RGB->Strings[0].ToInt();
  fCorSerie_.Green = RGB->Strings[1].ToInt();
  fCorSerie_.Blue = RGB->Strings[2].ToInt();
  this->Color = TGIFColorMap::RGB2Color(fCorSerie_);


  float mR = RGB->Strings[0].ToInt()<200 ? 1:0;
  float mG = RGB->Strings[1].ToInt()<200 ? 1:0;
  float mB = RGB->Strings[2].ToInt()<200 ? 1:0;

  fCorSerie_.Red = RGB->Strings[0].ToInt()+mR*(255/5);
  fCorSerie_.Green = RGB->Strings[1].ToInt()+mG*(255/5);
  fCorSerie_.Blue = RGB->Strings[2].ToInt()+mB*(255/5);

  line_ = this->Color;//TGIFColorMap::RGB2Color(fCorSerie_);


  cor_ = this->Color;

  ParentChart  = (TChart*)Owner;
  SeriePAT->ParentChart  = (TChart*)Owner;
  SerieContorno->ParentChart  = (TChart*)Owner;
  SeriePrefixo->ParentChart  = (TChart*)Owner;

  Style        = chasRectangle;
  //Transparency = PERCENTUAL_TRANSPARENCIA;


  PERCENTUAL_TRANSPARENCIA = 45;
  Pen->Style   = psSolid;
  Pen->Visible = true;
  Pen->Width   = 2;
  Pen->Color = (TColor)psSolid;
	Pen->Color =  line_;

  Transparency = PERCENTUAL_TRANSPARENCIA;

  this->Brush->Color = clWhite;
  this->Brush->Style = bsFDiagonal;

  this->Brush->Style = bsSolid;
  timeTP::TimeTP dataFimOcupacao;

  String sSb = "";

  if(pMovimentoPrevisto)
  movimento_ = pMovimentoPrevisto;
  else if(pMovimentoOficializado)
  movimento_ = pMovimentoOficializado;
  else if(pMovimentoRealizado)
  movimento_ = pMovimentoRealizado;


  if(pMovimentoPrevisto && pMovimentoPrevisto->ServerSegTremPlanejado)
   dataFimOcupacao = pMovimentoPrevisto->ServerSegTremPlanejado->getPeriodoOcupacao()->end();
  else if(pMovimentoOficializado && pMovimentoOficializado->ServerSegTremOficializado)
   dataFimOcupacao = pMovimentoOficializado->ServerSegTremOficializado->getDataHoraPeriodoOcupacaoOficializado();


  double tX0 = (double)(pMovimentoRealizado ?pMovimentoRealizado->DataChegada:(pMovimentoPrevisto)?pMovimentoPrevisto->DataChegada:pMovimentoOficializado->DataChegada);
  double tX1 = (double)((pMovimentoPrevisto ||pMovimentoOficializado)?dataFimOcupacao.asDateTime():pMovimentoRealizado->DataSaida);

  if(pMovimentoRealizado )
  {
    TDateTime dataHoraSistema = TTPFormsManager::getInstance()->Data;
    bool isViewer = TTPFormsManager::getInstance()->ShowVisualizador;
    if(isViewer && tX0>dataHoraSistema)
      tX0 = (double)dataHoraSistema;

    if(isViewer && tX1>dataHoraSistema)
      tX1 = (double)dataHoraSistema;
  }

  XDefs[0]          = tX0;
  XDefs[1]          = tX1;
  X0                = tX0;
  X1                = tX1;
  Y0                = pY0 ;
  Y1                = pY1 ;

  if(Y0==Y1)
  {
    Y0                = pY0 + (0.05 );
    Y1                = pY1 - (0.05 );
  }

  SeriePrefixo->Color = this->Color;
  SeriePrefixo->X0 = X0+(X1-X0)/2;
  SeriePrefixo->X1 = SeriePrefixo->X0;

  SeriePrefixo->Y0 = Y0+(Y1-Y0)/2;
  SeriePrefixo->Y1 = SeriePrefixo->Y0;
  SeriePrefixo->Pen->Visible = false;

  SeriePrefixo->Transparency = 0;
//  String p = "NFQ2126";
//  if(pTrem->Prefixo == p)
//  {
//     int g=0;
//  }

  if(TTPFormsManager::getInstance()->ExbirPATsGantt )
  {
    bool existePAT = false;
    if(pMovimentoPrevisto &&  (pMovimentoPrevisto->DataParadaAtividade.Val>0 || pMovimentoPrevisto->DataFimPAT.Val>0))
    {
      existePAT = true;
      SeriePAT->Color = clRed;//this->Color;


      SeriePAT->X0 = pMovimentoPrevisto->DataFimCurso;

      if(pMovimentoPrevisto->DataFimPAT.Val>0 && pMovimentoPrevisto->DataFimPAT > pMovimentoPrevisto->DataParadaAtividade)
      {
        SeriePAT->X1 = pMovimentoPrevisto->DataFimPAT;
      }
      else
      {
        SeriePAT->X1 = pMovimentoPrevisto->DataParadaAtividade;
      }
    }
    else  if(pMovimentoOficializado && pMovimentoOficializado->Serie && pMovimentoOficializado->Serie->TemAtividade())
    {
      SeriePAT->Color = clRed;//this->Color;

      TTPAtividadePtr atividade = pMovimentoOficializado->Trem->Atividades->operator[](pMovimentoOficializado->Serie->IndiceAtividade());

      SeriePAT->X0 = pMovimentoOficializado->DataFimCurso;

      TDateTime dataFim = atividade->DataFim;

      TDateTime dataFimParada = TDateTime(0);

      if(atividade->Duracao>0)
      {

      TimeTP dataLimiteParada = boost::posix_time::time_from_string
            (TUteis::narrow(pMovimentoOficializado->DataFimCurso.FormatString("yyyy-mm-dd hh:nn:ss").c_str()));
          dataLimiteParada += addSeconds(atividade->Duracao);

          dataFimParada = dataLimiteParada.asDateTime();
      }
      existePAT = true;
      
      if(dataFim.Val>0 &&  dataFim > dataFimParada)
      {
        SeriePAT->X1 = dataFim;
      }
      else if (dataFimParada.Val>0)
      {
        SeriePAT->X1 = dataFimParada;
      }
      else
      {
        existePAT = false;
      }
    }

    if(existePAT)
    {
      SeriePAT->Y0 = Y0;
      SeriePAT->Y1 = Y1;

      SeriePAT->Pen->Style   = psDash;
      SeriePAT->Pen->Visible = true;
      SeriePAT->Pen->Width   = 1;
      SeriePAT->Brush->Style = (TBrushStyle)psDash;
      SeriePAT->Pen->Color   =  clWhite;

      SeriePAT->Style = chasRectangle;

      SeriePAT->Transparency = 0;

      if(SeriePAT->X0==SeriePAT->X1)
      {
        delete SeriePAT;
      }
    }
    else
    {
      delete SeriePAT;
    }
  }
  else
  {
    delete SeriePAT;
  }
  SerieContorno->X0 = X0;
  SerieContorno->X1 = X1;
  SerieContorno->Y0 = Y0 ;
  SerieContorno->Y1 = Y1 ;

  SerieContorno->Pen->Style   = psSolid;
  SerieContorno->Pen->Visible = true;
  SerieContorno->Pen->Width   = 1;
  SerieContorno->Brush->Style = (TBrushStyle)psDash;
  SerieContorno->Pen->Color   =  line_;

  SerieContorno->Style = chasRectangle;

  SerieContorno->Transparency = 0;



  this->OnMouseEnter = DoSeriesMouseEnter;
  this->OnMouseLeave = DoSeriesMouseLeave;
  this->OnClick      = DoSeriesClick;
  this->OnDblClick   = DoSeriesMouseDblClick;
}
// ---------------------------------------------------------------------------
void __fastcall TTPTremSeries::DrawValue(int ValueIndex)
{
  DrawValue(ValueIndex, false);
}
void __fastcall TTPTremSeries::DrawValue(int ValueIndex, bool isRedraw)
{
	try {


//	TStringList* stringPrefixo = new TStringList();
  double tamanhominimo = (5.0/(double)this->ParentChart->Height);
  double totalY = this->ParentChart->LeftAxis->Maximum - this->ParentChart->LeftAxis->Minimum;
  double percBlocoY = ((this->Y1- this->Y0)/totalY)*this->ParentChart->Height;


	String texto = this->trem_->Prefixo;

	bool tTextoUmaLinha = percBlocoY<25;

	String tTabela = !this->movimento_->ServerSegTremOficializado ?
										this->movimento_->Trem->Tabela :
										this->movimento_->ServerSegTremOficializado->oficializacao->tabelaTremOficializado;;


	if(tTextoUmaLinha && tTabela!= "" )
	{
		texto += " - "+tTabela;
	}

	if(this->movimento_->MovimentoSelecionado || this->movimento_->Trem->IsSelecionado)
	{
	 this->Color = COR_MOVIMENTO_SELECIONADO;
	}
	else
	{
	 this->Color = cor_;
	}

	this->SerieContorno->Pen->Color   =  this->Color;
	//Pen->Color =  this->Color;
	while(texto.Length()>0)
	{
		double tamString = this->XScreenToValue(texto.Length()*6) - this->XScreenToValue(0);
    double minString = this->X0+(this->X1- this->X0)/2 - tamString/2;
    double maxString = this->X0+(this->X1- this->X0)/2 + tamString/2;
    if(this->X0>minString)
    {
      texto = texto.SubString0(0,texto.Length()-1);
    }
    else
    {
      break;
    }
  }


   this->SeriePrefixo->Text->Clear();
   this->SeriePrefixo->Text->Add(texto);

  if(!tTextoUmaLinha && tTabela!= "")
  {
     this->SeriePrefixo->Text->Add(tTabela.SubString0(0,texto.Length()));
  }

//  this->SeriePrefixo->Text = stringPrefixo;

	  if(!isRedraw)
		TChartShape::DrawValue(ValueIndex);
      else
		TChartShape::RefreshSeries();

	}
	catch (...)
	{
     	if (this->ParentChart ) {

		int val1 = this->ParentChart->SeriesList->IndexOf(this);

			if (val1 <0 ) {
														 int parar = 0;
			}
		}
		else
		 int parar =0;
		throw;
	}
}

__fastcall TTPTremSeries::~TTPTremSeries()
 {
   if (this->hint__)
  this->hint__->clearHint(this);
 };

void __fastcall TTPTremSeries::DoSeriesMouseEnter(System::TObject* Sender)
{
  this->hint__->PreencheHint(this);
}
void __fastcall TTPTremSeries::DoSeriesMouseLeave(System::TObject* Sender)
{
  if (this->hint__)
    this->hint__->clearHint(this);
}
// ------------------------------------------------------------------------------
void __fastcall TTPTremSeries::DoSeriesClick(TChartSeries* Sender, int ValueIndex, Controls::TMouseButton Button,
  System::Classes::TShiftState Shift, int X, int Y)
{
  ParentChart->AutoRepaint = false;
  TTPFormsManager::getInstance()->RetirarSelecaoTrens();
  //TTPFormsManager::getInstance()->setFocus("",movimento_,false,false,false);
  TTPFormsManager::getInstance()->SelecionarMovimento(movimento_);

  ParentChart->AutoRepaint = true;
  DrawValue(ValueIndex, true);
  delegateRefresh();
}
void __fastcall TTPTremSeries::DoSeriesMouseDblClick(TChartSeries *Sender, int ValueIndex, TMouseButton Button,
          TShiftState Shift, int X, int Y)
{
  ParentChart->AutoRepaint = false;
  TTPFormsManager::getInstance()->RetirarSelecaoTrens();
  movimento_->Serie->SetTremSelecionado(true);
  ParentChart->AutoRepaint = true;
  DrawValue(ValueIndex, true);
  delegateRefresh();
}

void __fastcall TTPTremSeries::Redraw()
{
  this->DrawValue(0,true);
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPObservacaoSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPObservacaoSeriesH
#define UTPObservacaoSeriesH


#include <System.Classes.hpp>
#include <VCLTee.series.hpp>

//#include "UTPMovimento.h"
#include "Classes\Model\UTPDefs.h"
	class TTPHintSeries;
  class TTPMovimentoSeries;
enum TTPTipoSerieObservacao { tsoComentario, tsoInconsistencia, tsoPAT, tsoAtividadeFilaAtiva, tsoAtividadeFilaInativa};

class TTPObservacaoSeries : public TPointSeries
{
private:
   TTPTipoSerieObservacao TipoSerieObservacao_;
	 TTPMovimento* movimento_;
	 TTPMovimentoSeries* movimentoSerie_;
	 void SetTrechoSelecionado(bool pSelecionado);
   bool GetTrechoSelecionado();
	 TTPHintSeries* hint;

	 int indexSerie_;
	 int indexThis_;
	 virtual void __fastcall DrawValue(int ValueIndex);

public:

	 __property TTPMovimento* Movimento = {read=movimento_,write=movimento_};
	 __property TTPMovimentoSeries* MovimentoSerie = {read=movimentoSerie_,write=movimentoSerie_};
	 __fastcall TTPObservacaoSeries(System::Classes::TComponent* AOwner, TTPMovimento* pMovimento, double pX, double pY, TTPTipoSerieObservacao tipoSerieObservacao,TTPHintSeries* t_hint);
   void ConfigurarSerie(bool layoutImpressao = false);
   __property TTPTipoSerieObservacao TipoSerieObservacao = {read=TipoSerieObservacao_, write=TipoSerieObservacao_};
   void __fastcall DoSeriesMouseEnter(System::TObject* Sender);
   void __fastcall DoSeriesMouseLeave(System::TObject* Sender);
   inline __fastcall virtual ~TTPObservacaoSeries(void);
	 int hintIndex_;


};
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Series/UTPSBSeries.h =====
//---------------------------------------------------------------------------
#ifndef UTPSBSeriesH
#define UTPSBSeriesH

#include <VCLTee.series.hpp>
//#include "UTPSB.h"
#include "UTPDefs.h"
#include "UTPEnums.h"

class TTPSBSeries : public TFastLineSeries
{
private:
    TTPSBListPtr SBsPainel_;
    String MaiorLabel_;
    TStringList *SBsOrdenadas_, *SBsOrdenadasAux_;
    double *PosicaoSBs_;

public:
    __fastcall TTPSBSeries(System::Classes::TComponent* AOwner);
    virtual __fastcall ~TTPSBSeries();
    void ConfigurarSerie(bool layoutImpressao = false);
    void AdicionarSB(int pIndex, String pLabel, double pIndexGrafico);
    TTPSBPtr GetSB(double pIndex);
    void AdicionarSB(TTPSBPtr pSB, bool isGannt = false);
    TTPTipoLegendaSB TipoLegenda;

    void DistribuiSeries();

    int getOrdemSB(TTPSBPtr pSB);
};
//---------------------------------------------------------------------------
int __fastcall SortSbs(TStringList* List, int Index1, int Index2);
int __fastcall SortSbsLinhas(TStringList* List, int Index1, int Index2);
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFormTabSheet.cpp =====
//---------------------------------------------------------------------------
#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFormTabSheet.h"
__fastcall TFormTabSheet::TFormTabSheet(TComponent* Owner,TForm* form) :TTabSheet(Owner)
{
  this->Form = form;
}
__fastcall TFormTabSheet::~TFormTabSheet(void)
{
}
//---------------------------------------------------------------------------
   void __fastcall TFormTabSheet::PaintWindow(HDC DC)
{
  TTabSheet::PaintWindow(DC);
}
#pragma package(smart_init)

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetFarolIntrajornada.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FWidgetFarolIntrajornada.h"
#include <cxGridStrs.hpp>
#include "cxGridExportLink.hpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "FWidgetBase"
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "cxGridBandedTableView"
#pragma link "cxDropDownEdit"
#pragma link "cxMaskEdit"
#pragma link "cxContainer"
#pragma link "cxTextEdit"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "..\ServerTP\Classes\maneger\GerentePublicacao.h"
#include <boost/thread.hpp>
#include "UDAO.h"
#include "UFormsManager.h"
TFormWidgetFarolIntrajornada *FormWidgetFarolIntrajornada;
//---------------------------------------------------------------------------
__fastcall TFormWidgetFarolIntrajornada::TFormWidgetFarolIntrajornada(TComponent* Owner)
    : TFormWidgetBase(Owner)
{
    TListaProperties = new TStringList();
    CriarAbasMesas();
    acRefreshExecute(NULL);
    acFiltraGridExecute(this);
    cxSetResourceString(&_scxGridGroupByBoxCaption,"Arraste as colunas aqui para agrupa-las");
    TListaProperties->CaseSensitive = true;
    AjustarEstadoControles();

    if (TTPFormsManager::getInstance()->getAmbienteDebug())
    {
      ltvOficializacoes->Column[0]->AutoSize = true;

      acRefresh->Enabled = true;
      acRefresh->Visible = true;

      acHabilitarRastreamento->Enabled = true;
      acHabilitarRastreamento->Visible = true;
      acRastrearTrem->Enabled = true;
      acRastrearTrem->Visible = true;
      lblRastreamento->Visible = true;
      tbtSepDebug->Visible = true;
    }
    else
    {
      acRefresh->Enabled = false;
      acRefresh->Visible = false;
      acHabilitarRastreamento->Enabled = false;
      acHabilitarRastreamento->Visible = false;
      acRastrearTrem->Enabled = false;
      acRastrearTrem->Visible = false;
      lblRastreamento->Visible = false;
      tbtSepDebug->Visible = false;
    }

    lblRastreamento->Caption = "";
    pnlGridFarolDebug->Enabled = false;
    pnlGridFarolDebug->Visible = false;


}
//---------------------------------------------------------------------------

  void __fastcall TFormWidgetFarolIntrajornada::PreencherGrid()
  {
    using namespace domain;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TStringList* tListaTrens = core->getMalha()->listaTrens;

    TStringList* listaEquipagensIncluidas = new TStringList();
    listaEquipagensIncluidas->CaseSensitive = true;
    TStringList* tMaquinistaFaltante = new TStringList();
    cxEditRepository1->Clear();
    TListaProperties->Clear();
     TcxEditRepositoryTextItem* cxRepItem2 = (TcxEditRepositoryTextItem*)cxEditRepository1->CreateItem(__classid(TcxEditRepositoryTextItem));
     cxRepItem2->Properties->ReadOnly=true;
     cxRepItem2->Properties->Alignment->Horz = taCenter;
     String name = "Modelo";
     TListaProperties->AddObject(name, (TObject*)cxRepItem2->Properties);
      cxRepItem2 = (TcxEditRepositoryTextItem*)cxEditRepository1->CreateItem(__classid(TcxEditRepositoryTextItem));
//     cxRepItem2->Properties->ReadOnly=true;
    cxRepItem2->Properties->Alignment->Horz = taCenter;
      name = "Ptio Usurio";
     TListaProperties->AddObject(name, (TObject*)cxRepItem2->Properties);

    //itera em todos os trens da malha
    for(int i = 0; i < tListaTrens->Count; i++)
    {
      bool isMaquinistaPresente = false;

      TremMalha* trem = (TremMalha*)tListaTrens->Objects[i];
      if(!trem->possuiRealizado() && !trem->possuiRealizadoForaMalha())
       continue;
      SegmentoTremBase* tSegmento = NULL;
      TrechoEquipagemTrem* trechoAtivo = NULL;
      FichaTrem* tFicha = NULL;
      String siglaOcupcacoReal = "";
      String apelidoMesa = "";
      TDateTime dataOflzMesa = TDateTime(0);
      String tagOficializacaoMesa = "";
      OcupacaoTrem* ocup =  trem->getUltimaOcupacaoTrem();

      if (ocup->getClassType() == SegmentoTremBase::TipoOcupacao::SEGMENTO_TREM_REALIZADO)
      {

          SegmentoTremRealizado* real = (SegmentoTremRealizado*)trem->rotaRealizada->Objects[trem->rotaRealizada->Count -1];
          for (int a = 0 ; a <  trem->listaOficializacoes->Count ; a++)
          {
            Oficializacao* of = (Oficializacao* )trem->listaOficializacoes->Objects[a];
            if (of->rotaOficializada->Count < 1 ||
            real->segmentoOcupado->ramal->IndicadorSistemaOrigemIntraJornada != of->getCodigoOrigemOficializacao())
            {
              continue;
            }
            SegmentoTremBase* pontoReal = (SegmentoTremBase*)trem->getSegmentoOficializadoNoPontoRealizado(of);
            if (pontoReal && pontoReal->getClassType() != SegmentoTremBase::TipoOcupacao::SEGMENTO_TREM_REALIZADO
            )
            {
             tSegmento = pontoReal;
             trechoAtivo = trem->getTrechoEquipagemAtivo(tSegmento);
             dataOflzMesa =  of->dataHoraBaseCarregamento.asDateTime();
            }
          }
          if (!trechoAtivo || !tSegmento|| tSegmento->segmentoOcupado->patioPertencente == trem->destino->patioPertencente)
            continue;
          tFicha = tSegmento->fichaTrem;
          siglaOcupcacoReal = tSegmento->segmentoOcupado->segmento;
          apelidoMesa       = tSegmento->segmentoOcupado->ramal->zona->mesa->aliasMesa;
          tagOficializacaoMesa = tSegmento->segmentoOcupado->ramal->zona->mesa->codTAGOficializacao;
      }
      else
      {
        domain::OcupacaTremForaMalha * ocupFora = (OcupacaTremForaMalha *)trem->listaOcupacaoForaMalha->Objects[trem->listaOcupacaoForaMalha->Count-1];
        siglaOcupcacoReal =  ocupFora->siglaOcupacao;
        tFicha = ocupFora->fichaTrem;
        trechoAtivo = trem->getTrechoEquipagemAtivo(NULL);
        if (!trechoAtivo)
          continue;// caso o trem tenha sido suprimido.
        apelidoMesa = "Outros Trechos";
      }
      TStringList* tListaEquipagem = tFicha->listaEquipagensFicha;
      Equipagem* equipagemReal = NULL;
      //itera na lista de equipagens da ficha
      int countEquipeReal=0;
      try
      {
      for(int k =0; k < tListaEquipagem->Count; k++)
      {
        //faz as coisas de popular
        Equipagem* equipagem =  (Equipagem*)tListaEquipagem->Objects[k];
        if(listaEquipagensIncluidas->IndexOf(equipagem->PID) > -1)
         continue ;
        listaEquipagensIncluidas->Add(equipagem->PID);

        isMaquinistaPresente = true;



        timeTP::DuracaoTP  jornadaAtual;
        cdsGrid->Append();
        if(!equipagem->dataInicioAtividadeServicoTrem.is_not_a_date_time())
        {
           timeTP::TimeTP horaCorrente;
           horaCorrente = TDAO::getCurrentDate();
           jornadaAtual = horaCorrente - equipagem->dataInicioAtividadeServicoTrem;
        }
        cdsGridMatricula->Text = equipagem->matricula;
        cdsGridNome->Text = equipagem->nome;
        cdsGridSede->Text = equipagem->codSede;
        cdsGriddataOflzMesa->Value = dataOflzMesa;

        cdsGridModeloIntra->Text = trechoAtivo->getSiglaPatioTrechoEquipagemDestino(equipagem);
        String valorUltimaOflz = "";
        for(int i= 0; i<trechoAtivo->listaPatiosAtvdOficializada->Count; i++)
        {
          if(valorUltimaOflz.Length() == 0)
            valorUltimaOflz = trechoAtivo->listaPatiosAtvdOficializada->Names[i];
          else
            valorUltimaOflz += " ," + trechoAtivo->listaPatiosAtvdOficializada->Names[i];
        }


        cdsGridUltimaOficializacao->Text = valorUltimaOflz;

        cdsGridpidTrecho->Text = trechoAtivo->getPID();
        if (!equipagem->dataInicioAtividadeTrem.is_not_a_date_time())
          cdsGridInicioAtividade->Text = equipagem->dataInicioAtividadeTrem.asString("%D/%M/%Y %h:%m:%s");
        cdsGridAtividadeAtual->Text = equipagem->codAtividade;
        if (!jornadaAtual.is_not_a_date_time())
          cdsGridJornadaAtual->Text = String(boost::posix_time::to_simple_string(jornadaAtual).c_str());
        cdsGridJornadaProjetada->Text =  equipagem->getTempoJornadaProjetada();
        cdsGridTrem->Text = trem->prefixoTrem;
        cdsGridOrigem->Text = equipagem->getSiglaOrigem();
        cdsGridDestino->Text = equipagem->getSiglaDestino();
        if (!equipagem->dataAberturaCaderno.is_not_a_date_time())
          cdsGridaberturaCaderno->Text =  equipagem->dataAberturaCaderno.asString("%D/%M/%Y %h:%m:%s");
        cdsGridpid->Text = trem->PID;
        //cdsGridPatioOptmove->Text =
        cdsGridpatioAtual->Text =  siglaOcupcacoReal;

        if(!FMesas_)
        {
          FMesas_ = new TStringList();
        }
        if(FMesas_->IndexOfName(apelidoMesa)== -1)
        {
          FMesas_->AddPair(apelidoMesa, tagOficializacaoMesa);
        }
        cdsGridmesa->Text =  apelidoMesa;
        if (!equipagem->dataInicioAtividadeServicoTrem.is_not_a_date_time())
            cdsGriddataInicioAtividadeServico->Text = equipagem->dataInicioAtividadeServicoTrem.asString("%D/%M/%Y %h:%m:%s");
        if (equipagem->segmentoTremBaseDestino)
           cdsGriddestinoAssociado->Text =  equipagem->segmentoTremBaseDestino->segmentoOcupado->segmento;

        cdsGridAvaliacao->Text = "No Avaliado" ;
        cdsGridpidEquipagem->Text = equipagem->PID;
        cdsGridisDuplado->Value = false;
        //cdsGridpidTrecho->Text =
        cdsGridisDuplado->Value = tFicha->verificaDuplaRealTrem(equipagem);
        cdsGridisReal->Value = equipagem->isReal;
        cdsGridrealizouIntra->Value = equipagem->realizouIntrajornada;

        TStringList* tListaEquipagem = trechoAtivo->getListaSegmetosOportunidade(equipagem);

        // TcxRepositoryItem* cxRep = cxgEquipagemDBTableView1PatioOptmove->GetRepositoryItem().
        TcxEditRepositoryComboBoxItem* cxRepItem = (TcxEditRepositoryComboBoxItem*)cxEditRepository1->CreateItem(__classid(TcxEditRepositoryComboBoxItem));
         cxRepItem->Properties->DropDownListStyle = lsEditFixedList;
             cxRepItem->Properties->Alignment->Horz = taCenter;
       String name = cdsGridpid->Text +  cdsGridpidEquipagem->Text  ;
        TListaProperties->AddObject(name, (TObject*)cxRepItem->Properties);
        cdsGridobservacao->Text = trechoAtivo->observacaoUsuario;
        cdsGridobservacaoOflz->Text = trechoAtivo->observacaoUsuario;
        if(tListaEquipagem)
        {
          //TcxComboBoxProperties* cbxPatioOptimove = (TcxComboBoxProperties*)cxgEquipagemDBTableView1PatioOptmove->Properties;
          for(int g = 0; g < tListaEquipagem->Count; g++)
          {
            cxRepItem->Properties->Items->Add(tListaEquipagem->Strings[g]);
          }
          cdsGridPatioOptmove->Text = tListaEquipagem->Strings[0];

        }

        cdsGridoficializado->Value = false;

        TStringList* listaSegmentoAtividadePadraoEquipagem = core->getListaSegmentoAtividadePadraoEquipagem(trem, trechoAtivo, equipagem);
//        if(listaSegmentoAtividadePadraoEquipagem->CommaText != "" )
//          Alerta(listaSegmentoAtividadePadraoEquipagem->CommaText);
        cdsGridlistaSegmentoAtvPadrao->Text = listaSegmentoAtividadePadraoEquipagem->CommaText;
        cdsGridUsuarioEscolheuCriarAtv->Value = false;
        delete listaSegmentoAtividadePadraoEquipagem;
        cdsGrid->Post();
        
      }

      }
      catch(Exception &e)
      {
        TTPFormsManager::getInstance()->gravarLog(e.Message) ;
        String erro = e.Message;
      }

      if (!isMaquinistaPresente)
      {
        cdsGrid->Append();
        cdsGridTrem->Text =  trem->prefixoTrem;
        cdsGridpatioAtual->Text =  siglaOcupcacoReal;
        cdsGridmesa->Text = apelidoMesa;
        cdsGridpid->Text =  trem->PID;
        cdsGridisReal->Value = false;
        cdsGridrealizouIntra->Value = false;
        cdsGridisDuplado->Value = false;
        TcxEditRepositoryComboBoxItem* cxRepItem = (TcxEditRepositoryComboBoxItem*)cxEditRepository1->CreateItem(__classid(TcxEditRepositoryComboBoxItem));
        cxRepItem->Properties->DropDownListStyle = lsEditFixedList;
        cxRepItem->Properties->Alignment->Horz = taCenter;
        cdsGridAvaliacao->Text = "No Avaliado" ;
        String name = cdsGridpid->Text +  cdsGridpidEquipagem->Text;
        TListaProperties->AddObject(name, (TObject*)cxRepItem->Properties);
        cdsGridoficializado->Value = false;


          String valorUltimaOflz = "";
        for(int i= 0; i<trechoAtivo->listaPatiosAtvdOficializada->Count; i++)
        {
          if(valorUltimaOflz.Length() == 0)
            valorUltimaOflz = trechoAtivo->listaPatiosAtvdOficializada->Names[i];
          else
            valorUltimaOflz += " ," + trechoAtivo->listaPatiosAtvdOficializada->Names[i];
        }
            cdsGridobservacao->Text = trechoAtivo->observacaoUsuario;
        cdsGridobservacaoOflz->Text = trechoAtivo->observacaoUsuario;
        cdsGridUltimaOficializacao->Text = valorUltimaOflz;

        cdsGridpidTrecho->Text = trechoAtivo->getPID();

        cdsGrid->Post();
      }

    }
   


    for(int j =0; j < tMaquinistaFaltante->Count; j++)
    {
      SegmentoTremBase* sg = (SegmentoTremBase*) tMaquinistaFaltante->Objects[j];
      cdsGrid->Append();
      cdsGridTrem->Text =  sg->trem->prefixoTrem;
      cdsGridpatioAtual->Text =  sg->segmentoOcupado->segmento;
      cdsGridmesa->Text =  sg->segmentoOcupado->ramal->zona->mesa->aliasMesa;
      cdsGridpid->Text =  sg->trem->PID;
      TcxEditRepositoryComboBoxItem* cxRepItem = (TcxEditRepositoryComboBoxItem*)cxEditRepository1->CreateItem(__classid(TcxEditRepositoryComboBoxItem));
      cxRepItem->Properties->DropDownListStyle = lsEditFixedList;
      cxRepItem->Properties->Alignment->Horz = taCenter;
      cdsGridAvaliacao->Text = "No Avaliado" ;
      // cxRepItem->Name = cdsGridpid->Text +  cdsGridpidEquipagem->Text;
      String name = cdsGridpid->Text +  cdsGridpidEquipagem->Text;
      TListaProperties->AddObject(name, (TObject*)cxRepItem->Properties);
      cdsGrid->Post();
    }


    if (cdsGrid->RecordCount > 0)
    {
        cdsGrid->RecNo = 1;
    }
    cdsGrid->EnableControls();

    delete listaEquipagensIncluidas;
 }


  void __fastcall TFormWidgetFarolIntrajornada::CriarAbasMesas()
  {

       using namespace domain;
       algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
       int qtdMesas = core->getMalha()->listaMesasPlanejamento->Count;
       for (int i = 0; i < qtdMesas ; i++)
       {
         String apelidoMesa = ((MesaPlanejamento*)core->getMalha()->listaMesasPlanejamento->Objects[i])->aliasMesa;
         String nomeMesa = ((MesaPlanejamento*)core->getMalha()->listaMesasPlanejamento->Objects[i])->codTAGOficializacao;
         if(apelidoMesa!="")
         {
           TTabSheet *tTab=                       new TTabSheet(pcMesas) ;
           tTab->Caption = apelidoMesa;
           tTab->PageControl = pcMesas;
           tTab->Name = nomeMesa;
         }
       }
         TTabSheet *tTab =  new TTabSheet(pcMesas);
         tTab->Caption = "Outros Trechos";
         tTab->PageControl = pcMesas;
         tTab->Name = "Outros_Trechos";
  }


void __fastcall TFormWidgetFarolIntrajornada::acRefreshExecute(TObject *Sender)
{
    try
    {
        Screen->Cursor = crHourGlass;
        cdsGrid->DisableControls();
        cdsGrid->Close();
        cdsGrid->CreateDataSet();
        cdsGrid->Open();
        habilitaDesabilitaEdicao(true);
        PreencherGrid();
    }
    __finally
    {
        Screen->Cursor = crDefault;
    }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::acFiltraGridExecute(TObject *Sender)

{
  cdsGrid->Close();
  cdsGrid->Filtered = false;
  String prefixo = "";
  prefixo = edtBuscaPrefixo->Text == "PREFIXO TREM" ?  (String) "" : (String) edtBuscaPrefixo->Text;
  cdsGrid->Filter = " mesa LIKE ('%"+ pcMesas->ActivePage->Caption +"%')";
  if (prefixo != "")
  {
    cdsGrid->Filter +=" and Trem LIKE ('%"+ prefixo +"%')";
  }

  //cdsGrid->Filter += "  (";
  if (!acExibirSemMaquinista->Checked)
  {
     cdsGrid->Filter += " and Matricula IS NOT NULL";
  }
  if (!acExibirDuplado->Checked)
  {

    cdsGrid->Filter += " and isDuplado = False ";
  }
  if (acExibirReal->Checked)
  {
    cdsGrid->Filter +=  " and isReal = True";
  }
  if (!acExibirIntrajornada->Checked)
  {
    cdsGrid->Filter +=  " and realizouIntra = False";
  }
  //cdsGrid->Filter += ")";
//    and (select count(*) from )
//    ";
  cdsGrid->Filtered = true;
  cdsGrid->Open();

}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::edtBuscaPrefixoExit(TObject *Sender)

{
   if(edtBuscaPrefixo->Text == "")
   {
     edtBuscaPrefixo->Clear();
   }
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1JornadaAtualCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{
    //duration_from_string
    if(AViewInfo->Text == NULL || AViewInfo->Text == "")
     return;
    timeTP::DuracaoTP duracaoJornadaAtual = boost::posix_time::duration_from_string(std::string( AnsiString(AViewInfo->Text).c_str()));
    ACanvas->Font->Color = clBlack;

    if ((duracaoJornadaAtual.hours() >= 0) && (duracaoJornadaAtual.hours() < 4) )
    {
          ACanvas->Brush->Color = (TColor)RGB(247, 241, 151);
    }
    else if ((duracaoJornadaAtual.hours() >= 4) && (duracaoJornadaAtual.hours() < 6) )
    {
          ACanvas->Brush->Color = clWebDarkSeaGreen;
    }
    else if (duracaoJornadaAtual.hours() >= 6)
    {
          ACanvas->Brush->Color = (TColor)RGB(250, 112, 112);
    }

}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1AvaliacaoCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{

    String textoCombo =  AViewInfo->Text;
    if(textoCombo != "")
     {
       if(textoCombo == "No Avaliado")
       {
           ACanvas->Brush->Color = (TColor)RGB( 237, 210, 90);
       }
       else if (textoCombo == "Modelo")
       {
           ACanvas->Brush->Color = (TColor)RGB(90, 237, 205);

       }
       else if (textoCombo == "Ptio Optmove")
       {

            ACanvas->Brush->Color = (TColor)RGB(138, 208, 255);

       }
       else if (textoCombo =="Ptio Usurio")
       {
           ACanvas->Brush->Color = (TColor)RGB(255, 189, 138);
       }

     }

}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::acExportarExcelExecute(TObject *Sender)

{
    try
  {
    SaveDialogGrid->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
    SaveDialogGrid->Title  = "Exportar para Excel...";
    SaveDialogGrid->FileName = "Intrajornada_"+pcMesas->ActivePage->Caption + "_"+Now().FormatString("DD_MM_YY_HH_M_SS");
    if (SaveDialogGrid->Execute())
    {
      ExportGridToExcel(SaveDialogGrid->FileName, cxgEquipagem);
      MessageDlg("A planilha foi salva em " + SaveDialogGrid->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
    }
  }
  catch (Exception& exception)
  {
    TTPFormsManager::getInstance()->gravarLog(exception.Message) ;
    throw Exception("No foi possvel exportar para Excel");
  }

}
//---------------------------------------------------------------------------
 void TFormWidgetFarolIntrajornada::ThreadOficializarAtividades(TTheadResultado *pResult)
{
	TStringList* AtividadesOficializar = new TStringList();
	try
  {
    try
    {
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      TDateTime dataOflz = core->getDataHoraBaseCalculo(true).asDateTime();


      domain::TipoAtividadeMovimento* tpAtividade =  core->getMalha()->getTipoAtividadePorCodigo("I");//intrajornada
      if (!tpAtividade)
      {
        String msg = "No foi possivel encontrar o tipo de atividade de intrajornada.";

        TTPFormsManager::getInstance()->gravarLog("Erro: " + msg);
        throw Exception(msg);
      }
      AguardeSetMensagem("Montando Objetos do Farol");
      cdsGrid->First();


      while(!cdsGrid->Eof)
      {

        int indexTrem = core->getMalha()->listaTrens->IndexOf(cdsGridpid->Text);
        bool isNaoAvaliado = cdsGridAvaliacao->Text == "No Avaliado";
        bool regValidoOflz = pcMesas->ActivePage->Caption == cdsGridmesa->Text
                && ( (cdsGridAvaliacao->Text == "Ptio Usurio" || cdsGridAvaliacao->Text == "Ptio Optmove" || cdsGridAvaliacao->Text == "Modelo")
                &&  cdsGridPatioOptmove->Text.Length() > 0
                   || (cdsGridobservacao->Text!=cdsGridobservacaoOflz->Text));


        if(!isNaoAvaliado && cdsGridPatioOptmove->Text.Length()< 3)
        {
          String msg =  "O Trem " + cdsGridTrem->Text + " est marcado como "+cdsGridAvaliacao->Text+". Porm, o ptio no est informado corretamente.";
          TTPFormsManager::getInstance()->gravarLog("Erro: " + msg );
          throw Exception(msg);
        }

        /*
        if(cdsGridPatioOptmove->Text.UpperCase().Trim() == cdsGridUltimaOficializacao->Text)
        {
          throw Exception("O Trem " + cdsGridTrem->Text + " est com o mesmo ptio de intrajornada informado da oficializao anterior.");
        }
        */
        if(indexTrem > -1 && regValidoOflz)  // Entra somente se o usurio colocou um ptio
        {

          domain::TremMalha* tremTemp = (domain::TremMalha*)core->getMalha()->listaTrens->Objects[indexTrem];
          /*
          domain::Equipagem* equipe = NULL;
          int indexOfEquipe = tremTemp->listaEquipagensTrem->IndexOf(cdsGridpidEquipagem->Text);
          if(indexOfEquipe > -1)
            equipe = (domain::Equipagem*)tremTemp->listaEquipagensTrem->Objects[indexOfEquipe];

          if(equipe && equipe->codPatioDestino == cdsGridPatioOptmove->Text.UpperCase().Trim())
          {
            throw Exception("O Trem " + cdsGridTrem->Text + " est com o ptio de intrajornada informado igual ao do detino da equipe .");
          }
          */
          SIntrajornadaOficializacao* atvds = new SIntrajornadaOficializacao();
          atvds->trem = tremTemp;
          atvds->dataPlano = dataOflz;
          atvds->dataLinhaTempo = TTPFormsManager::getInstance()->Data;
          atvds->mesa = FMesas_->ValueFromIndex[FMesas_->IndexOfName(cdsGridmesa->Text)];
          atvds->usuario = TTPFormsManager::getInstance()->Usuario.Codigo;

          atvds->dataOfilizacaoMesa = cdsGriddataOflzMesa->Value;
          atvds->maquinista = cdsGridMatricula->Text;
          atvds->patioAtual = cdsGridpatioAtual->Text;
          atvds->origemMaquinista = cdsGridOrigem->Text;
          atvds->destinoMaquinista = cdsGridDestino->Text;
          atvds->modeloIntra = cdsGridModeloIntra->Text;
          atvds->ultimaOflz = cdsGridUltimaOficializacao->Text;
          atvds->jornadaAtual = cdsGridJornadaAtual->Text;
          atvds->jornadaProjetada = cdsGridJornadaProjetada->Text;


          atvds->atividadesOficializar = new TStringList();
          atvds->observacaoUsuario = cdsGridobservacao->Text;
          SAtividadeIntrajornadaOficializacao* atv = new SAtividadeIntrajornadaOficializacao();
          atv->acao = !isNaoAvaliado ? "C": "L";
          atv->idTrecho = cdsGridpidTrecho->Text;
          atv->siglaPatio = !isNaoAvaliado ? (String)cdsGridPatioOptmove->Text.UpperCase().Trim():  (String)cdsGridUltimaOficializacao->Text.UpperCase().Trim();
          atv->segmento = core->GetSegmentoAtividadeOficializacaoIntrajornada(atv->siglaPatio, atvds->trem);
          atv->codigoAtividade = tpAtividade->codigoAtividadeExterna;
          atv->durcao = 1;
          atv->justificativa = tpAtividade->codigoJustificativaExterna;
          atv->observacao = "Atividade CRIADA pelo programador de intrajoranada OptMove";
          atv->PID = "";
          atv->patioOflzAnterior = cdsGridUltimaOficializacao->Text;
          atv->idEquipe = cdsGridpidEquipagem->Text;
          atv->usuarioEscolheuCriar = cdsGridUsuarioEscolheuCriarAtv->AsBoolean;

          String tipoAtividade = "";
          if(cdsGridAvaliacao->Text == "Ptio Usurio")
          {
            tipoAtividade = "U";
          }
          else if(cdsGridAvaliacao->Text == "Ptio Optmove")
          {
            tipoAtividade = "O";
          }
          else if(cdsGridAvaliacao->Text == "Modelo")
          {
            tipoAtividade = "M";
          }
          else
          {
            tipoAtividade = "N";
          }
          atv->tipoAtividade = tipoAtividade;

          atvds->atividadesOficializar->AddObject("",(TObject*)atv);

          AtividadesOficializar->AddObject(cdsGridMatricula->Text,(TObject*)atvds);
        }

        cdsGrid->Next();
      }
      AguardeSetMensagem("Gerando XML oficializacao");
      if(AtividadesOficializar->Count > 0)
      {
        core->OficializarAtividadesIntrajornada(AtividadesOficializar);

        cdsGrid->First();

        while(!cdsGrid->Eof)
        {
          if(AtividadesOficializar->IndexOf(cdsGridMatricula->Text) > -1)
          {
            cdsGrid->Edit();
            String tAvaliacao = cdsGridAvaliacao->Text;
            cdsGridAvaliacao->Text = tAvaliacao+"*";
            cdsGridoficializado->Value = true;
            cdsGrid->Post();
          }
          cdsGrid->Next();
        }

        pResult->Status = terSucesso;
        pResult->Resultado ="Oficializao da mesa " + pcMesas->ActivePage->Caption + " executada. Inserida(s) " + String(AtividadesOficializar->Count) + " atividade(s).";
        TTPFormsManager::getInstance()->gravarLog(pResult->Resultado);
      }
      else
      {
        pResult->Status = terAlerta;
        pResult->Resultado ="No existem registros para oficializar na mesa " + pcMesas->ActivePage->Caption + ".";
        TTPFormsManager::getInstance()->gravarLog(pResult->Resultado);
      }
    }
    catch (Exception &e)
    {
      pResult->Status = terErro;

      pResult->Resultado ="Erro ao oficializar Mensagem: "+ e.Message;
      TTPFormsManager::getInstance()->gravarLog(pResult->Resultado) ;

    }
    catch(...)
    {
      pResult->Status = terErro;
      pResult->Resultado ="Erro DESCONHECIDO ao oficializar";
      TTPFormsManager::getInstance()->gravarLog(pResult->Resultado) ;
    }

	}
  __finally
	{
    //Ao final, apagar os objetos para no vazar memria
    for(int i = 0; i<AtividadesOficializar->Count; i++)
    {
      SIntrajornadaOficializacao* atvds =  (SIntrajornadaOficializacao*)AtividadesOficializar->Objects[i];
      for(int j = 0; j < atvds->atividadesOficializar->Count; j++)
      {
        SAtividadeIntrajornadaOficializacao* atv = (SAtividadeIntrajornadaOficializacao*) atvds->atividadesOficializar->Objects[j];
        delete atv;
      }
      delete atvds->atividadesOficializar;
      delete atvds;
    }

		delete AtividadesOficializar;

    StopAguarde();
  }
}


void __fastcall TFormWidgetFarolIntrajornada::acOficializarExecute(TObject *Sender)
{
   bool lockMutex = false;
  TCursor t_oldcursor = Screen->Cursor;
  try
  {
    try
    {
      if (this->Visible)
      {
        edtBuscaPrefixo->SetFocus();//para evitar que a grid tente atualizar o dataset
      }
      using namespace domain;
      cdsGrid->DisableControls();
      TTPFormsManager::getInstance()->tryLockMutexProc(60,"Oficializar: Tente novamente em alguns segundos","Oficializar Intrajornada");

      lockMutex = true;
      TTPFormsManager::getInstance()->gravarLog("acOficializarAtividadesExecute Mutex: lock");


      Application->ProcessMessages();
      TTPFormsManager::getInstance()->EnableDisableTeechart(false);
      Application->ProcessMessages();
      TTPFormsManager::getInstance()->AjustarEstadoControles(false); // desabilita os botes
      TTheadResultado *tResult = new TTheadResultado();
      boost:: thread threadProc(&this->ThreadOficializarAtividades, tResult);
//        threadProc->
      Aguarde("Oficializando plano Intrajornada");  // Aps 30 segundos, vai habiliar o ESC do Aguar
      threadProc.join();
      Screen->Cursor = t_oldcursor;
      if ((tResult->Status == terAlerta || tResult->Status == terErro ) && !AguardeGetCancelUserRequest())
      {
        Alerta(tResult->Resultado);
      }
      else if(tResult->Status == terSucesso && !AguardeGetCancelUserRequest())
      {
        Informacao("Sucesso! "+  tResult->Resultado);
      }

      delete tResult;
      tResult = NULL;


    }
    catch (Exception& ex)
    {
      Screen->Cursor = t_oldcursor;
      TTPFormsManager::getInstance()->gravarLog("Ocorreu o erro: " + ex.Message +".") ;
      Alerta("Ocorreu o erro: " + ex.Message +".");
    }
  }
  __finally
  {
    if(lockMutex)
    {
      TTPFormsManager::getInstance()->gravarLog("acOficializarExecute Mutex: UNlock");
      TTPFormsManager::getInstance()->MutexProc->unlock();
    }
    cdsGrid->EnableControls();
    Application->ProcessMessages();
    TTPFormsManager::getInstance()->AjustarEstadoControles(true);
    TTPFormsManager::getInstance()->EnableDisableTeechart(true);

   
  }

}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::acExibirSemMaquinistaExecute(TObject *Sender)

{
  acExibirSemMaquinista->Checked = !(acExibirSemMaquinista->Checked);
//    acRefreshExecute(this);
  acFiltraGridExecute(this);
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::acExibirDupladoExecute(TObject *Sender)

{
  acExibirDuplado->Checked = !(acExibirDuplado->Checked);
//    acRefreshExecute(this);
  acFiltraGridExecute(this);
}
//---------------------------------------------------------------------------



void __fastcall TFormWidgetFarolIntrajornada::acExibirRealExecute(TObject *Sender)

{
    acExibirReal->Checked = !(acExibirReal->Checked);
//    acRefreshExecute(this);
  acFiltraGridExecute(this);

}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::acIniciarPlanejamentoExecute(TObject *Sender)

{
  if(!TTPFormsManager::getInstance()->VerificaShowIntrajornada())
  {
    return;
  }


  Application->ProcessMessages();

   try
   {
    Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(true, this);
    Screen->Cursor = crDefault;
    Application->ProcessMessages();
   }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    TTPFormsManager::getInstance()->gravarLog("Erro ao Inicializar Planejamento") ;
    Alerta("Erro ao Inicializar Planejamento");
  }

  AjustarEstadoControles();
//

}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::acFinalizarPlanejamentoExecute(TObject *Sender)

{
  if(!TTPFormsManager::getInstance()->VerificaShowIntrajornada())
  {
    return;
  }

  try
  {
    Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(false, this);
    Screen->Cursor = crDefault;
    Application->ProcessMessages();
  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao Finalizar Planejamento");
  }

  AjustarEstadoControles();
}
//---------------------------------------------------------------------------
void TFormWidgetFarolIntrajornada::AjustarEstadoControles()
{
  TTPProgramacaoEmCurso result = TDAO::checkProgramacaoEmCurso(0,TTPFormsManager::getInstance()->Usuario.Codigo);
  if (!result.isPlanoInicado)
  {
    acFinalizarPlanejamento->Enabled = false;
    acIniciarPlanejamento->Enabled = true;
    acOficializar->Enabled = false;
    tbtnPlanejamentoOnOff->Action = acIniciarPlanejamento;
  }
  else
  {
    acFinalizarPlanejamento->Enabled = true;
    acIniciarPlanejamento->Enabled = false;
    acOficializar->Enabled = true;
    tbtnPlanejamentoOnOff->Action = acFinalizarPlanejamento;
  }
}
void __fastcall TFormWidgetFarolIntrajornada::acExibirIntrajornadaExecute(TObject *Sender)

{
  acExibirIntrajornada->Checked = !(acExibirIntrajornada->Checked);
//    acRefreshExecute(this);
  acFiltraGridExecute(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1PatioOptmoveGetProperties(TcxCustomGridTableItem *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomEditProperties *&AProperties)

{
//  String valor = ARecord->ViewInfo -> GridRecord->Values[cxgEquipagemDBTableView1Avaliacao->Index];
//  //+ 1 para igualar com lista 0 based
//
//  int indice = TListaProperties->IndexOf(valor);
//  if (indice  < 0 )
//  {
//    String chave = cdsGridpid->Text +  cdsGridpidEquipagem->Text ;
//     indice = TListaProperties->IndexOf(chave);
//
//  }
//  if ( indice >=0)
//  {
//    AProperties = (TcxCustomEditProperties*)TListaProperties->Objects[indice];
//
//  }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1TremCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{
  if((AViewInfo->GridRecord->Values[cxgEquipagemDBTableView1isDuplado->Index]))
  {
    ACanvas->Font->Style = TFontStyles() << fsBold;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cdsGridAvaliacaoChange(TField *Sender)

{
  if(cdsGridoficializado->Value != true)
  {

    String valor = cdsGridAvaliacao->Text ;
    if (valor == "Modelo")
    {
      cdsGridPatioOptmove->Text = cdsGridModeloIntra->Text;
      if(cdsGridlistaSegmentoAtvPadrao->Text == "")
      {
        String mensagem = "No existem atividades padro criadas para o trem " + cdsGridTrem->Text + " no trecho " + "\n";
        if(cdsGridDestino->Text == cdsGridModeloIntra->Text)
        {
          mensagem += "O ptio intra  o mesmo ptio destino da equipagem (" + cdsGridModeloIntra->Text + "). No ser criada atividade.";
          TTPFormsManager::getInstance()->gravarLog(mensagem);
          // Informacao(mensagem);
        }
        else
        {
          mensagem += "Deseja criar?\n";
          int tResposta  = ConfirmeCancelar(mensagem);
          if (tResposta == IDNO)
          {
            cdsGridUsuarioEscolheuCriarAtv->Value = false;
          }
          else if (tResposta == IDYES)
          {
            cdsGridUsuarioEscolheuCriarAtv->Value = true;
          }
          else if (tResposta == IDCANCEL)
          {
            cdsGridUsuarioEscolheuCriarAtv->Value = false;
            cdsGridAvaliacao->Text = "No Avaliado";
          }
          TTPFormsManager::getInstance()->gravarLog(mensagem + "\n\t Resposta: " + tResposta );
        }
      }
    }

    if((valor == "No Avaliado") || (valor == "Ptio Optmove"))
    {
      String chave = cdsGridpid->Text +     cdsGridpidEquipagem->Text;
      int indice = TListaProperties->IndexOf(chave);
      if (indice > -1 && ((TcxComboBoxProperties*)TListaProperties->Objects[indice])->Items->Count >0)
      {
         cdsGridPatioOptmove->Text = ((TcxComboBoxProperties*)TListaProperties->Objects[indice])->Items[0].operator [](0);
      }
      else
         cdsGridPatioOptmove->Text ="";
    }
     if (valor =="Ptio Usurio")
     {
         cdsGridPatioOptmove->Text ="";
     }
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::FormClose(TObject *Sender, TCloseAction &Action)

{
  if (this->Visible)
  {
    edtBuscaPrefixo->SetFocus();//para evitar que a grid tente atualizar o dataset
  }
  cdsGrid->DisableControls();
  cdsGrid->Close();
  cdsGrid->CreateDataSet();
  cdsGrid->Open();
  TFormWidgetBase::FormClose(Sender, Action);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::FormShow(TObject *Sender)
{
  if (cdsGrid->RecordCount <=0)
  {
    acRefreshExecute(NULL);
    acExibirSemMaquinista->Checked = false;
    edtBuscaPrefixo->Text = "";
    acExibirSemMaquinista->Checked =false;
    acExibirDuplado->Checked = false;
    acExibirReal->Checked = true;
    acExibirIntrajornada->Checked = false;

    acFiltraGridExecute(this);
   }
   AjustarEstadoControles();
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
    String trem = ACellViewInfo->GridRecord->Values[cxgEquipagemDBTableView1pid->Index];
    String patio = ACellViewInfo->GridRecord->Values[cxgEquipagemDBTableView1patioAtual->Index];

    TTPFormsManager *t_formsManager = TTPFormsManager::getInstance();
    t_formsManager->SetFocusTremSegmento(trem, patio, false, false);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1PatioOptmoveGetPropertiesForEdit(TcxCustomGridTableItem *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomEditProperties *&AProperties)

{
  String valor = ARecord->ViewInfo -> GridRecord->Values[cxgEquipagemDBTableView1Avaliacao->Index];
  //+ 1 para igualar com lista 0 based

  int indice = TListaProperties->IndexOf(valor);
  if (indice  < 0 )
  {
    String chave = cdsGridpid->Text +  cdsGridpidEquipagem->Text ;
     indice = TListaProperties->IndexOf(chave);

  }
  if ( indice >=0)
  {
    AProperties = (TcxCustomEditProperties*)TListaProperties->Objects[indice];

  }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow)
{
  habilitaDesabilitaEdicao();
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::cxgEquipagemDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  habilitaDesabilitaEdicao();
}

bool TFormWidgetFarolIntrajornada::habilitaDesabilitaEdicao(bool pForcarEdicao)
{
  if(!pForcarEdicao && cdsGridoficializado->Value == true)
  {
    cxgEquipagemDBTableView1->OptionsData->Editing = false;
    cdsGrid->ReadOnly = true;
    cxgEquipagemDBTableView1Avaliacao->Options->Editing = false;
    cxgEquipagemDBTableView1observacao->Options->Editing = false;
    cxgEquipagemDBTableView1PatioOptmove->Options->Editing = false;

  }
  else
  {
    cxgEquipagemDBTableView1->OptionsData->Editing = true;
    cdsGrid->ReadOnly = false;
    cxgEquipagemDBTableView1Avaliacao->Options->Editing = true;
    cxgEquipagemDBTableView1observacao->Options->Editing = true;
    cxgEquipagemDBTableView1PatioOptmove->Options->Editing = true;

  }

  return true;//netto
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetFarolIntrajornada::acHabilitarRastreamentoExecute(TObject *Sender)
{
  if(pnlGridFarolDebug->Enabled)
  {
    pnlGridFarolDebug->Enabled = false;
    pnlGridFarolDebug->Visible = false;
  }
  else
  {
    pnlGridFarolDebug->Enabled = true;
    pnlGridFarolDebug->Visible = true;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetFarolIntrajornada::acRastrearTremExecute(TObject *Sender)
{
  if(!pnlGridFarolDebug->Enabled)
  {
    acHabilitarRastreamentoExecute(Sender);
  }
  if(edtBuscaPrefixo->Text.Length() < 7)
  {
    Alerta("Favor informar o prefixo para o rastreamento");
  }
  else
  {
    TStringList* idsTrem = TDAO::getIDTremAtualByPrefixo(edtBuscaPrefixo->Text);

    if(idsTrem->Count > 0)
    {

      String idTrem = idsTrem->Strings[0];

      String backFiltro = cdsGrid->Filter;
      cdsGrid->Filter = "";
      cdsGrid->DisableControls();
      cdsGrid->First();
      while(!cdsGrid->Eof)
      {
        if(cdsGridTrem->Text == edtBuscaPrefixo->Text)
        {
          lblRastreamento->Caption = cdsGridTrem->Text + " " + cdsGridmesa->Text + " - " + cdsGridNome->Text + " - Orig:" + cdsGridOrigem->Text +
          " Dest:" + cdsGridDestino->Text +
          //" - POp:" + cdsGridPatioOptmove->Text +
          " - PAt:" + cdsGridpatioAtual->Text +
          " - R:" + cdsGridisReal->Text + " " +
          " - I:" + cdsGridrealizouIntra->Text + " " +
          " - D:" + cdsGridisDuplado->Text + " | ";
        }
        cdsGrid->Next();
      }
      cdsGrid->Filter = backFiltro;
      cdsGrid->EnableControls();

      ltvOficializacoes->Items->Clear();
      TStringList* dummy = NULL;

      PtrQuery qrOficializacoes = TDAO::getUltimasOficializacoesByIdTrem(idTrem);

      while (!qrOficializacoes->Eof)
      {
        String oficializacao = qrOficializacoes->FieldByName("origem")->Text + " - Mesa " +
        qrOficializacoes->FieldByName("nu_mesa_pljm")->Text + " - " + qrOficializacoes->FieldByName("data")->Text;
        ltvOficializacoes->AddItem(oficializacao, dummy);

        qrOficializacoes->Next();
      }
      ltvOficializacoes->AddItem(idsTrem->Strings[0], dummy);
      ltvOficializacoes->AddItem(idsTrem->Strings[1], dummy);

      PtrQuery qrRasreamento = TDAO::getSituacaoFarolByIdTrem(idTrem);
      this->cdsDebug->Close();
      this->cdsDebug->CreateDataSet();
      this->cdsDebug->Open();

      cdsDebug->DisableControls();

      while (!qrRasreamento->Eof)
      {
        cdsDebug->Append();
        cdsDebugREAL2->Text = qrRasreamento->FieldByName("REAL2")->Text;
        cdsDebugID_FICHA->Text = qrRasreamento->FieldByName("id_trem_ficha")->Text;
        cdsDebugNU_SEQC->Text = qrRasreamento->FieldByName("nu_seqc")->Text;
        cdsDebugCD_SGMT->Text = qrRasreamento->FieldByName("cd_sgmt")->Text;
        cdsDebugMATRICULA_EQ->Text = qrRasreamento->FieldByName("nu_matl_eqpg")->Text;
        cdsDebugNOME_EQ->Text = qrRasreamento->FieldByName("nm_eqpg")->Text;
        cdsDebugORIGEM_PLAN->Text = qrRasreamento->FieldByName("sg_patio_orig_pljd")->Text;
        cdsDebugDEST_PLAN->Text = qrRasreamento->FieldByName("sg_patio_dest_pljd")->Text;
        cdsDebugORIGEM_REAL->Text = qrRasreamento->FieldByName("sg_patio_orig_rlzd")->Text;
        cdsDebugDEST_REAL->Text = qrRasreamento->FieldByName("sg_patio_dest_rlzd")->Text;
        cdsDebugDT_REAL->Text = qrRasreamento->FieldByName("dt_incs_rlzd")->Text;
        cdsDebugDT_ITNR->Text = qrRasreamento->FieldByName("criacaoI")->Text;
        cdsDebugSISTEMA_INC_FICHA->Text = qrRasreamento->FieldByName("ic_sist_incs")->Text;
        cdsDebugDT_FICHA->Text = qrRasreamento->FieldByName("criacaoF")->Text;

        cdsDebug->Post();
        qrRasreamento->Next();
      }

      cdsDebug->First();
      while(!cdsDebug->Eof)
      {
        if(cdsDebugREAL2->Text == cdsDebugCD_SGMT->Text)
        {

          break;
        }
        cdsDebug->Next();
      }
      cdsDebug->EnableControls();

    }
    else
    {
      Alerta("No foi possvel localizar o PID do trem");
    }
    delete idsTrem;
  }
}
//---------------------------------------------------------------------------







================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FTP.cpp =====

// ---------------------------------------------------------------------------
#include <vcl.h>
#include <System.math.hpp> //Round
#include <System.UITypes.hpp>
#include <System.DateUtils.hpp>
#include <boost/regex.hpp>
#include <DateTimeNull.h>
#pragma hdrstop

#include "FTP.h"
#include "UTPMovimento.h"
#include "UFControleLogsIntegracao.h"
#include "UDAO.h"
#include "UFMovimentosTrem.h"


#include "UTPRestricaoSeries.h"
//#include "UTPRestricao.h" incluido no   UFRestricao
#include "UTPTipoRestricao.h"
#include "UFRestricao.h"
#include "UFEditarMovimento.h"
#include "UFCriarTrem.h"
#include "UFFichaTrem.h"
//#include "CoreTMPlanner.h"
#include "UFormTabSheet.h"
#include "UFPrincipal.h"
#include "ULog.h"
#include "UFCriarAtividadeTrem.h"
#include "UFAtividadesTrem.h"
#include "UTPObservacaoSeries.h"
#include "UFParametrosSistema.h"
#include "UTPConflitoSeries.h"
#include "UTPSBConflitoSeries.h"
#include "UTPSB.h"
#include "UFPriorizacaoMovimentos.h"
#include "UTPAtividade.h"
#include "UTPTipoAtividade.h"
#include "UTPItinerarioTrem.h"
#include "UFDadosLoginReconexao.h"

#include "FDebugConflito.h"
#include "UFGradeTrens.h"
#include "UFFilas.h"
#include "UUteis.h"
#include "UGerenteProgramacao.h"
#include "UFResultadoProcessos.h"
#include "UFPriorizarDestino.h"
#include "UGerenteComunicacaoAQ.h"

#include "UFOrdemTrem.h"
#include "UFGatilhos.h"

#include "UTPHintSeries.h"
#include "FWidgetFarolIntrajornada.h"
#include "FWidgetGanttOcupacao.h"
#include "FWidgetDebug.h"
#pragma region Server
#include "../domain/TremMalha.h"
#include "../domain/ConflitoCandidato.h"
#pragma end_region

#include "FWidgetGridMonitoramentoEntrePlanos.h"
#include "FWidgetGridAtividadesAlteradas.h"

#include "UFAlertaTrensTabelaBusca.h"
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/SegmentoTremRealizado.h"

#include "FSelecionarOficializacao.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "VCLTee.TeeTools"
#pragma link "cxContainer"
#pragma link "cxControls"
#pragma link "cxEdit"
#pragma link "cxGraphics"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxTextEdit"
#pragma link "VCLTee.TeeAntiAlias"
#pragma link "cxScrollBox"
#pragma link "cxClasses"
#pragma link "cxHint"
#pragma link "dxCustomHint"
#pragma link "dxScreenTip"




#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma link "cxButtons"
#pragma link "cxClasses"
#pragma link "cxContainer"
#pragma link "cxControls"
#pragma link "cxEdit"
#pragma link "cxGraphics"
#pragma link "cxHint"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxTextEdit"
#pragma link "dxCustomHint"
#pragma link "dxScreenTip"
#pragma link "cxGroupBox"
#pragma resource "*.dfm"
#pragma region DEFINES
#define X1(serie ) serie->Marks->Positions->Position[0]->LeftTop.x
#define Y1(serie ) serie->Marks->Positions->Position[0]->LeftTop.y
#define X2(serie ) serie->Marks->Positions->Position[0]->LeftTop.x + serie->Marks->Positions->Position[0]->Width
#define Y2(serie ) serie->Marks->Positions->Position[0]->LeftTop.y + serie->Marks->Positions->Position[0]->Height
#define X12(serie ) serie->Marks->Positions->Position[0]->LeftTop.x + (serie->Marks->Positions->Position[0]->Width/2)
#define Y12(serie ) serie->Marks->Positions->Position[0]->LeftTop.y + (serie->Marks->Positions->Position[0]->Height/2)

const int TAM_MATRIZ = 300;

const double UMDIA    = 1.00000L;
const double DOISDIAS = 2.00000L;
const double UMAHORA  = 0.0416666666666666667L;

const double UMDIAPLAN    = 0.50000L;
const double DOISDIASPLAN = 1.00000L;
const double UMAHORAPLAN  = 0.0208333333333333L;

const TDateTime DATAFUTURODISTANTE = StrToDateTime("31/12/3000 23:59:59");

#define TP_MINX ((TP_->Data + TP_->Hora) + UMDIA) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA
#define TP_MAXX TP_->Data + DOISDIAS - TP_->DiasPassado*UMDIA

#define TP_MINX_PLAN ((TP_->Data + TP_->Hora) + UMDIAPLAN) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA
#define TP_MAXX_PLAN TP_->Data + DOISDIAS - TP_->DiasPassado*UMDIA

#define TP_MINY -1
#define TP_MAXY TP_->MaxY

#define MIN_TOP_HINT 60
#define MIN_SPACE_HINT 55

#define LIM_PIX_MOV 10

#define TP_MIN_X_DRAW (TP_->Data + TP_->Hora) - (UMAHORA * 8)
#define TP_MAX_X_DRAW TP_->Data + DOISDIAS - TP_->DiasPassado*UMDIA+(UMAHORA * 8)


#define TP_MINX_GRAF (TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA
#define PROPORCAO_TELA_POR_H_EXIBICAO (chrTTP->BottomAxis->Maximum -  chrTTP->BottomAxis->Minimum) / 1.75


#define PROPORCAO_POSICAO_INICIAL  0.20
#define PROPORCAO_TAMANHO_CHART_VISAO_PLANEJAMENTO 3.6 * PROPORCAO_TELA_POR_H_EXIBICAO
#define PROPORCAO_TAMANHO_CHART_VISAO_AMPLA 1.7 * PROPORCAO_TELA_POR_H_EXIBICAO
#define VELOCIDADE_PANNING_CHART 2
#define VELOCIDADE_PANNING_CHART_ZOOM 0.75

#pragma end_region

int PosicaoAnteriorScroll = 0;
int crMyCursor            = 5;

TFormTP *FormTP;
extern TFormWidgetGridDiferencasEntrePlanos *FormWidgetGridDiferencasEntrePlanos;
extern TFormWidgetGridAtividadesAlteradas   *FormWidgetGridAtividadesAlteradas;
extern TFormWidgetGanttOcupacao *FormWidgetGanttOcupacao;
extern TFormWidgetFarolIntrajornada *FormWidgetFarolIntrajornada;
extern TFormWidgetDebug *FormWidgetDebug;

bool FProgramando;

#pragma region BENCHMARK
//#define BENCHMARK_
#ifdef BENCHMARK_
class TTPBenchmark
{
 private:
 TTPBenchmark()
 {
      marks = new  TStringList();
 };

 public:
 static TTPBenchmark *instance ;
 TStringList *marks;

 static TTPBenchmark * getInstance()
 {
   if(!instance)

    instance = new TTPBenchmark();

    return instance;
 };

 void StartBenchmark(String pNomeBenchmark, float pValorBenchmark)
 {
   int index =	marks->IndexOf(pNomeBenchmark);
   TStringList *  ListBenchmark;
   if(index < 0)
   {
       ListBenchmark = new   TStringList();
       marks->AddObject(pNomeBenchmark,(TObject*)ListBenchmark);
   }
   else
   {
     ListBenchmark = (TStringList*) marks->Objects[index];
   }

   if(ListBenchmark->Count>0)
   {
     if(StrToFloat(ListBenchmark->operator [](ListBenchmark->Count-1) )<100)
     {
        ListBenchmark->Add(FloatToStr (pValorBenchmark/1000.00));
     }
   }
   else
   ListBenchmark->Add(FloatToStr (pValorBenchmark/1000.00));
 }

 void EndBenchmark(String pNomeBenchmark, float pValorBenchmark)
 {
   int index =	marks->IndexOf(pNomeBenchmark);
   TStringList *  ListBenchmark;
   if(index >= 0)
   {
     ListBenchmark = (TStringList*) marks->Objects[index];
     float tkAnterior =  StrToFloat(ListBenchmark->operator [](ListBenchmark->Count-1) );

     tkAnterior = pValorBenchmark/1000.00 - tkAnterior;
     ListBenchmark->Delete(ListBenchmark->Count-1);
     ListBenchmark->Add(FloatToStr(tkAnterior));
     ListBenchmark->SaveToFile("c:\\TBenchmark\\"+pNomeBenchmark+".tbm");
   }
 }
};

TTPBenchmark *TTPBenchmark::instance = 0;
#endif

#pragma end_region

void TFormTP::clearSmartPTr()
{
  FTremSelecionado_ = NULL;
  FTrens_= NULL;
  FRestricoes_= NULL;
  if(FSerieSBsChartTop_)
  {
    delete FSerieSBsChartTop_;
    FSerieSBsChartTop_=NULL;
  }
  if(FSerieSBsChartBot_)
  {
    delete FSerieSBsChartBot_;
    FSerieSBsChartBot_ = NULL;
  }
  if(FSerieSBsChartLeft_)
  {
    FSerieSBsChartLeft_ = NULL;
    delete FSerieSBsChartLeft_;
  }
  if(FSerieSBsChartRight_)
  {
    delete FSerieSBsChartRight_;
    FSerieSBsChartRight_ = NULL;
  }
  FListSBs_ = NULL;
  FRamal_ = NULL;
}
inline __fastcall TFormTP::~TFormTP(void)
{
//   clearSmartPTr();
  delete FSeriesRestSelecionadas_;
  delete FSeriesObservacao_;
  delete FSerieSBs_;
//  delete   FSerieSBsChartTop_ ;
//  delete FSerieSBsChartBot_ ;
//  delete FSerieSBsChartLeft_ ;
//  delete FSerieSBsChartRight_ ;
  delete TP_;
  delete t_seriesGlobal;
}

// ---------------------------------------------------------------------------
__fastcall TFormTP::TFormTP(TComponent* Owner, TTPRamalPtr pRamal) : TForm(Owner)
{
  TActionListState state = al->State;
  al->State              = asNormal;
  FTrens_                = TTPTremListPtr(new TTPTremList()); //netto - verificar
  // Vamos manter uma lista dos trens neste painel para facilitar pequisas e filtros
  FRestricoes_                         = TTPRestricaoListPtr(new TTPRestricaoList()); //netto - verificar
  FSeriesRestSelecionadas_             = new TXStringList();
  FSeriesObservacao_                   = new TXStringList();
  FSeriesRestSelecionadas_->Duplicates =  System::Types::dupIgnore;
  FRamal_                              = pRamal;
  acInicializar->OnExecute(this);
  FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;
  AjustarEstadoControles(false);
  AjustarEstadoControleMovimentosOficializadosEntreMesas();
  acCarregar->Enabled              = true;
  acCarregar->ShortCut             = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;
  FEditandoOrigem_                 = false;
  FMoverTremSelecionadoClickAtivo_ = false;
  FSelecionandoRestArrastoShift_   = false;
  FPrimeiraRestricao_              = -1;
  al->State                        = state;
  FMouseXScroll_                   = -1;
  FMouseYScroll_                   = -1;
  chrTTPRight->Height              = 0;
  chrTTPLeft->Height               = 0;
  FExecutouResetPosicao_           = false;
  FHorarioCentralAtual_            = -1;
  FIsMiminizedChart_               = false;
  FIsCtrlA_                        = false;
  FFezPanning_                     = false;
  FPanning_                        = false;
  FVisaoPlajemanto_                = false;
  FExibirMsgSalvarAltomatico_      = false;
  FAcionarAutomaticoOk_            = false;
  serieRefreshAfterPlotarTrens_ = NULL;
  pnlInfos->Width                  = 0;
  pnlGanttOcupacao->Height = 0;
  sptGanttOcupacao->Height = 0;
  dtsInfos->Visible                = false;
  FNoSetFocus_                     = false;
  FRedrawChart_                    = false;
  FRedrawChartOnMouseMove_         = false;
  FSelecionarTremRemoverRestricao_ = false;
  FSelecionouSerieRemoverRestricao_= false;
  FArrastoSeries_                  = NULL;
   FormWidgetGridDiferencasEntrePlanos = NULL;
   FormWidgetGridAtividadesAlteradas = NULL;

  acParametrosAtivos->Hint = FAROL_VERDE;
  acParametrosDesativados->Hint = FAROL_VERMELHO;
  acParametrosDesativadosTpExp->Hint = FAROL_AMARELO;

  menusDinamicos_ = TTPFormsManager::getInstance()->CarregarMenusDinamicos();
  if (menusDinamicos_->Count > 0)
  {
    bool criouSeparador = false;
    //fazer um for para criar os menus
    for (int i = 0; i< menusDinamicos_->Count; i++)
    {
      TTPMenuDinamico* menu = (TTPMenuDinamico*)menusDinamicos_->Objects[i];

      if(menu)
      {
        if(!criouSeparador)
        {
          TMenuItem *RestSep = new TMenuItem(pmnCadastroRestricao);
          RestSep->Caption = "-";
          pmnCadastroRestricao->Items->Add(RestSep);

          criouSeparador = true;
        }

        TMenuItem *RestDin = new TMenuItem(pmnCadastroRestricao);
        TAction *acRetDin = new TAction(al);
        acRetDin->OnExecute = acRetencaoDinamicaExecute;
        acRetDin->Caption = menu->Caption;

        RestDin->Action = acRetDin;
        RestDin->Caption = menu->Caption;
        pmnCadastroRestricao->Items->Add(RestDin);

      }
    }
  }
  FProgramando =  false;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::CreateParams(TCreateParams& Params)
{
  TForm::CreateParams(Params);
  /* WS_CLIPSIBLINGS no remover */

  Params.Style     = WS_CHILD | WS_MAXIMIZE | WS_CLIPSIBLINGS | WS_HSCROLL | WS_VSCROLL;
  Params.WndParent = dynamic_cast<TForm*>(Owner)->ClientHandle;
  // dynamic_cast<TForm*>(Owner)->ClientRect

  Params.Width  = this->Width; // dynamic_cast<TForm*>(Owner)->ClientRect.Right;
  Params.Height = this->Height;
  Params.Y      = 0; // dynamic_cast<TForm*>(Owner)->;
  Params.X      = 0; // dynamic_cast<TForm*>(Owner)->ClientOrigin.X;
}
// ---------------------------------------------------------------------------

void TFormTP::Inicializar(TTPRamalPtr pRamal, int DiasPassado)
{
  TdxScreenTipRepository* t_screenTipRepository = this->dxScreenTip;
  TcxHintStyleController* t_hintstylecontroller = this->cxHintController;

  OldScrollBoxWP = scbCharts->WindowProc;
  scbCharts->WindowProc = NewScrollBoxWP;

  this->t_seriesGlobal = new TTPHintSeries(t_hintstylecontroller, t_screenTipRepository, TTPFormsManager::getInstance()->ShowVisualizador);

  delete TP_;
  TP_ = NULL;
  delete FSerieSBs_;
  delete FSerieSBsChartLeft_;
  delete FSerieSBsChartRight_;
  FSerieSBs_ = NULL;
  FSerieSBsChartLeft_ = NULL;
  FSerieSBsChartRight_ = NULL;
  if(FArrastoSeries_)
	delete FArrastoSeries_;
  FArrastoSeries_        = NULL;
  FListSBs_              = NULL;
  FTipoArrasto_          = taSemArrasto;
  FTipoArrastoRealizado_ = taSemArrasto;

  LimparGrafico();
  chkTravar->Checked               = FRamal_->PermiteStandAloneProg;
  chkTravar->Visible               = FRamal_->PermiteStandAloneProg && !TTPFormsManager::getInstance()->VerificaShowVisualizador();
  chkTravar->Enabled               = FRamal_->PermiteStandAloneProg && !TTPFormsManager::getInstance()->VerificaShowVisualizador();

  if (this->FListSBs_ == NULL)
  {
    DModuleMP->ActivateUserDB();
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TTPFormsManager::getInstance()->Data = core->getDataHoraBaseCalculo().asDateTime();
    // Alterando para pegar a data no Server - TDAO::getCurrentDate();

    medData->Text = TTPFormsManager::getInstance()->Data.DateTimeString();

    this->FListSBs_    = pRamal->SBs;
    TDate tDataGrafico = TTPFormsManager::getInstance()->Data.DateString();
    if (TP_ == NULL)
    {
      TP_ = new TTP(tDataGrafico, this->FListSBs_->count(), pRamal->MinY,
      (pRamal->ComprimentoTotal < 1 ? 1 : pRamal->ComprimentoTotal));
        TP_->DiasPassado = DiasPassado;
    }

    FSerieSBs_ = new TTPSBSeries(NULL);
    FSerieSBsChartTop_ = new TTPSBSeries(NULL);
    FSerieSBsChartBot_ = new TTPSBSeries(NULL);
    FSerieSBsChartLeft_ = new TTPSBSeries(NULL);
    FSerieSBsChartRight_ = new TTPSBSeries(NULL);

    FSerieSBs_->TipoLegenda = TTPFormsManager::getInstance()->TipoLegenda;
    if(this->FListSBs_->count() > 0)
    {
      FSerieSBsChartTop_->AdicionarSB(this->FListSBs_->operator[](0));
      FSerieSBsChartBot_->AdicionarSB(this->FListSBs_->operator[](0));
    }
    for (int i = 0; i < this->FListSBs_->count(); i++)
    {
      FSerieSBs_->AdicionarSB(this->FListSBs_->operator[](i));
      FSerieSBsChartLeft_->AdicionarSB(this->FListSBs_->operator[](i));
      FSerieSBsChartRight_->AdicionarSB(this->FListSBs_->operator[](i));
    }

    TTPTipoTremListPtr tTipos = TTPFormsManager::getInstance()->TiposTrem;
    for (int i = 0; i < tTipos->count(); i++)
    {
      cboTipoTrem->Items->AddObject(tTipos->operator[](i)->Nome, (TObject*)&*tTipos->operator[](i));
    }

    FCountSeriesSBsPainel_ = this->FSerieSBs_->Count();

  }
  if (lblStatus != NULL)
  {
    lblStatus->Tag     = 0;
    lblStatus->Caption = "";
  }
}

// ---------------------------------------------------------------------------
void TFormTP::ConfigurarBotoes()
{
  #ifdef BAIXADA_SANTISTA
  grpControles->Width -= (tbtAutomatico->Width + tbtLog->Width + tbtAlarm->Width);
  gbxAlerta->Visible = false;
  tbtAutomatico->Visible = false;
	tbtLog->Visible = false;
	tbtAlarm->Visible = false;
  btnToolTerminais->Visible = false;
  grpBusca->Width -= btnToolTerminais->Width;
  grpControles->BringToFront();
  acPriorizarDestinos->Enabled = true;
  acPriorizarDestinos->Visible = true;
  #else
  acPriorizarDestinos->Enabled = false;
  acPriorizarDestinos->Visible = false;
  #endif

      ToolBarEventos->DisableAlign(); // Desativar o alinhamento temporariamente
      ToolBarMaisEventos->DisableAlign(); // Desativar o alinhamento temporariamente

    try
    {


         ToolBarEventos->Realign();
        ToolBarEventos->AutoSize = false; // Temporariamente desativar AutoSize
        ToolBarEventos->AutoSize = true;  // Reativar AutoSize para recalcular tamanho
           ToolBarEventos->Invalidate();      // Atualiza graficamente o ToolBar
          // Forar o realinhamento aps mudanas
        ToolBarMaisEventos->AutoSize = false; // Temporariamente desativar AutoSize
        ToolBarMaisEventos->AutoSize = true;  // Reativar AutoSize para recalcular tamanho
        ToolBarMaisEventos->Realign();
         ToolBarMaisEventos->Invalidate();      // Atualiza graficamente o ToolBar
    }
    __finally
    {
        ToolBarEventos->EnableAlign(); // Reativar o alinhamento
     ToolBarMaisEventos->EnableAlign(); // Reativar o alinhamento

    }




   AdjustGroupBoxSize(GroupBox1);
   AdjustGroupBoxSize(grpBusca);
   AdjustGroupBoxSize(grpControles);
 }
void TFormTP::AdjustGroupBoxSize(TGroupBox *GroupBox)
{
    int MaxWidth = 0;
    int TotalHeight = 0;
     // Obter o fator de escala DPI atual do monitor
    HDC ScreenDC = GetDC(0); // Obter o contexto de tela
    int DPI = GetDeviceCaps(ScreenDC, LOGPIXELSX); // DPI horizontal
    ReleaseDC(0, ScreenDC);
    float DPIScale = DPI / 96.0f; // Fator de escala (96 DPI  o padro)
    GroupBox->Height = GroupBox->Height-1;
    for (int i = 0; i < GroupBox->ControlCount; i++)
    {
        TControl *Control = GroupBox->Controls[i];
       if (!Control->Visible)
            continue;
        // Calcular a largura mxima
        MaxWidth = std::max(MaxWidth, Control->Left + Control->Width);

        // Calcular a altura total
        TotalHeight = std::max(TotalHeight, Control->Top + Control->Height);
    }
       // Adicionar margens escaladas
    int MarginWidth = static_cast<int>(10 * DPIScale);  // Margem horizontal
    int MarginHeight = static_cast<int>(20 * DPIScale); // Margem vertical (considerando o ttulo)

    // Ajustar tamanho do GroupBox
    GroupBox->Width = MaxWidth + MarginWidth;
    if(GroupBox->Constraints->MaxHeight>0 && GroupBox->Constraints->MaxHeight>TotalHeight + MarginHeight)
      GroupBox->Height = TotalHeight + MarginHeight;
    else
      GroupBox->Height = GroupBox->Constraints->MaxHeight;
}
// ---------------------------------------------------------------------------
void TFormTP::ConfigurarGrafico()
{
  double t_maximumY = chrTTP->LeftAxis->Maximum;
  double t_minimumY = chrTTP->LeftAxis->Minimum;
  double t_maximumX = chrTTP->BottomAxis->Maximum;
  double t_minimumX = chrTTP->BottomAxis->Minimum;

  if(!FIsMiminizedChart_)
  {
    chrTTP->Width = this->Width*PROPORCAO_TAMANHO_CHART_VISAO_PLANEJAMENTO;
    chrTTPTop->Width = chrTTP->Width;
    chrTTPBot->Width = chrTTP->Width;
    scbCharts->HorzScrollBar->Range = chrTTP->Width;
  }
  else
  {
    MinimizarChart();
  }

  chrTTPTop->AllowPanning = pmHorizontal;
  chrTTPBot->AllowPanning = pmHorizontal;

  ConfigurarGraficoAux(chrTTP);
  ConfigurarGraficoAux(chrTTPTop);
  ConfigurarGraficoAux(chrTTPBot);
  ConfigurarGraficoAux(chrTTPLeft);
  ConfigurarGraficoAux(chrTTPRight);

  FSerieSBs_->ParentChart = chrTTP;
  FSerieSBsChartTop_->ParentChart = chrTTPTop;
  FSerieSBsChartBot_->ParentChart = chrTTPBot;
  FSerieSBsChartLeft_->ParentChart = chrTTPLeft;
  FSerieSBsChartRight_->ParentChart = chrTTPRight;

  chrTTP->AddSeries(FSerieSBs_);
  chrTTPTop->AddSeries(FSerieSBsChartTop_);
  chrTTPBot->AddSeries(FSerieSBsChartBot_);
  chrTTPLeft->AddSeries(FSerieSBsChartLeft_);
  chrTTPRight->AddSeries(FSerieSBsChartRight_);

  if (FISZoomed_)
  {
    chrTTP->AllowPanning = pmBoth;
    chrTTP->LeftAxis->SetMinMax(t_minimumY, t_maximumY);
    chrTTP->RightAxis->SetMinMax(t_minimumY, t_maximumY);
    chrTTPTop->LeftAxis->SetMinMax(t_minimumY, t_maximumY);
    chrTTPTop->RightAxis->SetMinMax(t_minimumY, t_maximumY);
    chrTTPBot->LeftAxis->SetMinMax(t_minimumY, t_maximumY);
    chrTTPBot->RightAxis->SetMinMax(t_minimumY, t_maximumY);
  }
  else
  {
    chrTTP->AllowPanning = Vcltee::Teeprocs::pmNone;
    if (TP_MAXY < 2) // para os casos de Paineis com o comprimento muito pequeno
    {
      chrTTP->LeftAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTP->RightAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPTop->LeftAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPTop->RightAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPBot->LeftAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPBot->RightAxis->SetMinMax(-0.01, TP_MAXY + (3*(TP_MAXY / 100)));
    }
    else
    {
      chrTTP->LeftAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTP->RightAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPTop->LeftAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPTop->RightAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPBot->LeftAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
      chrTTPBot->RightAxis->SetMinMax(TP_MINY, TP_MAXY + (3*(TP_MAXY / 100)));
    }

    ConfigurarChartsLimitesHorizontaisDefault();
  }

  chrTTP->PopupMenu = pmnGeral;

  SincyCharts();

  chrTTP->Hide();
  chrTTPTop->Hide();
  chrTTPBot->Hide();
  chrTTPRight->Hide();
  chrTTPLeft->Hide();
}

// ---------------------------------------------------------------------------
void TFormTP::ConfigurarChartsLimitesHorizontaisDefault()
{
  chrTTP->BottomAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
  chrTTP->TopAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
  chrTTPTop->BottomAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
  chrTTPTop->TopAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
  chrTTPBot->BottomAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
  chrTTPBot->TopAxis->SetMinMax((TP_->Data + TP_->Hora) - (UMAHORA * 6) - TP_->DiasPassado*UMDIA, TP_MAXX_PLAN);
}

// ---------------------------------------------------------------------------
void TFormTP::ConfigurarGraficoAux(TChart *pChart)
{
  pChart->DoubleBuffered = true;
  pChart->DestroyComponents();
  pChart->Title->Text->Clear();
  pChart->Title->Text->Add("");
  pChart->View3D = false;

  pChart->ScaleLastPage = false;

  pChart->BottomAxis->LabelsMultiLine = true;
  // chrTTP->BottomAxis->DateTimeFormat    = "hh:nn dd/mm/yy";
  pChart->BottomAxis->DateTimeFormat    = "hh:nn";
  pChart->BottomAxis->AxisValuesFormat  = "#####0.#################";
  pChart->BottomAxis->Increment         = (FVisaoPlajemanto_ ? UMAHORAPLAN : UMAHORA);
  pChart->BottomAxis->Automatic         = false;
  pChart->BottomAxis->LabelStyle        = talValue;
  pChart->BottomAxis->Axis->Width       = 0.1;
  pChart->BottomAxis->Ticks->Width      = 0.1;
  pChart->BottomAxis->MinorTicks->Width = 0.1;
  pChart->BottomAxis->Grid->ZPosition   = 0;

  pChart->LeftAxis->LabelStyle   = talText;
  pChart->LeftAxis->LabelsOnAxis = true;
  pChart->LeftAxis->Axis->Width  = 0.1;

  pChart->RightAxis->LabelStyle   = talText;
  pChart->RightAxis->LabelsOnAxis = true;
  pChart->RightAxis->Axis->Width  = 0.1;

  pChart->TopAxis->LabelsMultiLine   = true;
  pChart->TopAxis->DateTimeFormat    = "hh:nn";
  pChart->TopAxis->AxisValuesFormat  = "#####0.#################";
  pChart->TopAxis->Increment         = (FVisaoPlajemanto_ ? UMAHORAPLAN : UMAHORA);
  pChart->TopAxis->Automatic         = false;
  pChart->TopAxis->LabelStyle        = talValue;
  pChart->TopAxis->Axis->Width       = 0.1;
  pChart->TopAxis->Ticks->Width      = 0.1;
  pChart->TopAxis->MinorTicks->Width = 0.1;

  pChart->LeftAxis->Grid->Color = TColor((210 * 65536) + (212 * 256) + 214); ;
  pChart->LeftAxis->Grid->Style      = (TPenStyle)psSmallDot; //netto
  pChart->LeftAxis->Grid->Width      = 0.1;
  pChart->LeftAxis->Grid->Visible    = false;
  pChart->LeftAxis->Grid->ZPosition  = -1;
  pChart->RightAxis->Grid->Color     = TColor((210 * 65536) + (212 * 256) + 214); ;
  pChart->RightAxis->Grid->Style     = (TPenStyle)psSmallDot; //netto
  pChart->RightAxis->Grid->Visible   = false;
  pChart->RightAxis->Grid->Width     = 0.1;
  pChart->RightAxis->Grid->ZPosition = -1;

}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::PlotarLinhasDuplas()
{
  try
  {
    double YFinalAnt = -1;
    TTPLinhaDuplaSeries* t_serieLinhaDuplaAnt;
    for (int iPosicaoY = 0; iPosicaoY < (TP_->TotalSBs * 2) - 1; iPosicaoY++)
  {
    TTPSBPtr t_sb1 = this->FSerieSBs_->GetSB(iPosicaoY);
    TTPSBPtr t_sb2 = this->FSerieSBs_->GetSB(iPosicaoY + 1);

      // Primeiro vamos verificar linha dupla
      bool linhaDuplaOrigem  = t_sb1->TipoVisao == "LD";
      bool linhaDuplaDestino = t_sb2->TipoVisao == "LD";

      if (linhaDuplaOrigem && linhaDuplaDestino)
      {
        double XInicial = (TP_->Data - DOISDIAS) + (TTime)0;
        double XFinal   = (TP_->Data + DOISDIAS) + (TTime)0;
        double YInicial = t_sb1->IndexGraficoI;
        double YFinal   = t_sb2->IndexGraficoS;

        if (YInicial > YFinal)
        {
          int aux  = YInicial;
          YInicial = YFinal;
          YFinal   = aux;
        }

        if (YInicial > YFinalAnt || YFinalAnt==-1)
        {
          TTPLinhaDuplaSeries* t_serieLinhaDupla = new TTPLinhaDuplaSeries(chrTTP, XInicial, XFinal, YInicial,
            YFinal, false);
          chrTTP->AddSeries(t_serieLinhaDupla);

          t_serieLinhaDuplaAnt = t_serieLinhaDupla;
        }
        else
        {
          t_serieLinhaDuplaAnt->alterY1Serie(YFinal);
        }
        YFinalAnt = YFinal;
      }
      else
      {
        // se NO tem linha dupla, vamos ver se tem prio!

        bool linhaVisaoPatioOrigem = t_sb1->Linhas > 1 && t_sb1->TipoVisao != "PD";
        bool linhaVisaoPatioDestino = t_sb2->Linhas > 1 && t_sb2->TipoVisao != "PD";

        if (linhaVisaoPatioOrigem && linhaVisaoPatioDestino)
        {
          double XInicial = (TP_->Data - DOISDIAS) + (TTime)0;
          double XFinal   = (TP_->Data + DOISDIAS) + (TTime)0;
          double YInicial = t_sb1->IndexGraficoI;
          double YFinal   = t_sb2->IndexGraficoS;

          if (YInicial > YFinal)
          {
            int aux  = YInicial;
            YInicial = YFinal;
            YFinal   = aux;
          }

          TTPLinhaDuplaSeries* t_serieLinhaDupla = new TTPLinhaDuplaSeries(chrTTP, XInicial, XFinal, YInicial,
            YFinal, true);
          chrTTP->AddSeries(t_serieLinhaDupla);
        }
      }
    }
  }
  catch (Exception& e)
  {
    int erro = 1;
    // TUtils::ShowMessage("Ocorreu um erro ao plotar os trechos com linha dupla deste painel. Alguns dos trechos podem no estar sendo exibidos. Favor avisar a Informtica sobre este problema.\n" + e.Message , MB_OK | MB_ICONWARNING);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::chrTTPMouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
  if(RefreshAfterPlotarTrens_ && !serieRefreshAfterPlotarTrens_)
  {
     chrTTP->AutoRepaint = true;

     serieRefreshAfterPlotarTrens_ = new TLineSeries(chrTTP);
     chrTTP->AddSeries(serieRefreshAfterPlotarTrens_);
     serieRefreshAfterPlotarTrens_->AddXY(double (TP_->Data + TP_->Hora), -0.9,"",clWhite);
     serieRefreshAfterPlotarTrens_->AddXY(double (TP_->Data + TP_->Hora), -1.0,"",clWhite);
     return;
  }
  else if(RefreshAfterPlotarTrens_ && serieRefreshAfterPlotarTrens_)
  {
     chrTTP->AutoRepaint = true;
      RefreshAfterPlotarTrens_ = false;
     chrTTP->RemoveSeries(serieRefreshAfterPlotarTrens_);
     delete serieRefreshAfterPlotarTrens_;
     serieRefreshAfterPlotarTrens_ = NULL;

     return;
  }



  double tdifX = 0;
  double tdifY = 0;

  int tDifArrastX = FMouseX_ - X;
  int tDifArrastY = FMouseY_ - Y;


  if(FRedrawChartOnMouseMove_ && (tDifArrastX!=0 || tDifArrastY!=0))
  {

    ForceRedrawChart();
     return;
  }

  chrTTP->AllowZoom   = Shift.Contains(ssLeft);
  if(tDifArrastX!=0 || tDifArrastY!=0)
  chrTTP->AutoRepaint = Shift.Contains(ssLeft);
  else
    chrTTP->AutoRepaint = false;

  bool semSelecionarAtivo = false;

  if(FISZoomed_)
    TTPFormsManager::getInstance()->DrawAllSeries = true;

  if((scbCharts->HorzScrollBar->Position==0 && !FExecutouResetPosicao_ ) ||
     (scbCharts->HorzScrollBar->Position==0 && FPerdeuFocus_))
  {
    if(FPerdeuFocus_ && FExecutouResetPosicao_)
      FPerdeuFocus_ = false;

    scbCharts->HorzScrollBar->Position =  ultimaPosicaoscbCharts_;

    if(FISZoomed_)
      scbCharts->VertScrollBar->Position  = ultimaPosicaoscbChartVert_;

    FExecutouResetPosicao_ = true;
    chrTTP->AllowZoom  = false;

  }
  else
  {
    if(!Shift.Contains(ssRight))
      ultimaPosicaoscbCharts_ =  scbCharts->HorzScrollBar->Position;
  }

  if (FMouseXScroll_!=-1 && Shift.Contains(ssRight))
  {
    tdifX = FMouseXScroll_ - X;
    tdifY = FMouseYScroll_ - Y;
  }

  FMouseX_ = X;
  FMouseY_ = Y;

  FMouseXScroll_ = X;
  FMouseYScroll_ = Y;

  // Movimentar grfico pelo boto direito
  if (Shift.Contains(ssRight))
  {
    //chrTTP->AutoRepaint = false;
    FHabilitarPopup = tdifX==0&&tdifY==0;
    HideHint();
    double valorInicial    = FSerieSBs_->XScreenToValue(FPontoInicioPanning_.x);
    double valorFinal      = FSerieSBs_->XScreenToValue(X);
    double diferenca       = valorFinal - valorInicial;
   // double novaHoraGrafico = chrTTP->BottomAxis->Maximum - (diferenca * 3);
    double novaHoraGrafico = valorFinal;
    // Multiplica por 3 para agilizar o scroll

    if (FVisaoPlajemanto_)
    {
      if (novaHoraGrafico > TP_MAXX)
      {
        novaHoraGrafico = TP_MAXX;
      }
      if (novaHoraGrafico < TP_MINX)
      {
        novaHoraGrafico = TP_MINX;
      }
    }
    else
    {
      if (novaHoraGrafico > TP_MAXX_PLAN)
      {
        novaHoraGrafico = TP_MAXX_PLAN;
      }
      if (novaHoraGrafico < TP_MINX_PLAN)
      {
        novaHoraGrafico = TP_MINX_PLAN;
      }
    }

   // chrTTP->BottomAxis->SetMinMax(novaHoraGrafico - (FVisaoPlajemanto_ ? UMDIA : UMDIAPLAN), novaHoraGrafico);
   // chrTTP->TopAxis->SetMinMax(novaHoraGrafico - (FVisaoPlajemanto_ ? UMDIA : UMDIAPLAN), novaHoraGrafico);

    TTime diferencaHoras = ((FVisaoPlajemanto_ ? TP_MAXX : TP_MAXX_PLAN) - novaHoraGrafico);
    // scbRodape->Position    = scbRodape->Max - (((double)diferencaHoras) / (FVisaoPlajemanto_ ? UMAHORA : UMAHORAPLAN));
    if(FPanning_)
    {
      if(tdifX!=0 && abs(tdifX)<1000)
       ScrollTo(NULL, tdifX*VELOCIDADE_PANNING_CHART);
      else
       tdifX = 0;

       FMouseXScroll_+= tdifX*VELOCIDADE_PANNING_CHART;
    }
    else
    {
      if((tdifX!=0 || tdifY!=0) && (abs(tdifX)<100 || abs(tdifY)<100))
      {
        FisRebuffered_ = false;
        ScrollToOnZoom(tdifX*VELOCIDADE_PANNING_CHART_ZOOM, tdifY*VELOCIDADE_PANNING_CHART_ZOOM);
      }
      else
      {
        tdifX = 0;
        tdifY = 0;
      }
    }

    FTotalPanning_ += abs(FPontoInicioPanning_.x - X) + abs(FPontoInicioPanning_.y - Y);
    FPontoInicioPanning_.x = X;
    FPontoInicioPanning_.y = Y;
    FFezPanning_           = FTotalPanning_ > LIM_PIX_MOV;
    return;
  }

  if (Shift.Contains(ssShift))
    chrTTP->Tag = 1;
  else
    chrTTP->Tag = 0;

  if (FISZoomed_ && Shift.Contains(ssRight))
  {
    FTotalPanning_ += abs(FPontoInicioPanning_.x - X) + abs(FPontoInicioPanning_.y - Y);
    FPontoInicioPanning_.x = X;
    FPontoInicioPanning_.y = Y;
    FFezPanning_           = FTotalPanning_ > LIM_PIX_MOV;
  }

  // Arrastar PAT
  else if ((FTipoArrasto_ != taSemArrasto && FTipoArrasto_ != taRestricaoInicio && FTipoArrasto_ != taRestricaoFim)
    && FSerieMovimentoSelecionada_ != NULL)
  {
    if (!FSerieMovimentoSelecionada_->Trem->IsSuprimido && tdifX==0 && tDifArrastX!=0)
      // FPlanoInicializado &&  S deixa arrastar de o plano j foi iniciado
    {
      Arrastar(X, Y);
    }
  }
  else if (FMarcarRestricao_ || FSelecionandoRestArrastoShift_)
  {
    double coordY = FSerieSBs_->YScreenToValue(Y);
    coordY        = RoundTo(coordY, -3);
    double tY     = FSerieSBs_->CalcYPosValue(coordY);

    int tTop = FCoordenadasSelecao_.Top;
    if (tTop == tY)
    {
      // Quando o ptio origem  o mesmo do destino,
      // ajusta coordenadas para o retangulo aparecer
      // se as coordenadas forem iguais o retangulo no aparece
      tTop += 0.05;
      tY -= 0.05;
    }
    ShapeSelecao->Top = tTop;
    ShapeSelecao->Height = tY - ShapeSelecao->Top;
    ShapeSelecao->Width  = X - ShapeSelecao->Left;
  }
  else if ((FTipoArrasto_ == taRestricaoInicio || FTipoArrasto_ == taRestricaoFim)
    && FSerieRestricaoSelecionada_ != NULL && Shift.Contains(ssLeft)) /*FSerieRestricaoSelecionada_->Restricao->Trem == NULL && */
  {
    ArrastarRestricao(X, Y);
  }
  else if (FCriandoTremArrasto_)
  {
    // Se NO est com o boto esquerdo pressionado
    if (!Shift.Contains(ssLeft))
    {
	  acCancelarTremArrasto->Execute();
      return;
    }
    else if (Shift.Contains(ssLeft))
    {
      // Arrastando...
      FTremSelecionadoSerie_->Arrastar(FSerieSBs_->XScreenToValue(X), RoundTo(FSerieSBs_->YScreenToValue(Y), -3));
    }
  }
  else if (FSerieRestricaoSelecionada_ != NULL)
  {
    if (FSerieRestricaoSelecionada_->CheckArrasto(X, Y))
    {
      if (FSerieRestricaoSelecionada_->Mover)
      {
        chrTTP->Cursor         = crHandPoint;
        chrTTP->OriginalCursor = crHandPoint;
      }
      else
      {
        chrTTP->Cursor         = crHSplit;
        chrTTP->OriginalCursor = crHSplit;
      }
    }
    else
    {
      chrTTP->Cursor         = crDefault;
      chrTTP->OriginalCursor = crDefault;
    }
  }
  else if (serieLinhaTempoCongelar_ != NULL && serieLinhaTempoCongelar_->Arrastando)
  {
    FCongelandoProgramacao_ = true;
    // Se NO est com o boto esquerdo pressionado
    if (!Shift.Contains(ssLeft))
    {
      FCongelandoProgramacao_ = false;
      return;
    }
    else if (Shift.Contains(ssLeft))
    {
      // Arrastando...
      serieLinhaTempoCongelar_->Arrastar(FSerieSBs_->XScreenToValue(X));
    }
  }
  else if (serieLinhaTempoAparagarParadas_ != NULL && serieLinhaTempoAparagarParadas_->Arrastando)
  {
    if (Shift.Contains(ssLeft))
    {
      // Arrastando...
      serieLinhaTempoAparagarParadas_->Arrastar(FSerieSBs_->XScreenToValue(X));
    }
  }
  else if (!Shift.Contains(ssLeft) || !Shift.Contains(ssRight))
  {
    //tmrMouseMovePrefixo->Enabled = true;

    if (!FPanning_ && (tDifArrastX != 0||tDifArrastY != 0))
    {
      if(TTPFormsManager::getInstance()->MovimentosSerieMouseOver!=NULL)
      {
        TTPTipoSerie tipoSerie = GetTipoSerieMP((TChartSeries* ) TTPFormsManager::getInstance()->MovimentosSerieMouseOver );

        if(tipoSerie != tsDesconhecido)
        {
      if(TTPFormsManager::getInstance()->MovimentosSerieMouseOver!=NULL && !TTPFormsManager::getInstance()->MovimentosSerieMouseOver->IsMovimentoSelecao && TTPFormsManager::getInstance()->MovimentosSerieMouseOver->Clicked(TPoint(X,Y))>-1)
      {
        TTPFormsManager::getInstance()->MovimentosSerieMouseOver->DoSeriesMouseEnter(this);
      }
        }
        else
        {
          TTPFormsManager::getInstance()->MovimentosSerieMouseOver=NULL;
        }
      }
                  }
                  }

  if ((!FPanning_) && FSerieSBs_ != NULL)
  {
    TDateTime * dt     = new TDateTime(FSerieSBs_->XScreenToValue(X));
    lblValorX->Caption = FormatDateTime("dd/mm/yyyy hh:mm", dt->DateTimeString()); // ->DateTimeString();
    TTPSBPtr t_sb      = GetSBByY(RoundTo(FSerieSBs_->YScreenToValue(Y), -3));
    if (!t_sb.isNull())
      lblValorY->Caption = t_sb->NomeVia;
    else
      lblValorY->Caption = "Fora do Painel";
    delete dt;
    dt = NULL;
  }
  // else
  // FArrastoSeries_->RefreshSeries();

  if (tDifArrastX != 0 || tDifArrastY != 0)
  {
    SincyCharts();
}

  // chrTTP->AutoRepaint = !Shift.Contains(ssRight);
  // else


}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::PlotarLinhaTempo()
{
  TDate dataMP    = System::Dateutils::DateOf(TP_->Data);
  TTime zeroHoras = System::Dateutils::TimeOf(-1);
  // Zero horas do dia atual
  double X
                                          = dataMP + zeroHoras;
  TTPLinhaTempoSeries* t_serieLinhaTempoZeroHorasAtual = new TTPLinhaTempoSeries(chrTTP, X, FCountSeriesSBsPainel_* 2,
    dataMP + zeroHoras);
  chrTTP->AddSeries(t_serieLinhaTempoZeroHorasAtual);

  // Zero horas do dia posterior
  X = (dataMP + 1) + zeroHoras;
  TTPLinhaTempoSeries* t_serieLinhaTempoZeroHorasPosterior = new TTPLinhaTempoSeries(chrTTP, X, FCountSeriesSBsPainel_ * 2,
    dataMP + zeroHoras);
  chrTTP->AddSeries(t_serieLinhaTempoZeroHorasPosterior);

  TDateTime dataHoraSistema = TTPFormsManager::getInstance()->Data;
  TP_->Hora                 = System::Dateutils::TimeOf(dataHoraSistema);
  if (dataHoraSistema > dataMP - 1 && dataHoraSistema < dataMP + 2)
  {
    // Data/Hora Atual
    X = System::Dateutils::DateOf(dataHoraSistema) + System::Dateutils::TimeOf(dataHoraSistema);
    TTPLinhaTempoSeries* t_serieLinhaTempo = new TTPLinhaTempoSeries(chrTTP, X, FRamal_->ComprimentoTotal,
      dataHoraSistema, tltHoraAtual);
    chrTTP->AddSeries(t_serieLinhaTempo);

    FLinhaTempoSerie_ = t_serieLinhaTempo;
  }

  // Criando a srie do congelamento do tempo
  if (serieLinhaTempoCongelar_ == NULL)
  {
    serieLinhaTempoCongelar_ = new TTPLinhaTempoSeries(chrTTP, X, FRamal_->ComprimentoTotal, dataHoraSistema,
      tltHoraAtual, true);
    chrTTP->AddSeries(serieLinhaTempoCongelar_);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::AtualizarLinhaCongelamento()
{
  // Criando a srie do congelamento do tempo
  TDateTime t_dataHoraCongelamento = TTPFormsManager::getInstance()->Data;
  if (TTPFormsManager::getInstance()->IsDataProgramacaoCongelada)
  {
    t_dataHoraCongelamento  = TTPFormsManager::getInstance()->DataProgramacaoCongelada;
    FCongelandoProgramacao_ = true;
  }
  else
  {
    FCongelandoProgramacao_ = false;
  }
  // double teste = t_dataHoraCongelamento
  if (serieLinhaTempoCongelar_ != NULL && FCongelandoProgramacao_)
  {
    serieLinhaTempoCongelar_->Arrastar(t_dataHoraCongelamento, true);
    serieLinhaTempoCongelar_->Arrastou   = false;
    serieLinhaTempoCongelar_->Arrastando = false;
  }
}

// ---------------------------------------------------------------------------
TDateTime __fastcall TFormTP::GetDataHoraSistema()
{
  return TDAO::getCurrentDate();
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::chrTTPGetAxisLabel(TChartAxis *Sender, TChartSeries *Series, int ValueIndex, String &LabelText)
{
  // if (!FVisaoPlajemanto_)
  {
    if (Sender == chrTTP->LeftAxis ||Sender == chrTTPLeft->LeftAxis)
    {
      if (!LabelText.Pos(".") > 0 && FSerieSBs_->TipoLegenda != 2)
        LabelText = "";
    }
    else if (Sender == chrTTP->RightAxis  ||Sender == chrTTPRight->RightAxis)
    {
      if (LabelText.Pos(".") > 0)
        LabelText = "";
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::VoltarScroll()
{
  if (PosicaoAnteriorScroll == 1)
  {
  }
  else if (PosicaoAnteriorScroll == 2)
  {
    chrTTP->BottomAxis->Scroll(-0.9999, false);
  }
  else
    chrTTP->BottomAxis->Scroll(0.9999, false);

  PosicaoAnteriorScroll = 1;
  scbRodape->Position   = (FVisaoPlajemanto_ ? 0 : 24);
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::PlotarTrens()
{
  chrTTP->AutoRepaint = false;
  TTPFormsManager::getInstance()->LimparIndicadoresAderenciaFila();
  TTPFormsManager::getInstance()->ValidarOrdemEntregaTrensFila();
  for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
  {
    TTPTremPtr t_Trem = TTPFormsManager::getInstance()->Trens->get(i);
    if (!t_Trem.isNull())
      TTPFormsManager::getInstance()->PlotarTrem(&*t_Trem);
    else
      int parar = 0;
  }

  TTPFormsManager::getInstance()->ReordenarSeriesObservacao();

  acFiltrarTrens->Execute();
  chrTTP->AutoRepaint = true;
  chrTTP->Repaint();

  pnlGraficoResize(this);
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::chrTTPMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
  FMouseX_ = X;
  if(FSelecionarTremRemoverRestricao)
  {
    FSelecionouSerieRemoverRestricao_ = false;
  }

  //tmrMouseMovePrefixo->Enabled = false;
  chrTTP->AllowZoom            = false;
  bool semSelecionarAtivo = false;
  if(!acSelecionarRestricao->Checked && !acSelecionar->Checked
  && !acCriarTrem->Checked && !acRestringir->Checked && !acInterditar->Checked )
  {
    semSelecionarAtivo = true;

    TObject* serieHintAtual = TTPFormsManager::getInstance()->Hint->SerieAtual;
    if(serieHintAtual)
    {
     //se a srie que esta no top do hint atual no tiver o mesmo chart
     //que a nova serie do hint, limpa a lista com as series
     acSelecionar->Checked = true;
     if(((TTPRestricaoSeries*)serieHintAtual)->ParentChart==chrTTP)
     {
        if(serieHintAtual->ClassName()=="TTPMovimentoSeries" )
          acSelecionar->Checked = true;
        else
          acSelecionarRestricao->Checked = true;
     }
    }

  }

  FHabilitarPopup = false;
  FPopupContexto_ = pmnGeral;

  if (acSelecionarRestricao->Checked && Shift.Contains(ssShift) && Shift.Contains(ssLeft))
  {
    FSelecionandoRestArrastoShift_ = true;
    ShapeSelecao->Visible          = true;
  }

  if (acRestringir->Checked || acInterditar->Checked || FSelecionandoRestArrastoShift_)
  {
    FMarcarRestricao_ = !FSelecionandoRestArrastoShift_;

    double coordY = FSerieSBs_->YScreenToValue(Y);
    coordY        = RoundTo(coordY, -3);
    double tY     = FSerieSBs_->CalcYPosValue(coordY);

    FCoordenadasSelecao_.Left   = X;
    FCoordenadasSelecao_.Top    = tY;
    FCoordenadasSelecao_.Right  = X;
    FCoordenadasSelecao_.Bottom = tY;

    ShapeSelecao->Visible = true;
    ShapeSelecao->Width   = 1;
    ShapeSelecao->Height  = 1;
    ShapeSelecao->Top     = tY;
    ShapeSelecao->Left    = X;
  }
  // se  para criar trem
  else if (acCriarTrem->Checked)
  {
    // Se o boto esquerdo do mouse NO estiver pressionado OU...
    // ...estiver pressionado, mas outros botes tambm estiverem (Direito ou Middle), cancela ao.
    if (!Shift.Contains(ssLeft) || (Shift.Contains(ssLeft) && (Shift.Contains(ssRight) || Shift.Contains(ssMiddle))))
    {
	  acCancelarTremArrasto->Execute();
      return;
    }

    // Seta flag, vamos criar um trem!!!
    FCriandoTremArrasto_ = true;

    // Pegando o ptio
    double coordY = FSerieSBs_->YScreenToValue(Y);
    coordY        = RoundTo(coordY, -3);
    double tY     = FSerieSBs_->CalcYPosValue(coordY);

    // Pegando a hora
    double tX = FSerieSBs_->XScreenToValue(X);

    // Criando uma nova Srie
    FTremSelecionadoSerie_ = new TTPCriaTremSeries(chrTTP, tX, coordY);
    FTremSelecionadoSerie_->setDataHoraIncio(tX);
    FTremSelecionadoSerie_->setLocalizacaoInicio(coordY);
    chrTTP->AddSeries(FTremSelecionadoSerie_);

  }
  if (acRealizarZoom->Checked)
  {
    RealizarZoomRapido(X, Y);
    // acSelecionar->Checked = true;
  }
  // Se est para Selecionar
  else
  {
    // Se est com o boto direito pressionado e o grfico no est com zoom
    if (Shift.Contains(ssRight) && !FISZoomed_)
    {
      FPontoInicioPanning_ = TPoint(X, Y);
      FPanning_            = true;
      FFezPanning_         = false;
      FTotalPanning_       = 0;

      if(chrTTP->SeriesCount()>0)
      {
        chrTTP->Series[0]->Visible = false;
        chrTTP->AutoRepaint = true;
        chrTTP->Series[0]->Visible = true;
      }


      return;
    }
    else if (Shift.Contains(ssRight))
    {
      FPontoInicioPanning_ = TPoint(X, Y);
      FTotalPanning_       = 0;
      FFezPanning_         = false;

      return;
    }

    TChartSeries* t_clickedSerie = NULL;
    // Verifica se Alguma Serie ou Mark foi clicada
    if(Shift.Contains(ssLeft))
    {
      if (!FMarcarRestricao_ && !FCriandoTremArrasto_ && !FSelecionandoRestArrastoShift_)
      {
        chrTTP->AllowZoom = true;
      }
    }
  }
  FHabilitarPopup = FSerieMovimentoSelecionada_ != NULL || FSerieRestricaoSelecionada_ != NULL;
  acTrazerPraFrenteExecute(this);
  if (serieLinhaTempoCongelar_ != NULL && serieLinhaTempoCongelar_->Arrastando)
    FCongelandoProgramacao_ = true;

  acSelecionarRestricao->Checked = false;
  acSelecionar->Checked = false;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
  try
  {
    chrTTP->AutoRepaint = true;
    FMouseXScroll_ = -1;
    FMouseYScroll_ = -1;
	// se um trem foi selecionado ele pode ter seu movimento alterado
	// ou descelecionado dependendo do boto do mouse usado
	if (FTremSelecionado_ && FMoverTremSelecionadoClickAtivo_)
	{
	  if (Button == mbLeft)
      {
        if (FSerieMovimentoSelecionada_)
        {
          if (!FSerieMovimentoSelecionada_->Movimento->IsRealizado)
          {
			FTipoArrasto_ = taSaida;
            Arrastar(X, Y);
          }
          else
          {
            return;
          }
        }
      }
      if (Button == mbMiddle || !FSerieMovimentoSelecionada_)
      {
        if (FSerieMovimentoSelecionada_)
          FSerieMovimentoSelecionada_->SetTremSelecionado(false);

		FTremSelecionado_ = NULL;
      }
    }
	// Inicializa componentes e variveis para tratamento do arrasto
    if ((FTipoArrasto_ != taSemArrasto) && FArrastou_)
	{
      FTipoArrastoRealizado_ = FTipoArrasto_;

      if (FTipoArrasto_ == taChegada || FTipoArrasto_ == taSaida || FTipoArrasto_ == taFimCurso)
	  {
        bool parar = true;
        // Controla se vai propagar a alterao do movimento

        // Pegando o incio do movimento anterior, levando em considerao que caso existe uma parada, o incio  da srie anteior
        // Se no existir parada, so duas sries para trs...

		double inicioMovimentoAnterior = 0;
		if (FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior != NULL &&
		  FArrastoSeries_->SerieMovimento->IsPlotada)
        {
		  if (FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->DataChegada
            != FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->DataSaida)
          {
            inicioMovimentoAnterior = FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->DataChegada;
          }
		  else if (FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->MovimentoAnterior!= NULL)
          {
            inicioMovimentoAnterior =
              FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->MovimentoAnterior->DataChegada;
          }
        }
        TTPTrem* tTrem = FArrastoSeries_->SerieMovimento->Trem;
        getTremFilho(tTrem);

        AtualizarSaidaTremArrastoMouse(parar, false); // Shift.Contains(ssShift)

        TTPFormsManager::getInstance()->PlotarTrem(FArrastoSeries_->SerieMovimento->Trem, false, false, true, !FTremFilho_);
        if(!PlotarTremFilho(tTrem) && FTremFilho_)
          TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

        acVerificarConflitosExecute(this);
      }
      if (FSerieMovimentoSelecionada_ != NULL)
      {
        FSerieMovimentoSelecionada_->Movimento->MovimentoSelecionado = false;
        FSerieMovimentoSelecionada_                       = NULL;
      }
    }
    // Tratamento de itens relacionados a registro de restrio/interdio
    else if (FMarcarRestricao_)
    {
      GerenciarRestricoes(X, Y);
    }
    else if (FSelecionandoRestArrastoShift_ && ShapeSelecao->Width > 1)
    {
      SelecionarRestricoes(X, Y);
    }
    else if (FSelecionandoRestArrastoShift_ && ShapeSelecao->Width <= 1)
    {
      FSelecionandoRestArrastoShift_ = false;
    }

    else if (FCriandoTremArrasto_)
    {
      try
      {
        if (FTremSelecionadoSerie_->GetArrastou())
        {
          // chama a tela com os parmetros preenchidos
          double coordY = FSerieSBs_->YScreenToValue(Y);
          coordY        = RoundTo(coordY, -3);
          double tY     = FSerieSBs_->CalcYPosValue(coordY);
          FTremSelecionadoSerie_->setLocalizacaoFim(coordY);
          GerenciarCriacaoTremArrasto(X, Y);
          // acPlotarAtualizar->Execute();
        }
      }
      __finally
      {
		acCancelarTremArrasto->Execute();
      }
    }
    else if (FSerieRestricaoSelecionada_ != NULL && (FSerieRestricaoSelecionada_->Arrastando &&
      (FTipoArrasto_ == taRestricaoInicio || FTipoArrasto_ == taRestricaoFim) || FSerieRestricaoSelecionada_->Movendo))
    {
      AtualizarRestricoesServer(NULL,true);
    }

    if (serieLinhaTempoCongelar_ != NULL && FCongelandoProgramacao_)
    {
      if (serieLinhaTempoCongelar_->Arrastou)
      {
        FCongelandoProgramacao_            = false;
        serieLinhaTempoCongelar_->Arrastou = false;
      }
      serieLinhaTempoCongelar_->Arrastando = false;
    }

    if (serieLinhaTempoAparagarParadas_ != NULL)
    {
      if (serieLinhaTempoAparagarParadas_->Arrastou)
      {
        // FCongelandoProgramacao_              = false;
        serieLinhaTempoAparagarParadas_->Arrastou = false;
        TTPFormsManager::getInstance()->DataZerarParadasTrem = serieLinhaTempoAparagarParadas_->DataCongelada;
      }
      serieLinhaTempoAparagarParadas_->Arrastando = false;
    }

    FPanning_ = false;
    FArrastou_                      = false;
    FTipoArrasto_                   = taSemArrasto;
    FArrastoSeries_->SerieMovimento = NULL;
    FArrastoSeries_->Visible        = false;

    if (Button == mbRight && FISZoomed_)
    {
	  acAjustarPrefixos->Execute();
    }

    if (FSerieMovimentoSelecionada_ != NULL)
    {
      FSerieMovimentoSelecionada_->Arrastando = false;
    }

    if (FTremSelecionado_)
    {
      // aps edio do movimento via click
      // achar o primeiro movimento plotado para
      // re-selecionar o trem
      TTPMovimentoSeries* tMovimento = FTremSelecionado_->ItinerarioTrem->Movimentos->operator[](0)->Serie;

     // while (!tMovimento->IsPlotada)
     //		tMovimento = tMovimento->SerieMovimentoPosterior;
      tMovimento->SetTremSelecionado(true);

      FTremSelecionado_ = NULL;
    }

    if(!FSelecionouSerieRemoverRestricao_ && FSelecionarTremRemoverRestricao)
    {
      FSelecionarTremRemoverRestricao = false;
    }
  }
  catch (Exception& e)
  {
	Alerta(e.Message);
    FExecutouResetPosicao_ = false;
    FTremSelecionado_ = NULL;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPDblClick(TObject *Sender)
{
  acAjustarRestricaoAoTrem->Checked = false;
  acAjustarRestricaoAoTremDinamico->Checked = false;
  TTPFormsManager::getInstance()->RetirarSelecao();

  FHabilitarPopup = false;

  if (TTPFormsManager::getInstance()->Trens != NULL)
  {
    for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
    {
      TTPTremPtr t_Trem = TTPFormsManager::getInstance()->Trens->operator[](i);
      if (t_Trem->IsSelecionado)
      {
        for(int j = 0; j<t_Trem->ItinerarioTrem->Movimentos->count(); j++)
        {
          if(t_Trem->ItinerarioTrem->Movimentos->operator[](j)->Serie)
          {
            t_Trem->ItinerarioTrem->Movimentos->operator[](j)->Serie->SetTremSelecionado(false);
            break;
          }
        }
        lblStatus->Tag = 0;
      }
    }
  }
}

// ---------------------------------------------------------------------------
void TFormTP::ClickMPSeries(TChartSeries* serie, TShiftState Shift, int X, int Y)
{
  // se no extiver no modo de edio por click do trem
  if (FTremSelecionado_ != NULL)
    return;

  FTipoArrasto_ = taSemArrasto;
  if (acSelecionarRestricao->Checked)
  {
    if (!acAjustarRestricaoAoTrem->Checked)
    {
      bool tMaterSelecao = Shift.Contains(ssRight) || Shift.Contains(ssShift);
      TTPFormsManager::getInstance()->RetirarSelecao(tMaterSelecao);
    }
    else
    {
      TTPFormsManager::getInstance()->RetirarSelecao();
    }
  }
  else
  {
    TTPFormsManager::getInstance()->RetirarSelecao(Shift.Contains(ssShift));
  }

  TTPTipoSerie t_tipoSerie = GetTipoSerieMP(serie);

  if(t_tipoSerie == tsDesconhecido && TTPFormsManager::getInstance()->MovimentosSerieMouseOver!=NULL)
  {
    serie = (TChartSeries*)TTPFormsManager::getInstance()->MovimentosSerieMouseOver;
    t_tipoSerie = GetTipoSerieMP(serie);
  }

  switch (t_tipoSerie)
  {
  case tsMovimento:
  case tsPointer:
    {
      //if (acSelecionar->Checked && ((TTPMovimentoSeries*)serie)->Trem->TipoTrem->Nome != "C")
      {
        // Incio teste multi-seleo
        {
          if (Shift.Contains(ssShift) && FSerieMovimentoSelecionada_ != NULL && FMovimentoSelecionado_->Trem ==
            ((TTPMovimentoSeries*)serie)->Trem && FMovimentoSelecionado_->Sequencial <
            ((TTPMovimentoSeries*)serie)->Movimento->Sequencial)
          {

            while (true)
            {
              if (((TTPMovimentoSeries*)serie)->Movimento == ((TTPMovimentoSeries*)serie)->SerieMovimentoSelecionado->Movimento)
              {
                break;
              }
              ((TTPMovimentoSeries*)serie)->addMovimentoSelecionado(
              ((TTPMovimentoSeries*)serie)->SerieMovimentoSelecionado->Movimento->MovimentoPosterior);

//							FSerieMovimentoSelecionada_->Movimento = FSerieMovimentoSelecionada_->Movimento->MovimentoPosterior;
//							if (FMovimentoSelecionado_)
//							{
//								FMovimentoSelecionado_->Serie->SerieMovimentoSelecionado->Movimento->MovimentoSelecionado = true;
//							}
//            }
            }
          }
          else
          {
            TTPFormsManager::getInstance()->RetirarSelecao();
          }
        }
        // Recupera srie selecionada
        if(t_tipoSerie == tsPointer)
          FMovimentoSelecionado_ = ((TTPPointerSeries*)serie)->serieMovimento->Movimento;
        else
          FMovimentoSelecionado_ = ((TTPMovimentoSeries*)serie)->Movimento;
        FTipoSelecaoAtual_ = tselMovimento;
        // Marca srie selecionada
        FMovimentoSelecionado_->MovimentoSelecionado = true;

        FSerieMovimentoSelecionada_ = FMovimentoSelecionado_->Serie;
        MontarPopupTrem();
        FSerieMovimentoSelecionada_->SetMovimentoSelecionado(true);

        // Guarda informaes do movimento para selecionar novamente aps refresh
        FSequenciaSBOrigemMovimentoSelecionado_  = FSerieMovimentoSelecionada_->Movimento->SB->SeqSB;
        FSequenciaSBDestinoMovimentoSelecionado_ = FSerieMovimentoSelecionada_->Movimento->SB->SeqSB;
        FPIDObjetoSelecionado_                   = FSerieMovimentoSelecionada_->Trem->PID;

        FPopupContexto_ = pmnTrem;

        if (Shift.Contains(ssLeft))
        {
          // Verificao do Arrasto
          FTipoArrasto_ = VerificarSerieParaArrasto(FSerieMovimentoSelecionada_, X, Y, Shift);
          FArrastou_    = false;
          if (FTipoArrasto_ != taSemArrasto)
          {
            FSerieMovimentoSelecionada_->TipoArrasto = FTipoArrasto_;
            FSerieMovimentoSelecionada_->Arrastando  = true;
          }
          chrTTP->Refresh();
        }
      }
      /*else*/ if (acAjustarRestricaoAoTrem->Checked == true)
      {
        if(!FSerieMovimentoSelecionada_)
        {
          FSerieMovimentoSelecionada_ = (TTPMovimentoSeries*)serie;
        }
        if(FSerieMovimentoSelecionada_->Movimento->IsRealizado)
        {
          TTPFormsManager::getInstance()->RetirarSelecao();
          throw Exception("No  possvel ajustar a restrio  um movimento realizado");
        }
        AplicarAjusteRestricaoAoTrem(FSerieMovimentoSelecionada_->Trem, Shift.Contains(ssCtrl), acAjustarRestricaoAoTremDinamico->Checked);
      }
      break;
    case tsRestricao:
      {
        if (acSelecionarRestricao->Checked && !acAjustarRestricaoAoTrem->Checked)
        {
          // Recupera srie selecionada
          FSerieRestricaoSelecionada_              = ((TTPRestricaoSeries*)serie);
          FSerieRestricaoSelecionada_->Selecionado = true;
          FHabilitarPopup                          = true;
          FSelecionandoRestArrastoShift_           = false;
          FPopupContexto_                          = pmnRestricoes;

          if (FSeriesRestSelecionadas_->IndexOf(FSerieRestricaoSelecionada_->Restricao->PID) == -1)
            FSeriesRestSelecionadas_->AddObject(FSerieRestricaoSelecionada_->Restricao->PID,
            (TObject*)FSerieRestricaoSelecionada_);

          FTipoSelecaoAtual_     = tselRestricao;
          FPIDObjetoSelecionado_ = FSerieRestricaoSelecionada_->Restricao->PID;
          if (FSerieRestricaoSelecionada_->ResizeDireito || FSerieRestricaoSelecionada_->ResizeEsquerdo ||
            FSerieRestricaoSelecionada_->Mover)
            FTipoArrasto_ = taRestricaoFim;
          chrTTP->Refresh();
        }
        if (acAjustarRestricaoAoTrem->Checked)
        {
          acAjustarRestricaoAoTrem->Checked = false;
          TTPFormsManager::getInstance()->RetirarSelecao();
        }
        break;
      }
      default:
      {
        if (acAjustarRestricaoAoTrem->Checked == true)
        {
          acAjustarRestricaoAoTrem->Checked = false;
          TTPFormsManager::getInstance()->RetirarSelecao();
        }
        FPopupContexto_ = pmnGeral;
      }
    }
  }
}

// ---------------------------------------------------------------------------
TTPTipoSerie TFormTP::GetTipoSerieMP(TChartSeries* serie)
{
// try
// {
  if (serie==NULL )
     return tsDesconhecido;
  if(chrTTP->SeriesList->IndexOf(serie) <0)
    {
      return tsDesconhecido;
    }

    return (TTPTipoSerie)serie->Tag;
// }
// catch(...)
// {
//   return tsDesconhecido;
// }
    }

// ---------------------------------------------------------------------------
TTPTipoArrasto TFormTP::VerificarSerieParaArrasto(TTPMovimentoSeries* serieMovimento, int posicaoXClick,
 int posicaoYClick, TShiftState Shift)
{
  serieMovimento->ConfigurarSerieArrasto();
  int diffChegada  = FSerieSBs_->CalcXPosValue(serieMovimento->Movimento->DataChegada) - posicaoXClick;
  int diffFimCurso = FSerieSBs_->CalcXPosValue(serieMovimento->Movimento->DataFimCurso) - posicaoXClick;
  int diffSaida = FSerieSBs_->CalcXPosValue(serieMovimento->Movimento->DataSaida) - posicaoXClick;

  int diffChegadaY  = abs(FSerieSBs_->CalcYPosValue(serieMovimento->YValue[serieMovimento->GetIndexSerieFromMovimento()]) - posicaoYClick);
  int diffFimCursoY = abs(FSerieSBs_->CalcYPosValue(serieMovimento->YValue[serieMovimento->GetIndexSerieFromMovimento()+1]) - posicaoYClick);
  int diffSaidaY = abs(FSerieSBs_->CalcYPosValue(serieMovimento->YValue[serieMovimento->GetIndexSerieFromMovimento()+2]) - posicaoYClick);

  diffChegada  = (diffChegada < 0 ? diffChegada*-1 : diffChegada);
  diffFimCurso = (diffFimCurso < 0 ? diffFimCurso*-1 : diffFimCurso);
  diffSaida    = (diffSaida < 0 ? diffSaida*-1 : diffSaida);

  bool controlPressionado = Shift.Contains(ssCtrl);
  bool altPressionado     = Shift.Contains(ssAlt);
  bool clicouChegada      = diffChegada < 5 && (diffChegadaY<=diffFimCursoY && diffFimCursoY<=diffSaidaY);
  bool clicouFimCurso     = diffFimCurso < 5 && (diffFimCursoY<=diffChegadaY && diffFimCursoY<=diffSaidaY);
  bool clicouSaida        = diffSaida < 5 && (diffSaidaY<=diffChegadaY && diffSaidaY<=diffFimCursoY);

  if (clicouChegada && clicouSaida)
  {
    //if (serieMovimento->SerieMovimentoAnterior)
    if (serieMovimento->Movimento->MovimentoAnterior)
      if (!serieMovimento->Movimento->MovimentoAnterior->IsRealizado)
        {
          clicouChegada = false;
        }
  }
  // Se qualquer um dos itens tm permisso no ISA (arrasto previsto ou realizado)
  // -> Fabiano - if(!serieTrecho->Trem->isFinalizado && ((acConfirmarArrastoPrevisao->Enabled || acConfirmarArrastoRealizado->Enabled) || (acAlterarItinerario->Enabled && altPressionado)))
  {
    TTPMovimento* t_movimentoSelecionado = serieMovimento->Movimento;
    // t_movimentoSelecionado = ;

    if (!t_movimentoSelecionado->IsRealizado && serieMovimento->Trem->TipoTrem->Nome != "C")
      // Se  um trecho previsto
    {
      TTPSBPtr t_SB = t_movimentoSelecionado->SB;
      // Se  o primeiro ptio e no teve data de sada registrada ou...
      // no  o ltimo ptio e chegou mas no saiu do ptio
      // ento, pode arrastar a saida...
      // bool pontosSobrepostos = (t_patioItinerario->DataPrevisaoChegada == t_patioItinerario->DataPrevisaoSaida) && (t_patioItinerario->HoraPrevisaoChegada == t_patioItinerario->HoraPrevisaoSaida)
      bool chegadaPrevista = true;
      // ( !t_movimentoSelecionado->ChegadaRealizada && !t_SB->IsPrimeiroPatio );
      bool saidaPrevista = true; // ( !t_movimentoSelecionado->SaidaRealizada   && !t_SB->IsUltimoPatio   );

      if (altPressionado)
      {
        if (chegadaPrevista)
        {
          if (controlPressionado)
            return taItinerarioSaida;
          else
            return taItinerarioChegada;
        }
        else
        {
          return taItinerarioSaida;
        }
      }
      else
      {
        if (clicouFimCurso && !clicouSaida)
          return taFimCurso;

        if (clicouChegada && clicouSaida)
        {
          if (controlPressionado && saidaPrevista)
          {
            return taSaida;
          }
          else
          {
            if (chegadaPrevista)
            {
              return taChegada;
            }
      else if (saidaPrevista)
            {
              return taSaida;
            }
          }
        }
        else
        {
          if (clicouChegada && chegadaPrevista)
          {
            return taChegada;
          }
          else if (clicouSaida && saidaPrevista)
          {
            return taSaida;
          }
        }
      }
    }
  } return taSemArrasto;
}

// ---------------------------------------------------------------------------
void TFormTP::Arrastar(double X, int Y, double XLimit)
{
  FArrastou_ = true;
  chrTTP->AutoRepaint = true;
  TTPFormsManager::getInstance()->MovimentosSerieMouseOver = NULL;

  // lblHintSerie->Hide();
  // shpHintSerie->Hide();

 // pnlHintPrefixo->Hide();
  TTPMovimentoSeries* tMovimentoSelecionado = FSerieMovimentoSelecionada_;
  // verificaes para limpeza da fila caso esteja ativada
  FSerieMovimentoSelecionada_ = tMovimentoSelecionado;
  double t_horaX              = FSerieSBs_->XScreenToValue(X);
  // Substituir pelas propriedades FirstValueIndex e LastValueIndex
  double XAnteriorOrigem       = FSerieMovimentoSelecionada_->Movimento->DataChegada;
  double XAnteriorDestino      = FSerieMovimentoSelecionada_->Movimento->DataSaida;
  double diferencaEntrePontosX = XAnteriorDestino - XAnteriorOrigem;

  FAlteraPrevisaoSaida_ =
    FSerieMovimentoSelecionada_ != NULL && FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior == NULL;

  if (FTipoArrasto_ == taChegada || FTipoArrasto_ == taItinerarioChegada)
  {
    bool alterandoItinerario = (FTipoArrasto_ == taItinerarioChegada); // Se true, arrasta verticamente
    double novoY             = RoundTo(FSerieMovimentoSelecionada_->YScreenToValue(Y), -3);
    double novoXOrigem       = FSerieMovimentoSelecionada_->XScreenToValue(X);
    double novoXDestino      = novoXOrigem + diferencaEntrePontosX;
    double limiteMinimoEixoX =
      FSerieMovimentoSelecionada_ != NULL && FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior != NULL ?
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataChegada : TP_->Data + TP_->Hora;
    if (FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior  != NULL &&
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataChegada !=
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataSaida)
    {
      TDateTime dataParada = FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataParadaAtividade;
      if (dataParada > FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataChegada)
        limiteMinimoEixoX = dataParada;
      else
        limiteMinimoEixoX = FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataChegada;
    }
    else if (FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior != NULL &&
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataChegada ==
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->DataSaida &&
      FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->MovimentoAnterior != NULL)
    {
      // limiteMinimoEixoX   = FSerieMovimentoSelecionada_->MovimentoAnterior->MovimentoAnterior->Movimento->DataChegada;
      limiteMinimoEixoX = FSerieMovimentoSelecionada_->Movimento->DataChegada;
    }

    // Corrige para o limite
    if (novoXOrigem < limiteMinimoEixoX)
    {
      novoXOrigem = limiteMinimoEixoX;
    }

    FArrastoSeries_->XValue[0] = novoXOrigem;

    bool alteraSB = (FTipoArrasto_ == taItinerarioChegada || FTipoArrasto_ == taItinerarioSaida);
    if (alteraSB || FArrastoSeries_->Visible == false)
      FArrastoSeries_->YValue[0] = novoY;
    FArrastoSeries_->SerieMovimento = FSerieMovimentoSelecionada_;
    FArrastoSeries_->Visible        = true;
  }
  else if (FTipoArrasto_ == taSaida || FTipoArrasto_ == taItinerarioSaida || FTipoArrasto_ == taFimCurso)
  {
    bool alterandoItinerario = (FTipoArrasto_ == taItinerarioSaida); // Se true, arrasta verticamente
    double novoY             = RoundTo(FSerieMovimentoSelecionada_->YScreenToValue(Y), -3);
    double novoXDestino      = FSerieMovimentoSelecionada_->XScreenToValue(X);
    // Desloca Destino do trecho anterior...
    //TTPMovimentoSeries* t_movimentoPosterior = FSerieMovimentoSelecionada_->SerieMovimentoPosterior(NULL);
    TTPSBPtr t_patioArrasto                  = FSerieMovimentoSelecionada_->Movimento->SB;
    double limiteMinimoEixoX                 = FSerieMovimentoSelecionada_->Movimento->DataChegada;

    if (FSerieMovimentoSelecionada_->Movimento->DataChegada != FSerieMovimentoSelecionada_->Movimento->DataSaida)
    {
      TDateTime dataParada = FSerieMovimentoSelecionada_->Movimento->DataParadaAtividade;
      if (dataParada > FSerieMovimentoSelecionada_->Movimento->DataChegada)
        limiteMinimoEixoX = dataParada;
      else
        limiteMinimoEixoX = FSerieMovimentoSelecionada_->Movimento->DataChegada;
    }

    // Corrige para o limite
    if (novoXDestino < limiteMinimoEixoX)
    {
      novoXDestino = limiteMinimoEixoX;
    }
    FDataHoraArrasto_ = novoXDestino;

    FArrastoSeries_->XValue[0] = novoXDestino;
    bool alteraSB              = (FTipoArrasto_ == taItinerarioChegada || FTipoArrasto_ == taItinerarioSaida);
    if (alteraSB || FArrastoSeries_->Visible == false)
	  FArrastoSeries_->YValue[0] = novoY;

    FArrastoSeries_->SerieMovimento = FSerieMovimentoSelecionada_;
    FArrastoSeries_->Visible        = true;

  }
  // TTPFormsManager::getInstance()->SincronzaTremClientServer(FSerieMovimentoSelecionada_->Trem);
  // FSerieMovimentoSelecionada_->MarcarFimTrem();

}

// ---------------------------------------------------------------------------
void TFormTP::ArrastarRestricao(double X, int Y)
{
  if (FSerieRestricaoSelecionada_->Mover) // Movendo interdio inteira
  {
    FSerieRestricaoSelecionada_->Arrastando = false;
    FSerieRestricaoSelecionada_->Movendo    = true;

    double XValue       = FSerieRestricaoSelecionada_->XScreenToValue(X);
    double posicaoOld   = FSerieRestricaoSelecionada_->Posicao;
    double tNewPosition = XValue + (FSerieRestricaoSelecionada_->XDefs[0] - FSerieRestricaoSelecionada_->XDefs[1] -
      ((FSerieRestricaoSelecionada_->XDefs[0] - FSerieRestricaoSelecionada_->XDefs[1]) / 2));
    if (tNewPosition >= chrTTP->BottomAxis->Minimum && tNewPosition <= chrTTP->BottomAxis->Maximum)
    {
      FSerieRestricaoSelecionada_->Posicao = tNewPosition;
    }
    double diferenca = FSerieRestricaoSelecionada_->Posicao - posicaoOld;

    FSerieRestricaoSelecionada_->DrawValue(0);

    for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
    {
      TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
      if (restSel != FSerieRestricaoSelecionada_ && !restSel->Restricao->ISIniciada()
        && !restSel->Restricao->ISEncerrada() && restSel->Restricao->Trem == NULL)
      {
        restSel->Arrastando = false;
        restSel->Movendo    = true;
        restSel->SincronizarFlags(FSerieRestricaoSelecionada_);
        tNewPosition = restSel->Posicao + diferenca;
        if (tNewPosition >= chrTTP->BottomAxis->Minimum && tNewPosition <= chrTTP->BottomAxis->Maximum)
        {
          restSel->Posicao += diferenca;
          restSel->DrawValue(0);
        }
      }
    }
  }
  else // Resize esquerdo ou direito
  {
    FSerieRestricaoSelecionada_->Arrastando = true;
    FSerieRestricaoSelecionada_->Movendo    = false;
    double larguraOld                       = FSerieRestricaoSelecionada_->Largura;

    if (FSerieRestricaoSelecionada_->ResizeDireito)
    {
      double XValue                        = FSerieRestricaoSelecionada_->XScreenToValue(X);
      if(FSerieRestricaoSelecionada_->Restricao->Trem != NULL
          && FSerieRestricaoSelecionada_->Restricao->DataMaxFim > TDateTime(0) && FSerieRestricaoSelecionada_->Restricao->ISDataMaxFimAtiva)
      {
        double novoFim = FSerieRestricaoSelecionada_->XDefs[0] + (XValue - FSerieRestricaoSelecionada_->XDefs[0]);
        if(novoFim > FSerieRestricaoSelecionada_->Restricao->DataMaxFim)
          return;
      }

      FSerieRestricaoSelecionada_->Posicao = FSerieRestricaoSelecionada_->XDefs[0];
      FSerieRestricaoSelecionada_->Largura = XValue - FSerieRestricaoSelecionada_->XDefs[0];
      FSerieRestricaoSelecionada_->DrawValue(0);
      double diferenca = FSerieRestricaoSelecionada_->Largura - larguraOld;

      for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        double limiteArrasto = 0;
        if(restSel->Restricao->Trem != NULL && restSel->Restricao->ISDataMaxFimAtiva && restSel->Restricao->DataMaxFim > TDateTime(0))
        {
          limiteArrasto = restSel->Restricao->DataMaxFim;
        }

        if (restSel != FSerieRestricaoSelecionada_ && !restSel->Restricao->ISIniciada()
          && !restSel->Restricao->ISEncerrada() && (limiteArrasto == 0 || restSel->XDefs[0] + restSel->Largura + diferenca <= limiteArrasto))
        {
          restSel->Arrastando = true;
          restSel->Movendo    = false;
          restSel->SincronizarFlags(FSerieRestricaoSelecionada_);
          restSel->Posicao = restSel->XDefs[0];
          restSel->Largura += diferenca;
          restSel->DrawValue(0);
        }
      }
    }
    else if (FSerieRestricaoSelecionada_->ResizeEsquerdo)
    {
      double XValue                        = FSerieRestricaoSelecionada_->XScreenToValue(X);
      FSerieRestricaoSelecionada_->Posicao = XValue;
      FSerieRestricaoSelecionada_->Largura = (FSerieRestricaoSelecionada_->XDefs[1]) - XValue;
      FSerieRestricaoSelecionada_->DrawValue(0);
      double diferenca = FSerieRestricaoSelecionada_->Largura - larguraOld;

      for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        if (restSel != FSerieRestricaoSelecionada_ && !restSel->Restricao->ISIniciada()
          && !restSel->Restricao->ISEncerrada())
        {
          restSel->Arrastando = true;
          restSel->Movendo    = false;
          restSel->SincronizarFlags(FSerieRestricaoSelecionada_);
          restSel->Posicao -= diferenca;
          restSel->Largura += diferenca;
          restSel->DrawValue(0);
        }
      }
    }
  }
}
// ---------------------------------------------------------------------------
void __fastcall TFormTP::UpdateStatusProgramando(boost::shared_ptr<boost::thread>  th, bool updateProgress, int timeOutCancelamento, String msgComplementar)
{
  if (updateProgress)
  {
    utils::TULog::getInstance()->SaveLog("Carregando;" + TTPFormsManager::getInstance()->Mesa,utils::ltEnd);
    Sleep(1000);
    utils::TULog::getInstance()->SaveLog("Programando;"+TTPFormsManager::getInstance()->Mesa + " "+msgComplementar,utils::ltStart);
    Aguarde("Programando "+ msgComplementar, false, timeOutCancelamento);

    double lasVal=0;
    bool isCancel =false;
    AguardeSetProgress(0);
    while (!th->timed_join(boost::posix_time::milliseconds(10)))
    {
      Sleep(90);
      if (AguardeGetCancelUserRequest() )
      {
        if (!isCancel)
        {// server em processamento.
          algorithm::CoreTMPlanner::getInstance()->setCancelCalcularTrensMalha();
          isCancel = true;
        }
        Application->ProcessMessages();
      }
      else
      {
        double currVal = algorithm::CoreTMPlanner::getInstance()->getProgessoSolucionarConflito();

        if (std::abs(lasVal - currVal) > 0.1)
        {
          lasVal = currVal;
        }
        AguardeSetProgress(lasVal);
      }
    }
  }
  else
  {
    utils::TULog::getInstance()->SaveLog("Carregando;"+TTPFormsManager::getInstance()->Mesa,utils::ltEnd);
    Sleep(1000);
    utils::TULog::getInstance()->SaveLog("Programando;"+TTPFormsManager::getInstance()->Mesa,utils::ltStart);
    Aguarde("Programando");

  }
  AguardeSetProgress(0);
}
// ---------------------------------------------------------------------------
void __fastcall TFormTP::acCarregarExecute(TObject *Sender)
{
	if(FArrastoSeries_ && FArrastoSeries_->SerieMovimento)
	{
	  return;
	}
  if(FProgramando)
  {
   // Alerta("A funo de Carregar foi chamada multiplas vezes, favor aguarde alguns segundos antes do prximo acionamento");
    return;
  }
  else
  {
    FProgramando = true;
  }

  TCursor t_oldcursor = Screen->Cursor;
  bool lockMutex = false;

  try
  {
    try
    {
    TTPFormsManager::getInstance()->gravarLog("Optmove Client");
    TTPFormsManager::getInstance()->FecharFormsAbertos();
    TTPFormsManager::getInstance()->TrensOrdemAlterada->Clear();

    FIsCtrlA_ = true;

    int tIDRamalTravar = -1;
    String nomeRamalTravado = "";

    if(chkTravar->Checked)
    {
      tIDRamalTravar = FRamal_->Numero;
      nomeRamalTravado = FRamal_->Nome;
    }

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    core->isCarregarMovimentosOficializadosAutomatico = core->isCarregarMovimentosOficializadosAutomaticoSelecionado;

    Application->ProcessMessages();
    Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->gravarLog("Incio: MinimizeOtherCharts");
    TTPFormsManager::getInstance()->MinimizeOtherCharts(this);

    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Carregar Trens :Tente novamente em alguns segundos","Carregar Trens");

    lockMutex = true;

    TTPFormsManager::getInstance()->gravarLog("acCarregarExecute Mutex: lock");
    Application->ProcessMessages();

    TTPFormsManager::getInstance()->EnableDisableTeechart(false);
    Application->ProcessMessages();

    TTPFormsManager::getInstance()->AjustarEstadoControles(false);
    TTPGerenteProgramacao::getInstance()->checkProgramacaoEmCurso();
    FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

    //---------------------------------------------------------------
    String isSincronizarPlano = algorithm::CoreTMPlanner::getInstance()->getParamByName("CPTO_SNZC_PGMC_CTRL_A");
    bool isExibicaoProgresso = algorithm::CoreTMPlanner::getInstance()->getParamByName("EXIB_PRGR_PGMC", "SISTEMA") == "TRUE";
    int timeoutCancelamento = algorithm::CoreTMPlanner::getInstance()->getParamByName("TP_MIN_CANC_PGMC", "SISTEMA").ToIntDef(0);
    if (TTPFormsManager::getInstance()->getAmbienteDebug() ) isSincronizarPlano = "FALSE";
    if (isSincronizarPlano.UpperCase()=="TRUE")
    {
      try
      {
      TTheadResultado *tResult = new TTheadResultado();

      boost:: thread threadProc(&this->ThreadSincronizarProgramacao, tResult);
      Aguarde("Sincronizar Programao");
      threadProc.join();
      if (tResult->Status > 1)
      {
        TFormResultadoProcessos *fResultado = new TFormResultadoProcessos(this, tResult->ListaResultados);
        fResultado->ShowModal();
      }
      delete tResult;
      tResult = NULL;
      Screen->Cursor = crDefault;
      }
      catch (Exception &e)
      {
      Screen->Cursor = crDefault;
      Alerta(e.Message);
      FExecutouResetPosicao_ = false;
      }
      catch (...)
      {
      Screen->Cursor = crDefault;
      Alerta("Erro ao Sincronizar Programaao");
      }
    }
    //---------------------------------------------------------------
      #ifndef MODO_MULT_THREAD
        TTheadResultado *tResultIcones = new TTheadResultado();
        ThreadCarregarIconesAtividades(tResultIcones);
      #else
        TTheadResultado *tResultIcones = new TTheadResultado();
        boost:: thread threadCarregarIconesAtividades2(&this->ThreadCarregarIconesAtividades, tResultIcones);

      #endif

    TTPFormsManager::getInstance()->AntialiasONOFF(false);

    TTPFormsManager::getInstance()->LimparGraficos();

#ifndef MODO_MULT_THREAD
    utils::TULog::getInstance()->SaveLog("Carregando;"+TTPFormsManager::getInstance()->Mesa,utils::ltStart);
    Aguarde("Carregando Trens");
    TTheadResultado *tResult = new TTheadResultado();
    ThreadCarregarTrensMalha(tResult);
#else
    TTheadResultado *tResult = new TTheadResultado();
    boost:: thread threadProcessamentoCalc(&this->ThreadCarregarTrensMalha, tResult);
#endif
#ifdef MODO_MULT_THREAD
    utils::TULog::getInstance()->SaveLog("Carregando;"+TTPFormsManager::getInstance()->Mesa,utils::ltStart);
    Aguarde("Carregando Trens");
    threadProcessamentoCalc.join();
#endif

    if (tResult->Status == terSucesso)
    {
      if (tResultIcones->Status == terSucesso)
      {
      delete tResultIcones;
      Application->ProcessMessages();
    #ifndef MODO_MULT_THREAD
      Aguarde("Programando");
      tResult = new TTheadResultado();
      ThreadCalcularTrens(tResult);
    #else
      delete tResult;
      tResult = new TTheadResultado();
			  //boost:: thread threadProcessamentoCalc(&this->ThreadCalcularTrens, tResult, tIDRamalTravar);
      boost::shared_ptr<boost::thread> threadProcessamentoCalc(new boost::thread(&this->ThreadCalcularTrens, tResult));

    #endif

    #ifdef MODO_MULT_THREAD

      UpdateStatusProgramando(threadProcessamentoCalc, isExibicaoProgresso, timeoutCancelamento,"");

      threadProcessamentoCalc->join();
    #endif

      if (tResult->Status == terSucesso)
      {

        #ifdef MODO_MULT_THREAD
      //  Aguarde("Carregando cones das Atividades");
        threadCarregarIconesAtividades2.join();
        #endif
        utils::TULog::getInstance()->SaveLog("Programando;"+TTPFormsManager::getInstance()->Mesa,utils::ltEnd);
        Sleep(1000);
        utils::TULog::getInstance()->SaveLog("Plotando;"+TTPFormsManager::getInstance()->Mesa,utils::ltStart);
        Aguarde("Plotando Grfico",false);
        TTPFormsManager::getInstance()->AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);
        TTPFormsManager::getInstance()->ServerCarregarFilas();

        TTPFormsManager::getInstance()->AjustarLinhaTempo();

        // Plotar Restries
        for (int i = 0; i < TTPFormsManager::getInstance()->Restricoes->count(); i++)
        {
        TTPRestricaoPtr t_Restricao = TTPFormsManager::getInstance()->Restricoes->get(i);
        TTPFormsManager::getInstance()->PlotarRestricao(t_Restricao);
        }

        //Fixando a ordem dos trens
        {
        TFormFilas* formErrosFila = new TFormFilas(Owner);
        //formErrosFila->ShowModal();
        formErrosFila->AtualizarPosicaoTrens();
        delete formErrosFila;
        }

        PlotarTrens();

        filtrou_ = false;

        TTPFormsManager::getInstance()->VerificarConflitos();
        TTPFormsManager::getInstance()->AjustarPrefixos();

        //TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(FPlanoInicializado, this);

       // TTPFormsManager::getInstance()->AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);

        TTPFormsManager::getInstance()->ServerSetSelecionar(true);
        StopAguarde();
      }
      }
    }
    Screen->Cursor = t_oldcursor;

    if (tResult->Status == terErro)
    {
      Alerta(tResult->ListaResultados->Text);
      acCarregar->Enabled  = true;
      acCarregar->ShortCut = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;
    }
    else
    {
      Application->ProcessMessages();
      TTPFormsManager::getInstance()->AjustarEstadoControles(true);
      TTPFormsManager::getInstance()->EnableDisableTeechart(true);
    }
    delete tResult;
    }
    catch (Exception &e)
    {
    acCarregar->Enabled  = true;
    acCarregar->ShortCut = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;

    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
    }
  }
  __finally
  {
    FProgramando = false;
    if(lockMutex)
    {
    TTPFormsManager::getInstance()->gravarLog("acCarregarExecute Mutex: UNlock");
    TTPFormsManager::getInstance()->MutexProc->unlock();
    }
    RestaurarChart();
    Sleep(1000);
    utils::TULog::getInstance()->SaveLog("Plotando;"+TTPFormsManager::getInstance()->Mesa,utils::ltEnd);
    Application->ProcessMessages();
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acVisaoExecute(TObject *Sender)
{
  chrTTP->UndoZoom();
  FVisaoPlajemanto_ = !FVisaoPlajemanto_;
  RedimencionaChartToVisao();
  ScrollTo(NULL, 0);
}
// ---------------------------------------------------------------------------

void TFormTP::RetirarSelecao(bool pManterMovimento)
{
  FTipoSelecaoAtual_ = tselSemSelecao;
  // Voltar para cor da srie ()
  if (!pManterMovimento || (pManterMovimento && acSelecionarRestricao->Checked))
  {
    if (FSerieMovimentoSelecionada_ != NULL && FSerieMovimentoSelecionada_->Movimento && chrTTP->SeriesList->IndexOf(FSerieMovimentoSelecionada_)>-1)
    {
      FSerieMovimentoSelecionada_->SetTremSelecionado(false);
      FSerieMovimentoSelecionada_->Movimento->MovimentoSelecionado = false;
    }
    FSerieMovimentoSelecionada_ = NULL;
    // Voltar a cor da restrio para a cor original
  }
  if (!pManterMovimento || (pManterMovimento && acSelecionar->Checked == true))
  {
    if (FSerieRestricaoSelecionada_ && !FSelecionarTremRemoverRestricao_)
    {
      FSerieRestricaoSelecionada_->Selecionado = false;
      FSerieRestricaoSelecionada_              = NULL;
    }
    for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
    {
      TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];

      if(IsSerieValida(restSel))
      restSel->Selecionado        = false;
      /*
      else
        Alerta("Peguei");
      */
    }
    if (acAjustarRestricaoAoTrem->Checked != true)
      FSeriesRestSelecionadas_->Clear();
  }

  lblStatus->Tag = 0;
  lblStatus->Caption = "";
}

// ---------------------------------------------------------------------------
void TFormTP::RetirarSelecaoZerarParadas()
{
  RemoverSerieMP((TChartSeries*&)serieLinhaTempoAparagarParadas_);
  acZerarParadasTrens->Checked = false;
}

// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRealizarZoomExecute(TObject *Sender)
{
  acRealizarZoom->Checked = true;
}
// ---------------------------------------------------------------------------

void TFormTP::RealizarZoomRapido(double pX, int pY)
{

  TRect zoomRapido;

  if (!FISZoomed_)
  {
    chrTTP->ZoomRect(Rect(pX - chrTTP->Width*0.03, pY - chrTTP->Height*0.01, pX + chrTTP->Width*0.03,
      pY + chrTTP->Height*0.03));
  }

  zoomRapido.Left = pX - 300;
  zoomRapido.Right  = pX + 300;
  zoomRapido.Top    = pY - 200;
  zoomRapido.Bottom = pY + 200;

  // Verificando se ultrapassa os limites do grfico.
  // Esquerda
  if (zoomRapido.Left < 30)
  {
    zoomRapido.Left = 30;
  }

  // Direita
  if (zoomRapido.Right > chrTTP->Width)
  {
    zoomRapido.Right = chrTTP->Width - 20;
  }

  // Topo
  if (zoomRapido.Top < 40)
  {
    zoomRapido.Top = 40;
  }

  if (zoomRapido.Bottom > chrTTP->Height - 40)
  {
    zoomRapido.Bottom = chrTTP->Height - 40;
  }

  chrTTP->ZoomRect(zoomRapido);
}
// ---------------------------------------------------------------------------

TTPSBPtr TFormTP::GetSBByY(double pY)
{

  TTPSBPtr t_sb = NULL;

  for (int i = 0; i < this->FListSBs_->count(); i++)
  {
    TTPSBPtr sb = this->FListSBs_->operator[](i);
    if (pY >= sb->IndexGraficoI && pY < sb->IndexGraficoS + 0.5)
    {
      t_sb = sb;
      break;
    }
  }

  return t_sb;

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPUndoZoom(TObject *Sender)
{
 TTPFormsManager::getInstance()->gravarLog("Incio: UndoZoom");
 TTPFormsManager::getInstance()->gravarLog("Incio: EnableDisableChart");
  EnableDisableChart(false);

  TTPFormsManager::getInstance()->gravarLog("Incio: ConfigurarChartsLimitesHorizontaisDefault");
  ConfigurarChartsLimitesHorizontaisDefault();

  if(FISZoomed_)
  {

    scbCharts->VertScrollBar->Range = scbCharts->Height-20;

    scbCharts->VertScrollBar->Visible = false;
	FISZoomed_ = false;
	TTPFormsManager::getInstance()->gravarLog("Incio: RedimencionaChartToVisao");
	RedimencionaChartToVisao();
	TTPFormsManager::getInstance()->gravarLog("Incio: ScrollTo");
	ScrollTo(NULL,FHorarioCentralAtual_);
  }

  //AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);
  chrTTP->AllowPanning = Vcltee::Teeprocs::pmNone;
  //Application->ProcessMessages();

  TTPFormsManager::getInstance()->gravarLog("Incio: DesfazerAjustarPrefixos");
  DesfazerAjustarPrefixos();
  scbRodape->Enabled = true;

  chrTTP->ScrollMouseButton = mbMiddle;
  TTPFormsManager::getInstance()->gravarLog("Incio: SincyCharts");
  SincyCharts();
  scbCharts->HorzScrollBar->Position = ultimaPosicaoscbCharts_;
  //Application->ProcessMessages();

  TTPFormsManager::getInstance()->gravarLog("Incio: EnableDisableChart");
  EnableDisableChart(true);
  TTPFormsManager::getInstance()->gravarLog("Incio: chrTTP->Repaint()");
  chrTTP->Repaint();
  TTPFormsManager::getInstance()->gravarLog("Incio: chrTTPTop->Repaint()");
  chrTTPTop->Repaint();
  TTPFormsManager::getInstance()->gravarLog("Incio: chrTTPBot->Repaint()");
  chrTTPBot->Repaint();

  if(FIsMiminizedChart_)
  {
	TTPFormsManager::getInstance()->gravarLog("Incio: MinimizarChart");
	MinimizarChart();
  }
  TTPFormsManager::getInstance()->gravarLog("Fim: UndoZoom");
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::SincyCharts()
{
  ScrollToOnZoom(0,0);

  double t_maximumYNew = chrTTP->LeftAxis->Maximum;
  double t_minimumYNew = chrTTP->LeftAxis->Minimum;
  double t_maximumXNew = chrTTP->BottomAxis->Maximum;
  double t_minimumXNew = chrTTP->BottomAxis->Minimum;

  chrTTPTop->LeftAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPTop->RightAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPTop->BottomAxis->SetMinMax(t_minimumXNew, t_maximumXNew);
  chrTTPTop->TopAxis->SetMinMax(t_minimumXNew, t_maximumXNew);

  chrTTPBot->LeftAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPBot->RightAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPBot->BottomAxis->SetMinMax(t_minimumXNew, t_maximumXNew);
  chrTTPBot->TopAxis->SetMinMax(t_minimumXNew, t_maximumXNew);

  chrTTPLeft->LeftAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPLeft->RightAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPLeft->BottomAxis->SetMinMax(t_minimumXNew, t_maximumXNew);
  chrTTPLeft->TopAxis->SetMinMax(t_minimumXNew, t_maximumXNew);

  chrTTPRight->LeftAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPRight->RightAxis->SetMinMax(t_minimumYNew, t_maximumYNew);
  chrTTPRight->BottomAxis->SetMinMax(t_minimumXNew, t_maximumXNew);
  chrTTPRight->TopAxis->SetMinMax(t_minimumXNew, t_maximumXNew);

  scbChartLeft->VertScrollBar->Range = scbCharts->VertScrollBar->Range;
  scbChartRight->VertScrollBar->Range = scbCharts->VertScrollBar->Range;

  if(scbCharts->VertScrollBar->Position>0 )
  {
     if(chrTTPLeft->Align != alNone)
     {
      chrTTPLeft->Align = alNone;
      chrTTPRight->Align = alNone;
     }

    pnlScrollTop->Top = 0; //(scbCharts->VertScrollBar->Position - scbCharts->Height/2)*test;
    pnlScrollBot->Top = scbCharts->Height-35;
    chrTTPLeft->Top = -scbCharts->VertScrollBar->Position;
    chrTTPRight->Top = -scbCharts->VertScrollBar->Position;
  }
  else if(chrTTPLeft->Align != alLeft)
  {
    pnlScrollTop->Top  = 0;
    pnlScrollBot->Top = scbCharts->Height-35;
    chrTTPLeft->Top = 0;
    chrTTPRight->Top = 0;

    chrTTPLeft->Align = alLeft;
    chrTTPRight->Align = alNone;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::chrTTPZoom(TObject *Sender)
{
  FISZoomed_ = true;
  scbRodape->Enabled = false;

  scbCharts->HorzScrollBar->Range = scbCharts->Width*2-20;
  scbCharts->VertScrollBar->Range = scbCharts->Height*2-20;

  if(!FIsMiminizedChart_)
  {
    chrTTP->Width = scbCharts->HorzScrollBar->Range;
    chrTTPTop->Width = chrTTP->Width;
    chrTTPBot->Width = chrTTP->Width;
  }
  scbCharts->VertScrollBar->Visible = true;

  double t_maximumYNew = chrTTP->LeftAxis->Maximum;
  double t_minimumYNew = chrTTP->LeftAxis->Minimum;
  double t_maximumXNew = chrTTP->BottomAxis->Maximum;
  double t_minimumXNew = chrTTP->BottomAxis->Minimum;

  double sizeY = t_maximumYNew - t_minimumYNew;
  double sizeX = t_maximumXNew - t_minimumXNew;

  chrTTP->LeftAxis->Minimum -=  sizeY;
  chrTTP->LeftAxis->Maximum +=  sizeY;

  chrTTP->RightAxis->Minimum -=  sizeY;
  chrTTP->RightAxis->Maximum +=  sizeY;

  chrTTP->BottomAxis->Minimum -=  sizeX;
  chrTTP->BottomAxis->Maximum +=  sizeX;

  chrTTP->TopAxis->Minimum -=  sizeX;
  chrTTP->TopAxis->Maximum +=  sizeX;

  //---- *** ----//

  chrTTPTop->LeftAxis->Minimum -=  sizeY;
  chrTTPTop->LeftAxis->Maximum +=  sizeY;

  chrTTPTop->RightAxis->Minimum -=  sizeY;
  chrTTPTop->RightAxis->Maximum +=  sizeY;

  chrTTPTop->BottomAxis->Minimum -=  sizeX;
  chrTTPTop->BottomAxis->Maximum +=  sizeX;

  chrTTPTop->TopAxis->Minimum -=  sizeX;
  chrTTPTop->TopAxis->Maximum +=  sizeX;

  chrTTPBot->LeftAxis->Minimum -=  sizeY;
  chrTTPBot->LeftAxis->Maximum +=  sizeY;

  chrTTPBot->RightAxis->Minimum -=  sizeY;
  chrTTPBot->RightAxis->Maximum +=  sizeY;

  chrTTPBot->BottomAxis->Minimum -=  sizeX;
  chrTTPBot->BottomAxis->Maximum +=  sizeX;

  chrTTPBot->TopAxis->Minimum -=  sizeX;
  chrTTPBot->TopAxis->Maximum +=  sizeX;

  //---- *** ----//

  scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Range/2 - scbCharts->Width/2;
  scbCharts->VertScrollBar->Position = scbCharts->VertScrollBar->Range/2 - scbCharts->Height/2;

  FHorarioCentralAtual_ =  chrTTP->BottomAxis->Minimum + (chrTTP->BottomAxis->Maximum - chrTTP->BottomAxis->Minimum)/2;

  ultimaPosicaoscbChartVert_ = scbCharts->VertScrollBar->Position;
  ultimaPosicaoscbCharts_     = scbCharts->HorzScrollBar->Position;

  AjustarPrefixos(FISZoomed_);

  pnlScrollTop->Left = chrTTP->Left;
  pnlScrollTop->Width = chrTTP->Width - chrTTPLeft->Width;
  pnlScrollTop->Left += chrTTPLeft->Width;

  pnlScrollBot->Left = chrTTP->Left;
  pnlScrollBot->Width = chrTTP->Width - chrTTPLeft->Width;
  pnlScrollBot->Left += chrTTPLeft->Width;


  if(FormWidgetGanttOcupacao)
  {
    FormWidgetGanttOcupacao->Hide();
    FormWidgetGanttOcupacao->LimparGannt();
    pnlGanttOcupacao->Height = 0;
  }
  SincyCharts();

}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::MontarPopupTrem()
{

  acEditarRestricao->Enabled  = FHabilitarPopup;
  acExcluirRestricao->Enabled = FHabilitarPopup;

  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* t_tremSelecionado = FSerieMovimentoSelecionada_->Trem;
    mniPrefixo->Caption        = t_tremSelecionado->Prefixo;
    acExcluirTrem->Enabled     = t_tremSelecionado->IsTransiente;
    acSuprimirTrem->Enabled =
      (t_tremSelecionado->TipoTrem->PermissaoExclusao ||
      (!t_tremSelecionado->TipoTrem->PermissaoExclusao && t_tremSelecionado->EstadoTrem != 3) ||
      t_tremSelecionado->EstadoTrem == 1) && !t_tremSelecionado->IsTransiente && !t_tremSelecionado->IsSuprimido;
   acEditarMovimentoOrigem->Enabled = !t_tremSelecionado->PossuiMovimentoRealizado && !t_tremSelecionado->IsSuprimido;

    #ifdef BAIXADA_SANTISTA
    if(acSuprimirTrem->Enabled || acEditarMovimentoOrigem->Enabled)
    {
      if(t_tremSelecionado->PrimeiroMovimentoPrevisto)
      {
        acSuprimirTrem->Enabled = t_tremSelecionado->PrimeiroMovimentoPrevisto->Mesa == TTPFormsManager::getInstance()->Mesa;
        acEditarMovimentoOrigem1->Enabled = t_tremSelecionado->PrimeiroMovimentoPrevisto->Mesa == TTPFormsManager::getInstance()->Mesa;
        acEditarMovimentoOrigem->Enabled = t_tremSelecionado->PrimeiroMovimentoPrevisto->Mesa == TTPFormsManager::getInstance()->Mesa;
      }
      else
      {
        acSuprimirTrem->Enabled = false;
        acEditarMovimentoOrigem1->Enabled = false;
        acEditarMovimentoOrigem->Enabled = false;
      }
    }
    PriorizarMovimentos1->Visible = false;
    acLimparMovimentosPriorizados1->Visible = false;
    #endif
    acRestaurarTrem->Enabled         = t_tremSelecionado->IsSuprimido;

    acAtualizarTrem->Enabled         = !t_tremSelecionado->IsSuprimido;

    acEditarMovimento->Enabled  = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acExcluirMovimento->Enabled = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acIncluirParada->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;

    acAtividadesTrem->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acCriarAtividade->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acPriorizarMovimentos->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acLimparMovimentosPriorizados->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acReexibirMovimentos->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acZerarParadasTrem->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acZerarParadasOcultandoMovimentos->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acEditarTrem->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acFichaTrem->Enabled     = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;;
    acAtivarValidacaoHorGrade->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;
    acDesativarValidacaoHorGrade->Enabled    = FHabilitarPopup && !t_tremSelecionado->IsSuprimido;

    acOficializarTrem->Enabled = acOficializar->Enabled;

    acAtivarDesativarCalculoVelocidade->Enabled = FHabilitarPopup && !t_tremSelecionado->IsSuprimido
      && TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo;
    if(t_tremSelecionado->ISCalculoVelocidadeAtivo)
      acAtivarDesativarCalculoVelocidade->Caption = "Desativar Clculo de Velocidade";
    else
      acAtivarDesativarCalculoVelocidade->Caption = "Ativar Clculo de Velocidade";

    if (t_tremSelecionado->ISTremFila)
    {
      if (t_tremSelecionado->ISCalculoFilaAtivo)
      {
        acAtivarCalculoFila->Enabled    = false && !t_tremSelecionado->IsSuprimido;
        acAtivarCalculoFila->Visible    = false && !t_tremSelecionado->IsSuprimido;
        acDesativarCalculoFila->Enabled = true && !t_tremSelecionado->IsSuprimido;
        acDesativarCalculoFila->Visible = true && !t_tremSelecionado->IsSuprimido;
      }
      else
      {
        acAtivarCalculoFila->Enabled    = true && !t_tremSelecionado->IsSuprimido;
        acAtivarCalculoFila->Visible    = true && !t_tremSelecionado->IsSuprimido;
        acDesativarCalculoFila->Enabled = false && !t_tremSelecionado->IsSuprimido;
        acDesativarCalculoFila->Visible = false && !t_tremSelecionado->IsSuprimido;
      }
    }
    else
    {
      acAtivarCalculoFila->Enabled    = false && !t_tremSelecionado->IsSuprimido;
      acAtivarCalculoFila->Visible    = false && !t_tremSelecionado->IsSuprimido;
      acDesativarCalculoFila->Enabled = false && !t_tremSelecionado->IsSuprimido;
      acDesativarCalculoFila->Visible = false && !t_tremSelecionado->IsSuprimido;
    }

    if(t_tremSelecionado->PossuiAtividadeMetaGrade && !t_tremSelecionado->IsSuprimido)
    {

      acAtivarValidacaoHorGrade->Enabled    = true;
      acDesativarValidacaoHorGrade->Enabled = true;

      acAtivarValidacaoHorGrade->Visible    = true;
      acDesativarValidacaoHorGrade->Visible = true;

    }
    else
    {

      acAtivarValidacaoHorGrade->Enabled    = false;
      acDesativarValidacaoHorGrade->Enabled = false;

      acAtivarValidacaoHorGrade->Visible    = false;
      acDesativarValidacaoHorGrade->Visible = false;

    }
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::pmnTremPopup(TObject *Sender)
{
  MontarPopupTrem();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPContextPopup(TObject *Sender, TPoint &MousePos, bool &Handled)
{
  if (FHabilitarPopup)
  {
    if (!FFezPanning_)
      chrTTP->PopupMenu = FPopupContexto_;
    else
      chrTTP->PopupMenu = NULL;
  }
  else if (!FFezPanning_)
  {
    chrTTP->PopupMenu = pmnGeral;
  }
  else
  {
    chrTTP->PopupMenu = NULL;
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acExcluirMovimentoExecute(TObject *Sender)
{
//	try
//  {
//    TStringList *movimentosExcluir = new TStringList();
//
//    if (FSerieMovimentoSelecionada_ != NULL)
//    {
//      if (FSerieMovimentoSelecionada_->Movimento->IsRealizado)
//      {
//        throw Exception("Trecho realizado no pode ser editado");
//      }
//
//      TTPTrem* t_trem = FSerieMovimentoSelecionada_->Trem;
//
//      TTPMovimentoSeries* t_seriePosterior = FSerieMovimentoSelecionada_->SerieMovimentoPosterior(NULL);
//
//			while (t_seriePosterior)
//      {
//        movimentosExcluir->AddObject("", t_seriePosterior);
//        t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior;
//			}
//
//      for (int i = movimentosExcluir->Count - 1; i >= 0; i--)
//      {
//        TTPMovimentoSeries *t_movimentoEx = (TTPMovimentoSeries*)movimentosExcluir->Objects[i];
//        t_trem->ItinerarioTrem->Movimentos->remove(t_movimentoEx->Movimento->PID);
//        TTPFormsManager::getInstance()->RemoverSerieMP(t_movimentoEx);
//      }
//
//      TTPMovimentoSeries* t_serieAnterior = FSerieMovimentoSelecionada_->SerieMovimentoAnterior;
//      t_serieAnterior->SerieMovimentoPosterior = NULL;
//      t_trem->ItinerarioTrem->Movimentos->remove(FSerieMovimentoSelecionada_->Movimento->PID);
//      TTPFormsManager::getInstance()->RemoverSerieMP(FSerieMovimentoSelecionada_);
//
//      if (t_serieAnterior->SerieMovimentoAnterior != NULL)
//        FSerieMovimentoSelecionada_ = t_serieAnterior->SerieMovimentoAnterior;
//      else
//        FSerieMovimentoSelecionada_ = t_serieAnterior;
//
//      FSerieMovimentoSelecionada_->MovimentoSelecionado = true;
//    }
//
//    delete movimentosExcluir;
//    movimentosExcluir = NULL;
//
//  }
//  catch (Exception &e)
//  {
//    Alerta(e.Message);
//  }
}

// ---------------------------------------------------------------------------
void TFormTP::RemoverSerieMP(TChartSeries *&serie)
{
  int indexOf = -1;

  if (((TChart*)chrTTP) != NULL && ((TChartSeries*)serie) != NULL)
  {
    indexOf = chrTTP->SeriesList->IndexOf(serie);
    if (indexOf > -1)
    {
      TTPTipoSerie tipoSerie = GetTipoSerieMP(serie);

      chrTTP->RemoveSeries(serie);

      switch (tipoSerie)
      {
        case tsMovimento :
        {
          // Remove a ocupao da SB para no detectar conflitos erroniamente
          TTPSBPtr tSB = NULL;
          TTPMovimentoSeries* movSerie = ((TTPMovimentoSeries*)serie);
          TTPMovimento* movimento = &*movSerie->Trem->ItinerarioTrem->Movimentos->operator[](0);

          while (movimento)
          {
            int indexOf  = FListSBs_->IndexOf(movimento->SB->NomeVia);
            if (indexOf > -1)
            {
              tSB = this->FListSBs_->operator[](indexOf);
              tSB->RemoverOcupacaoSB(movSerie->Trem->PID + movimento->PID);
              tSB->RemoverMovimentosSB(movSerie->Trem->PID + movimento->PID);
            }

             movimento = movimento->MovimentoPosterior;
           }
          break;
        }
        case tsObservacao:
        {
          /*
          delete(TTPObservacaoSeries*)serie;
          serie = NULL;
          */
          break;
        }
        case tsPrefixo:
        {
					
            indexOf = chrTTP->SeriesList->IndexOf(((TTPPrefixoSeries*)serie)->PrimeiraSerieTrecho);
            if (indexOf > -1)
            {
          chrTTP->RemoveSeries(((TTPPrefixoSeries*)serie)->PrimeiraSerieTrecho);
            }
          //((TTPPrefixoSeries*)serie)->PrimeiraSerieTrecho = NULL;
          delete(TTPPrefixoSeries*)serie;
          serie = NULL;
           break;
        }
        case tsRestricao:
        {
          delete(TTPRestricaoSeries*)serie;
          serie = NULL;
          break;
        }
      case tsConflito:
        {
          delete serie;
          serie = NULL;
          break;
        }
      case tsLinhaDupla:
        {
          delete(TTPLinhaDuplaSeries*)serie;
          serie = NULL;
          break;
        }
      case tsLinhaTempo:
        {
          delete(TTPLinhaTempoSeries*)serie;
          serie = NULL;
          break;
        }
//      Removido pois esta limpeza  feita no destrutor do TTPMovimentoSeries
//      case tsAderenciaFila:
//        {
//          delete(TTPAderenciaFilaSeries*)serie;
//          serie = NULL;
//          break;
//        }
        }
      }
    }
  }
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRestringirExecute(TObject *Sender)
{
  acRestringir->Checked = true;
  FMarcarRestricao_     = false;
}
// ---------------------------------------------------------------------------

void TFormTP::GerenciarRestricoes(double pPontoEixoX, double pPontoEixoY)
{
  TCursor t_oldcursor = Screen->Cursor;

  unsigned short yi, yf, hora, min, sec, ms, hora2, min2;
  double intX_ini, intX_fim, converte, coordYInicio, coordYFim;
  TTPSBPtr sbIni;
  TTPSBPtr sbFim;
  ShapeSelecao->Visible = false;

  coordYInicio = FSerieSBs_->YScreenToValue(FCoordenadasSelecao_.Top);
  coordYInicio = RoundTo(coordYInicio, -3);
  if (coordYInicio < 0)
    coordYInicio = 0;
  sbIni = GetSBByY(coordYInicio); // FSerieSBs_->GetSB(coordYInicio);

  if (sbIni.isNull())
  {
    sbIni = FSerieSBs_->GetSB(TP_->TotalSBs - 1);
  }

  coordYFim = FSerieSBs_->YScreenToValue(pPontoEixoY);
  coordYFim = RoundTo(coordYFim, 0);
  if (coordYFim < 0)
    coordYFim = 0;
  sbFim = GetSBByY(coordYFim); // FSerieSBs_->GetSB(coordYFim);
  if (sbFim.isNull())
  {
    sbFim = FSerieSBs_->GetSB(TP_->TotalSBs - 1);
  }

  // Data
  TDate t_dataInicioInterdicao, t_dataFimInterdicao;
  int horaInt;

  float t_horaInicioX    = FSerieSBs_->XScreenToValue(FCoordenadasSelecao_.Left);
  horaInt                = t_horaInicioX;
  t_dataInicioInterdicao = horaInt;

  float t_horaFinalX  = FSerieSBs_->XScreenToValue(pPontoEixoX);
  horaInt             = t_horaFinalX;
  t_dataFimInterdicao = horaInt;

  // Hora
  int timeInt         = t_horaInicioX;
  float timeFloat     = (t_horaInicioX - timeInt);
  TTime auxHoraInicio = System::Dateutils::TimeOf(FloatToDateTime(timeFloat));

  timeInt          = t_horaFinalX;
  timeFloat        = (t_horaFinalX - timeInt);
  TTime auxHoraFim = System::Dateutils::TimeOf(FloatToDateTime(timeFloat));
  // DataHora
  TDateTime t_dataHoraInicioInterdicao, t_dataHoraFimInterdicao;
  t_dataHoraInicioInterdicao = t_dataInicioInterdicao + auxHoraInicio;
  t_dataHoraFimInterdicao    = t_dataFimInterdicao + auxHoraFim;

  // Criar objeto de negio (futuramente ser includo em um gerente)
  TTPRestricaoPtr t_restricao = new TTPRestricao();

  if (acInterditar->Checked)
  {
    for (int i = 0; i < TTPFormsManager::getInstance()->TiposRestricao->count(); i++)
    {
      if (TTPFormsManager::getInstance()->TiposRestricao->get(i)->ISPararTrem == true
          && !acReter->Checked && !TTPFormsManager::getInstance()->TiposRestricao->get(i)->ISPermiteOcupacao)
      {
        t_restricao->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get(i);
        break;
      }
      else if (TTPFormsManager::getInstance()->TiposRestricao->get(i)->ISPararTrem == true
               && acReter->Checked &&  TTPFormsManager::getInstance()->TiposRestricao->get(i)->ISPermiteOcupacao)
      {
        t_restricao->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get(i);
        break;
      }
    }
  }
  else
  {
    for (int i = 0; i < TTPFormsManager::getInstance()->TiposRestricao->count(); i++)
    {
      if (TTPFormsManager::getInstance()->TiposRestricao->get(i)->ISReducaoVelocidade)
      {
        t_restricao->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get(i);
        break;
      }
    }
  }
  if (t_restricao->Tipo == NULL)
    throw Exception("Tipo de Restrio no configurada.");

  t_restricao->DataInicio = t_dataHoraInicioInterdicao;
  t_restricao->DataFim    = t_dataHoraFimInterdicao;

  //t_restricao->DataMinInicio = t_dataHoraInicioInterdicao;
  //t_restricao->DataMaxFim    = t_dataHoraFimInterdicao;


  TFormRestricao* t_formRestricao = new TFormRestricao(this, this->FListSBs_, t_restricao, sbIni, sbFim);
  t_formRestricao->Caption        = (t_restricao->Tipo->ISPararTrem ? "Interdio da Via" :
    "Restrio Temporria de Velocidade");

  if (t_formRestricao->ShowModal() == mrOk)
  {
    TTPFormsManager::getInstance()->Restricoes->add(t_restricao->PID, t_restricao);
    TTPFormsManager::getInstance()->AtualizarRestricao(t_restricao,tarInclusao);

    if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
    {
      TDAO::gravarRestricao(t_restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
      t_restricao->IsAlteradoUsuario = false;
    }
  }

  acSelecionar->Checked = true;
  acSelecionarExecute(this);

  Screen->Cursor = t_oldcursor;

}
// ---------------------------------------------------------------------------

void TFormTP::GerenciarCriacaoTremArrasto(double pPontoEixoX, double pPontoEixoY)
{
  TCursor t_oldcursor = Screen->Cursor;

  unsigned short yi, yf, hora, min, sec, ms, hora2, min2;
  double intX_ini, intX_fim, converte, coordYInicio, coordYFim;
  TTPSBPtr sbIni;
  TTPSBPtr sbFim;
  ShapeSelecao->Visible = false;

  coordYInicio = FTremSelecionadoSerie_->getLocalizacaoInicio();
  coordYInicio = RoundTo(coordYInicio, -3);
  if (coordYInicio < 0)
    coordYInicio = 0;
  sbIni = GetSBByY(coordYInicio); // FSerieSBs_->GetSB(coordYInicio);

  if (sbIni.isNull())
  {
    sbIni = FSerieSBs_->GetSB(TP_->TotalSBs - 1);
  }

  coordYFim = FTremSelecionadoSerie_->getLocalizacaoFim();
  coordYFim = RoundTo(coordYFim, -3);
  if (coordYFim < 0)
    coordYFim = 0;
  sbFim = GetSBByY(coordYFim); // FSerieSBs_->GetSB(coordYFim);
  if (sbFim.isNull())
  {
    sbFim = FSerieSBs_->GetSB(TP_->TotalSBs - 1);
  }

  // DataHora
  TDateTime t_dataHora = FTremSelecionadoSerie_->getDataHoraIncio();
  TTPTremPtr t_trem = new TTPTrem();

  TFormCriarTrem* t_formCriarTrem;

  if (acCriarTremTabela->Checked)
  {
    TTPTremListPtr tTrensTabela = new TTPTremList();
    TXStringList* tTabelas      = new TXStringList();

    for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
    {
      TTPTremPtr t_Trem = TTPFormsManager::getInstance()->Trens->get(i);
      if (!t_Trem.isNull() && t_Trem->Tabela.Length() > 0)
      {
        tTrensTabela->add(t_Trem->PID, t_Trem);
        tTabelas->Add(t_Trem->Tabela);
      }
    }

    t_formCriarTrem = new TFormCriarTrem(this, &*t_trem, tTrensTabela, tTabelas);
    acCriarTremTabela->Checked = false;
  }
  else
  {
    t_formCriarTrem = new TFormCriarTrem(this, TTPFormsManager::getInstance()->TiposTrem, &*t_trem, this->FListSBs_,
      t_dataHora, sbIni, sbFim, TTPFormsManager::getInstance()->SBs, TTPFormsManager::getInstance()->GruposVMP);
  }

  if (t_formCriarTrem->ShowModal() == mrOk)
  {
    t_trem = AddTremListaLocal(t_formCriarTrem->PIDTremCriado);

    //acSelecionarExecute(this);
    acVerificarConflitosExecute(this);
  }

  acSelecionar->Checked = true;
  acSelecionarExecute(this);

  Screen->Cursor = t_oldcursor;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acInterditarExecute(TObject *Sender)
{
  acInterditar->Checked = true;
  FMarcarRestricao_     = false;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acMarcarRestricaoUpdateExecute(TObject *Sender)
{
  if (acInterditar->Checked || acRestringir->Checked || FSelecionandoRestArrastoShift_)
  {
    chrTTP->AllowZoom      = false;
    chrTTP->Cursor         = crCross;
    chrTTP->OriginalCursor = crCross;
  }
  else
  {
    ShapeSelecao->Visible = false;
    acReter->Checked = false;
    if (!acInterditar->Checked && !acRestringir->Checked)
      FMarcarRestricao_ = false;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acSelecionarExecute(TObject *Sender)
{
  if (!TTPFormsManager::getInstance()->ChamouSelecionar)
  {
    if (!acSelecionar->Checked)
      TTPFormsManager::getInstance()->Selecionar();
    else
      TTPFormsManager::getInstance()->SelecionarDefault();
  }
  else
  {
    if (acSelecionar->Checked == true)
      acSelecionar->Checked = false;
    else
    {
      FPopupContexto_ = NULL;
      TTPFormsManager::getInstance()->RetirarSelecao();

      int t_primeiraSerieMovimento = 0;

      for (int i = 0; i < chrTTP->SeriesCount(); i++)
      {
        TChartSeries* t_serie = chrTTP->Series[i];
        if (GetTipoSerieMP(t_serie) == tsLinhaTempo)
        {
          t_primeiraSerieMovimento = i + 1;
          break;
        }
      }

      for (int i = 0; i < chrTTP->SeriesCount(); i++)
      {
        TChartSeries* t_serie = chrTTP->Series[i];
        if (GetTipoSerieMP(t_serie) == tsRestricao)
        {
          chrTTP->ExchangeSeries(i, t_primeiraSerieMovimento);
          t_primeiraSerieMovimento++;
        }
      }

        for (int i = 0; i < chrTTP->SeriesCount(); i++)
      {
        TChartSeries* t_serie = chrTTP->Series[i];
        if (GetTipoSerieMP(t_serie) == tsObservacao)
        {
          chrTTP->ExchangeSeries(i, t_primeiraSerieMovimento);
          t_primeiraSerieMovimento++;
        }
      }
      acSelecionar->Checked = true;
    }
    ConfigurarTextoSelecionar();
  }

  chrTTP->Cursor         = crDefault;
  chrTTP->OriginalCursor = crDefault;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::EditarRestrio1Click(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_)
  {
    TTPRestricaoPtr t_restricaoCirculacao = FSerieRestricaoSelecionada_->Restricao;
  }
}
// ---------------------------------------------------------------------------

void TFormTP::AtualizarRestricao(TTPRestricaoPtr &pRestricao, TTPTipoAtualizacaoRestricao pTipo)
{
  String sbIni = "";
  String sbFim = "";
  chrTTP->AutoRepaint = true;
  if (!pRestricao->GetSBInicio(FRamal_->Nome).isNull())
  {
    sbIni = pRestricao->GetSBInicio(FRamal_->Nome)->NomeVia;
    sbFim = pRestricao->GetSBFim(FRamal_->Nome)->NomeVia;
  }

  if (!pRestricao->GetSBInicio(FRamal_->Nome).isNull() && FListSBs_->IndexOf(sbIni) >
    -1 && FListSBs_->IndexOf(sbFim) > -1)
  {

    TCursor t_oldcursor                     = Screen->Cursor;
    TTPRestricaoSeries* t_serieRestricao    = NULL;
    TTPRestricaoSeries* t_serieRestricaoOld = NULL;

    try
    {
      Screen->Cursor = crHourGlass;

      // Se for uma incluso
      if (pTipo == tarInclusao)
      {
        if (FSerieRestricaoSelecionada_)
        {
          FSerieRestricaoSelecionada_->Selecionado = false;
          FSerieRestricaoSelecionada_              = NULL;
        }
        t_serieRestricao = PlotarRestricao(pRestricao);
        if (t_serieRestricao)
        {
          bool flagInicio = false;
          // Reorganizar ordem da nova srie. Como o mtodo DownSeries no est funcionando
          // vamos alterar a ordem de todas as restries at chegarmos a primeira srie de um trem
          for (int i = 0; i < chrTTP->SeriesCount(); i++)
          {
            TChartSeries* t_serie = chrTTP->Series[i];
            if (GetTipoSerieMP(t_serie) == tsRestricao)
            {
              flagInicio       = true;
              int z1           = i;
              int z2           = chrTTP->SeriesList->IndexOf(t_serieRestricao);
              t_serieRestricao = (TTPRestricaoSeries*) chrTTP->Series[i];
              chrTTP->ExchangeSeries(z1, z2);
            }

            if (flagInicio && !(GetTipoSerieMP(t_serie) == tsRestricao))
            {
              int z1 = i;
              int z2 = chrTTP->SeriesList->IndexOf(t_serieRestricao);
              chrTTP->ExchangeSeries(z1, z2);
              break;
            }
          }
        } // if (t_serieRestricao)
      } // if (pTipo == tarInclusao)
      else
      {
        // Se no for incluso, vamos guardar a srie antiga...
        if (FSerieRestricaoSelecionada_)
        {
          t_serieRestricaoOld         = FSerieRestricaoSelecionada_;
          FSerieRestricaoSelecionada_ = NULL;
        }
        // ...e, se no for excluso...
        if (pTipo != tarExclusao)
        {
          t_serieRestricao = PlotarRestricao(pRestricao);
          if (t_serieRestricao)
          {
            int z1 = chrTTP->SeriesList->IndexOf(t_serieRestricaoOld);
            int z2 = chrTTP->SeriesList->IndexOf(t_serieRestricao);
            if(z1 > -1)
            chrTTP->ExchangeSeries(z1, z2);
          }
        }
        // Agora apaga a srie...
        if (t_serieRestricaoOld)
        {
          chrTTP->RemoveSeries(t_serieRestricaoOld);
          t_serieRestricaoOld->Selecionado = false;
          FSerieRestricaoMouseOver_        = NULL;
          /*
          No posso tirar da lista devido a For's aninhados - Fabiano 08/2020
          int indexOf = FSeriesRestSelecionadas_->IndexOf(t_serieRestricaoOld->Restricao->PID);
          if (indexOf > -1)
            FSeriesRestSelecionadas_->Delete(indexOf);
          */
          delete t_serieRestricaoOld;
          t_serieRestricaoOld = NULL;
          FRestricoes_->remove(pRestricao->PID);
        }
        else // Teremos que buscar a srie da restrio pelo PID para os fomulrios em a mesma no foi selecionada
        {
          for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
          {
            TChartSeries* t_serie  = chrTTP->Series[i];
            TTPTipoSerie tipoSerie = GetTipoSerieMP(t_serie);
            if (tipoSerie == TTPTipoSerie::tsRestricao)
            {
              TTPRestricaoSeries* restSerieExcluir = (TTPRestricaoSeries*)t_serie;
              if ((pTipo == tarEdicao && restSerieExcluir != t_serieRestricao && restSerieExcluir->Restricao->PID == pRestricao->PID)
                  || (pTipo == tarExclusao && restSerieExcluir->Restricao->PID == pRestricao->PID))
              {
                chrTTP->RemoveSeries(restSerieExcluir);
                /*
                No posso tirar da lista devido a For's aninhados - Fabiano 08/2020

                int indexOf = FSeriesRestSelecionadas_->IndexOf(restSerieExcluir->Restricao->PID);
                if (indexOf > -1)
                  FSeriesRestSelecionadas_->Delete(indexOf);
                */
                delete restSerieExcluir;
                restSerieExcluir = NULL;
                FRestricoes_->remove(pRestricao->PID);
              }
            }
          }
        }

      }
      chrTTP->Refresh();
    }
    catch (Exception& e)
    {
      // acPlotarAtualizar->Execute();
      Screen->Cursor = t_oldcursor;
    }
    Screen->Cursor = t_oldcursor;
  }
}

// ---------------------------------------------------------------------------
TTPRestricaoSeries* TFormTP::PlotarRestricao(TTPRestricaoPtr &pRestricao)
{
  TTPRestricaoSeries* restricao = NULL;
  if (!pRestricao->GetSBInicio(FRamal_->Nome).isNull() && !pRestricao->GetSBFim(FRamal_->Nome).isNull()
    && FListSBs_->IndexOf(pRestricao->GetSBInicio(FRamal_->Nome)->NomeVia) >
    -1 && FListSBs_->IndexOf(pRestricao->GetSBFim(FRamal_->Nome)->NomeVia) > -1)
  {
    restricao = new TTPRestricaoSeries(chrTTP, pRestricao, pRestricao->DataInicio, pRestricao->DataFim,
      pRestricao->GetSBInicio(FRamal_->Nome)->IndexGraficoS, pRestricao->GetSBFim(FRamal_->Nome)->IndexGraficoI,
      lblStatus,t_seriesGlobal);
    if (FRestricoes_->IndexOf(pRestricao->PID) == -1)
      FRestricoes_->add(pRestricao->PID, pRestricao);

    if (chrTTP->SeriesList->IndexOf(restricao) == -1)
      chrTTP->AddSeries(restricao);
    if (FPrimeiraRestricao_ == -1)
      FPrimeiraRestricao_ = chrTTP->SeriesList->IndexOf(restricao);

    pRestricao->Serie = restricao;
  }
  return restricao;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acEditarRestricaoExecute(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_)
  {
    TTPRestricaoSeries* restTemp = FSerieRestricaoSelecionada_;

    acAjustarRestricaoAoTrem->Checked = false;
    TTPFormsManager::getInstance()->RetirarSelecao();

    FSerieRestricaoSelecionada_              = restTemp;
    FSerieRestricaoSelecionada_->Selecionado = true;
    FHabilitarPopup                          = true;
    FPopupContexto_                          = pmnRestricoes;
    FTipoSelecaoAtual_                       = tselRestricao;
    FPIDObjetoSelecionado_                   = FSerieRestricaoSelecionada_->Restricao->PID;

    TTPRestricaoPtr t_restricao = FSerieRestricaoSelecionada_->Restricao;
    if (!t_restricao->GetSBInicio().isNull() && !t_restricao->GetSBFim().isNull())
    {
      TFormRestricao* t_formRestricao = new TFormRestricao(this, this->FListSBs_, t_restricao,
        t_restricao->GetSBInicio(), t_restricao->GetSBFim());
      String tCaptionForm = t_formRestricao->Caption;
      t_formRestricao->Caption = (t_restricao->Tipo->ISPararTrem ? "Gerenciamento de Interdio" :
        "Gerenciamento de Restrio") + tCaptionForm;

      if (t_formRestricao->ShowModal() == mrOk)
      {
        Application->ProcessMessages();
        if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
        {
          TDAO::gravarRestricao(t_restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
          t_restricao->IsAlteradoUsuario = false;
        }

        TTPFormsManager::getInstance()->AtualizarRestricao(t_restricao);
        //acSelecionar->Checked = true;
        //acSelecionarExecute(this);
      }
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acExcluirRestricaoExecute(TObject *Sender)
{
  for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
  {
     chrTTP->AutoRepaint = true;
    TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
    TTPRestricaoPtr t_restricao = restSel->Restricao;

    FSerieRestricaoSelecionada_ = restSel;

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    core->ExcluirRestricao(t_restricao->PID);

    //
    TTPFormsManager::getInstance()->AtualizarRestricao(t_restricao, tarExclusao);
    if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
      TDAO::deleteRestricao(t_restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
    else
      TTPFormsManager::getInstance()->RestricoesDel->add(t_restricao->PID, t_restricao);

    TTPFormsManager::getInstance()->Restricoes->remove(t_restricao->PID);
    TTPFormsManager::getInstance()->RestricoesDinamicas->remove(t_restricao->PID);

    t_seriesGlobal->clearHint(NULL);
  }

  acAjustarRestricaoAoTrem->Checked = false;
  FSeriesRestSelecionadas_->Clear();

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acSelecionarRestricaoExecute(TObject *Sender)
{

  if (!TTPFormsManager::getInstance()->ChamouSelecionarRestricao)
  {
    if (!acSelecionarRestricao->Checked)
      TTPFormsManager::getInstance()->SelecionarRestricao();
    else
      TTPFormsManager::getInstance()->SelecionarDefault();
  }
  else
  {
    if (acSelecionarRestricao->Checked)
      acSelecionarRestricao->Checked = false;
    else
    {
      FPopupContexto_ = NULL;
      TTPFormsManager::getInstance()->RetirarSelecao();

      int t_totalSeries = chrTTP->SeriesCount();
      int index         = 1;
      for (int i = 0; i < t_totalSeries; i++)
      {
        TChartSeries* t_serie = chrTTP->Series[i];
        TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);
        if (t_tipo == tsRestricao || t_tipo == tsConflito)
        {
          chrTTP->ExchangeSeries(i, t_totalSeries - index);
          index++;
        }
      }
      acSelecionarRestricao->Checked = true;
    }
    ConfigurarTextoSelecionar();
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::acIncluirParadaExecute(TObject *Sender)
{
//	if (FSerieMovimentoSelecionada_ != NULL)
//  {
//    {
//      FSerieMovimentoSelecionada_->MovimentoSelecionado = false;
//			FSerieMovimentoSelecionada_                       = FSerieMovimentoSelecionada_->SerieMovimentoPosterior;
//      FSerieMovimentoSelecionada_->MovimentoSelecionado = true;
//    }
//
//    double pontoEixoXDestino = FSerieMovimentoSelecionada_->Movimento->DataSaida;
//    pontoEixoXDestino += 0.006;
//
//    // Vamos utilizar o FArrastoSeries para atualizar os movimentos do trem
//    FArrastoSeries_->XValue[0]      = pontoEixoXDestino;
//    FArrastoSeries_->SerieMovimento = FSerieMovimentoSelecionada_;
//    AtualizarSaidaTremArrastoMouse();
//
//    PlotarTrem(FSerieMovimentoSelecionada_->Trem, false, false, true);
//    acVerificarConflitosExecute(this);
//    FArrastoSeries_->SerieMovimento->MovimentoSelecionado = true;
//    FSerieMovimentoSelecionada_                           = FArrastoSeries_->SerieMovimento;
//
//  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acEditarMovimentoExecute(TObject *Sender)
{
  try
  {
    if (FSerieMovimentoSelecionada_ != NULL)
    {

      if (FSerieMovimentoSelecionada_->Movimento->IsRealizado)
      {
        throw Exception("Trecho realizado no pode ser editado");
      }

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      TTPMovimento* t_movimento = (FEditandoOrigem_)?
                                  FSerieMovimentoSelecionada_->MovimentoOrigem():
                                  FSerieMovimentoSelecionada_->Movimento;

      if (t_movimento->Serie != NULL && chrTTP->SeriesList->IndexOf(t_movimento->Serie) > -1)
      {
        FSerieMovimentoSelecionada_                       = t_movimento->Serie;
        FSerieMovimentoSelecionada_->Movimento->MovimentoSelecionado = true;
      }

      TTPMovimento* t_movimentoAnterior = NULL;
      TTPMovimento* t_movimentoPosterior = NULL;

      TTPSBListPtr t_listSB = new TTPSBList();

      String segmento = "";
      segmento        = t_movimento->SB->CodigoSegmento;

      if (t_movimento->MovimentoPosterior != NULL)
      {
        t_movimentoPosterior = t_movimento->MovimentoPosterior;
      }

      if (t_movimento->MovimentoAnterior != NULL)
      {
        t_movimentoAnterior = t_movimento->MovimentoAnterior;
      }

      for (int i = 0; i < this->FListSBs_->count(); i++)
      {
        if (this->FListSBs_->operator[](i)->CodigoSegmento == segmento)
        {
          TTPSBPtr sbTemp = this->FListSBs_->operator[](i);
          t_listSB->add(sbTemp->NomeVia, sbTemp);
        }
      }
      TTPTrem* t_Trem = FSerieMovimentoSelecionada_->Trem;
      getTremFilho(t_Trem);

      TFormEditarMovimento* t_formEditarMovimento = new TFormEditarMovimento(this, FSerieMovimentoSelecionada_->Trem,
        t_movimento, t_movimentoAnterior, t_movimentoPosterior, t_listSB, FEditandoOrigem_);

      // Armazena a chave de ocupao para caso a SB seja alterada, limpar a ocupao
      TTPFormsManager::getInstance()->gravarLog("acEditarMovimentoExecute " + FSerieMovimentoSelecionada_->Trem->PID);
      String chaveOcupacaoLimpar1 = FSerieMovimentoSelecionada_->Trem->PID + t_movimento->PID;
      String chaveOcupacaoLimpar2 = "";
      if (FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior != NULL)
        chaveOcupacaoLimpar2 = FSerieMovimentoSelecionada_->Trem->PID +
          FSerieMovimentoSelecionada_->Movimento->MovimentoAnterior->PID;

      TTPSBPtr tSB = NULL;
      // Primeiramente, procura na lista do formulrio
      if (FListSBs_->IndexOf(t_movimento->SB->NomeVia) > -1)
        tSB = this->FListSBs_->operator[](FListSBs_->IndexOf(t_movimento->SB->NomeVia));
      else if (TTPFormsManager::getInstance()->SBs->IndexOf(t_movimento->SB->NomeVia) > -1)
        // SE no tem, vai pra lista geral
          tSB = TTPFormsManager::getInstance()->SBs->operator[]
          (TTPFormsManager::getInstance()->SBs->IndexOf(t_movimento->SB->NomeVia));
      String nomeSbOld = FSerieMovimentoSelecionada_->Movimento->SB->NomeVia;

      TTPMovimentoSeries* serieSelecionada = FSerieMovimentoSelecionada_;

      if (t_formEditarMovimento->ShowModal() == mrOk)
      {

        TTPTrem* t_trem = serieSelecionada->Trem;

        if (FEditandoOrigem_ &&  t_movimento->ServerSegTremPlanejado != NULL)
        {
          if (t_formEditarMovimento->chkEmanciparTremFilho->Checked)
            core->removerLinkTremPai(serieSelecionada->Trem->PID);

          timeTP::TimeTP dataSaida;
          dataSaida = t_movimento->GetDataSaidaClient();

          t_movimento->ServerSegTremPlanejado->trem->setDataSaidaRotaTremUsuario(dataSaida,
            domain::SegmentoTremImpactado::SentidoConflito::SENTIDO_IGUAL, core->getDataHoraBaseCalculo());
          // Pedido Danilo
          serieSelecionada->Trem->PrevisaoSaidaOriginal = dataSaida.asDateTime();
          acZerarParadasTrem->OnExecute(this);
        }
        else
        {
          String nomeSb = "";
          if (serieSelecionada->Movimento->ServerSegTremPlanejado != NULL)
          {
            nomeSb = core->AlterarDataPartidaMovimento(serieSelecionada->Movimento->ServerSegTremPlanejado,
              serieSelecionada->Movimento->GetDataSaidaClient())->sb;
          }

        }

        TTPTremPtr tTrem = TTPFormsManager::getInstance()->Trens->get(t_trem->PID);
        if (tTrem->ItinerarioTrem->Movimentos->operator[](tTrem->ItinerarioTrem->TotalMovimentos - 1)
          ->ServerSegTremPlanejado != NULL)
          tTrem->ItinerarioTrem->Movimentos->operator[](tTrem->ItinerarioTrem->TotalMovimentos - 1)
            ->ServerSegTremPlanejado->getPeriodoOcupacao();

        TTPFormsManager::getInstance()->SincronizarTremClientServer(&*tTrem);

        TTPFormsManager::getInstance()->PlotarTrem(&*tTrem, true, false, true);

        DesfazerAjustarPrefixos();

        PlotarTremFilho(&*tTrem);
        acVerificarConflitosExecute(this);

        RetirarSelecao();
      }

      // FSerieMovimentoSelecionada_->MovimentoSelecionado = false;
      FSerieMovimentoSelecionada_ = NULL;
    }
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRealizarMovimentoExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_->Movimento->MovimentoPosterior != NULL)
  {
    TTPMovimentoSeries* t_movimento = FSerieMovimentoSelecionada_;
    //while (t_movimento)
    {
      t_movimento->Movimento->IsRealizado = true;
      t_movimento->LinePen->Style         = psSolid;
      //t_movimento                         = t_movimento->SerieMovimentoAnterior;
    }
  }
}

// ---------------------------------------------------------------------------
TTPMovimentoSeries* TFormTP::PlotarRotaTrem(TTPTrem* pTrem, bool pPlotarPrefixo, bool pTremCopia, bool pAtualizar, TTPMovimentoListPtr pRota, TTPMovimentoSeries* pMovimentoSerie)
{

  if (FormWidgetGanttOcupacao)
  {
    FormWidgetGanttOcupacao->LimparGannt();
    if (FormWidgetGanttOcupacao->Visible)
    {
      FormWidgetGanttOcupacao->Hide();
      pnlGanttOcupacao->Height = 0;
    }
  }
  if(t_seriesGlobal->SeriesHint)
  {
    t_seriesGlobal->SeriesHint = NULL;
    t_seriesGlobal->clearHint(NULL);
  }

  TTPMovimentoSeries *movimento = pMovimentoSerie;

  if(movimento)
    movimento->AddPontoNull();

  try
  {
    FExecutouResetPosicao_ = false;
    FPerdeuFocus_          = false;
    FSerieMovimentoSelecionada_ = NULL;
    bool tremSubindo;
    bool mudouSentido             = false;
    bool sbOcultaMudancaSentido   = false;
    bool primeiroMovimentoPainel  = false;
    bool tremExisteListaLocal     = false;
    bool tremAdicionadoListaLocal = false;

    TDateTime dataInicio;
    String nomeIni, nomeFim;
    double indexIni, indexFim;
    TTPMovimentoSeries* movimentoAnterior   = NULL;
    TTPPrefixoSeries* t_seriePrefixoOrigem  = NULL;
    TTPPrefixoSeries* t_seriePrefixoDestino = NULL;

    double pontoEixoYOrigem  = 0;
    double pontoEixoXOrigem  = 0;
    double pontoEixoYDestino = 0;
    double pontoEixoXDestino = 0;

    double pontoEixoYDestinoAntReal = 0;
    bool tratamentoSuprimirBaixada = true;
    #ifdef BAIXADA_SANTISTA
    tratamentoSuprimirBaixada = !pTrem->IsSuprimido;
    #endif

    if (pAtualizar)
    {
      LimparSeriesObservacao(pTrem);
      LimparSeriesTransposicao(pTrem);
      TTPFormsManager::getInstance()->ValidarOrdemEntregaTrensFila(pTrem->FilaTerminal);
      AjustarEstadoControleSinalizadorInconsistenciaFila(true, true);
      pAtualizar = false;
    }

    // Varivel que auxilia descobrir se o trem alterou o sentido
    TTPMovimentoSeries *ultimaSerie = NULL;
    tremExisteListaLocal                     = this->FTrens_->IndexOf(pTrem->PID) > -1;
    TTPMovimento* t_movimentoAnteriorPlotado = NULL;
    if (!pTrem->ItinerarioTrem.isNull())
    {
      if (!pRota.isNull())
      {
        bool pararCriarMovimentosDescarga = false;
        for (int i = 0; i < pRota->count(); i++)
        {
          TTPMovimentoPtr t_movimento = pRota->operator[](i);
          double minX = TP_MIN_X_DRAW;
          double maxX = TP_MAX_X_DRAW;
          double tdataSaida = (double)t_movimento->DataSaida;
          double tdataChegada = (double)t_movimento->DataChegada;

          if (TTPFormsManager::getInstance()->VerificaShowIntrajornada() && t_movimento->ServerSegTremOficializado)
          {
            String origemIntra = t_movimento->ServerSegTremOficializado->getSegmentoOcupado()->ramal->IndicadorSistemaOrigemIntraJornada;
            String origemOf = t_movimento->ServerSegTremOficializado->oficializacao->getCodigoOrigemOficializacao();
            if(origemOf != origemIntra || TTPFormsManager::getInstance()->Data > t_movimento->DataSaida )
            {
              continue;
            }
          }

          if (t_movimento->SB && t_movimento->SB->Ramal == FRamal_->Nome && tdataSaida >= minX && tdataChegada <= maxX)
          {
            TTPMovimentoPtr t_movimentoAnterior       = NULL;
            TTPMovimentoPtr t_movimentoPosterior      = NULL;

            bool isMovimentoSimulado = !t_movimento->IsRealizado && t_movimento->DataChegada <
              TP_->Data + TP_->Hora && t_movimento->DataSaida < TP_->Data + TP_->Hora;

            tremSubindo = t_movimento->SentidoGrafico == strSubindo;

            bool ultimoRealizado = false;
            if(t_movimento->IsRealizado && t_movimento->MovimentoPosterior && !t_movimento->MovimentoPosterior->IsRealizado)
            {
                ultimoRealizado = true;
            }

            // Verifica se o trem mudou de sentido
            if (i > 1)
            {
              if (!t_movimento->SB.isNull() && t_movimento->SB->CodigoSegmento != NULL &&
                t_movimento->SB->CodigoSegmento == (pRota->operator[](i - 2))
                ->SB->CodigoSegmento)
              {
                //tremSubindo  = !tremSubindo;
                mudouSentido = true;
              }
            }

           //	bool isUlimoRealizado = false;
            if (!TTPFormsManager::getInstance()->ShowVisualizador && i == 0 && t_movimento->MovimentoAnterior)
            {
              int indexOfinMovimentos = pTrem->ItinerarioTrem->MovimentosRealizados->IndexOf(t_movimento->MovimentoAnterior->PID);
              if(indexOfinMovimentos>0)
              {
                t_movimentoAnterior = pTrem->ItinerarioTrem->MovimentosRealizados->operator[](indexOfinMovimentos);
                if(t_movimentoAnterior->Serie && t_movimentoAnterior->Serie->ParentChart == this->chrTTP)
                {
                  movimentoAnterior =  t_movimentoAnterior->Serie;
                  t_movimentoAnteriorPlotado =  t_movimentoAnterior->Serie->Movimento;

                  pontoEixoYDestinoAntReal = t_movimentoAnterior->Serie->YValue[t_movimentoAnterior->Serie->YValues->Count-1];
                }
              }
            }

            //Correo do erro de ligar os movimentos de um trem quando o mesmo sai do ramal e volta  posteriormente
            bool movimentoAnteriorInOtherChart = false;
            if(movimento)
            {
              movimentoAnteriorInOtherChart = t_movimento->MovimentoAnterior &&  t_movimento->MovimentoAnterior->MovimentoAnterior
                                              && (t_movimento->MovimentoAnterior->SB->Ramal != FRamal_->Nome &&
                                              t_movimento->MovimentoAnterior->MovimentoAnterior->SB->Ramal != FRamal_->Nome );

              //Caso mude de ramal por mais de 2 movimentos a MovimentoSeries Atual e a anterior
              //so limpas para que o chart crie uma nova srie e no ocorra de ligar os dois movimentos
              if(movimentoAnteriorInOtherChart)
              {
                movimento = NULL;
                t_movimentoAnteriorPlotado = NULL;
              }

            }

            if (i == 1)
            {
              t_movimentoAnterior       = pRota->operator[](0);
            }
            else if (i > 1)
            {
              t_movimentoAnterior       = pRota->operator[](i - 1);
            }

            if (i < pRota->count() - 1)
            {
              t_movimentoPosterior = pRota->operator[](i + 1);
            }

            if(!t_movimentoPosterior && t_movimento->IsRealizado && t_movimento->MovimentoPosterior)
            {
              int indexOfinMovimentos = pTrem->ItinerarioTrem->Movimentos->IndexOf(t_movimento->MovimentoPosterior->PID);

              if(indexOfinMovimentos>-1)
                t_movimentoPosterior = pTrem->ItinerarioTrem->Movimentos->operator[](indexOfinMovimentos);
            }

            if(t_movimentoAnterior)
            {
              bool isMovimentoAnteriorSimulado = !t_movimentoAnterior->IsRealizado && t_movimentoAnterior->DataChegada <
              TP_->Data + TP_->Hora && t_movimentoAnterior->DataSaida < TP_->Data + TP_->Hora;

              if(isMovimentoAnteriorSimulado != isMovimentoSimulado || t_movimentoAnterior->IsRealizado && !t_movimento->IsRealizado )
              {
                if(movimento)
                  movimento->AddPontoNull();

                movimento = NULL;
              }
            }

            nomeIni = t_movimento->SB->NomeVia;
            dataInicio = t_movimento->DataChegada;

            if (this->FListSBs_->get(nomeIni).isNull())
            {
              if (mudouSentido)
              {
                sbOcultaMudancaSentido = true;
              }
              continue;
            }

            TTPSBPtr tSB = this->FListSBs_->get(nomeIni);

            if (!tremExisteListaLocal && !tremAdicionadoListaLocal )
            {
              tremAdicionadoListaLocal = true;
              TTPTremPtr tt = TTPFormsManager::getInstance()->Trens->get(pTrem->PID) ;
              this->FTrens_->add(tt->PID,tt );
            }

            TTPMovimentoSeries *t_MovimentoTransposicao;
            bool t_TemTransposicao = false;

            pontoEixoYOrigem = (tremSubindo ? tSB->IndexGraficoI : tSB->IndexGraficoS); //&& !t_movimento->IsRealizado
            pontoEixoXOrigem = dataInicio;
            if (!t_movimentoAnteriorPlotado)
              pontoEixoYDestinoAntReal = pontoEixoYOrigem;

            // Faz verificao se  necessrio alterar pontos para correo de linhas paralelas
            if (t_movimentoAnteriorPlotado != NULL && !t_movimentoAnterior.isNull())
            {
              // Foranco conectar com a srie anterior
              pontoEixoXOrigem   = t_movimentoAnteriorPlotado->DataSaida;
              String nomeIniProx = t_movimentoAnteriorPlotado->SB->NomeVia;

              if (mudouSentido && !tremSubindo)
              {
                TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnteriorPlotado->SB->NomeVia);
                if (!tSBAnterior.isNull())
                {
                  if (sbOcultaMudancaSentido)
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoS;
                  }
                  else
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoI;
                  }
                }
              }
              else if (mudouSentido && tremSubindo)
              {
                TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnteriorPlotado->SB->NomeVia);
                if (!tSBAnterior.isNull())
                {
                  if (sbOcultaMudancaSentido)
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoI;
                  }
                  else
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoS;
                  }
                }
              }
              else if ( /* !pAtualizar  && */ t_movimentoAnteriorPlotado != NULL &&
                ((t_movimento->IsRealizado || t_movimentoAnteriorPlotado->IsRealizado) && chrTTP->SeriesList->IndexOf
                (t_movimentoAnteriorPlotado->Serie) >
                -1 && pontoEixoYOrigem != t_movimentoAnteriorPlotado->Serie->YValue
                [t_movimentoAnteriorPlotado->Serie->PontosPlotados - 1]))
              {
                /*
                if ((t_movimento->IsRealizado) || t_movimentoAnteriorPlotado->IsRealizado)
                {
                  TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnteriorPlotado->SB->NomeVia);

                  pontoEixoXOrigem = t_movimento->DataChegada;
                  if (tremSubindo) //&& !ultimoRealizado)
                  {
                    if(!ultimoRealizado)
                      pontoEixoYOrigem = tSB->IndexGraficoS;
                    else
                      pontoEixoYOrigem = tSB->IndexGraficoI;
                  }
                  else
                  {
                    if(!ultimoRealizado)
                      pontoEixoYOrigem = tSB->IndexGraficoI;
                    else
                      pontoEixoYOrigem = tSB->IndexGraficoS;
                  }
                  // Criando a srie de Transposicao
                  double pontoXOrigemTransposicao = movimentoAnterior->Movimento->DataSaida;
                  double pontoXDestinoTransposicao = t_movimento->DataChegada;
                  double pontoYOrigemTransposicao  = 0;
                  double pontoYDestinoTransposicao = 0;

                  if (tremSubindo)
                  {
                    TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnterior->SB->NomeVia);
                    if (!tSBAnterior.isNull())
                    {
                      pontoYOrigemTransposicao = tSBAnterior->IndexGraficoS;
                    }
                    pontoYDestinoTransposicao = tSB->IndexGraficoS;
                  }
                  else
                  {
                    TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnterior->SB->NomeVia);
                    if (!tSBAnterior.isNull())
                    {
                      pontoYOrigemTransposicao = tSBAnterior->IndexGraficoI;
                    }
                    pontoYDestinoTransposicao = tSB->IndexGraficoI;
                  }

                } // if (t_movimento->IsRealizado || t_movimentoAnteriorPlotado->IsRealizado)
                */
              }
              else if (t_movimentoAnteriorPlotado != NULL
                    && chrTTP->SeriesList->IndexOf(t_movimentoAnteriorPlotado->Serie) > -1
                    && pontoEixoYOrigem !=
                      t_movimentoAnteriorPlotado->Serie->YValue[t_movimentoAnteriorPlotado->Serie->PontosPlotados - 1])
              {
                if (tremSubindo)
                {
                  TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnteriorPlotado->SB->NomeVia);
                  if (!tSBAnterior.isNull())
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoS;
                  }
                }
                else
                {
                  TTPSBPtr tSBAnterior = this->FListSBs_->get(t_movimentoAnteriorPlotado->SB->NomeVia);
                  if (!tSBAnterior.isNull())
                  {
                    pontoEixoYOrigem = tSBAnterior->IndexGraficoI;
                  }
                }
              }
            } // if (movimentoAnterior != NULL && !t_movimentoAnterior.isNull())

            pontoEixoYDestino = (tremSubindo ? this->FListSBs_->get(nomeIni)->IndexGraficoS :
              this->FListSBs_->get(nomeIni)->IndexGraficoI); //&& !ultimoRealizado

            // Se vai ocultar o movimento de descarga, iguala as datas
            if (pararCriarMovimentosDescarga)
            {
              pontoEixoXDestino = t_movimento->DataChegada;
            }
            else
            {
              pontoEixoXDestino = t_movimento->DataSaida;
            }

            if (mudouSentido && !t_movimentoPosterior.isNull()
              && t_movimentoAnteriorPlotado != NULL && chrTTP->SeriesList->IndexOf(t_movimentoAnteriorPlotado->Serie) >
              -1 && this->FListSBs_->IndexOf(t_movimentoPosterior->SB->NomeVia) > -1)
            {
              if (sbOcultaMudancaSentido)
              {
                pontoEixoYDestino =
                  (tremSubindo ? this->FListSBs_->get(t_movimentoPosterior->SB->NomeVia)->IndexGraficoI :
                  this->FListSBs_->get(t_movimentoPosterior->SB->NomeVia)->IndexGraficoS);
                sbOcultaMudancaSentido = false;
              }
              /*
              else
              {
                pontoEixoYDestino =
                  (tremSubindo ? this->FListSBs_->get(t_movimentoPosterior->SB->NomeVia)->IndexGraficoS :
                  this->FListSBs_->get(t_movimentoPosterior->SB->NomeVia)->IndexGraficoI);
              }
              */
            }

            if (t_movimento->IsRealizado && (!TTPFormsManager::getInstance()->ShowVisualizador || (t_movimentoPosterior != NULL && t_movimentoPosterior->IsRealizado))/* && !pAtualizar /*&& !t_TemTransposicao */)
            {
              // Faz verificao se  necessrio alterar pontos para correo de linhas paralelas
              if (movimentoAnterior != NULL && t_movimentoPosterior != NULL)
                // && (t_movimentoPosterior->SB->NumeroLinha != 1 || mudouSentido || falhaPlotagem))
              {
                String nomeIniProx = t_movimentoPosterior->SB->NomeVia;
                if (!this->FListSBs_->get(nomeIniProx).isNull())
                {
                  if (mudouSentido && !tremSubindo)
                  {
                    pontoEixoYDestino = this->FListSBs_->get(nomeIniProx)->IndexGraficoI;
                  }
                  else if (mudouSentido && tremSubindo)
                  {
                    pontoEixoYDestino = this->FListSBs_->get(nomeIniProx)->IndexGraficoS;
                  }
                  /*
                  else
                  {
                    // Vamos descobri se o prximo movimento existe transposio de SBs...
                    int indexOfPatio        = FListSBs_->IndexOf(t_movimento->SB->NomeVia);
                    int indexOfProximoPatio = FListSBs_->IndexOf(t_movimentoPosterior->SB->NomeVia);
                    bool temSBTransposta    = false;
                    if (tremSubindo && indexOfPatio + 1 != indexOfProximoPatio)
                    {
                      temSBTransposta = true;
                    }
                    if (!tremSubindo && (indexOfPatio - 1 != indexOfProximoPatio))
                    {
                      temSBTransposta = true;
                    }
                    if (t_movimentoPosterior->SB->NumeroLinha != 1 || temSBTransposta)
                    {
                      if (tremSubindo)
                      {
                        pontoEixoYDestino = this->FListSBs_->get(nomeIniProx)->IndexGraficoI;
                      }
                      else
                      {
                        pontoEixoYDestino = this->FListSBs_->get(nomeIniProx)->IndexGraficoS;
                      }
                    }
                  }
                  */
                } // SE NO ENCONTROU A SB
                else
                {
                  bool erro = true;
                }
                pontoEixoXDestino = t_movimento->DataSaida;
              } // if (movimentoAnterior != NULL && t_movimentoPosterior != NULL)
            } // if (t_movimento->IsRealizado && !pAtualizar)

            bool tPlotarSuprimido = !t_movimento->IsRealizado && pTrem->IsSuprimido;

              // Criando a srie
              //TTPMovimentoSeries *movimento = NULL
              if (pTremCopia)
              {
                movimento = new TTPMovimentoSeries(chrTTP, pTrem, &*t_movimento,t_seriesGlobal);
                t_movimento->Serie = movimento;

              }
              else if (!movimento && tratamentoSuprimirBaixada)
              {
                  movimento = new TTPMovimentoSeries(chrTTP, pTrem, &*t_movimento,t_seriesGlobal);
                  t_movimento->Serie = movimento;

                if (tPlotarSuprimido)
                {
                  movimento->SetMovimentoTremSuprimido();
                }
              }
              else
              {
                t_movimento->Serie = movimento;
              }

              if (movimento == NULL)
              {
                t_movimento->Serie = NULL;
                break;
              }

              movimento->LinhaTempo = TP_->Data + TP_->Hora;
              movimento->IsSimulado   = isMovimentoSimulado;
              movimento->LabelPrefixo = lblStatus;

              // Plotando movimento
              chrTTP->AddSeries(movimento);

              double pontoXChegada = t_movimento->DataChegada;

              if (t_movimentoAnteriorPlotado && !movimentoAnteriorInOtherChart)
              {
                pontoXChegada = t_movimentoAnteriorPlotado->DataSaida;
              }

              double pontoXFimCurso = t_movimento->DataFimCurso;
              double pontoXSaida = t_movimento->DataSaida;

              if(pontoXFimCurso >= TP_MAX_X_DRAW+UMDIAPLAN*1)
              {
                 pontoXFimCurso =  TP_MAX_X_DRAW+UMDIAPLAN*1;
              }

              if(pontoXSaida >= TP_MAX_X_DRAW+UMDIAPLAN*1)
              {
                 pontoXSaida =  TP_MAX_X_DRAW+UMDIAPLAN*1;
              }

              if(pontoXChegada <= TP_MIN_X_DRAW-UMDIAPLAN*1)
              {
                 pontoXChegada =  TP_MIN_X_DRAW-UMDIAPLAN*1;
              }

              if(t_movimento->IsRealizado && t_movimentoPosterior && !t_movimentoPosterior->IsRealizado)
              {
                movimento->PlotarPontos(&*t_movimento,pontoXChegada, pontoEixoYOrigem, pontoXFimCurso, pontoEixoYOrigem, pontoXSaida,
                pontoEixoYDestino);
              }
              else
              {
              //if ((!t_movimento->IsRealizado && t_movimentoAnterior &&!t_movimentoAnterior->IsRealizado && pontoEixoYDestinoAntReal == pontoEixoYOrigem)&&(!t_movimento->IsRealizado || pontoEixoYDestinoAntReal == pontoEixoYOrigem))
                movimento->PlotarPontos(&*t_movimento,pontoXChegada, pontoEixoYOrigem, pontoXFimCurso, pontoEixoYDestino, pontoXSaida,
                pontoEixoYDestino);
              }
              /*
              else
              {
                movimento->PlotarPontos(&*t_movimento, pontoXChegada, pontoEixoYDestinoAntReal, pontoXFimCurso, pontoEixoYOrigem,
                  pontoXSaida, pontoEixoYDestino);
              }
              */
              pontoEixoYDestinoAntReal = pontoEixoYDestino;

              movimentoAnterior = movimento;

              if (!t_movimento->Trem->IsSuprimido && t_movimento->Serie->TemAtividade() && ((!t_movimento->Serie->Movimento->IsRealizado) ||
                (t_movimento->Serie->Movimento->IsRealizado && t_movimento->MovimentoPosterior == NULL))
                && movimento->TemParada)
              {
                double pontoEixoXObservacao = (pontoXFimCurso + ((pontoXSaida - pontoXFimCurso) / 2.0));
                double pontoEixoYObservacao = (pontoEixoYDestino + ((pontoEixoYDestino - pontoEixoYDestino) / 2.0));
                TTPObservacaoSeries* t_serieObservacao =
                  new TTPObservacaoSeries(chrTTP, &*t_movimento, pontoEixoXObservacao, pontoEixoYObservacao,
                  (t_movimento->Serie->AtividadeFila && !t_movimento->Serie->AtividadeFilaIrrelevante ?
                  tsoAtividadeFilaAtiva : tsoPAT),t_seriesGlobal);
                chrTTP->AddSeries(t_serieObservacao);
                movimento->SeriesObservacao->AddObject(movimento->Movimento->PID,(TObject*)t_serieObservacao);

                FSeriesObservacao_->AddObject(movimento->Movimento->PID,(TObject *)t_serieObservacao);

                int z1 = chrTTP->SeriesList->IndexOf(t_serieObservacao);
                  int z2 = chrTTP->SeriesList->IndexOf(t_movimento->Serie);
                  chrTTP->ExchangeSeries(z1, z2);

              }
              if (((double)t_movimento->DataAderenciaFila) > 0 && t_movimento->DataAderenciaFila < t_movimento->DataChegada)
              {
                TTPAderenciaFilaSeries* aderenciaFila = t_movimento->Serie->SerieAderenciaFila;
                chrTTP->AddSeries(aderenciaFila);
                aderenciaFila->PlotarPontos(t_movimento->DataChegada, pontoEixoYDestino, t_movimento->DataChegada, pontoEixoYDestino, false);

                TTPFormsManager::getInstance()->TrensAderenciaFila->Add(t_movimento->Trem->ItinerarioTrem->Movimentos->operator[]
                     (t_movimento->Trem->ItinerarioTrem->Movimentos->count() - 1)->SB->CodigoSegmento + " | " +
                      t_movimento->Trem->Prefixo);
              }
              // Fim Plotando o indicador de atividade

              t_movimentoAnteriorPlotado = movimento->Movimento;
              t_TemTransposicao = false;

              bool movimentoAnteriorInChart = !primeiroMovimentoPainel && movimento->Movimento->MovimentoAnterior &&
                                              movimento->Movimento->MovimentoAnterior->IsRealizado &&
                                              movimento->Movimento->MovimentoAnterior->Serie &&
                                              (TChart *)movimento->Movimento->MovimentoAnterior->Serie->ParentChart == this->chrTTP;
              // Se for o primeiro ponto, inlcui prefixo
              if (!primeiroMovimentoPainel && pPlotarPrefixo && !movimentoAnteriorInChart )
              {

                // if (tremSubindo)
                if(!movimento->Movimento->Prefixo)
                {
                t_seriePrefixoOrigem = new TTPPrefixoSeries(chrTTP, pTrem, TTPFormsManager::getInstance()->ShowVisualizador, pontoEixoXOrigem, pontoEixoYOrigem,
                  tdpCima, ppInicio, false, movimento->Movimento);
                t_seriePrefixoOrigem->PrimeiraSerieTrecho = movimento;
                movimento->Movimento->Prefixo             = t_seriePrefixoOrigem;
                chrTTP->AddSeries(t_seriePrefixoOrigem);
              }
                else
                {
                  t_seriePrefixoOrigem = movimento->Movimento->Prefixo;
                }
              }

              if (tPlotarSuprimido && !movimento->Movimento->IsRealizado)
              {
                break;
              }

              primeiroMovimentoPainel = true;


           
            // --> Por fim, adiciona o movimento a lista para verificar conflitos
            if (!t_movimento->IsRealizado && t_movimento->DataChegada >
              TP_->Data + TP_->Hora && t_movimento->DataSaida >
              TP_->Data + TP_->Hora && t_movimento->ServerSegTremPlanejado != NULL)
            {
              timeTP::PeriodTP *periodo =
                new timeTP::PeriodTP(*t_movimento->ServerSegTremPlanejado->getPeriodoOcupacao());
              if(!t_movimento->ServerSegTremPlanejado->isCancelarOcupacaoViaCadastroSegmento())
                tSB->AdicionarOcupacaoSB(pTrem->PID + t_movimento->PID, periodo);
            }

            if (t_movimento->ServerSegTremRealizado || t_movimento->ServerSegTremPlanejado || t_movimento->ServerSegTremOficializado)
            {
              if ((t_movimento->ServerSegTremRealizado && t_movimento->ServerSegTremRealizado->getSB()->segmento->patioPertencente) ||
                  (t_movimento->ServerSegTremPlanejado && t_movimento->ServerSegTremPlanejado->getSB()->segmento->patioPertencente) ||
                  (t_movimento->ServerSegTremOficializado && t_movimento->ServerSegTremOficializado->getSB()->segmento->patioPertencente))
              {
                String SiglaPatio = t_movimento->ServerSegTremRealizado ? t_movimento->ServerSegTremRealizado->getSB()->segmento->patioPertencente->sigla :
                    t_movimento->ServerSegTremPlanejado ? t_movimento->ServerSegTremPlanejado->getSB()->segmento->patioPertencente->sigla :
                    t_movimento->ServerSegTremOficializado->getSB()->segmento->patioPertencente->sigla;

                if (TTPFormsManager::getInstance()->SiglaPatios->IndexOf(SiglaPatio) == -1)
                {
                  TTPFormsManager::getInstance()->SiglaPatios->Add(SiglaPatio);
                }

              }

              if (t_movimento->ServerSegTremOficializado)
              {
                tSB->AdicionarMovimentosSB(pTrem->PID + t_movimento->PID + t_movimento->ServerSegTremOficializado->oficializacao->PID, t_movimento);
              }
              else
              {
                tSB->AdicionarMovimentosSB(pTrem->PID + t_movimento->PID, t_movimento);
              }

            }

            // --> Por fim, adiciona o movimento a lista para verificar conflitos

            mudouSentido = false;

          } // if RAMAL

          contPlotagem++;

        } // For Movimentos

        if(pTrem->PrimeiroMovimentoPrevisto && pTrem->PrimeiroMovimentoPrevisto->Serie)
          pTrem->PrimeiroMovimentoPrevisto->Serie->RedrawTrain();
      }
    } // if
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
  catch (...)
  {
    int parar = 1;
    return NULL;
  }

  if(movimento)
    movimento->AddPontoNull();
  return movimento;
}

void __fastcall TFormTP::acCriarTremExecute(TObject *Sender)
{

  acCriarTremTabela->Checked = false;
  acCriarTrem->Checked       = true;
  FMarcarRestricao_          = false;
  FCriandoTremArrasto_       = false;

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acCancelarTremArrastoExecute(TObject *Sender)
{
  try
  {
   // acSelecionar->Checked = true;
    acCriarTrem->Checked  = false;
    if (FTremSelecionadoSerie_)
	  chrTTP->RemoveSeries(FTremSelecionadoSerie_);
  }
  __finally
  {
    FCriandoTremArrasto_ = false;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRealizadoProgramadoExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* t_trem = &*TTPFormsManager::getInstance()->CopiaTrens->get(FSerieMovimentoSelecionada_->Trem->PID);
    FSerieMovimentoSelecionada_->SetTremSelecionado();
    PlotarTrem(t_trem, false, true);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRemoverRealizadoProgramadoExecute(TObject *Sender)
{
  for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
  {
    TChartSeries* t_serie    = chrTTP->Series[i];
    TTPTipoSerie t_tipoSerie = GetTipoSerieMP(t_serie);

    if (((TChartSeries*)t_serie) != NULL && t_tipoSerie == tsMovimento && ((TTPMovimentoSeries*)t_serie)
      ->Trem->TipoTrem->Nome == "C")
    {
      RemoverSerieMP(t_serie);
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acPesquisarPrefixoExecute(TObject *Sender)
{
  FPerdeuFocus_ = true;
  PesquisarPrefixo(edtPesquisar->Text);
}

// ---------------------------------------------------------------------------
bool TFormTP::PesquisarPrefixo(String pBusca, bool pLancarExcecao)
{

  bool achou                       = false;
  bool setFocus                    = false;
  chrTTP->SetFocus();

  if(pBusca=="")
    return true;

  #ifdef BAIXADA_SANTISTA
  TTPTremPtr tTremBaixada = NULL;
  //tTrem->PrefixoAnotherRailway == pBusca

  for (int x = 0; x < TTPFormsManager::getInstance()->Trens->count(); x++)
  {
    tTremBaixada = TTPFormsManager::getInstance()->Trens->get(x);
    if (tTremBaixada->PrefixoAnotherRailway == pBusca)
    {
      pBusca = tTremBaixada->Prefixo;
      break;
    }
  }

  #endif


  if (TTPFormsManager::getInstance()->Trens != NULL)
  {
    String prefixoPrimeiroTrem = "";
    if(pBusca.Length()<7)
    {
      TStringList* tTrensBusca  = new TStringList();
      tTrensBusca->Sorted = true;
      TTPTremPtr tTrem = NULL;

      if(!TTPFormsManager::getInstance()->ShowVisualizador)
      {
        for (int x = 0; x < TTPFormsManager::getInstance()->Trens->count() && !setFocus; x++)
        {
          tTrem = TTPFormsManager::getInstance()->Trens->get(x);
          if (tTrem->Tabela == pBusca)
          {
            for (int i = 0; i < tTrem->ItinerarioTrem->Movimentos->count(); i++)
            {
              if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie)
              {
                if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->ParentChart)
                {
                  TTPMovimento* movimento = &*tTrem->ItinerarioTrem->Movimentos->operator[](i);
                  tTrensBusca->AddObject(tTrem->PID,(TObject *)movimento);
                  break;
                }
              }
            }
          }
        }
      }
      else
      {
        for (int x = 0; x < TTPFormsManager::getInstance()->Trens->count() && !setFocus; x++)
        {
          tTrem = TTPFormsManager::getInstance()->Trens->get(x);
          if (!tTrem->ItinerarioTrem.isNull())
          {
            for(int i=1; i<tTrem->ItinerarioTrem->GetTotalRotas(); i++ )
            {
               TTPMovimentoListPtr pRota = tTrem->ItinerarioTrem->getRota(i);
              if(!pRota.isNull() && pRota->count()>0 && pRota->operator[](0) && pRota->operator[](0)->ServerSegTremOficializado)
              {
                domain::SegmentoTremOficializado *segmentoTremOficializado = pRota->operator[](0)->ServerSegTremOficializado;
                if(segmentoTremOficializado && segmentoTremOficializado->oficializacao->tabelaTremOficializado == pBusca)
                {
                  for (int j = 0; j < pRota->count(); j++)
                  {
                    TTPMovimento* movimento = &*pRota->operator[](j);
                    if(movimento->Serie && movimento->Serie->ParentChart)
                    {
                      tTrensBusca->AddObject(tTrem->PID,(TObject *)movimento);
                      prefixoPrimeiroTrem = tTrem->Prefixo;
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }

      if(tTrensBusca->Count>1)
      {
       TFormAlertaTrensTabelaBusca *FormAlertaTrensTabelaBusca = new TFormAlertaTrensTabelaBusca(this,tTrensBusca);

       FormAlertaTrensTabelaBusca->ShowModal();

       if(FormAlertaTrensTabelaBusca->ModalResult != mrOk)
       {
         delete FormAlertaTrensTabelaBusca;
         return true;
       }
       else
       {
         pBusca = FormAlertaTrensTabelaBusca->cdsGridPrefixo->Text;
       }
       delete FormAlertaTrensTabelaBusca;
      }
      else if(tTrensBusca->Count==1 && TTPFormsManager::getInstance()->ShowVisualizador)
      {
         pBusca = prefixoPrimeiroTrem;
      }

    }

  EnableDisableChart(false);
  TTPMovimentoPtr tPrimeiroMovimentoPrevisto, tPrimeiroMovimento;

    TTPTremPtr tTrem = NULL;
    for (int x = 0; x < TTPFormsManager::getInstance()->Trens->count() && !setFocus; x++)
    {
      tTrem = TTPFormsManager::getInstance()->Trens->get(x);
      if (tTrem->Prefixo == pBusca || (tTrem->Tabela == pBusca && tTrem->EstadoTrem != etrSuprimido))
      {
        for (int i = 0; i < tTrem->ItinerarioTrem->Movimentos->count(); i++)
        {
          if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie)
          {
            if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->ParentChart)
            {
              if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->IsRealizado)
              {
                tPrimeiroMovimento = tTrem->ItinerarioTrem->Movimentos->operator[](i);
              }

              if (tPrimeiroMovimento.isNull() || (tTrem->ItinerarioTrem->Movimentos->operator[](i)->MovimentoAnterior && tTrem->ItinerarioTrem->Movimentos->operator[](i)->MovimentoAnterior->IsRealizado))
              {
                tPrimeiroMovimento = tTrem->ItinerarioTrem->Movimentos->operator[](i);
              }
              if ((TChart *)tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->ParentChart == chrTTP
              && tTrem->ItinerarioTrem->Movimentos->operator[](i)->DataChegada <  (TTPFormsManager::getInstance()->DataLimiteGrafico - (1.0/24.0/2.0)))
              {
                TTPFormsManager::getInstance()->setFocus(pBusca,&*tTrem->ItinerarioTrem->Movimentos->operator[](i));
                tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->SetTremSelecionado();
                TTPFormsManager::getInstance()->SetMovimentoTremSelecionado(&*tTrem);
                setFocus           = true;
                tPrimeiroMovimento = NULL;
                break;

              };
            }
          }
        }
        if(tPrimeiroMovimento || tTrem->Prefixo == pBusca)
        {
          break;
        }
      }
    }
    if (tPrimeiroMovimento && (pLancarExcecao || !tPrimeiroMovimento->Trem->IsSuprimido))
    {
      edtPesquisar->Clear();
      TTPFormsManager::getInstance()->setFocus(pBusca,&*tPrimeiroMovimento);
      tPrimeiroMovimento->Serie->SetTremSelecionado();
      achou = true;
      setFocus = true;
    }

      if (tTrem && (tTrem->Prefixo == pBusca || tTrem->Tabela == pBusca))
      {
        FExecutouResetPosicao_ = false;
        //verifica se o movimento inicial do trem  maior que o limite do grfico
        //se sim pergunta se o usurio deseja alterar a data de partida
        if(tTrem->ItinerarioTrem->GetMovimento(0) != NULL)
        {
          if(tTrem->ItinerarioTrem->GetMovimento(0)->DataChegada>TTPFormsManager::getInstance()->DataLimiteGrafico)
          {
            if (Confirme("A data de partida do Movimento de Origem do trem "+pBusca+" est com data posterior ao limite do Grfico.\nDeseja editar a Data de Partida Movimento de Origem?"))
            {
              EditarMovimentoOrigemTremForaLimiteGrafico(tTrem);
            }
            else
            {
             EnableDisableChart(true);
             return true;
            }
          }
        }

        for (int i = 0; i < chrTTP->SeriesCount(); i++)
        {
          TChartSeries* t_serie = chrTTP->Series[i];
          if (GetTipoSerieMP(t_serie) == tsMovimento && ((TTPMovimentoSeries*)t_serie)->Trem->PID == tTrem->PID)
          {
            ((TTPMovimentoSeries*)t_serie)->SetTremSelecionado();
            setFocus = true;
            break;
          }
        }
        if (!tTrem->IsSuprimido)
          achou = true;
      }

    if (achou)
    {
      String ramal;
      // Verificar a situao dos Trens Suprimidos
      if (this->FTrens_->IndexOf(tTrem->PID) < 0 && tTrem->EstadoTrem != etrPrevisto  && !setFocus)
      {
        // Verificar a situao dos Trens Suprimidos
        if (tTrem->PrimeiroMovimentoPrevisto != NULL)
        {
          if(tTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado
            && tTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->segmentoOcupado
            && tTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->segmentoOcupado->patioPertencente
            && tTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->segmentoOcupado->patioPertencente->sigla ==  tTrem->Destino)
          {
            ramal = " Trem: " + pBusca +
              " encontra-se no destino: " + tTrem->Destino + " Data de Chegada: " + tTrem->PrimeiroMovimentoPrevisto->DataChegada.DateTimeString() ;
            if(!TTPFormsManager::getInstance()->ShowVisualizador)
              Alerta(ramal);
          }
          else
          {
            String localizacao = tTrem->PrimeiroMovimentoPrevisto->SB->Ramal + " - " + tTrem->PrimeiroMovimentoPrevisto->SB->NomeVia;
            ramal = " Trem: " + pBusca +
              " encontra-se em " + localizacao;
            if(!TTPFormsManager::getInstance()->ShowVisualizador)
              Alerta(ramal);
          }
        }
        else
        {
          ramal = " Trem: " + pBusca +
            " encontrado. Porm no possui movimentos planejados (verificar se no encontra-se encerrado).";
          achou = false;
          if(!TTPFormsManager::getInstance()->ShowVisualizador)
          Alerta(ramal);

          FExecutouResetPosicao_ = false;
        }
      }
      else if(setFocus)
      {
        //No faz nada pq j marcou o trem
    }
      else
      {
        String localizacao = "";
        if(tTrem->PrimeiroMovimentoPrevisto != NULL)
        {
          localizacao = tTrem->PrimeiroMovimentoPrevisto->SB->Ramal + " - " + tTrem->PrimeiroMovimentoPrevisto->SB->NomeVia;
          ramal = " Trem: " + pBusca +
          " encontra-se em: " + localizacao;
        }
        else
        {
          int indexUltimo = tTrem->ItinerarioTrem->Movimentos->count() -1;
          TTPMovimentoPtr t_destino =
            tTrem->ItinerarioTrem->Movimentos->operator [](indexUltimo);
          localizacao = t_destino->SB->Ramal + " - " + t_destino->SB->NomeVia;
          ramal = " Trem: " + pBusca +
          " encontra-se no destino: " + localizacao;
        }
        
        if(!TTPFormsManager::getInstance()->ShowVisualizador)
          Alerta(ramal);
      }
    }
    else if (pLancarExcecao)
    {
      Alerta("Trem no localizado!");
      FExecutouResetPosicao_ = false;
      edtPesquisar->SetFocus();
    }
  }

  EnableDisableChart(true);
  return achou;
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::edtPesquisarEnter(TObject *Sender)
{
  // Menus->
  FPopupContexto_ = NULL;
  TTPFormsManager::getInstance()->RetirarSelecao();
  FHabilitarPopup = false;
  acEditarMovimento->Enabled  = FHabilitarPopup;
  acExcluirMovimento->Enabled = FHabilitarPopup;

  acIncluirParada->Enabled = FHabilitarPopup;

  FExecutouResetPosicao_ = false;

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::LimparGrafico()
{
  TCursor t_oldcursor = Screen->Cursor;
  Screen->Cursor      = crHourGlass;

  // #############################################################################
  // Zerar controles para validao pelo usurio
  // #############################################################################
  TTPFormsManager::getInstance()->RetirarSelecao();

  LimparListaConflitos();

  for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
  {
    TChartSeries* t_serie = chrTTP->Series[i];
    if(t_serie == NULL)
      int parar = 0;
    TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);
  if (t_tipo == tsMovimento || t_tipo == tsRestricao || t_tipo == tsPrefixo || t_tipo == tsConflito ||
    t_tipo == tsLinhaTempo)
    RemoverSerieMP(t_serie);
  }
  lblLinhaFerroviaria->Color = clWhite;
  RemoverSerieMP((TChartSeries*&)serieLinhaTempoCongelar_);
  serieLinhaTempoCongelar_ = NULL;

  RemoverSerieMP((TChartSeries*&)serieLinhaTempoAparagarParadas_);
  serieLinhaTempoAparagarParadas_ = NULL;

  // Limpando a lista local de trens
  FTrens_->clear();
  FRestricoes_->clear();
  FPrimeiraRestricao_ = -1;
  Screen->Cursor      = t_oldcursor;
}

// ---------------------------------------------------------------------------
void TFormTP::LimparListaConflitos()
{
  if (FListSBs_ != NULL)
    for (int i = 0; i < FListSBs_->count(); i++)
    {
      TTPSBPtr tSB = FListSBs_->operator[](i);
      tSB->LimparListaOcupacaoSB();
    }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::LimparSeriesObservacao(TTPTrem* pTrem)
{
  TCursor t_oldcursor = Screen->Cursor;
  Screen->Cursor      = crHourGlass;

  TTPFormsManager::getInstance()->RetirarSelecao();

  TTPMovimento* movimento = &*pTrem->ItinerarioTrem->Movimentos->operator[](0);
  while (movimento)
  {
     int index = FSeriesObservacao_->IndexOf(movimento->PID);
     if(index>-1)
     FSeriesObservacao_->Delete(index);

     movimento = movimento->MovimentoPosterior;
   }
  //  t_serie = t_serie->SerieMovimentoPosterior;

  Screen->Cursor = t_oldcursor;
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::LimparTrens()
{
  try
  {
    TCursor t_oldcursor = Screen->Cursor;
    Screen->Cursor      = crHourGlass;

    TTPFormsManager::getInstance()->RetirarSelecao();

    for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
    {
      TChartSeries* t_serie = chrTTP->Series[i];
      TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);

      if (t_tipo == tsPointer || t_tipo == tsPrefixo || t_tipo == tsObservacao || t_tipo == tsConflito)
        RemoverSerieMP(t_serie);
    }

    if (seriesTransposicao_)
    {
      for (int i = 0; i < seriesTransposicao_->Count; i++)
      {
        delete(TTPMovimentoSeries*)seriesTransposicao_->Objects[i];
        seriesTransposicao_->Objects[i] = NULL;
      }

      delete seriesTransposicao_;
      seriesTransposicao_ = NULL;
      seriesTransposicao_ = new TStringList();
    }

    // Limpando a lista local de trens
    if (!FTrens_.isNull() && FTrens_->count() > 0)
      FTrens_->clear();

    LimparListaConflitos();
    FSeriesObservacao_->Clear();

    Screen->Cursor = t_oldcursor;

  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao Finalizar Planejamento");
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::cboTipoTremChange(TObject *Sender)
{
  filtrou_ = true;
  if (cboTipoTrem->ItemIndex == -1)
    cboTipoTrem->Text = "TIPO TREM";
  acFiltrarTrens->Execute();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::cboEstadoTremChange(TObject *Sender)
{
  filtrou_ = true;
  if (cboEstadoTrem->ItemIndex == -1)
    cboEstadoTrem->Text = "ESTADO TREM";

  acFiltrarTrens->Execute();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::pmnRestricoesPopup(TObject *Sender)
{
  acEditarRestricao->Enabled  = FHabilitarPopup;
  acExcluirRestricao->Enabled = FHabilitarPopup;
  bool tTemRestricoesDinamicas    = false;
  bool tTodasRestricoesDinamicas  = true;
  bool tTemDataMaximaAtiva        = false;
  bool tTremRetencao              = false;

  if (FHabilitarPopup && FSerieRestricaoSelecionada_)
  {
    acAtivaDesativaDataMaxFimRestricao->Checked = false;
    //acAtivaDesativaDataFimFixa->Checked = false;

    if(FSeriesRestSelecionadas_->Count > 0)
    {
      for(int i=0; i<FSeriesRestSelecionadas_->Count; i++ )
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        if(restSel->Restricao->Trem != NULL)
          tTemRestricoesDinamicas = true;

        if(tTodasRestricoesDinamicas && restSel->Restricao->Trem == NULL)
          tTodasRestricoesDinamicas = false;

        if(restSel->Restricao->ISDataMaxFimAtiva)
        {
          acAtivaDesativaDataMaxFimRestricao->Checked = true;
          tTemDataMaximaAtiva = true;
        }
        if(!restSel->Restricao->Tipo->ISPararTrem || restSel->Restricao->ISIniciada()
            || restSel->Restricao->ISEncerrada() || restSel->Restricao->ISRestricaoInconsistente)
        {
          acAjustarRestricaoAoTremDinamico->Enabled = false;
        }

        if(restSel->Restricao->RetencaoServer &&
            restSel->Restricao->RetencaoServer->getClassType() == RestricaoSB::RestricaoClassType::RETENCAOSB)
        {
          tTremRetencao = true;
        }
      }
    }
    else
    {
      if(tTodasRestricoesDinamicas && FSerieRestricaoSelecionada_->Restricao->Trem == NULL)
        tTodasRestricoesDinamicas = false;

      if(FSerieRestricaoSelecionada_->Restricao->Trem != NULL)
        tTemRestricoesDinamicas = true;

	  acAjustarRestricaoAoTremDinamico->Enabled = FHabilitarPopup && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem
            && !FSerieRestricaoSelecionada_->Restricao->ISIniciada() && !FSerieRestricaoSelecionada_->Restricao->ISEncerrada()
            && !!FSerieRestricaoSelecionada_->Restricao->ISRestricaoInconsistente;
    }
  }

  acAjustarRestricaoAoTremDinamico->Enabled = FHabilitarPopup;
  acLimparTremRestricaoDinamica->Enabled = (FHabilitarPopup && tTodasRestricoesDinamicas);

  acLimparTremRestricaoDinamica->Enabled = (FHabilitarPopup && tTodasRestricoesDinamicas);
  acAtivaDesativaDataMaxFimRestricao->Enabled = acAjustarRestricaoAoTremDinamico->Enabled && acLimparTremRestricaoDinamica->Enabled && !tTremRetencao;
  acAdicionarTempoDataMaxRestricao->Enabled = acAjustarRestricaoAoTremDinamico->Enabled  && acLimparTremRestricaoDinamica->Enabled && !tTremRetencao;
  acReduzirTempoDataMinRestricao->Enabled = acAjustarRestricaoAoTremDinamico->Enabled  && acLimparTremRestricaoDinamica->Enabled && !tTremRetencao;
  //acAtivaDesativaDataFimFixa->Enabled = acAjustarRestricaoAoTremDinamico->Enabled  && acLimparTremRestricaoDinamica->Enabled;
  acRestaurarDuracaoOriginal->Enabled = acAjustarRestricaoAoTremDinamico->Enabled  && acLimparTremRestricaoDinamica->Enabled && !tTemDataMaximaAtiva && !tTremRetencao;
  acSetDuracaoRestricao->Enabled = acAjustarRestricaoAoTremDinamico->Enabled  && acLimparTremRestricaoDinamica->Enabled;

  acAjustarRestricaoAoTrem->Enabled = FHabilitarPopup && !tTemRestricoesDinamicas && !acAtivaDesativaDataMaxFimRestricao->Enabled;

  acRemoverTrensRetencao->Enabled = FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->RetencaoServer && FSerieRestricaoSelecionada_->Restricao->ListaTrensDesconsiderar->Count==0  && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPermiteOcupacao && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem;
  acRemoverTrensRetencao->Visible = FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->RetencaoServer && FSerieRestricaoSelecionada_->Restricao->ListaTrensDesconsiderar->Count==0  && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPermiteOcupacao && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem;

  acLimparTrensRemovidosRetencao->Enabled = FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->RetencaoServer && !acRemoverTrensRetencao->Enabled && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPermiteOcupacao && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem;
  acLimparTrensRemovidosRetencao->Visible = FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->RetencaoServer && !acRemoverTrensRetencao->Enabled && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPermiteOcupacao && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem;

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::FormClose(TObject *Sender, TCloseAction &Action)
{
  Action = caFree;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acInicializarExecute(TObject *Sender)
{

  FPageControl      = ((TFormPrincipal*)Owner)->pc;

  lblLinhaFerroviaria->Caption = FRamal_->Nome;

  Inicializar(FRamal_);

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acProgramarExecute(TObject *Sender)
{

  if(FArrastoSeries_ && FArrastoSeries_->SerieMovimento)
	{
	  return;
	}

  if(FProgramando)
  {
  //  Alerta("A funo de Programar foi chamada multiplas vezes, favor aguarde alguns segundos antes do prximo acionamento");
    return;
  }
  else
  {
    FProgramando = true;
  }

  bool lockMutex = false;
  TCursor t_oldcursor      = Screen->Cursor;
  try
  {
  TTPFormsManager::getInstance()->tryLockMutexProc(60,"Programar :Tente novamente em alguns segundos","Programar");
  }catch(...)
  {
  FProgramando = false;
  }
  lockMutex = true;
  TTPFormsManager::getInstance()->gravarLog("acProgramarExecute Mutex: lock");
  try
  {
    try
    {
      TTPFormsManager::getInstance()->FecharFormsAbertos();
      TTPFormsManager::getInstance()->TrensOrdemAlterada->Clear();

      TTPFormsManager::getInstance()->EnableDisableTeechart(false);
      Application->ProcessMessages();
      TTPFormsManager::getInstance()->AjustarEstadoControles(false);
      Application->ProcessMessages();

      int tIDRamalTravar = -1;
      String nomeRamalTravado = "";
      Screen->Cursor = crHourGlass;

      TTPFormsManager::getInstance()->MinimizeOtherCharts(this);

      if(chkTravar->Checked)
      {
        tIDRamalTravar = FRamal_->Numero;
        nomeRamalTravado = FRamal_->Nome;
      }
      bool isExibicaoProgresso = algorithm::CoreTMPlanner::getInstance()->getParamByName("EXIB_PRGR_PGMC", "SISTEMA") == "TRUE";
      int timeoutCancelamento = algorithm::CoreTMPlanner::getInstance()->getParamByName("TP_MIN_CANC_PGMC", "SISTEMA").ToIntDef(0);

    //  TTPFormsManager::getInstance()->AntialiasONOFF(false);
      bool tCongelarLinha = serieLinhaTempoCongelar_->DataCongelada > TTPFormsManager::getInstance()->Data;
      // Se a data est congelada, verifica se houve alterao da mesma para evitar setar no server desnecessariamente mais de uma vez
      if (tCongelarLinha && TTPFormsManager::getInstance()
        ->DataProgramacaoCongelada == serieLinhaTempoCongelar_->DataCongelada)
      {
        tCongelarLinha = false;
      }
      else if (tCongelarLinha) // Se no cancelou o flag...
      {
        TTPFormsManager::getInstance()->DataProgramacaoCongelada = serieLinhaTempoCongelar_->DataCongelada;
        TTPFormsManager::getInstance()->IsDataProgramacaoCongelada = true;
      }
      // Se voltou a linha do congelamento, seta novamente a data atual no server
      else if (TTPFormsManager::getInstance()->IsDataProgramacaoCongelada)
      {
        tCongelarLinha = true;
        TTPFormsManager::getInstance()->IsDataProgramacaoCongelada = false;
        serieLinhaTempoCongelar_->DataCongelada = TTPFormsManager::getInstance()->Data;
        TTPFormsManager::getInstance()->DataProgramacaoCongelada = serieLinhaTempoCongelar_->DataCongelada;
      }

      TTheadResultado *tResult = new TTheadResultado();
  #ifndef MODO_MULT_THREAD
      this->ThreadProgramarTrens(tCongelarLinha, tResult, tIDRamalTravar);
  #else

  //    boost:: thread threadProc(&this->ThreadProgramarTrens, tCongelarLinha, tResult, tIDRamalTravar);
      boost::shared_ptr<boost::thread> threadProc(new boost::thread(&this->ThreadProgramarTrens, tCongelarLinha, tResult, tIDRamalTravar));

      UpdateStatusProgramando(threadProc,isExibicaoProgresso,timeoutCancelamento,nomeRamalTravado);
      threadProc->join();

  #endif
      if (tResult->Status == terSucesso)
      {
        utils::TULog::getInstance()->SaveLog("Plotando;"+TTPFormsManager::getInstance()->Mesa,utils::ltStart);
        Aguarde("Plotando Grfico",false);
    //    TTPFormsManager::getInstance()->AntialiasONOFF(false);
        // Movido para c pois no pode ser chamado pela Thread secundria
        TTPFormsManager::getInstance()->RetirarSelecaoZerarParadas();

        // Lugar Antigo

        PlotarTrens();
        TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
        TTPFormsManager::getInstance()->AtualizarLinhaCongelamento();
        TTPFormsManager::getInstance()->ServerSetSelecionar(true);
        TTPFormsManager::getInstance()->VerificarConflitos();
        TTPFormsManager::getInstance()->AjustarPrefixos();
  //      CloseAguarde();
        StopAguarde();
      }
      else
      {
        Screen->Cursor = t_oldcursor;
        Alerta(tResult->ListaResultados->Text);
      }
      TTPFormsManager::getInstance()->AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);
      delete tResult;
      Screen->Cursor = t_oldcursor;
    }
    catch (Exception &e)
    {
      Screen->Cursor = t_oldcursor;
      throw;
    }
  }
  __finally
  {


    chrTTP->UndoZoom();

    Application->ProcessMessages();
    RestaurarChart();
    Sleep(1000);
    utils::TULog::getInstance()->SaveLog("Plotando;"+TTPFormsManager::getInstance()->Mesa,utils::ltEnd);
    TTPFormsManager::getInstance()->EnableDisableTeechart(true);
    TTPFormsManager::getInstance()->AjustarEstadoControles(true);

    FProgramando = false;
    if(lockMutex)
    {
      TTPFormsManager::getInstance()->gravarLog("acProgramarExecute Mutex: UNlock");
      TTPFormsManager::getInstance()->MutexProc->unlock();
    }
  }
}

// ---------------------------------------------------------------------------
void TFormTP::AjustarPrefixos(bool inZoomed)
{
  for (int i = 0; i < chrTTP->SeriesCount(); i++)
  {
    TChartSeries* t_serie = chrTTP->Series[i];
    if (GetTipoSerieMP(t_serie) == tsPrefixo)
    {
      double pontoVisivelX = DBL_MIN;
      double pontoVisivelY = DBL_MIN;

      TTPPrefixoSeries* t_seriePrefixo = ((TTPPrefixoSeries*)t_serie);

      if ((inZoomed) && (t_seriePrefixo->Posicao != ppZoom))
        continue;

      if ((!inZoomed) && (t_seriePrefixo->Posicao == ppZoom))
      {
        t_seriePrefixo->Marks->Visible = false;
        continue;
      }

      TTPMovimentoSeries* t_seriePosterior = t_seriePrefixo->PrimeiraSerieTrecho;
      //while (t_seriePosterior) // Pegar  o 1. ou a ultimo ponto de serie visivel
//      {
//				int indexOf = chrTTP->SeriesList->IndexOf(t_seriePosterior);
//        if (indexOf > -1 && PontoVisivel(t_seriePosterior->CalcXPos(0), t_seriePosterior->CalcYPos(0)))
//        {
//          pontoVisivelX = t_seriePosterior->XValue[0];
//          pontoVisivelY = t_seriePosterior->YValue[0];
//          if (t_seriePrefixo->Posicao == ppInicio)
//            break;
//				}
        //t_seriePosterior = t_seriePosterior->SerieMovimentoPosterior(NULL);
//          for(int i = 0; i < t_seriePosterior->XValues->Count
//                      && i < t_seriePosterior->YValues->Count; i++)

          int i=0;
          bool isVisivel = false;
          for(i = 0; i < t_seriePosterior->XValues->Count
                    && i < t_seriePosterior->YValues->Count; i++)
          {
            if(PontoVisivel(t_seriePosterior->CalcXPos(i), t_seriePosterior->CalcYPos(i)))
            {
              isVisivel = true;
              break;
            }
          }

          if(isVisivel)
          {
            pontoVisivelX = t_seriePosterior->XValue[i];
            pontoVisivelY = t_seriePosterior->YValue[i];
          }



      //}

      if (pontoVisivelX != DBL_MIN) // Se existe ponto visvel...
      {
        double X1 = t_seriePrefixo->XValue[0];
        double Y1 = t_seriePrefixo->YValue[0];

        t_seriePrefixo->XValue[0] = pontoVisivelX;
        t_seriePrefixo->YValue[0] = pontoVisivelY;
        if (!inZoomed)
        {
          t_seriePrefixo->VisivelParaImpressao = true;
          CorrigirSobreposicaoPrefixo(t_seriePrefixo);
        }
        else
        {
          t_seriePrefixo->Marks->Visible = true;
        }
      }
      else if (!inZoomed) // Se no existe ponto visvel
      {
        t_seriePrefixo->Marks->Visible = false;
      }
    }
  }
}

// ---------------------------------------------------------------------------
void TFormTP::DesfazerAjustarPrefixos()
{
  int i = 0;
  try
  {

  for (i = 0; i < chrTTP->SeriesCount(); i++)
  {
    TChartSeries* t_serie = chrTTP->Series[i];

    if (t_serie != NULL && GetTipoSerieMP(t_serie) == tsPrefixo)
    {
      TTPPrefixoSeries* t_seriePrefixo = ((TTPPrefixoSeries*)t_serie);

      if (t_seriePrefixo->Posicao == ppZoom)
      {
        t_seriePrefixo->Marks->Visible = false;
      }

      TTPMovimentoSeries* t_seriePosterior = t_seriePrefixo->PrimeiraSerieTrecho;
      if(!t_seriePrefixo->PrimeiraSerieTrecho)
      {
        continue;
      }
      // if( ( FParametros.ExibePrefixoInicio ) &&   (t_seriePrefixo->Posicao == ppInicio) )
      {
        t_seriePrefixo->XValue[0]      = t_seriePosterior->XValue[0];
        t_seriePrefixo->YValue[0]      = t_seriePosterior->YValue[0];
        t_seriePrefixo->Marks->Visible = true;
      }
      if (t_seriePrefixo->Posicao == ppFim)
        // ( FParametros.ExibePrefixoFinal ) &&   (t_seriePrefixo->Posicao == ppFim) )
      {
        TTPMovimentoSeries* t_seriePosteriorUltima = t_seriePrefixo->PrimeiraSerieTrecho;
//				while (t_seriePosterior)
//				{
//          t_seriePosteriorUltima = t_seriePosterior;
//					t_seriePosterior       = t_seriePosterior->SerieMovimentoPosterior;
//				}

        t_seriePrefixo->XValue[0] = t_seriePosteriorUltima->getUltimaChegadaCoord().x;
        t_seriePrefixo->YValue[0]      = t_seriePosteriorUltima->getUltimaChegadaCoord().y;
        t_seriePrefixo->Marks->Visible = true;
      }
    }
  }
  }catch(...)
  {
     i = 0;
  }
}

// ---------------------------------------------------------------------------
// Mtodo que verifica a visibilidade do ponto no grfico.
bool TFormTP::PontoVisivel(double pX, double pY)
{
  if ((pY > chrTTP->ChartRect.Top) && (pY < chrTTP->ChartRect.Bottom) && (pX > chrTTP->ChartRect.left) && (pX <
    chrTTP->ChartRect.Right))
  {
    return true;
  }
  return false;
}

// ---------------------------------------------------------------------------
void TFormTP::CorrigirSobreposicaoPrefixo(TTPPrefixoSeries *pnovaSerie)
{
  TXStringList* listaPrefixoSeries = new TXStringList();

  //Application->ProcessMessages();
  if (pnovaSerie->Marks != NULL && pnovaSerie->Marks->Positions != NULL && pnovaSerie->Marks->Positions->Position[0]
    == NULL)
    return;

  for (int i = 0; i < chrTTP->SeriesCount(); i++)
  {
    TChartSeries* t_serie = chrTTP->Series[i];

    if ((GetTipoSerieMP(t_serie) == tsPrefixo) && (((TTPPrefixoSeries*) t_serie)->VisivelParaImpressao) &&
      (pnovaSerie != t_serie)&& ((TTPPrefixoSeries*) t_serie)->Trem !=  pnovaSerie->Trem)
    {
      listaPrefixoSeries->AddObject(IntToStr(i), (TObject*)t_serie);
    }
  }

  TTime t_tCalculo = Time();
  TTime t_tEspera = StrToTime("00:01:05");
  for (int i = 0; i < listaPrefixoSeries->Count; i++)
  {
    TChartSeries* t_serie = (TChartSeries*)listaPrefixoSeries->Objects[i];
    if(pnovaSerie != t_serie)
    {
      int deslocamentoY = -2;
      if ((Y1(pnovaSerie)) < (chrTTP->ChartRect.Top + chrTTP->ChartRect.Height() / 2))
        deslocamentoY = 4;

      int deslocamentoX = 4;
      if ((X1(pnovaSerie)) < (chrTTP->ChartRect.Left + chrTTP->ChartRect.Width() / 2))
        deslocamentoX = -4;
      bool passouY = false;
     if(PontoVisivel(X1(pnovaSerie), Y1(pnovaSerie)))
     {
        while((X1(pnovaSerie)>=X1(t_serie) && Y1(pnovaSerie) >= Y1(t_serie) &&
               X1(pnovaSerie)<=X2(t_serie) && Y1(pnovaSerie) <= Y2(t_serie)) ||
              (X2(pnovaSerie)>=X1(t_serie) && Y1(pnovaSerie) >= Y1(t_serie) &&
              X2(pnovaSerie)<=X2(t_serie) && Y1(pnovaSerie) <= Y2(t_serie)) ||
              (X1(pnovaSerie)>=X1(t_serie) && Y2(pnovaSerie) >= Y1(t_serie) &&
               X1(pnovaSerie)<=X2(t_serie) && Y2(pnovaSerie) <= Y2(t_serie)) ||
              (X2(pnovaSerie)>=X1(t_serie) && Y1(pnovaSerie) >= Y1(t_serie) &&
              X2(pnovaSerie)<=X2(t_serie) && Y1(pnovaSerie) <= Y2(t_serie)))
        {
          pnovaSerie->Marks->Positions->Position[0]->Custom = true;

          if (!passouY)
          {
            pnovaSerie->Marks->Positions->Position[0]->LeftTop.y += deslocamentoY;
            if(!PontoVisivel(X1(pnovaSerie), Y1(pnovaSerie)))
            {
               break;
            }
          }
          else
          {
            pnovaSerie->Marks->Positions->Position[0]->LeftTop.x += -(deslocamentoX);
            if(!PontoVisivel(X1(pnovaSerie), Y1(pnovaSerie)))
            {
               break;
            }
          }

          passouY = !passouY;

          i = 0;
        }

         if(!PontoVisivel(X1(pnovaSerie), Y1(pnovaSerie)))
          {
             if(passouY)
             pnovaSerie->Marks->Positions->Position[0]->LeftTop.x -= -(deslocamentoX);
             else
             pnovaSerie->Marks->Positions->Position[0]->LeftTop.y -= deslocamentoY;
             break;
          }
      }
    }
  }
  delete listaPrefixoSeries;
  listaPrefixoSeries = NULL;

  // pnovaSerie->Repaint();
  // pnovaSerie->Marks->Positions->Position[0]->Custom = false;  //pnovaSerie->Marks->Positions->Position[0]->Custom = false;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acAjustarPrefixosExecute(TObject *Sender)
{
  // AjustarPrefixos(FISZoomed_);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acFiltrarTrensExecute(TObject *Sender)
{

  if ((cboTipoTrem->ItemIndex != -1 && cboTipoTrem->Text != "") || cboEstadoTrem->ItemIndex != -1 || filtrou_)
  {

    for (int i = 0; i < FTrens_->count(); i++)
    {
      TTPTremPtr t_Trem = FTrens_->get(i);

      bool liberado = true;

      if (cboTipoTrem->ItemIndex != -1 && cboTipoTrem->Text != "")
      {
        if (t_Trem->TipoTrem->Nome != cboTipoTrem->Text)
          liberado = false;
      }

      if (cboEstadoTrem->ItemIndex != -1 && cboEstadoTrem->ItemIndex + 1 != (int)t_Trem->EstadoTrem)
        liberado = false;

      /* PENDENCIA - Quando uma mesma srie aparecer em mais de um painel diferente, o filtro de outra poder afetar a exibio do trem no outro painel */
      if (liberado)
      {
        for (int i = 0; i < t_Trem->ItinerarioTrem->Movimentos->count(); i++)
        {
          if (this->FListSBs_->get(t_Trem->ItinerarioTrem->Movimentos->operator[](i)->SB->NomeVia) != NULL)
          {
            if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)
              ->Serie != NULL && t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->IsPlotada)
              t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->Visible = true;
            if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo != NULL && chrTTP->SeriesList->IndexOf
              (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo) > -1)
              t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo->Visible = true;
            if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie != NULL )
              {
                t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->SetObservacoesVisible(true);
              };

            break;
          }
        }
      }
      else
      {
        for (int i = 0; i < t_Trem->ItinerarioTrem->Movimentos->count(); i++)
        {
          if (!this->FListSBs_->get(t_Trem->ItinerarioTrem->Movimentos->operator[](i)->SB->NomeVia).isNull())
            if (!t_Trem->ItinerarioTrem->Movimentos->operator[](i).isNull())
            {
              if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)
                ->Serie != NULL && t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->IsPlotada)
                t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->Visible = false;
              if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo != NULL && chrTTP->SeriesList->IndexOf
                (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo) > -1)
                t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Prefixo->Visible = false;
              if (t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie != NULL )
                {
                t_Trem->ItinerarioTrem->Movimentos->operator[](i)->Serie->SetObservacoesVisible(false);
                };

              break;
            }
        }
      }
    }
    filtrou_ = false;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::edtPesquisarExit(TObject *Sender)
{
  acProgramar->Visible = true;
  if (edtPesquisar->Text == "")
    edtPesquisar->Clear();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acMovimentosTremExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TFormMovimentosTrem *formMovimentos = new TFormMovimentosTrem(this, FSerieMovimentoSelecionada_->Trem,
      &*FSerieMovimentoSelecionada_->Movimento);
    formMovimentos->Show();
    AddFormAberto(formMovimentos);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acPriorizarDestinosExecute(TObject *Sender)
{
  #ifdef BAIXADA_SANTISTA
  if(TTPFormsManager::getInstance()->ShowVisualizador)
  {
    TFormPriorizarDestinos *frmPriorizarDestinos = new TFormPriorizarDestinos(this, TTPFormsManager::getInstance()->getListaOficializacoesViewer());
    frmPriorizarDestinos->ShowModal();
    AddFormAberto(frmPriorizarDestinos);
  }
  else
  {
    TFormPriorizarDestinos *frmPriorizarDestinos = new TFormPriorizarDestinos(this);
    frmPriorizarDestinos->ShowModal();
    AddFormAberto(frmPriorizarDestinos);
  }
  #endif
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acFichaTremExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TFormFichaTrem *formFicha = new TFormFichaTrem(this, FSerieMovimentoSelecionada_->Trem,
    FSerieMovimentoSelecionada_);
    formFicha->ShowModal();
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acCriarAtividadeExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* t_trem          = FSerieMovimentoSelecionada_->Trem;
    TTPMovimento* tMovimento = FSerieMovimentoSelecionada_->Movimento;
    TFormCriarAtividadeTrem *criarAtividade;

    getTremFilho(t_trem);

    if (!FSerieMovimentoSelecionada_->TemAtividade())
    {
      if(tMovimento->ServerSegTremOficializado || tMovimento->ServerSegTremRealizado)
        return;

      criarAtividade = new TFormCriarAtividadeTrem(this, t_trem, &*tMovimento, TTPFormsManager::getInstance()->SBs);
    }
    else
    {
      criarAtividade = new TFormCriarAtividadeTrem(this,
        t_trem->Atividades->operator[](FSerieMovimentoSelecionada_->IndiceAtividade()),
        TTPFormsManager::getInstance()->SBs);
    }

   TTPMovimentoSeries* serieSelecionada = FSerieMovimentoSelecionada_;
   if (criarAtividade->ShowModal() == mrOk)
    {
      if (serieSelecionada->Movimento->ServerSegTremPlanejado)
        serieSelecionada->Movimento->ServerSegTremPlanejado->trem->getUltimoMovimento()
          ->getPeriodoOcupacao();

      TTPFormsManager::getInstance()->PlotarTrem(t_trem, false, false, true, !FTremFilho_);
      if(!PlotarTremFilho(t_trem) && FTremFilho_)
        TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

      acVerificarConflitosExecute(this);
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acAtividadesTremExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
   TTPMovimentoSeries* serieSelecionada = FSerieMovimentoSelecionada_;


    getTremFilho(serieSelecionada->Trem);

    TFormAtividadesTrem *atividades = new TFormAtividadesTrem(this, serieSelecionada->Trem,
      &*serieSelecionada->Movimento, TTPFormsManager::getInstance()->SBs);

    atividades->ShowModal();
    if (atividades->FAtualiazarTrem)
    {
      TTPTrem* t_trem = serieSelecionada->Trem;

      if (serieSelecionada->Movimento->ServerSegTremPlanejado)
        serieSelecionada->Movimento->ServerSegTremPlanejado->trem->getUltimoMovimento()
          ->getPeriodoOcupacao();

      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer(serieSelecionada->Trem);

      TTPFormsManager::getInstance()->PlotarTrem(t_trem, false, false, true, !FTremFilho_);
      if(!PlotarTremFilho(t_trem) && FTremFilho_)
        TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();


      acVerificarConflitosExecute(this);
    }

    delete atividades;
    atividades = NULL;
  }
}
// ---------------------------------------------------------------------------


// ---------------------------------------------------------------------------

void __fastcall TFormTP::preencherFilas()
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  Filas_ = core->getFilas();
   TTPFormsManager::getInstance()->FParametros.listaFilasInativas->Clear();
     TTPFormsManager::getInstance()->FParametros.listaFilasAtivas->Clear();

      for (int i = 0; i < Filas_->Count; i++)
      {
        domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)Filas_->Objects[i];
        domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
        if (t_segmento->codZonaControleResponsavel == TTPFormsManager::getInstance()->Mesa)
        {
          if(t_filaMalha->isAtiva()==true)
          {
            TTPFormsManager::getInstance()->FParametros.listaFilasAtivas->Add(t_filaMalha->getPatioDestino()->sigla);
          }else
          {

            TTPFormsManager::getInstance()->FParametros.listaFilasInativas->Add(t_filaMalha->getPatioDestino()->sigla);
            if (!t_filaMalha->dataExpiracao.is_not_a_date_time())
            TTPFormsManager::getInstance()->FParametros.dtExpiracao = t_filaMalha->dataExpiracao.asDateTime() ;

          }
        }
      }
}



// ---------------------------------------------------------------------------
void __fastcall TFormTP::acExibirParametrosExecute(TObject *Sender)
{

  TFormParametrosSistema* formParametros = new TFormParametrosSistema(this);
  try
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    formParametros->chkExibirRealizadoReal->Checked = TTPFormsManager::getInstance()->FParametros.ExibirRealizadoReal;
    formParametros->chkExibirDeteccaoConflitos->Checked =
      TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos;
    formParametros->chkAtivarAntialias->Checked      = TTPFormsManager::getInstance()->FParametros.AtivarAntialias;
    formParametros->chkExibirHints->Checked          = TTPFormsManager::getInstance()->FParametros.ExibirHints;
    formParametros->chkExibirCargaDescarga->Checked  = TTPFormsManager::getInstance()->FParametros.ExibirCargaDescarga;
    formParametros->chkParametroOperacional->Checked =
      TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais;
    //formParametros->chkDesativarCalculoFila->Checked = !CheckFilasAtivas();
    formParametros->chkIsCarregarOrdemGatilho->Checked = core->getIsCarregarOrdemGatilho();
    TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio = CheckGatilhoVazio();
    formParametros->chkIsCalculoVelocidadeAtivo->Checked = core->getIsCalculoVelocidadeAtivo();
    //preencher as filas

     preencherFilas();
      formParametros->FdataExpiracao_ = TTPFormsManager::getInstance()->FParametros.dtExpiracao;
     formParametros->carregarListaFilas(TTPFormsManager::getInstance()->FParametros.listaFilasAtivas,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);


    // TTPFormsManager::getInstance()->FParametros.DasativarCalculoFilas;
    formParametros->chkDesativarCadenciaVazio->Checked = TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio;
    if (formParametros->ShowModal() == mrOk)
    {
      TTPFormsManager::getInstance()->FParametros.ExibirRealizadoReal = formParametros->chkExibirRealizadoReal->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos =
        formParametros->chkExibirDeteccaoConflitos->Checked;
      TTPFormsManager::getInstance()->FParametros.AtivarAntialias = formParametros->chkAtivarAntialias->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirHints = formParametros->chkExibirHints->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirCargaDescarga = formParametros->chkExibirCargaDescarga->Checked;
      TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais =
        formParametros->chkParametroOperacional->Checked;
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      core->setUtilizarParamentroOperacionalCapacidadeTerminal(formParametros->chkParametroOperacional->Checked);

      if(formParametros->chkIsCalculoVelocidadeAtivo->Checked != TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo)
      {
        core->setIsCalculoVelocidadeAtivo(formParametros->chkIsCalculoVelocidadeAtivo->Checked);
        TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo = core->getIsCalculoVelocidadeAtivo();
        TTPFormsManager::getInstance()->SincronizarTodosTrensClientServer();
      }
      if (formParametros->chkDesativarCadenciaVazio->Checked !=  TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio)
      {
        DesativarGatilhoVazio(formParametros->chkDesativarCadenciaVazio->Checked);
      }
      TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio = formParametros->chkDesativarCadenciaVazio->Checked ;
      core->setIsCarregarOrdemGatilho(formParametros->chkIsCarregarOrdemGatilho->Checked);
      TTPFormsManager::getInstance()->FParametros.CarregarOrdemGatilho = core->getIsCarregarOrdemGatilho();

      AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);

      core->manterEstadoFilas(false,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);
      core->manterEstadoFilas(true,TTPFormsManager::getInstance()->FParametros.listaFilasAtivas);

      TTPFormsManager::getInstance()->AtualizarStatusFarolParametros();
      TTPFormsManager::getInstance()->SincronizarTodosTrensClientServer();
      // acPlotarAtualizar->Execute();
    }
  }
  __finally
  {
    if (formParametros)
    {
      delete formParametros;
      formParametros = NULL;
    }
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acVerificarConflitosExecute(TObject *Sender)
{
  TTPMovimentoSeries* tSerieMovimentoSelecionada = FSerieMovimentoSelecionada_;
  if (TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos)
  {
    //TTPFormsManager::getInstance()->RetirarSelecao();

    for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
    {
      TChartSeries* t_serie = chrTTP->Series[i];
      TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);

      if (t_tipo == tsConflito)
      {
        RemoverSerieMP(t_serie);
      }
    }

    for (int i = 0; i < FListSBs_->count(); i++)
    {
      TTPSBPtr sbConflito    = FListSBs_->operator[](i);
      TXStringList *periodos = sbConflito->VerificarConflito();

      if (periodos->Count > 0)
      {
        for (int i = 0; i < periodos->Count; i++)
        {
          timeTP::PeriodTP *periodo = (timeTP::PeriodTP*)periodos->Objects[i];
          timeTP::TimeTP inicio     = periodo->begin();
          timeTP::TimeTP fim        = periodo->end();

          TTPSBConflitoSeries* t_conflitoSerie = new TTPSBConflitoSeries(chrTTP, inicio.asDateTime(), fim.asDateTime(),
            sbConflito->IndexGraficoS, sbConflito->IndexGraficoI); ;
          chrTTP->AddSeries(t_conflitoSerie);
        }

        int t_totalSeries = chrTTP->SeriesCount();
        int index = 0;
        for (int i = 0; i < t_totalSeries; i++)
        {
          TChartSeries* t_serie = chrTTP->Series[i];
          TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);
          if (t_tipo == tsMovimento && index == 0)
            index = i;

          if (t_tipo == tsConflito && index > 0)
          {
            chrTTP->ExchangeSeries(i, index);
            index++;
          }
        }
      }
      if (periodos)
      {
        delete periodos;
        periodos = NULL;
      }
    }
  }
  FSerieMovimentoSelecionada_ = tSerieMovimentoSelecionada;
}

// ---------------------------------------------------------------------------
void TFormTP::AntialiasONOFF(bool pOnOff)
{
 // if (!FISZoomed_)
 // chrTTP->Enabled = pOnOff;

  TeeGDIPlus1->Antialias = pOnOff;
  TeeGDIPlus1->Active    = pOnOff;

   chrTTP->AutoRepaint = false;
   chrTTP->AutoRepaint = true;
}

// ---------------------------------------------------------------------------
void TFormTP::AjustarEstadoControles(bool pOnOff)
{
  TActionListState state = al->State;
  al->State              = asNormal;
  bool isCarregado = !TTPFormsManager::getInstance()->IsPrimeiroCarregamento;

  if (pOnOff)
  {
    acCarregar->ShortCut           = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;
    acProgramar->ShortCut          = shortCutProgramar > 0 && isCarregado ? shortCutProgramar : acProgramar->ShortCut;
    acPublicarEntreMesas->ShortCut = shortCutPublicar > 0 && isCarregado ? shortCutPublicar : acPublicarEntreMesas->ShortCut;
  }
  else
  {
    shortCutCarregar  = acCarregar->ShortCut > 0 ? acCarregar->ShortCut : shortCutCarregar;
    shortCutProgramar = acProgramar->ShortCut > 0 ? acProgramar->ShortCut : shortCutProgramar;
    shortCutPublicar  = acPublicarEntreMesas->ShortCut > 0 ? acPublicarEntreMesas->ShortCut : shortCutPublicar;
    // shortCutOficializar;
    acProgramar->ShortCut          = NULL;
    acPublicarEntreMesas->ShortCut = NULL;
    acCarregar->ShortCut           = NULL;

//    if(FormWidgetGridAtividadesAlteradas)
//    {
//     delete FormWidgetGridAtividadesAlteradas;
//     FormWidgetGridAtividadesAlteradas = NULL;
//    }
  }


  acCarregar->Enabled                  = pOnOff;
  pOnOff = pOnOff && isCarregado;

  acProgramar->Enabled = pOnOff;
  acPesquisarPrefixo->Enabled          = pOnOff;
  acRestaurarTremNaoPlanejado->Enabled = pOnOff;
  acRestringir->Enabled                = pOnOff;
  acInterditar->Enabled                = pOnOff;
  acReter->Enabled                     = pOnOff;
  acRetencaoDinamica->Enabled          = pOnOff;
  acCriarTrem->Enabled                 = pOnOff;
  acSelecionar->Enabled                = pOnOff;
  acSelecionarRestricao->Enabled       = pOnOff;
  acVisao->Enabled                     = pOnOff;
  acPublicarEntreMesas->Enabled        = pOnOff;
  acGradeDeTrens->Enabled              = pOnOff;
  acFilasTerminais->Enabled            = pOnOff;
  acZerarParadasTrens->Enabled         = pOnOff;
  acEntreMesasOficializado->Enabled    = pOnOff;
  acEntreMesasAutomatico->Enabled      = pOnOff;
  acAcionarAutomatico->Enabled         = pOnOff;

  acAtividadesTrem->Enabled     = pOnOff;
  acCriarAtividade->Enabled     = pOnOff;
  acPriorizarMovimentos->Enabled     = pOnOff;
  acLimparMovimentosPriorizados->Enabled     = pOnOff;
  acReexibirMovimentos->Enabled     = pOnOff;
  acZerarParadasTrem->Enabled     = pOnOff;
  acZerarParadasOcultandoMovimentos->Enabled     = pOnOff;
  acEditarTrem->Enabled     = pOnOff;

  acOcupacaoPatios->Enabled = pOnOff;

  AjustarEstadoControleSinalizadorInconsistenciaFila(pOnOff);

  acExibirParametros->Enabled = true;

  AjustarEstadoControleOficializar();
  AjustarEstadoControleMovimentosOficializadosEntreMesas();

  acParametrosAtivos->Enabled = true;
  acParametrosDesativadosTpExp->Enabled = true;
  acParametrosDesativados->Enabled = true;
  acParametrosVazio->Enabled = true;

  al->State = state;

  // acOficializar->Enabled = true; //teste Carmo Merge

}

// ---------------------------------------------------------------------------
void TFormTP::AjustarEstadoControleOficializar(bool pForcarDesabilitar)
{

  FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

  TActionListState state = al->State;
  al->State              = asNormal;
  if (pForcarDesabilitar || (FPlanoInicializado && TTPGerenteProgramacao::getInstance()
    ->ProgramacaoEmCurso.mesa != TTPFormsManager::getInstance()->Mesa))
  {
    tbtnPlanejamentoOnOff->Action = acIniciarPlanejamento;
    acOficializar->Enabled        = false;
    acOficializarTrem->Enabled    = false;
    acPublicarEntreMesas->Enabled = false;
  }
  else
  {
    if (FPlanoInicializado)
    {
      tbtnPlanejamentoOnOff->Action    = acFinalizarPlanejamento;
      acFinalizarPlanejamento->Enabled = true;
      acIniciarPlanejamento->Enabled   = false;
    }
    else
    {
      tbtnPlanejamentoOnOff->Action    = acIniciarPlanejamento;
      acFinalizarPlanejamento->Enabled = false;
      acIniciarPlanejamento->Enabled   = true;
    }

    if (pForcarDesabilitar)
    {
      acIniciarPlanejamento->Enabled   = true;
      acFinalizarPlanejamento->Enabled = true;
    }

    acOficializar->Enabled = FPlanoInicializado && TTPFormsManager::getInstance()->Trens->count() > 0;
    acOficializarTrem->Enabled = acOficializar->Enabled;
    String cadeadoTravaEntreMesas = algorithm::CoreTMPlanner::getInstance()->getParamByName("CPTO_TRAVA_ENTRE_MESAS");
    if ( cadeadoTravaEntreMesas.UpperCase()!="TRUE")
    {
      acPublicarEntreMesas->Enabled = FPlanoInicializado && TTPFormsManager::getInstance()->Trens->count() > 0;
    }
  }

  al->State = state;
}

// ---------------------------------------------------------------------------
void TFormTP::AjustarEstadoControleSinalizadorInconsistenciaFila(bool pHabilitar, bool pChecarTodosForms)
{
  this->acListarAderenciaFila->Enabled = pHabilitar && (TTPFormsManager::getInstance()->TrensAderenciaFila->Count >
    0 || TTPFormsManager::getInstance()->TrensForaOrdemFila->Count > 0);
  if (pChecarTodosForms)
		TTPFormsManager::getInstance()->AjustarEstadoControleSinalizadorInconsistenciaFila(pHabilitar);

}

// ---------------------------------------------------------------------------
String TFormTP::getNomeRamal()
{
  if (FRamal_)
    return FRamal_->Nome;
  else
    return "";
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::tmrMouseMovePrefixoTimer(TObject *Sender)
{
  //removido
      }
// ---------------------------------------------------------------------------

void TFormTP::ShowHint(double pX, double pY)
{
  /*Deprecado*/
}

// ---------------------------------------------------------------------------
void TFormTP::ShowHint(String pPrefixo, String pSB, String pAtividade, String pDataFim, String pDuracao, double pX,
  double pY)
{
  /*Deprecado*/
}

// ---------------------------------------------------------------------------
void TFormTP::HideHint()
{
  //pnlHintPrefixo->Hide();
}

// ---------------------------------------------------------------------------
void TFormTP::AjustarLinhaTempo()
{
  if (FISZoomed_)
  {
    chrTTP->UndoZoom();
  }

  TDateTime dataHoraSistema = TTPFormsManager::getInstance()->Data;
  TP_->Hora                 = System::Dateutils::TimeOf(dataHoraSistema);
  PlotarLinhaTempo();
  /*
   double inicio = TP_->Data; // (TP_->Data + TP_->Hora) - (UMAHORA * 1.5);
   chrTTP->BottomAxis->SetMinMax(inicio, inicio + UMDIA);
   chrTTP->TopAxis->SetMinMax(inicio, inicio + UMDIA);
   */
  

  FVisaoPlajemanto_ = false;
  acVisao->OnExecute(this);

  ConfigurarChartsLimitesHorizontaisDefault();

  FIsCtrlA_ = true;
  ScrollTo(NULL, 0);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acOficializarExecute(TObject *Sender)
{
  bool lockMutex = false;
  TCursor t_oldcursor = Screen->Cursor;
  try
  {
    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Oficializar :Tente novamente em alguns segundos","Oficializar");
    TTPFormsManager::getInstance()->LimparXmlPublicacaoTrens();
    lockMutex = true;
    TTPFormsManager::getInstance()->gravarLog("acOficializarExecute Mutex: lock");

    tbtOficializar->Visible = true;

    TTPFormsManager::getInstance()->FecharFormsAbertos();
    Application->ProcessMessages();
    Application->ProcessMessages();
    TTPFormsManager::getInstance()->EnableDisableTeechart(false);
    Application->ProcessMessages();
    TTPFormsManager::getInstance()->AjustarEstadoControles(false); // desabilita os botes

    if (Confirme("Confirma a oficializao da : " + TTPFormsManager::getInstance()->Mesa + "?"))
    {
      Screen->Cursor = crHourGlass;

      TStringList * lstErros = NULL;

      if (!TTPGerenteProgramacao::getInstance()->validarOficializacao(lstErros,
        TTPFormsManager::getInstance()->DataProgramacaoCongelada, TTPFormsManager::getInstance()->Trens))
      {
        Screen->Cursor = t_oldcursor;
        Application->ProcessMessages();
        TTPFormsManager::getInstance()->AjustarEstadoControles(true);
        TTPFormsManager::getInstance()->EnableDisableTeechart(true);
        TTPFormsManager::getInstance()->gravarLog("acOficializarExecute Mutex: UNlock");
        TTPFormsManager::getInstance()->MutexProc->unlock();
        if (lstErros)
          delete lstErros;
        return;
      }

      if (lstErros != NULL && lstErros->Count > 0)
      {
        Screen->Cursor                      = t_oldcursor;
        TFormResultadoProcessos *fResultado = new TFormResultadoProcessos(this, lstErros);
        fResultado->Caption                 = "Divergncia dos trens programados OptimOre";
        fResultado->ShowModal();

        FExecutouResetPosicao_ = false;

        if (!Confirme("Deseja continuar a oficializao ?"))
        {
          Application->ProcessMessages();
          TTPFormsManager::getInstance()->AjustarEstadoControles(true);
          TTPFormsManager::getInstance()->EnableDisableTeechart(true);
          TTPFormsManager::getInstance()->gravarLog("acOficializarExecute Mutex: UNlock");
          TTPFormsManager::getInstance()->MutexProc->unlock();
          if (lstErros)
            delete lstErros;
          return;
        }
        Screen->Cursor = crHourGlass;
      }
     if (lstErros)
          delete lstErros;
      //variavl para controlar se vai tentar ao novamente
      bool tentarOficializar = true;
      while(tentarOficializar)
      {
      TTheadResultado *tResult = new TTheadResultado();
#ifndef MODO_MULT_THREAD
      this->ThreadOficializar(tResult);
#else
      boost:: thread threadProc(&this->ThreadOficializar, tResult);
      Aguarde("Oficializando plano");  // Aps 30 segundos, vai habiliar o ESC do Aguar
      threadProc.join();
#endif

	  if (tResult->Resultado.Length() > 0 && !AguardeGetCancelUserRequest())
	  {
		String msgErro = "Oficializao realizada parcialmente. Os serguintes trens apresentaram problemas: \n" +
		  tResult->Resultado;
          if (tResult->Resultado.Pos("ORA-30006")) // ORA-30006: recurso ocupado; aquisio com timeout WAIT exibe mensagem e tenta ao novamente aps tempo
        {
          String msgLock = TDAO::getMensagemLockUnicidade(algorithm::CoreTMPlanner::getInstance()->DB_SCHEMA);
          msgErro =
              "Oficializao no iniciaizada.\nGentileza aguardar 1 minuto e oficialize o plano novamente.\nCaso o erro persista por mais de 10 minutos, acionar pronto atendimento com as seguintes informaes:\n\nInformao TI: \n -ERRO: "+tResult->Resultado+"\n"+msgLock;
           tentarOficializar = InformacaoTimer(msgErro,"Oficializar") == rtiRestart;
        }
          else
          {
        Informacao(msgErro);
            //erro comum pode parar de tentar oficilizar/publicar
            tentarOficializar = false;
      }
        }
        else
      {
          if(!AguardeGetCancelUserRequest())
          {
        Informacao("Oficializao realizada com sucesso!");

      }
          //cancelou ou conseguiu oficilizar/publicar pode parar de tentar novamente a ao
          tentarOficializar = false;
        }

        delete tResult;
        tResult = NULL;
      }

      TTPFormsManager::getInstance()->tmrAtualizarOcializacao->Interval = 100;
      TTPFormsManager::getInstance()->tmrAtualizarOcializacao->Enabled = true;

      Screen->Cursor = t_oldcursor;
    }
  }
  catch (Exception& e)
  {
    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }
  if(lockMutex)
  {
  TTPFormsManager::getInstance()->gravarLog("acOficializarExecute Mutex: UNlock");
  TTPFormsManager::getInstance()->MutexProc->unlock();
  }
  Application->ProcessMessages();
  TTPFormsManager::getInstance()->AjustarEstadoControles(true);
  TTPFormsManager::getInstance()->EnableDisableTeechart(true);
  TTPFormsManager::getInstance()->AtualizarStatusFarolParametros();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acZerarParadasTremExecute(TObject * Sender)
{

  TTPMovimentoSeries *tSerieSelecionada = FSerieMovimentoSelecionada_;

  if (FSerieMovimentoSelecionada_ != NULL )//&& FSerieMovimentoSelecionada_->Movimento->ServerSegTremPlanejado != NULL)
  {
    // FSerieMovimentoSelecionada_->Movimento->ServerSegTremPlanejado->zerarTemposMovimentosSolicitadoUsuario();
    TTPTrem* t_trem = FSerieMovimentoSelecionada_->Trem;
    getTremFilho(t_trem);

    timeTP::TimeTP tempo(boost::posix_time::not_a_date_time);

    TTPMovimento* tMovimentoNegocio       = FSerieMovimentoSelecionada_->Movimento;
    TTPMovimento* tUltimoMovimentoNegocio = NULL;

    if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      tMovimentoNegocio->ServerSegTremPlanejado->zerarTemposMovimentosSolicitadoUsuario();

    // Faremos o primeiro loop somente setando a data do arrasto nulo
    while (tMovimentoNegocio)
    {
      if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      {
        tMovimentoNegocio->ServerSegTremPlanejado->setDataPartidaUsuario(tempo);
      }
      tUltimoMovimentoNegocio = tMovimentoNegocio;
      tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
    }
    // Pede o perodo de ocupao do ltimo moviemtno para recalcular no Server
    if (tUltimoMovimentoNegocio->ServerSegTremPlanejado != NULL)
      tUltimoMovimentoNegocio->ServerSegTremPlanejado->getPeriodoOcupacao();

    tMovimentoNegocio = FSerieMovimentoSelecionada_->Movimento;
    if (tMovimentoNegocio->MovimentoAnterior != NULL)
      tMovimentoNegocio = tMovimentoNegocio->MovimentoAnterior;
    // Seta nos cliente os valores dos movimento do Server
    String tNovaSB = "";
    while (tMovimentoNegocio)
    {
      if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      {
        tNovaSB = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
        if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
          tMovimentoNegocio->SB = TTPFormsManager::getInstance()->SBs->get(tNovaSB);

        if (tMovimentoNegocio->MovimentoPosterior != NULL)
        {
          tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
          if(tMovimentoNegocio->ServerSegTremPlanejado)
          tNovaSB           = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
          if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
            tMovimentoNegocio->SB = TTPFormsManager::getInstance()->SBs->get(tNovaSB);
        }
      }
      tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
    }

    t_trem                      = FSerieMovimentoSelecionada_->Trem;
    #ifdef BAIXADA_SANTISTA
     TTPFormsManager::getInstance()->SincronizarTremClientServer(t_trem);
    #endif
    TTPFormsManager::getInstance()->PlotarTrem(&*TTPFormsManager::getInstance()->Trens->get(t_trem->PID), false,
      false, true, !FTremFilho_);

    if(!PlotarTremFilho(t_trem) && FTremFilho_)
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

    acVerificarConflitosExecute(this);
    FSerieMovimentoSelecionada_ = NULL;
   // FSerieMovimentoSelecionada_->SetMovimentoSelecionado(true);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acReexibirMovimentosExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
//		TTPMovimentoSeries *tSerie = FSerieMovimentoSelecionada_->SerieMovimentoPosterior;
//    while (tSerie)
//		{
//      tSerie->Visible = true;
//      tSerie          = tSerie->SerieMovimentoPosterior;
//		}
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acZerarParadasOcultandoMovimentosExecute(TObject *Sender)
{
  acZerarParadasTrem->OnExecute(this);
  if (FSerieMovimentoSelecionada_ != NULL)
  {
//		TTPMovimentoSeries *tSerie = FSerieMovimentoSelecionada_->SerieMovimentoPosterior;
//    while (tSerie)
//		{
//      tSerie->Visible = false;
//      tSerie          = tSerie->SerieMovimentoPosterior;
//    }

    FSerieMovimentoSelecionada_->Visible = false;
  }
}
// ---------------------------------------------------------------------------

void TFormTP::AtualizarSaidaTremArrastoMouse(bool pParar, bool pShift)
{
  //movimentos oficializados no contem o segmento planejado do server, logo no pode ser arrastado
  if(FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado==NULL)
  return;

  bool Shift                     = pShift;
  bool parar                     = pParar;
  bool propagarDestino           = true; // FArrastoSeries_->SerieMovimento->XValue[1] > FArrastoSeries_->XValue[0];
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TDateTime tDataSaida           = NULL;

  // S propaga para ORIGEM se parada
  // if (!propagarDestino && !parar)
  propagarDestino = true;

  double t_diferenca = FArrastoSeries_->SerieMovimento->XValue[FArrastoSeries_->SerieMovimento->PontosPlotados - 1] -
    FArrastoSeries_->XValue[0];
  TDateTime t_diferencaDT = t_diferenca;

  TTPMovimentoSeries* serieMovimento         = NULL;
  TTPMovimentoSeries* serieMovimentoAnterior = NULL;

  TTPMovimento* movimento;

  if ((FTipoArrasto_ == taFimCurso) && (!Shift && !(FArrastoSeries_->XValue[0] <
    FArrastoSeries_->SerieMovimento->XValue[0])))
  {
    if (FArrastoSeries_->SerieMovimento != NULL)
    {
      FArrastoSeries_->SerieMovimento->XValue[FArrastoSeries_->SerieMovimento->PontosPlotados - 1] = FArrastoSeries_->XValue[0];
      FArrastoSeries_->SerieMovimento->Movimento->DataSaida = FArrastoSeries_->XValue[0];
      tDataSaida = FArrastoSeries_->XValue[0];

    serieMovimento = FArrastoSeries_->SerieMovimento;
      if (tDataSaida <=
        serieMovimento->Movimento->DataChegada && serieMovimento->Movimento->ServerSegTremPlanejado != NULL)
      {
        serieMovimento->Movimento->ServerSegTremPlanejado->setDataPartidaUsuario
          (boost::posix_time::time_from_string("1900-01-01 00:00:00"));
      }
      else if (serieMovimento->Movimento->ServerSegTremPlanejado != NULL)
      {
        String nomeSb = core->AlterarDataPartidaMovimento(serieMovimento->Movimento->ServerSegTremPlanejado,
        tDataSaida)->sb;
        String nomeSbOld = serieMovimento->Movimento->SB->NomeVia;
        if (nomeSbOld != nomeSb)
          TrocarSBMovimento(serieMovimento->Movimento, nomeSb);
      }

      // if (FArrastoSeries_->SerieMovimento->SerieMovimentoPosterior != NULL)
      // serieMovimento = FArrastoSeries_->SerieMovimento->SerieMovimentoPosterior->SerieMovimentoPosterior;
    }
  }
  else if (FTipoArrasto_ == taSaida)
  {
    FArrastoSeries_->SerieMovimento->XValue[FArrastoSeries_->SerieMovimento->PontosPlotados-1] = FArrastoSeries_->XValue[0];
    // Ajustando a data do objeto de negcio
    FArrastoSeries_->SerieMovimento->Movimento->DataSaida = FArrastoSeries_->XValue[0];
    tDataSaida                                            = FArrastoSeries_->XValue[0];
    if (tDataSaida <= FArrastoSeries_->SerieMovimento->Movimento->DataChegada &&
      FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado != NULL)
    {

      FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado->setDataPartidaUsuario
        (boost::posix_time::time_from_string("1900-01-01 00:00:00"));
      FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado->trem->getUltimoMovimento()
        ->getPeriodoOcupacao();
    }
    else
    {
      String nomeSb = "";
      if (FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado != NULL)
      {
        nomeSb = core->AlterarDataPartidaMovimento(FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado,
          tDataSaida)->sb;
        FArrastoSeries_->SerieMovimento->Movimento->ServerSegTremPlanejado->trem->getUltimoMovimento()
          ->getPeriodoOcupacao();
      }
      String nomeSbOld = FArrastoSeries_->SerieMovimento->Movimento->SB->NomeVia;
      if (nomeSbOld != nomeSb)
        TrocarSBMovimento(FArrastoSeries_->SerieMovimento->Movimento, nomeSb);
    }

//		if (FArrastoSeries_->SerieMovimento->SerieMovimentoAnterior(NULL) != NULL)
//      serieMovimentoAnterior = FArrastoSeries_->SerieMovimento->SerieMovimentoAnterior;
//    if (FArrastoSeries_->SerieMovimento->SerieMovimentoPosterior != NULL)
//      serieMovimento = FArrastoSeries_->SerieMovimento->SerieMovimentoPosterior;
  }
  else if (FTipoArrasto_ == taChegada)
  {
  if (FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior != NULL)
      {
      if (FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->ServerSegTremPlanejado)
        {
//				if(FArrastoSeries_->SerieMovimento->MovimentoAnterior->PontosPlotados>0)
//				{
//					FArrastoSeries_->SerieMovimento->MovimentoAnterior->XValue
//					[FArrastoSeries_->SerieMovimento->MovimentoAnterior->PontosPlotados-1] = FArrastoSeries_->XValue[0];
//				}

        FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior->DataSaida = FArrastoSeries_->XValue[0];
        tDataSaida = FArrastoSeries_->XValue[0];

        movimento = FArrastoSeries_->SerieMovimento->Movimento->MovimentoAnterior;
        if (tDataSaida <=
          movimento->DataChegada && movimento->ServerSegTremPlanejado != NULL)
        {
          movimento->ServerSegTremPlanejado->setDataPartidaUsuario
            (boost::posix_time::time_from_string("1900-01-01 00:00:00"));
        }
        else if (movimento->ServerSegTremPlanejado != NULL)
        {
          String nomeSb = core->AlterarDataPartidaMovimento(movimento->ServerSegTremPlanejado,
            tDataSaida)->sb;
          String nomeSbOld = movimento->SB->NomeVia;
          if (nomeSbOld != nomeSb)
            TrocarSBMovimento(movimento, nomeSb);
        }

//				if (FArrastoSeries_->SerieMovimento->SerieMovimentoAnterior->SerieMovimentoAnterior != NULL)
//          serieMovimento = FArrastoSeries_->SerieMovimento->SerieMovimentoAnterior->SerieMovimentoAnterior;
      }
    }
  }
  // Sincronizar Trens Client / Server
  TTPFormsManager::getInstance()->SincronizarTremClientServer(FArrastoSeries_->SerieMovimento->Trem);
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::acExcluirTremExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;
    TTPFormsManager::getInstance()->gravarLog("acExcluirTremExecute " + tTrem->PID);
    TTPFormsManager::getInstance()->ExcluirTrem(&*tTrem);
    TTPFormsManager::getInstance()->VerificarConflitos();
  }
}

// ---------------------------------------------------------------------------
void TFormTP::ExcluirTrem(TTPTrem* pTrem, TTPTipoExclusaoTrem pTipoExcluscao)
{
  try
  {
    if(t_seriesGlobal->SeriesHint)
  {
    t_seriesGlobal->SeriesHint = NULL;
    t_seriesGlobal->clearHint(NULL);
  }

    // Se no for suprimir
    if (pTipoExcluscao == texSuprimir)
    {
      if(FMovimentoSelecionado_ != NULL)
      {
        TTPMovimentoSeries *serieASerLimpa = FMovimentoSelecionado_->Serie;
        TTPFormsManager::getInstance()->RemoverSerieMP((TChartSeries*&)FMovimentoSelecionado_->Serie);
        pTrem->ItinerarioTrem->LimparSerieMovimentos(FMovimentoSelecionado_->Serie);
        delete serieASerLimpa;
      }
    }
    if (pTipoExcluscao == texParcial)
    {
      FTrens_->remove(pTrem->PID);
    }
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::acSuprimirTremExecute(TObject *Sender)
{
  TCursor t_oldcursor = Screen->Cursor;
  bool lockMutex = false;
  TTPFormsManager::getInstance()->gravarLog("--> Inicia Suprimir Trem");
  try
  {
    Screen->Cursor = crHourGlass;
    
    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Suprimir Trem:Tente novamente em alguns segundos","Suprimir Trem");

    lockMutex = true;
    if (FSerieMovimentoSelecionada_ != NULL)
    {
      if (TTPFormsManager::getInstance()->TrensSuprimidos->IndexOf(FSerieMovimentoSelecionada_->Trem->PID) > -1)
        throw Exception("O trem j encontra-se suprimido!");
      else
      {
        TTPTrem* tTrem     = FSerieMovimentoSelecionada_->Trem;
        tTrem->IsSuprimido = true;
        TTPFormsManager::getInstance()->gravarLog("acSuprimirTremExecute " + tTrem->PID);
        TTPFormsManager::getInstance()->TrensSuprimidos->add(FSerieMovimentoSelecionada_->Trem->PID,
          TTPFormsManager::getInstance()->Trens->get(FSerieMovimentoSelecionada_->Trem->PID));

        algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
        core->ExcluirTrem(FSerieMovimentoSelecionada_->Trem->PID);

        TTPFormsManager::getInstance()->ExcluirTrem(tTrem, texSuprimir);
        if(tTrem->PrimeiroMovimentoPrevisto && tTrem->PrimeiroMovimentoPrevisto->Serie)
          FSerieMovimentoSelecionada_ = tTrem->PrimeiroMovimentoPrevisto->Serie;
        else
          FSerieMovimentoSelecionada_ = NULL;

       //	acAtualizarTremExecute(Sender);

        TTPFormsManager::getInstance()->PlotarTrem(tTrem);
      }
    }
    acVerificarConflitosExecute(this);
    TTPFormsManager::getInstance()->MutexProc->unlock();
    Screen->Cursor = t_oldcursor;
	TTPFormsManager::getInstance()->gravarLog("--> Fim Suprimir Trem");
  }
  catch (Exception &e)
  {
    if(lockMutex)
      TTPFormsManager::getInstance()->MutexProc->unlock();

    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRestaurarTremExecute(TObject *Sender)
{
  TCursor t_oldcursor = Screen->Cursor;
  bool lockMutex = false;
  try
  {
    Screen->Cursor = crHourGlass;

    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Restaurar Trem:Tente novamente em alguns segundos","Restaurar Trem");

    lockMutex = true;
    if (FSerieMovimentoSelecionada_ != NULL || FMovimentoSelecionado_!=NULL)
    {
      TTPTrem* tTrem = (FSerieMovimentoSelecionada_ != NULL) ?
                        FSerieMovimentoSelecionada_->Trem:
                        FMovimentoSelecionado_->Trem;

      getTremFilho(tTrem);

      String tPIDTremRest = tTrem->PID;

      TTPFormsManager::getInstance()->ExcluirTrem(tTrem, texRePlotar);

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      core->RestaurarTrem(tPIDTremRest, "");

      tTrem->IsSuprimido = false;
      TTPFormsManager::getInstance()->TrensSuprimidos->remove(tPIDTremRest);

      tTrem = &*TTPFormsManager::getInstance()->RecriarTremCliente
        (&*TTPFormsManager::getInstance()->Trens->get(tPIDTremRest));
      TTPFormsManager::getInstance()->PlotarTrem(tTrem, true, false, false, !FTremFilho_);

      if(!PlotarTremFilho(tTrem) && FTremFilho_)
        TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();


      acVerificarConflitosExecute(this);
      if(tTrem->PrimeiroMovimentoPrevisto)
      {
      FMovimentoSelecionado_=tTrem->PrimeiroMovimentoPrevisto;
      FSerieMovimentoSelecionada_ = tTrem->PrimeiroMovimentoPrevisto->Serie;
    }
      else
      {
        FMovimentoSelecionado_ = NULL;
        FSerieMovimentoSelecionada_ = NULL;
  }
    }

    TTPFormsManager::getInstance()->MutexProc->unlock();
    Screen->Cursor = t_oldcursor;
  }
  catch (Exception &e)
  {
    if(lockMutex)
      TTPFormsManager::getInstance()->MutexProc->unlock();

    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acEditarMovimentoOrigemExecute(TObject *Sender)
{
  try
  {
    if (FSerieMovimentoSelecionada_ != NULL)
    {

      FEditandoOrigem_ = true;
      if (FSerieMovimentoSelecionada_->Trem->PossuiMovimentoRealizado)
        throw Exception("O trem j est em circulao!");

      TTPMovimentoSeries* t_movimento = FSerieMovimentoSelecionada_;
      t_movimento->MovimentoOrigem();
      if(t_movimento->MovimentoOrigem())
        FEditandoOrigem_ = true;

      FSerieMovimentoSelecionada_->Movimento->MovimentoSelecionado = true;
      acEditarMovimento->OnExecute(this);
      FEditandoOrigem_ = false;
    }
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}

// ---------------------------------------------------------------------------
// Mtodo criado para removier a srie de prefixo e movimentos de transposio
// de um determinado trem
void TFormTP::RemoverSeriesPrefixoTransposicao(TTPTrem* pTrem, bool pSuprimir)
{
  try
  {
    // Removendo srie transposicao
    if (!pSuprimir)
    {
      if (seriesTransposicao_)
      {
        TStringList* tSeriesExcluir = new TStringList();

        for (int i = 0; i < seriesTransposicao_->Count; i++)
        {
          TTPMovimentoSeries* tSerie = (TTPMovimentoSeries*)seriesTransposicao_->Objects[i];
          if (tSerie->Trem->PID == pTrem->PID)
          {
            int indexOf = chrTTP->SeriesList->IndexOf(tSerie);
            if (indexOf > -1)
            {
              chrTTP->RemoveSeries(tSerie);
              tSeriesExcluir->AddObject("", tSerie);
            }
          }
        }
        delete tSeriesExcluir;
        tSeriesExcluir = NULL;
      }
    }

    // Removendo prefixos
    // Limpar Prefixo Trem
    for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
    {
      TChartSeries* t_serie    = chrTTP->Series[i];
      TTPTipoSerie t_tipoSerie = GetTipoSerieMP(t_serie);

      // PREFIXO
      if (t_tipoSerie == tsPrefixo)
      {
    if (((TTPPrefixoSeries*)t_serie)->Trem->Prefixo == pTrem->Prefixo)
        {
          RemoverSerieMP(t_serie);
          break;
        }
      }
    }
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::acPriorizarMovimentosExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    // Pegando os movimentos selecionados
    TStringList* movimentosSelecionados = new TStringList();
    for (int i = 0; i < FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->Movimentos->count(); i++)
    {
      TTPMovimentoPtr tMovimento = FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->Movimentos->operator[](i);
      if (tMovimento->Serie && tMovimento->MovimentoSelecionado)
      {
        movimentosSelecionados->Add(tMovimento->PID);
      }
    }

    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;
    if (movimentosSelecionados->Count < 2)
    {
      delete movimentosSelecionados;
      movimentosSelecionados = NULL;
    }

    TFormPriorizacaoMovimentos *priorizacao = new TFormPriorizacaoMovimentos(this, tTrem, FRamal_,
      &*FSerieMovimentoSelecionada_->Movimento, movimentosSelecionados);

    priorizacao->ShowModal();
    {
      if (FSerieMovimentoSelecionada_ != NULL)
      {
        FSerieMovimentoSelecionada_->Movimento->MovimentoSelecionado = false;
        FSerieMovimentoSelecionada_                       = NULL;
      }
    }

    delete priorizacao;
    priorizacao = NULL;

    if (movimentosSelecionados)
    {
      delete movimentosSelecionados;
      movimentosSelecionados = NULL;
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acEditarTremExecute(TObject *Sender)
{

  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* tTrem                   = FSerieMovimentoSelecionada_->Trem;
    TFormCriarTrem* t_formEditarTrem = new TFormCriarTrem(this, tTrem, this->FListSBs_,
      TTPFormsManager::getInstance()->SBs, &*FSerieMovimentoSelecionada_->Movimento);

    getTremFilho(tTrem);

    if (t_formEditarTrem->ShowModal() == mrOk)
    {
      if (t_formEditarTrem->chkAlterarItinerario->Checked)
      {
        TTPFormsManager::getInstance()->ExcluirTrem(tTrem, texRePlotar);
        TTPTremPtr tTremPtr = TTPFormsManager::getInstance()->RecriarTremCliente(tTrem);
        tTremPtr->ItinerarioTrem->ISAlteradoUsuario = true;
        TTPFormsManager::getInstance()->PlotarTrem(&*tTremPtr, true);
      }
      else
      {
        if (tTrem->ItinerarioTrem->Movimentos->operator[](tTrem->ItinerarioTrem->TotalMovimentos - 1)
          ->ServerSegTremPlanejado != NULL)
          tTrem->ItinerarioTrem->Movimentos->operator[](tTrem->ItinerarioTrem->TotalMovimentos - 1)
            ->ServerSegTremPlanejado->getPeriodoOcupacao();

        TTPFormsManager::getInstance()->PlotarTrem(&*tTrem, false, false, true, !FTremFilho_);
        if(!PlotarTremFilho(tTrem) && FTremFilho_)
          TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

      }

    }

    delete t_formEditarTrem;
    t_formEditarTrem = NULL;
  }
}

// ---------------------------------------------------------------------------
bool TFormTP::TrocarSBMovimento(TTPMovimento* pMovimento, String pNovaSB)
{
  try
  {
    TTPSBPtr tSB = NULL;
    int indexOf  = FListSBs_->IndexOf(pMovimento->SB->NomeVia);
    if (indexOf > -1)
    {
      tSB = this->FListSBs_->operator[](indexOf);
      tSB->RemoverOcupacaoSB(pMovimento->Serie->Trem->PID + pMovimento->PID);
      tSB->RemoverMovimentosSB(pMovimento->Serie->Trem->PID + pMovimento->PID);

    }

    pMovimento->SB = TTPFormsManager::getInstance()->SBs->get(pNovaSB);

    tSB     = NULL;
    indexOf = FListSBs_->IndexOf(pNovaSB);
    if (indexOf > -1 && pMovimento->ServerSegTremPlanejado != NULL)
    {
      tSB                       = FListSBs_->operator[](indexOf);
      timeTP::PeriodTP *periodo = new timeTP::PeriodTP(*pMovimento->ServerSegTremPlanejado->getPeriodoOcupacao());
      if(!pMovimento->ServerSegTremPlanejado->isCancelarOcupacaoViaCadastroSegmento())
        tSB->AdicionarOcupacaoSB(pMovimento->Serie->Trem->PID + pMovimento->PID, periodo);
    }

    return true;
  }
  catch (Exception &e)
  {
    return false;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acRestaurarTremNaoPlanejadoExecute(TObject *Sender)
{
  try
  {
    FPerdeuFocus_ = true;
    using namespace domain;

    String tPrefixo = edtPesquisar->Text;

    if (PesquisarPrefixo(tPrefixo, false))
    {
      return;
    }

    //buscando pela tabela no executa a busca pra restaurar o trem
    //pois uma tabela pode pertencer a mais de um trem
    if(tPrefixo.Length()<7)
    {
      Alerta("Tabela " + tPrefixo + " no localizada!");
      return;
    }

    EnableDisableChart(false);

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    TStringList * t_trens           = core->getTrensNaoPlanejados();
    TStringList * t_trensEncntrados = new TStringList();
    TTPTremPtr tTremRecuperado;
    bool achei          = false;
    TremMalha* tremCalc = NULL;

    for (int i = 0; i < t_trens->Count; i++)
    {
      tremCalc = (TremMalha*)t_trens->Objects[i];
      if (tremCalc->prefixoTrem == tPrefixo)
      {
        achei = true;

        // Vamos buscar o trem na lista de suprimidos
        int indexOfSuprimido = TTPFormsManager::getInstance()->TrensSuprimidos->IndexOf(tremCalc->PID);
        if (indexOfSuprimido > -1)
        {
          FExecutouResetPosicao_ = false;
          if (Confirme("O Trem " + tPrefixo +
            " encontra-se suprimido. Deseja restaura-lo para ser programado?"))
          {
            TTPTremPtr tTrem                   = TTPFormsManager::getInstance()->TrensSuprimidos->get(tremCalc->PID);
            int indexOfUtimoMovimento          = tTrem->ItinerarioTrem->Movimentos->count() - 1;
            TTPMovimento* movimento = &*tTrem->ItinerarioTrem->GetPrimeiroMovimentoPrevisto();
            if (movimento->SB && movimento->SB->Ramal == FRamal_->Nome)
            {
              FMovimentoSelecionado_ = movimento;
              acRestaurarTrem->OnExecute(this);
              if(FMovimentoSelecionado_)
              FMovimentoSelecionado_->Serie->SetTremSelecionado(true);
            }
            else
            {
              Alerta("O trem " + tPrefixo + " est no ramal: " + movimento->SB->Ramal +
                ". Para restaura-lo, v para o referido painel e execute este processo novamente.");
            }
            // if(movimento->)
            // movimento
          }
        }
        else if (Confirme("O Trem " + tPrefixo + " no est sendo planejado. Deseja tentar restaura-lo para o plano?"))
        {
          FExecutouResetPosicao_ = false;

          tremCalc = core->RestaurarTrem(tremCalc->PID, "");
          if (tremCalc != NULL)
          {
            tTremRecuperado = TTPFormsManager::getInstance()->Trens->get(tremCalc->PID);
            if (tTremRecuperado != NULL)
            {
              tTremRecuperado = TTPFormsManager::getInstance()->RecriarTremCliente(&*tTremRecuperado);
            }
            else
            {
              tTremRecuperado = TTPFormsManager::getInstance()->CriarTremCliente(tremCalc, NULL, false);
            }

            tTremRecuperado->IsSuprimido = false;
            TTPFormsManager::getInstance()->PlotarTrem(&*tTremRecuperado, true);
            acVerificarConflitosExecute(this);

          }
        }
        break;
      }
    }

    if (!achei)
    {
      tremCalc = core->RestaurarTrem("", tPrefixo);

      FExecutouResetPosicao_ = false;

      if (tremCalc != NULL && !Confirme("O Trem " + tPrefixo +
        " encontra-se suprimido. Deseja restaura-lo para ser programado?"))
      {
        core->ExcluirTrem(tremCalc->PID);
      }
      else if (tremCalc == NULL)
      {
        Alerta("Prefixo " + tPrefixo + " no localizado!");
      }
      else
      {
        tTremRecuperado = TTPFormsManager::getInstance()->Trens->get(tremCalc->PID);
        if (tTremRecuperado != NULL)
        {
          tTremRecuperado = TTPFormsManager::getInstance()->RecriarTremCliente(&*tTremRecuperado);
        }
        else
        {
          tTremRecuperado = TTPFormsManager::getInstance()->CriarTremCliente(tremCalc, NULL, false);
        }

        tTremRecuperado->IsSuprimido = false;
        TTPFormsManager::getInstance()->TrensSuprimidos->remove(tremCalc->PID);
        TTPFormsManager::getInstance()->PlotarTrem(&*tTremRecuperado, true);
        acVerificarConflitosExecute(this);
      }
    }
    else
    {
      edtPesquisar->Clear();
    }

  }
  catch (Exception &e)
  {
    Alerta(e.Message);
    FExecutouResetPosicao_ = false;
  }

  EnableDisableChart(true);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acPublicarEntreMesasExecute(TObject *Sender)
{
  TCursor t_oldcursor = Screen->Cursor;
  bool lockMutex = false;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();


  if(core->getIsCarregandoMetadados())
  {
    TFDadosLoginReconexao *fDados = new TFDadosLoginReconexao(this);
    fDados->ShowModal();

    DB_SCHEMA_MODL   = fDados->edtSchema->Text;
    DB_INSTANCE_MODL = fDados->edtInstance->Text;
    DB_USR_SRV_MODL  = fDados->edtUsuario->Text;
    DB_PWD_CORE_MODL = fDados->edtSenha->Text;

    if(DB_SCHEMA_MODL != "" && DB_INSTANCE_MODL != "" && DB_USR_SRV_MODL != "" && DB_PWD_CORE_MODL != "")
    {

      DModuleMP->ReconectDB(DB_SCHEMA_MODL, DB_INSTANCE_MODL, DB_PWD_CORE_MODL, DB_USR_SRV_MODL);
    }
    else
    {
      throw Exception("Dados de login ivlidos");
    }
    delete fDados;
    fDados = NULL;
  }

  try
  {
    bool tPublicarEntreMesas =   !core->getIsCarregandoMetadados() ? true : (ConfirmeCancelar("O contedo do owner destino ("+ DB_INSTANCE_MODL + " | " + DB_SCHEMA_MODL + ")  ser APAGADO! Deseja continuar?") == mrYes);
    TTPFormsManager::getInstance()->LimparXmlPublicacaoTrens();
    if(tPublicarEntreMesas)
    {
      TTPFormsManager::getInstance()->tryLockMutexProc(60,"Publicar :Tente novamente em alguns segundos","Publicar");

      lockMutex = true;

        if(core->getIsCarregandoMetadados())
        {
           TTheadResultado *tResult = new TTheadResultado();
        #ifndef MODO_MULT_THREAD
            ThreadGravarModelo(tResult);
        #else
            boost::thread threadProc(&this->ThreadGravarModelo, tResult);
            Aguarde("Gravando tabelas Modelo");  // Aps 30 segundos, vai habiliar o ESC do Aguar
            //threadProc.join();
        #endif
        }

        TTPFormsManager::getInstance()->gravarLog("acPublicarEntreMesasExecute Mutex: lock");
        tbtOficializar->Visible = true;

        String msgAcionarAutomatico  = FExibirMsgSalvarAltomatico_ ?
        "Para o acionamento do Automtico  preciso salvar o plano atual. " : "";

        bool tConfirmaPublicacao =   core->getIsCarregandoMetadados() ? true : (Confirme(msgAcionarAutomatico+"Confirma a publicao da : " + TTPFormsManager::getInstance()->Mesa + "?"));
        if (tConfirmaPublicacao)
        {
          FAcionarAutomaticoOk_ = true;
          Screen->Cursor = crHourGlass;
          TTPFormsManager::getInstance()->FecharFormsAbertos();
          Application->ProcessMessages();
          Application->ProcessMessages();
          TTPFormsManager::getInstance()->EnableDisableTeechart(false);
          Application->ProcessMessages();
          TTPFormsManager::getInstance()->AjustarEstadoControles(false);

           //variavl para controlar se vai tentar ao novamente
          bool tentarOficializar = true;
          while(tentarOficializar)
          {
             TTheadResultado *tResult = new TTheadResultado();
    #ifndef MODO_MULT_THREAD
          ThreadPublicarEntreMesas(tResult);
    #else
          boost:: thread threadProc(&this->ThreadPublicarEntreMesas, tResult);
          Aguarde("Publicando entre mesas");  // Aps 30 segundos, vai habiliar o ESC do Aguar
          threadProc.join();
    #endif

          if (tResult->Resultado.Length() > 0 && !AguardeGetCancelUserRequest())
            {
              String msgErro = "Publicao realizada parcialmente. Os serguintes trens apresentaram prloblemas: \n" +
              tResult->Resultado;
              if (tResult->Resultado.Pos("ORA-30006")) // ORA-30006: recurso ocupado; aquisio com timeout WAIT exibe mensagem e tenta ao novamente aps tempo
              {
                String msgLock = TDAO::getMensagemLockUnicidade(algorithm::CoreTMPlanner::getInstance()->DB_SCHEMA);
                msgErro =
                  "Publicao no iniciaizada.\nGentileza aguardar 1 minuto e oficialize o plano novamente.\nCaso o erro persista por mais de 10 minutos, acionar pronto atendimento com as seguintes informaes:\n\nInformao TI: \n -ERRO: "+tResult->Resultado+"\n"+msgLock;
               tentarOficializar = InformacaoTimer(msgErro,"Publicar Entre Mesas") == rtiRestart;
              }
              else
              {
                Informacao(msgErro);
                //erro comum pode parar de tentar oficilizar/publicar
                tentarOficializar = false;
              }

               // Alerta("Publicao realizada parcialmente. Os serguintes trens apresentaram prloblemas: \n" +
                //tResult->Resultado);
             }
            else
            {
              if(!AguardeGetCancelUserRequest())
              {
                Informacao("Oficializao realizada com sucesso!");

              }
              //cancelou ou conseguiu oficilizar/publicar pode parar de tentar novamente a ao
              tentarOficializar = false;
            }

          delete tResult;
          tResult = NULL;
          }
          Screen->Cursor = t_oldcursor;
        }
    }
    else
    {
        this->Close();
    }
  }
  catch (Exception& e)
  {
    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }

  if(lockMutex)
  {
    TTPFormsManager::getInstance()->gravarLog("acPublicarEntreMesasExecute Mutex: UNlock");
    TTPFormsManager::getInstance()->MutexProc->unlock();
  }

  Application->ProcessMessages();
  TTPFormsManager::getInstance()->AjustarEstadoControles(true);
  TTPFormsManager::getInstance()->EnableDisableTeechart(true);
  TTPFormsManager::getInstance()->AtualizarStatusFarolParametros();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acGradeDeTrensExecute(TObject *Sender)
{
  TFormGradeTrens *fGradeTrens = new TFormGradeTrens(this);
  fGradeTrens->CarregarTrens();
  fGradeTrens->Show();
  AddFormAberto(fGradeTrens);
  // delete fGradeTrens;
  // fGradeTrens = NULL;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acZerarParadasTrensExecute(TObject *Sender)
{
  if (acZerarParadasTrens->Checked)
  {
    TTPFormsManager::getInstance()->RemoverSerieMP((TChartSeries*&)serieLinhaTempoAparagarParadas_);
    TTPFormsManager::getInstance()->DataZerarParadasTrem = TTPFormsManager::getInstance()->Data;
    TTPFormsManager::getInstance()->IsZerarParadas = false;
    acZerarParadasTrens->Checked = false;
  }
  else
  {
    double X = System::Dateutils::DateOf(TTPFormsManager::getInstance()->DataProgramacaoCongelada) +
      System::Dateutils::TimeOf(TTPFormsManager::getInstance()->DataProgramacaoCongelada);
    serieLinhaTempoAparagarParadas_ = new TTPLinhaTempoSeries(chrTTP, X, FRamal_->ComprimentoTotal,
      TTPFormsManager::getInstance()->DataProgramacaoCongelada, tslZerarParada);
    chrTTP->AddSeries(serieLinhaTempoAparagarParadas_);
    TTPFormsManager::getInstance()->IsZerarParadas = true;
    acZerarParadasTrens->Checked = true;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acAtualizarTremExecute(TObject *Sender)
{
if (FArrastoSeries_ && FArrastoSeries_->SerieMovimento)
	{
	  return;
	}
  TCursor t_oldcursor = Screen->Cursor;
  bool lockMutex = false;
  try
  {
    Screen->Cursor = crHourGlass;

	TTPFormsManager::getInstance()->tryLockMutexProc(60,"Atualizar Trem :Tente novamente em alguns segundos","Atualizar Trem");

    lockMutex = true;
    String tPID ="";
    if (FSerieMovimentoSelecionada_ != NULL)
    {
      TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;
      if(!tTrem->IsTransiente)
      {
        getTremFilho(tTrem);

        tPID= tTrem->PID;

        TTPFormsManager::getInstance()->ExcluirTrem(tTrem, texRePlotar);
        TTPFormsManager::getInstance()->LimparListasPersistenciaAtividadesTrem(tTrem);
        TStringList *trensAtualizar = new TStringList();
        trensAtualizar->Add(tPID);
        // fechar forms no f5
        TTPFormsManager::getInstance()->FecharFormsAbertos();
        algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
        core->AtualizarTrensDB(trensAtualizar);
        delete trensAtualizar;
        tTrem = &*TTPFormsManager::getInstance()->RecriarTremCliente(tTrem);
        TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

        TTPFormsManager::getInstance()->ValidarOrdemEntregaTrensFila(tTrem->FilaTerminal);
        AjustarEstadoControleSinalizadorInconsistenciaFila(true, true);
        TTPFormsManager::getInstance()->PlotarTrem(tTrem, true, false, true, !FTremFilho_);
        if(!PlotarTremFilho(tTrem) && FTremFilho_)
          TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

        acVerificarConflitosExecute(this);
      }
    }
    TTPFormsManager::getInstance()->gravarLog("acAtualizarTremExecute unlock PID: " + tPID);
    TTPFormsManager::getInstance()->MutexProc->unlock();
    Screen->Cursor = t_oldcursor;
  }
  catch (Exception &e)
  {
    String valor =lockMutex? "T":"F";
    TTPFormsManager::getInstance()->gravarLog("acAtualizarTremExecute Exception: "+e.Message+ " unlock lockMutex: "+valor);
    if(lockMutex)
    TTPFormsManager::getInstance()->MutexProc->unlock();

    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::mniPrefixoDrawItem(TObject *Sender, TCanvas *ACanvas, TRect &ARect, bool Selected)
{
  TMenuItem *MenuItem   = ((TMenuItem*)Sender);
  ACanvas->Font->Style  = TFontStyles() << fsBold;
  ACanvas->Font->Size   = 10;
  ACanvas->Brush->Color = clBtnFace;
  ACanvas->Font->Color  = clWindowText;
  TRect TempRect        = ARect;
  TempRect.Top          = 3;
  DrawText(ACanvas->Handle, MenuItem->Caption.c_str(), MenuItem->Caption.Length(), &TempRect, DT_CENTER);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acGerarPlanilhaEquipagemExecute(TObject *Sender)
{
  try
  {
    FExecutouResetPosicao_ = false;
    if (Confirme("Confirma a gerao da planilha de Equipagem?"))
    {
      Screen->Cursor = crHourGlass;
      TTPGerenteProgramacao::getInstance()->GerarPlanilhaEquipagem();

      Screen->Cursor = crDefault;
    }
  }
  catch (Exception& e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acCriarTremTabelaExecute(TObject *Sender)
{
  acCriarTremTabela->Checked = true;
  acCriarTrem->Checked       = true;
  FMarcarRestricao_          = false;
  FCriandoTremArrasto_       = false;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::edtPesquisarKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  if (Key == 13)
  {
    acRestaurarTremNaoPlanejado->Execute();
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acTrazerPraFrenteExecute(TObject *Sender)
{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    chrTTP->AutoRepaint = true;
    TTPMovimentoSeries* tSerieOrdem = FSerieMovimentoSelecionada_;

    int t_primeiraSerieMovimento = chrTTP->SeriesCount()-1;

    int indexOf = -1;
    indexOf     = chrTTP->SeriesList->IndexOf(FSerieMovimentoSelecionada_);
    if (indexOf > -1)
    {
      chrTTP->ExchangeSeries(indexOf, t_primeiraSerieMovimento);
      t_primeiraSerieMovimento--;
    }

//		if (tSerieOrdem)
//		{
//      indexOf = chrTTP->SeriesList->IndexOf(tSerieOrdem);
//      if (indexOf > -1)
//      {
//        chrTTP->ExchangeSeries(indexOf, t_primeiraSerieMovimento);
//        t_primeiraSerieMovimento--;
//      }
//      tSerieOrdem = tSerieOrdem->SerieMovimentoPosterior;
//    }
//
//    tSerieOrdem = FSerieMovimentoSelecionada_->SerieMovimentoAnterior;
//		if (tSerieOrdem)
//    {
//			indexOf = chrTTP->SeriesList->IndexOf(tSerieOrdem);
//      if (indexOf > -1)
//      {
//        chrTTP->ExchangeSeries(indexOf, t_primeiraSerieMovimento);
//        t_primeiraSerieMovimento--;
//      }
//			tSerieOrdem = tSerieOrdem->SerieMovimentoAnterior;
//    }
//
//    // traz pra frente por ltimo
//    indexOf = chrTTP->SeriesList->IndexOf(FSerieMovimentoSelecionada_);
//    if (indexOf > -1)
//    {
//      chrTTP->ExchangeSeries(indexOf, t_primeiraSerieMovimento);
//      t_primeiraSerieMovimento--;
//    }
    chrTTP->AutoRepaint = false;
    chrTTP->Repaint();
  }
}

// ---------------------------------------------------------------------------
void TFormTP::ThreadCarregarTrensMalha(TTheadResultado *&pResult)
{
	try
	{
	algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Incio: Carregando Trens");
#endif

    TTPFormsManager::getInstance()->ServerCarregarTrensMalha(this);


    if (TTPFormsManager::getInstance()->IsPrimeiroCarregamento)
    {// primeiro carregamento do sistema devemos forcar o estado da janela na malha

    //se uma das duas filas tem pelo menos um objeto  , forco o estado das listas

        if((TTPFormsManager::getInstance()->FParametros.listaFilasAtivas->Count > 0)||
         (TTPFormsManager::getInstance()->FParametros.listaFilasInativas->Count > 0))
        {
             core->manterEstadoFilas(false,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);
             core->manterEstadoFilas(true,TTPFormsManager::getInstance()->FParametros.listaFilasAtivas);
        }

        //desativa ou ativa o gatilho para sincrozinar apos ler o arquivo de parametro.
        if (TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio !=  CheckGatilhoVazio())
        {
          DesativarGatilhoVazio(TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio);
    }
    }
    else
    {
      TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio =  CheckGatilhoVazio();
    }

    TTPFormsManager::getInstance()->gravarLog("--X Chamando Stop Aguarde");

    pResult->Status = terSucesso;
    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Carregando Trens");
#endif
	}
  catch (Exception &e)
	{
		TObject *excecao = &e;
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog(e.Message);

	}
	catch (...)
	{
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado");
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------
void TFormTP::ThreadCalcularTrens(TTheadResultado *&pResult)
{
	try
  {
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Calculando Trens");
#endif
    // Evita que o sistema trave em caso da operao seja muito rpida
    #ifdef BAIXADA_SANTISTA
      int tIDRamalTravar = -1;
      String nomeRamalTravado = "";

      if(chkTravar->Checked)
      {
        tIDRamalTravar = FRamal_->Numero;
        nomeRamalTravado = FRamal_->Nome;
      }

      TTPFormsManager::getInstance()->ServerCalcularTrens(tIDRamalTravar);
    #else
      TTPFormsManager::getInstance()->ServerCalcularTrens();
    #endif
    TTPFormsManager::getInstance()->gravarLog("--X Chamando Stop Aguarde");

    pResult->Status = terSucesso;
    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Calculando Trens");
#endif
	}
  catch (Exception &e)
	{
		TObject *excecao = &e;
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado");
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------
void TFormTP::ThreadProgramarTrens(bool pCongelarLinha, TTheadResultado *&pResult, int pBranchProgramingID)
{
	try
  {
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Programar Trens");
#endif
    TTPFormsManager::getInstance()->LimparTrens(true);

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("  -->ServerProgramarTrens");
#endif

    TTPFormsManager::getInstance()->ServerProgramarTrens
      (TTPFormsManager::getInstance()->FParametros.ExibirRealizadoReal, pCongelarLinha, pBranchProgramingID);

    pResult->Status = terSucesso;
#ifdef MODO_MULT_THREAD
    StopAguarde();
#endif

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Programar Trens");
#endif
  }
  catch (Exception &e)
	{
		TObject *excecao = &e;
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
#ifdef MODO_MULT_THREAD
		StopAguarde();
#endif
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
  catch (...)
  {
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado.");
#ifdef MODO_MULT_THREAD
		StopAguarde();
#endif
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------
void TFormTP::ThreadPublicarEntreMesas(TTheadResultado *pResult)
{

	try
	{
#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Incio: Publicar");
#endif
		pResult->Resultado = TTPGerenteProgramacao::getInstance()->Oficializar
			(algorithm::CoreTMPlanner::getInstance()->getMesaControle(), TTPFormsManager::getInstance()->Trens,
			TTPFormsManager::getInstance()->Restricoes, TTPFormsManager::getInstance()->RestricoesDel,
			TTPFormsManager::getInstance()->RestricoesDinamicas, TTPFormsManager::getInstance()->Usuario.Codigo);

		TTPFormsManager::getInstance()->RestricoesDel->clear();

		StopAguarde();

#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Fim: Publicar");
#endif
	}
	catch (Exception &e)
	{
		StopAguarde();
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		pResult->Resultado = e.Message;
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado.");
		pResult->Resultado = "Erro no identificado.";
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------
void TFormTP::ThreadGravarModelo(TTheadResultado *pResult)
{
	try
	{
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Gravando Modelo");
#endif

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    pResult->Resultado = core->persistirModelo(DB_SCHEMA_MODL, DB_INSTANCE_MODL, DB_PWD_CORE_MODL, DB_USR_SRV_MODL);

    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Gravando Modelo");
#endif
  }
  catch (Exception &e)
  {
		StopAguarde();
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		pResult->Resultado = e.Message;
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado.");
		pResult->Resultado = "Erro no identificado.";
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------

void TFormTP::ThreadOficializar(TTheadResultado *pResult)
{
	try
  {
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Oficializar");
#endif
    // trava light.
    // TTPFormsManager::getInstance()->DataProgramacaoCongelada
    // relaizar o sql

    pResult->Resultado = TTPGerenteProgramacao::getInstance()->Oficializar
      (algorithm::CoreTMPlanner::getInstance()->getMesaControle(), TTPFormsManager::getInstance()->Trens,
      TTPFormsManager::getInstance()->Restricoes, TTPFormsManager::getInstance()->RestricoesDel,
      TTPFormsManager::getInstance()->RestricoesDinamicas,
      TTPFormsManager::getInstance()->Usuario.Codigo, true, FRamal_->OficializaSomenteSubMesa,
      FRamal_->CodigoOficializacaoZonaMesa);

    TTPFormsManager::getInstance()->RestricoesDel->clear();

    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Oficializar");
#endif
  }
  catch (Exception &e)
  {
		StopAguarde();
		if(pResult->Status != terCancel)
		pResult->Status    = terErro;
		pResult->Resultado = e.Message;
		pResult->ListaResultados->Add(e.Message);
		TTPFormsManager::getInstance()->gravarLog(e.Message);
  }
  catch (...)
	{
    StopAguarde();
		pResult->Status    = terErro;
    pResult->Resultado = "Erro no identificado.";
		pResult->ListaResultados->Add("Erro no identificado.");
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}

}

// ---------------------------------------------------------------------------
void TFormTP::ThreadGerarPlanilha()
{
	try
	{
#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Incio: Planilha");
#endif

		TTPGerenteProgramacao::getInstance()->GerarPlanilhaEquipagem();
		StopAguarde();

#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Fim: Planilha");
#endif
	}
	catch (Exception &e)
	{
		StopAguarde();
		// pResult->Resultado = e.Message;
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		// pResult->Resultado = "Erro no identificado.";
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}



// ---------------------------------------------------------------------------
void TFormTP::ThreadSincronizarProgramacao(TTheadResultado *pResult)
{
	try
  {
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Sincronizar Programao");
#endif

    if (TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado)
      TTPGerenteProgramacao::getInstance()->SincronizarInicioPlanoSistemExterno(pResult,false,true);
    else
      TTPGerenteProgramacao::getInstance()->SincronizarInicioPlanoSistemExterno(pResult,true,false);

    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Sincronizar Programao");
#endif
  }
  catch (Exception &e)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = e.Message;
		pResult->ListaResultados->Add(e.Message);
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = "Erro no identificado.";
		pResult->ListaResultados->Add("Erro no identificado.");
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}

// ---------------------------------------------------------------------------


void __fastcall TFormTP::acIniciarPlanejamentoExecute(TObject *Sender)
{

  Application->ProcessMessages();
  bool isGraficoVisivel = chrTTP->Visible;

   try
   {
    Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(true, this);
    Screen->Cursor = crDefault;
   }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    Alerta("Erro ao Inicializar Planejamento");
  }

  Application->ProcessMessages();
//
  if (FPlanoInicializado)
  {
    if (isGraficoVisivel)
    {
      TTPFormsManager::getInstance()->EnableDisableTeechart(true);
    }

      TTPFormsManager::getInstance()->AjustarEstadoControles(true);
    //acCarregar->Enabled  = true;
  }
  else
  {
    if (isGraficoVisivel)
    {
      TTPFormsManager::getInstance()->EnableDisableTeechart(true);
    }

    TTPFormsManager::getInstance()->AjustarEstadoControles(true);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acFinalizarPlanejamentoExecute(TObject *Sender)
{

  try
  {
    Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(false, this);
    Screen->Cursor = crDefault;
  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao Finalizar Planejamento");
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acConsultarLogOficializacaoExecute(TObject *Sender)
{
  try
  {
    Screen->Cursor = crHourGlass;
    String strData = this->lblDataOficializacao->Caption;
    TDateTime dataHoraOficializacao;
    TTPFormsManager::getInstance()->IsAtualizarOcializacaoRunning = false;
    if (TryStrToDateTime(strData, dataHoraOficializacao))
    {
      PtrQuery qrResult     = TTPFormsManager::getInstance()->VerificaShowIntrajornada() ?
      TDAO::getResultUltimaOficializacaoAtividadeIntrajornada(dataHoraOficializacao) :
      TDAO::getResultUltimaOficializacao(dataHoraOficializacao);

      if (!qrResult->Eof)
      {
        TFormResultadoProcessos *fResultado = new TFormResultadoProcessos(this, qrResult);
        fResultado->Caption                 = "Resultado da Oficializao (Divergncia)";
        fResultado->ShowModal();
      }
    }
    else
    {
      Screen->Cursor = crDefault;
      Alerta("No foi possivel encontrar oficializao (Formato invlido)");
    }
    Screen->Cursor = crDefault;

  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    StopAguarde();
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acLimparMovimentosPriorizadosExecute(TObject *Sender)
{
  try
  {
    if (FSerieMovimentoSelecionada_)
    {
      for (int i = 0; i < FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->Movimentos->count(); i++)
      {
        if (FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->Movimentos->operator[](i)->SB->Ramal == FRamal_->Nome)
        {
          TTPMovimentoPtr tMovimento = FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->Movimentos->operator[](i);
          FSerieMovimentoSelecionada_->Trem->ItinerarioTrem->MovimentosPriorizados->remove(tMovimento->PID);
          if (tMovimento->ServerSegTremPlanejado != NULL)
            tMovimento->ServerSegTremPlanejado->setPrioridadeUsuario(false);
        }
      }
      Informacao("Movimentos priorizados limpos com sucesso!");
    }
  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acAtivarCalculoFilaExecute(TObject *Sender)
{
  if (!FSerieMovimentoSelecionada_)
    return;

  TTPMovimentoSeries *tSerieSelecionada = FSerieMovimentoSelecionada_;
  if (!tSerieSelecionada->Trem->ISCalculoFilaAtivo)
  {

    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;

    getTremFilho(tTrem);

    tTrem->IsFilaDasativUsu = false;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    String tPID = "";
    int idx = core->getMalha()->listaTrens->IndexOf(tTrem->PID);
    if (idx >= 0)
      tPID = tTrem->PID;

    core->ativarFilaTrem(tPID);
    // Sincronizar Trens Client / Server
    TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

    TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, !FTremFilho_);
    if(!PlotarTremFilho(tTrem) && FTremFilho_)
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acDesativarCalculoFilaExecute(TObject *Sender)
{
  if (!FSerieMovimentoSelecionada_)
    return;

  TTPMovimentoSeries *tSerieSelecionada = FSerieMovimentoSelecionada_;
  if (tSerieSelecionada->Trem->ISCalculoFilaAtivo)
  {

    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;

    getTremFilho(tTrem);
    tTrem->IsFilaDasativUsu = true;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    String tPID = "";
    int idx = core->getMalha()->listaTrens->IndexOf(tTrem->PID);
    if (idx >= 0)
      tPID = tTrem->PID;

    core->desativarCalculoFilaTrem(tPID);
    // Sincronizar Trens Client / Server
    TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

    TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, !FTremFilho_);
    if(!PlotarTremFilho(tTrem) && FTremFilho_)
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acFilasTerminaisExecute(TObject *Sender)
{
  TFormFilas *fFilasTerminais = new TFormFilas(this);
  fFilasTerminais->Show();
  AddFormAberto(fFilasTerminais);
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::DesativarFilas(bool desativa)
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  core->manterEstadoFilas(desativa,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);
}

void __fastcall TFormTP::DesativarGatilhoVazio(bool desativa)
{
  using namespace domain;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    Segmento* segParada = t_gatilhoMalha->getSegmentoParada();

    if (segParada && ((segParada->patioPertencente &&
     (segParada->patioPertencente->sigla == "FBA" ||
     segParada->patioPertencente->sigla == "FOS" ||
     segParada->patioPertencente->sigla == "FBP"))
     ||
     segParada->segmento == "FBP-108") )
    {
       if (desativa)
        core->desabilitarGatilho(t_gatilhoMalha);
       else
        core->habilitarGatilho(t_gatilhoMalha);
    }
  }

}

bool __fastcall TFormTP::CheckGatilhoVazio()
{
   return TTPFormsManager::getInstance()->CheckGatilhoVazio();

 /* using namespace domain;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    Segmento* segParada = t_gatilhoMalha->getSegmentoParada();

    if (segParada && !t_gatilhoMalha->getIsDesativadoUsuario() && segParada->patioPertencente &&
     (segParada->patioPertencente->sigla == "FBA" ||
     segParada->patioPertencente->sigla == "FOS" ||
     segParada->patioPertencente->sigla == "FBP"))
    {
      return false;
    }
  }
  return true;  */
}
// ---------------------------------------------------------------------------
// Verfica se todas as filas esto desativadas
bool __fastcall TFormTP::CheckFilasAtivas()
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();

  // Se no tem fila, volta true pq  o Default no caso de haverem filas
  //Evita o erro do parmetro de desativar filas antes do CTRL+A
  if(t_filas->Count == 0)
    return true;

  for (int i = 0; i < t_filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    if (t_filaMalha->isAtiva())
      return true;
  }

  return false;
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::FechaFormsAbertos()
{
  //destroi os forms de Widget
  if(FormWidgetGridDiferencasEntrePlanos)
  {
     delete FormWidgetGridDiferencasEntrePlanos;
     FormWidgetGridDiferencasEntrePlanos = NULL;
  }
  if(FormWidgetGridAtividadesAlteradas)
  {
    delete FormWidgetGridAtividadesAlteradas;
    FormWidgetGridAtividadesAlteradas = NULL;
  }
  if( FormWidgetFarolIntrajornada)
  {
    FormWidgetFarolIntrajornada->Close();
    delete FormWidgetFarolIntrajornada;
    FormWidgetFarolIntrajornada = NULL;
  }

  if(FormWidgetGanttOcupacao)
  {
     delete FormWidgetGanttOcupacao;
     FormWidgetGanttOcupacao = NULL;
  }

  if (formsAbertos_ == NULL)
    return;

  while (formsAbertos_->Count > 0)
  {
    TForm *t_form = (TForm*) formsAbertos_->Objects[formsAbertos_->Count - 1];
    t_form->Close();
    formsAbertos_->Delete(formsAbertos_->Count - 1);
    delete t_form;
    t_form = NULL;
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::AddFormAberto(TForm *formAberto)
{
  if (formsAbertos_ == NULL)
    formsAbertos_ = new TStringList();

  formsAbertos_->AddObject("", (TObject *)formAberto);
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::WsFormsAbertos(TWindowState t_ws)
{
  if (formsAbertos_ == NULL)
    return;

  for (int i = 0; i < formsAbertos_->Count; i++)
  {
    // elimina os forms que estejam fechados quando o form principal  minimizado
    if (t_ws == wsMinimized)
    {
      TForm *t_form = (TForm*) formsAbertos_->Objects[i];
      if (t_form->Visible == false)
      {
        formsAbertos_->Delete(i);
        delete t_form;
        i = 0;
      }
    }
  }

  for (int i = 0; i < formsAbertos_->Count; i++)
  {
    TForm *t_form       = (TForm*) formsAbertos_->Objects[i];
    t_form->WindowState = t_ws;
    t_form->Visible     = (t_ws == wsMinimized) ? false : true;
  }
}

// ---------------------------------------------------------------------------
TTPMovimentoSeries* __fastcall TFormTP::SerieProximaPontoY(float Y)
{
  //TODO bruno entender e reescrever se for preciso
//
//	TTPMovimentoSeries* tMovimento    = FTremSelecionado_->ItinerarioTrem->Movimentos->operator[](0)->Serie;
//  TTPMovimentoSeries* tMovimentoAtu = tMovimento;
//
//  // somente pode ser lido o valor de movimentos que sejam simulados
//  while (!tMovimentoAtu)
//		tMovimentoAtu = tMovimentoAtu->SerieMovimentoPosterior;
//
//  // procura o 1 movimento plotado
//  while (!tMovimentoAtu->IsPlotada)
//    tMovimentoAtu = tMovimentoAtu->SerieMovimentoPosterior;
//
//  tMovimento = tMovimentoAtu;
//
//  float tdistanciaMin = fabs(tMovimentoAtu->YValue[0] - Y);
//
//  while (tMovimentoAtu->SerieMovimentoPosterior)
//  {
//    tMovimentoAtu                   = tMovimentoAtu->SerieMovimentoPosterior;
//    tMovimentoAtu->Pointer->Visible = false;
//
//    if (tMovimentoAtu->IsArrastavel && tMovimentoAtu->Movimento->SB->Ramal == FRamal_->Nome)
//    {
//      float tdistanciaMov = fabs(tMovimentoAtu->YValue[0] - Y);
//
//      if (tdistanciaMin >= tdistanciaMov)
//      {
//        tMovimento    = tMovimentoAtu;
//        tdistanciaMin = tdistanciaMov;
//      }
//    }
//  }
//  // s retorna um movimento se ele pertencer ao ramal do grafico
//  if (tMovimento->IsPlotada && tMovimento->Movimento->SB->Ramal == FRamal_->Nome)
//  {
//		tMovimento->Pointer->Visible = true;
//    return tMovimento;
//  }

  return NULL;

}

// ---------------------------------------------------------------------------
void TFormTP::LimparSeriesTransposicao(TTPTrem* pTrem)
{
  try
  {
    // Removendo srie transposicao
    if (seriesTransposicao_)
    {
      TStringList* tSeriesExcluir = new TStringList();

      for (int i = 0; i < seriesTransposicao_->Count; i++)
      {
        TTPMovimentoSeries* tSerie = (TTPMovimentoSeries*)seriesTransposicao_->Objects[i];
        if (tSerie->Trem->PID == pTrem->PID)
        {
          int indexOf = chrTTP->SeriesList->IndexOf(tSerie);
          if (indexOf > -1)
          {
            chrTTP->RemoveSeries(tSerie);
            tSeriesExcluir->AddObject("", tSerie);
          }
        }
      }
      delete tSeriesExcluir;
      tSeriesExcluir = NULL;
    }
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acTabExecute(TObject *Sender)
{
  this->FPageControl->SelectNextPage(true, true);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acListarAderenciaFilaExecute(TObject *Sender)
{
  String tTrens = "";
  if (TTPFormsManager::getInstance()->TrensAderenciaFila->Count > 0)
  {
    tTrens = "Trens Ociosidade:\n";
    tTrens += TTPFormsManager::getInstance()->TrensAderenciaFila->GetText();
  }
  if (TTPFormsManager::getInstance()->TrensForaOrdemFila->Count > 0)
  {
    if (tTrens.Length() > 0)
      tTrens += "- \n";
    tTrens += "Trens Fora de Ordem:\n";
    tTrens += TTPFormsManager::getInstance()->TrensForaOrdemFila->GetText();
  }
  if (tTrens.Length() > 0)
    Informacao(tTrens);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acAjustarRestricaoAoTremExecute(TObject *Sender)
{
  if (acAjustarRestricaoAoTrem->Checked == true)
  {
    acAjustarRestricaoAoTrem->Checked = false;
  }
  else
  {
    acAjustarRestricaoAoTrem->Checked = true;
  }
}

// ---------------------------------------------------------------------------
void TFormTP::AplicarAjusteRestricaoAoTrem(TTPTrem* pTrem, bool pAjusteTremRetomada, bool pFixarTrem)
{

  TDateTime dtMovimento;

  for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
  {
    TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
    if (pAjusteTremRetomada)
    {
      dtMovimento = DATAFUTURODISTANTE;
    }
    else
    {
      dtMovimento = 0;
    }
    for (int j = 0; j < restSel->Restricao->SBsRestricao->count(); j++)
    {
      TTPSBPtr sb = restSel->Restricao->SBsRestricao->get(j);
      for (int x = 0; x < pTrem->ItinerarioTrem->Movimentos->count(); x++)
      {
        if (pTrem->ItinerarioTrem->Movimentos->operator[](x)->SB->CodigoSegmento == sb->CodigoSegmento)
        {
          TDateTime dtTemp;
          if (pAjusteTremRetomada)
          {
            dtTemp = pTrem->ItinerarioTrem->Movimentos->operator[](x)->DataChegada;
            if (dtTemp < dtMovimento)
              dtMovimento = dtTemp;
          }
          else
          {
            dtTemp = pTrem->ItinerarioTrem->Movimentos->operator[](x)->DataSaida;
            if (dtTemp > dtMovimento)
              dtMovimento = dtTemp;
          }
          break;
        }
      }
    }
    if ((double)dtMovimento > 0 && dtMovimento <
      DATAFUTURODISTANTE && pAjusteTremRetomada && !restSel->Restricao->ISIniciada()
      && !restSel->Restricao->ISEncerrada())
    {
      restSel->Posicao = dtMovimento - restSel->Largura - 0.005;
      restSel->DrawValue(0);
      dtMovimento = DATAFUTURODISTANTE;
    }
    else if ((double)dtMovimento > 0 && !pAjusteTremRetomada && !restSel->Restricao->ISIniciada()
      && !restSel->Restricao->ISEncerrada())
    {
      restSel->Posicao = dtMovimento + 0.005;
      restSel->DrawValue(0);
      dtMovimento = 0;
    }
  }
  if(acAjustarRestricaoAoTremDinamico->Checked)
  {
    //Evitar dar o DrawValue - Erro GDI o mtodo AtualizarRestricoesDinamicas vai fazer o zervio
    AtualizarRestricoesServer(pTrem, true);
    TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
  }
  else
  {
    AtualizarRestricoesServer();
  }
  acAjustarRestricaoAoTrem->Checked = false;
  acAjustarRestricaoAoTremDinamico->Checked = false;
  FSeriesRestSelecionadas_->Clear();
}

// ---------------------------------------------------------------------------
void TFormTP::AtualizarRestricoesServer(TTPTrem* pTrem, bool pAvoidRedrawSeries)
{
  try
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    for (int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
    {
      TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];

      if (!restSel->Restricao->ISIniciada() && !restSel->Restricao->ISEncerrada())
      {
        restSel->Arrastando = false;
        restSel->Movendo    = false;
        // Se tem o trem, no precisa fazer drawValue pq a restrio ser atualizada por outro processo
        if(!pAvoidRedrawSeries)
          restSel->DrawValue(0);

        if(pTrem)
        {
          if(acAtivaDesativaDataMaxFimRestricao->Checked == true)
          {
            //CA - Respeita as datas mnina de incio e Mxima de sada
            //if(acAtivaDesativaDataFimFixa->Checked == true)
            //  restSel->Restricao->ICComportamentoTremRef = "CAT";
            //else
              restSel->Restricao->ICComportamentoTremRef = "CA";
          }
          else
          {
            //CI - Respeita a data mnina de incio (para evitar deslocar a interdio demasiadamente em caso de ganho de circlao)
            //if(acAtivaDesativaDataFimFixa->Checked == true)
            //  restSel->Restricao->ICComportamentoTremRef = "CIT";
            //else
              restSel->Restricao->ICComportamentoTremRef = "CI";
          }

          core->SetTremRefInterdicao(pTrem->PID, restSel->Restricao->PID, restSel->Restricao->ICComportamentoTremRef);
          int indexOfRest = TTPFormsManager::getInstance()->RestricoesDinamicas->IndexOf(restSel->Restricao->PID);
          if(indexOfRest == -1)
            TTPFormsManager::getInstance()->RestricoesDinamicas->add(restSel->Restricao->PID, restSel->Restricao);
          restSel->Restricao->Trem = pTrem;

          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(restSel->Restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
            restSel->Restricao->IsAlteradoUsuario = false;
          }
          else
          {
            restSel->Restricao->IsAlteradoUsuario = true;
          }
        }

        restSel->Restricao->DataInicio         = restSel->XDefs[0];
        restSel->Restricao->DataFim            = restSel->XDefs[1];
        restSel->Restricao->DataInicioOriginal = restSel->Restricao->DataInicio;
        restSel->Restricao->DataFimOriginal    = restSel->Restricao->DataFim;

        FTipoArrasto_  = taSemArrasto;
        Screen->Cursor = crDefault;

        TStringList *t_listServer = new TStringList();
        for (int i = 0; i < restSel->Restricao->SBsRestricao->count(); i++)
        {
          t_listServer->Add(restSel->Restricao->SBsRestricao->operator[](i)->NomeVia);
        }

        algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
        core->AlterarRestricao(restSel->Restricao->DataInicio, restSel->Restricao->DataFim, t_listServer,
          restSel->Restricao->PID, restSel->Restricao->VMA, restSel->Restricao->DataInicioReal,
          restSel->Restricao->DataFimReal, restSel->Restricao->ListaConexoes, restSel->Restricao->DataMinInicio, restSel->Restricao->DataMaxFim);

        if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
        {
          TDAO::gravarRestricao(restSel->Restricao, TTPFormsManager::getInstance()->Usuario.Codigo, false);
          restSel->Restricao->IsAlteradoUsuario = false;
        }
        else
        {
          restSel->Restricao->IsAlteradoUsuario = true;
        }

        delete t_listServer;
        t_listServer = NULL;
      }
    }
  }
  catch(Exception &e)
  {
    TTPFormsManager::getInstance()->RetirarSelecao();
    Alerta(e.Message);
  }
}

// ---------------------------------------------------------------------------
void TFormTP::SelecionarRestricoes(double pX, int pY)
{
  FSelecionandoRestArrastoShift_    = false;
  acAjustarRestricaoAoTrem->Checked = false;
  acAjustarRestricaoAoTremDinamico->Checked = false;
  TTPFormsManager::getInstance()->RetirarSelecao();

  for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
  {
    TChartSeries* t_serie = chrTTP->Series[i];
    TTPTipoSerie t_tipo   = GetTipoSerieMP(t_serie);
    if (t_tipo == tsRestricao)
    {
      if ((t_serie->XValue[0] >= FSerieSBs_->XScreenToValue(FCoordenadasSelecao_.Left) || t_serie->XValue[1] >=
        FSerieSBs_->XScreenToValue(FCoordenadasSelecao_.Left)) && (t_serie->XValue[1] <=
        FSerieSBs_->XScreenToValue(pX) || t_serie->XValue[0] <= FSerieSBs_->XScreenToValue(pX)) &&
        (t_serie->YValue[0] <= FSerieSBs_->YScreenToValue(FCoordenadasSelecao_.Top) || t_serie->YValue[1] <=
        FSerieSBs_->YScreenToValue(FCoordenadasSelecao_.Top)) && (t_serie->YValue[1] >=
        FSerieSBs_->YScreenToValue(pY) || t_serie->YValue[0] >= FSerieSBs_->YScreenToValue(pY)))
      {

        // Recupera srie selecionada
        FSerieRestricaoSelecionada_              = ((TTPRestricaoSeries*)t_serie);
        if(!FSerieRestricaoSelecionada_->Restricao->ISIniciada() && !FSerieRestricaoSelecionada_->Restricao->ISEncerrada())
        {
        FSerieRestricaoSelecionada_->Selecionado = true;

        if (FSeriesRestSelecionadas_->IndexOf(FSerieRestricaoSelecionada_->Restricao->PID) == -1)
          FSeriesRestSelecionadas_->AddObject(FSerieRestricaoSelecionada_->Restricao->PID,
          (TObject*)FSerieRestricaoSelecionada_);
      }
    }
    }

  }
  if (FSerieRestricaoSelecionada_ != NULL)
  {
    FHabilitarPopup        = true;
    FPopupContexto_        = pmnRestricoes;
    FTipoSelecaoAtual_     = tselRestricao;
    FPIDObjetoSelecionado_ = FSerieRestricaoSelecionada_->Restricao->PID;
    chrTTP->Refresh();
  }

  // chrTTP->Cursor         = crDefault;
  // chrTTP->OriginalCursor = crDefault;

}

// ---------------------------------------------------------------------------// ----------------------------------------------------------------------------

void __fastcall TFormTP::acEnviarRestPTrasExecute(TObject *Sender)
{
  for (int i = chrTTP->SeriesCount() - 1; i >= 0; i--)
  {
    TChartSeries* t_serie    = chrTTP->Series[i];
    TTPTipoSerie t_tipoSerie = GetTipoSerieMP(t_serie);
    if (t_tipoSerie == tsRestricao)
    {
      chrTTP->ExchangeSeries(t_serie, FSerieRestricaoSelecionada_);
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::acTrazerRestPFrenteExecute(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_ != NULL)
  {
    int t_ultimaSerie = chrTTP->SeriesList->Count - 1;
    int indexOf       = -1;
    indexOf           = chrTTP->SeriesList->IndexOf(FSerieRestricaoSelecionada_);
    if (indexOf > -1)
    {
      chrTTP->ExchangeSeries(indexOf, t_ultimaSerie);
    }
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::acOrdemSaidaExecute(TObject *Sender)
{

  TTPFormsManager::getInstance()->AjustarEstadoControles(false);
  formOrdemTrem = new TformOrdemTrem(this);
  formOrdemTrem->ShowModal();
  TTPFormsManager::getInstance()->AjustarEstadoControles(true);

  for (int i = 0; i < formOrdemTrem->FListaTremsRefresh_->count(); i++)
  {
    FSerieMovimentoSelecionada_ = formOrdemTrem->FListaTremsRefresh_->operator[](i)
      ->ItinerarioTrem->Movimentos->operator[](0)->Serie;

    getTremFilho(&*formOrdemTrem->FListaTremsRefresh_->operator[](i));

    TTPFormsManager::getInstance()->SincronizarTremClientServer(&*formOrdemTrem->FListaTremsRefresh_->operator[](i));
    TTPFormsManager::getInstance()->PlotarTrem(&*formOrdemTrem->FListaTremsRefresh_->operator[](i), false, false, true, !FTremFilho_);
    bool plotou = PlotarTremFilho(&*formOrdemTrem->FListaTremsRefresh_->operator[](i));
    if(!plotou && FTremFilho_)
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

  }
  delete formOrdemTrem;
  acVerificarConflitosExecute(this);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::ScrollTo(TTPMovimentoSeries * tSerieSelecionada, double horario)
{
  //scbCharts->Repaint();

  if(FISZoomed_)
    chrTTP->UndoZoom();

  if (!tSerieSelecionada && horario == -1)
    return;

  double size = chrTTP->BottomAxis->Maximum - chrTTP->BottomAxis->Minimum;

  if (tSerieSelecionada)
  {
    horario = tSerieSelecionada->Movimento->DataChegada;

    if (FSerieMovimentoSelecionada_)
    {
      FSerieMovimentoSelecionada_->SetTremSelecionado(false);
      FSerieMovimentoSelecionada_->SetMovimentoSelecionado(false);
      chrTTP->UndoZoom();
    }

    FSerieMovimentoSelecionada_ = tSerieSelecionada;
    FSerieMovimentoSelecionada_->SetMovimentoSelecionado(true);
  }
  else
  {
    //horario = chrTTP->BottomAxis->Minimum + size / 2;
    if(horario<3000)
    {
      if(horario == 0)
      {
       horario = (TP_->Data + TP_->Hora) + (UMAHORA * (FVisaoPlajemanto_? 6: 3));
//        scbCharts->HorzScrollBar->Position = chrTTP->Width*(double)PROPORCAO_POSICAO_INICIAL;
//        ultimaPosicaoscbCharts_ = scbCharts->HorzScrollBar->Position;
      }
      else
       {
        if(scbCharts->HorzScrollBar->Position + horario < scbCharts->HorzScrollBar->Range - scbCharts->Width -1)
        {
          scbCharts->HorzScrollBar->Position += horario;
        }
        else
        {
          FExecutouResetPosicao_ = false;
          scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Range - scbCharts->Width -1;
        }

        ultimaPosicaoscbCharts_ = scbCharts->HorzScrollBar->Position;

        if (FormWidgetGanttOcupacao)
        {
          FormWidgetGanttOcupacao->scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Position;
        }
        return;
       }
    }
  }

  double max = chrTTP->BottomAxis->Maximum;
  double min = chrTTP->BottomAxis->Minimum;

  TDateTime teste = horario;
  String testeS = StrToDateTime(teste);

  double pos = (horario - min) / (max - min);
  scbCharts->HorzScrollBar->Position = chrTTP->Width * pos - scbCharts->Width/2;

  ultimaPosicaoscbCharts_ = scbCharts->HorzScrollBar->Position;

  if (FormWidgetGanttOcupacao)
  {
    FormWidgetGanttOcupacao->scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Position;
}
}

// ---------------------------------------------------------------------------
void __fastcall TFormTP::alExecute(TBasicAction *Action, bool &Handled)
{
  HideHint();
}
// ---------------------------------------------------------------------------

void TFormTP::getTremFilho(TTPTrem* Trem)
{
  // validao se o trem da alterao possui filho
  FTremFilho_ = TTPFormsManager::getInstance()->getTremFilho(Trem);
  if (FTremFilho_)
  {
    FDataHoraCriacaoTremFilho_ = FTremFilho_->ItinerarioTrem->GetMovimento(0)->DataChegada;
  }
}

// ---------------------------------------------------------------------------
bool TFormTP::PlotarTremFilho(TTPTrem* Trem)
{
  // se o trem arrastado possui filho e o horario de criao dele foi alterado replotar o filho tambem
  if (!FTremFilho_)
    return false;

  TTPTrem* tremAux = TTPFormsManager::getInstance()->getTremFilho(Trem);

  if (tremAux && FTremFilho_->PID == tremAux->PID)
  {
    // TTPFormsManager::getInstance()->SincronzaTremClientServer(FTremFilho_);
    TDateTime tDateTimeCriacao = TTPFormsManager::getInstance()->getDataHoraPrimeiroMovimentoTremFilhoSrv(Trem);
    if (FDataHoraCriacaoTremFilho_ != tDateTimeCriacao)
    {
      TTPFormsManager::getInstance()->PlotarTrem(&*FTremFilho_, false, false, true);
      return true;
    }
  }
  return false;
}

// ---------------------------------------------------------------------------
void TFormTP::ConfigurarTextoSelecionar()
{
  ModoSelecaoTrens->Checked = acSelecionar->Checked;
  ModoSelecaoRestricoes->Checked = acSelecionarRestricao->Checked;
}

// ---------------------------------------------------------------------------
void  TFormTP::EditarMovimentoOrigemTremForaLimiteGrafico(TTPTremPtr pTrem)
{
 try
 {
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  if (pTrem.isNull())
    {
      throw Exception("Trem no programado");
    }
    else if (TTPFormsManager::getInstance()->Mesa != pTrem->GetMesaAtualProgramacao())
    {
      throw Exception("Trem encontra-se em outra mesa");
    }

    TTPMovimentoPtr tMovimento = pTrem->ItinerarioTrem->GetMovimento(0);

    TFormEditarMovimento* t_formEditarMovimento = new TFormEditarMovimento(this, &*pTrem, &*tMovimento, NULL, NULL,
      NULL, True);

    if (t_formEditarMovimento->ShowModal() == mrOk)
    {
      timeTP::TimeTP dataSaida;
      dataSaida = pTrem->PrimeiroMovimentoPrevisto->GetDataSaidaClient();

      if(pTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado)
      pTrem->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->trem->setDataSaidaRotaTremUsuario(dataSaida,
        domain::SegmentoTremImpactado::SentidoConflito::SENTIDO_IGUAL, core->getDataHoraBaseCalculo());
      pTrem->PrevisaoSaidaOriginal = dataSaida.asDateTime();

      TTPFormsManager::getInstance()->ExcluirTrem(&*pTrem, texRePlotar);

      pTrem = TTPFormsManager::getInstance()->RecriarTremCliente(&*pTrem);
      TTPFormsManager::getInstance()->PlotarTrem(&*pTrem, true);
    }

    delete t_formEditarMovimento;
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acGatilhosExecute(TObject *Sender)
{
  TformGatilhos2* formGatilhos = new TformGatilhos2(this);
  formGatilhos->ShowModal();
}
//---------------------------------------------------------------------------

void TFormTP::ThreadCarregarIconesAtividades(TTheadResultado *&pResult)
{

	try
  {
#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Incio: Carregando cones Atividades");
#endif

    TTPFormsManager::getInstance()->CarregarIconesAtividades(this);

    TTPFormsManager::getInstance()->gravarLog("--X Chamando Stop Aguarde");

    pResult->Status = terSucesso;
//    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Carregando Icones Atividades");
#endif
  }
  catch (Exception &e)
	{
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado");
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
  }
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::acDesativarValidacaoHorGradeExecute(TObject *Sender)
{
 if (!FSerieMovimentoSelecionada_)
    return;

  TTPMovimentoSeries *tSerieSelecionada = FSerieMovimentoSelecionada_;

  TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;

  for (int i = 0; i < tTrem->Atividades->count(); i++)
  {
    TTPAtividadePtr atividade = tTrem->Atividades->operator[](i);
    if(atividade->ISValidarDataMaximaSaidaAtivo)
    {
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      core->AlterarAtividade(atividade->PID,
                           atividade->DataHoraMinimaChegada,
                           atividade->DataFim,
                           atividade->Duracao*60,
                           atividade->DuracaoPercurso*60,
                           atividade->Descricao,
                           atividade->DataFimFila,
                           atividade->DataHoraMinimaSaida ,
                           atividade->DataHoraMaximaSaida,
                           false,
                           false);

      atividade->ISValidarDataMinimaChegadaAtivo = false;
      atividade->ISValidarDataMaximaSaidaAtivo = false;

      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf(atividade->Trem->PID) == -1)
      {
        if (atividade->Trem->AtividadesUpdate->IndexOf(atividade->PID) > -1)
          atividade->Trem->AtividadesUpdate->remove(atividade->PID);
        atividade->Trem->AtividadesUpdate->add(atividade->PID, atividade);
        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->add(atividade->Trem->PID,
          TTPFormsManager::getInstance()->Trens->get(atividade->Trem->PID));
      }

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->IndexOf
        (atividade->PID) > -1)
      {
        if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->get
          (atividade->PID)->ISAlterandoDatasAtividades)
          atividade->ISAlterandoDatasAtividades = true;

        if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->get
          (atividade->PID)->ISReativarValidarDataMaximaSaidaAtivo && atividade->ISValidarDataMaximaSaidaAtivo)
          atividade->ISReativarValidarDataMaximaSaidaAtivo = true;

        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->remove
          (atividade->PID);

      }
      TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->add
        (atividade->PID, atividade);
     }
   }

  TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, !FTremFilho_);
  if(!PlotarTremFilho(tTrem) && FTremFilho_)
    TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acAtivarValidacaoHorGradeExecute(TObject *Sender)
{
 if (!FSerieMovimentoSelecionada_)
    return;

  TTPMovimentoSeries *tSerieSelecionada = FSerieMovimentoSelecionada_;

  TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;

  TXStringList* atvReativadas =  new TXStringList();

  for (int i = 0; i < tTrem->Atividades->count(); i++)
  {
    TTPAtividadePtr atividade = tTrem->Atividades->operator[](i);

    double tDataHoraMaximaSaida = atividade->DataHoraMaximaSaida;
    double tDataHoraMinimaChegada = atividade->DataHoraMinimaChegada;

    if(!atividade->ISValidarDataMaximaSaidaAtivo && tDataHoraMaximaSaida > 0)
    {
      atvReativadas->Add(atividade->PID);

      atividade->ISReativarValidarDataMaximaSaidaAtivo = true;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      atividade->DataFim = atividade->DataHoraMaximaSaida;

      core->AlterarAtividade(atividade->PID,
                             atividade->DataHoraMinimaChegada,
                           atividade->DataFim,
                           atividade->Duracao*60,
                           atividade->DuracaoPercurso*60,
                           atividade->Descricao,
                           atividade->DataFimFila,
                           atividade->DataHoraMinimaSaida ,
                           atividade->DataHoraMaximaSaida,
                           true,
                             tDataHoraMinimaChegada > 0);

      atividade->ISValidarDataMinimaChegadaAtivo = tDataHoraMinimaChegada>0;
      atividade->ISValidarDataMaximaSaidaAtivo = true;

      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf(atividade->Trem->PID) == -1)
      {

        if (atividade->Trem->AtividadesUpdate->IndexOf(atividade->PID) > -1)
          atividade->Trem->AtividadesUpdate->remove(atividade->PID);
        atividade->Trem->AtividadesUpdate->add(atividade->PID, atividade);
        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->add(atividade->Trem->PID,
          TTPFormsManager::getInstance()->Trens->get(atividade->Trem->PID));
      }

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->IndexOf
        (atividade->PID) > -1)
      {
        if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->get
          (atividade->PID)->ISAlterandoDatasAtividades)
          atividade->ISAlterandoDatasAtividades = true;

        if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->get
          (atividade->PID)->ISReativarValidarDataMaximaSaidaAtivo && atividade->ISValidarDataMaximaSaidaAtivo)
          atividade->ISReativarValidarDataMaximaSaidaAtivo = true;

        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->remove
          (atividade->PID);

      }
      TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->add
        (atividade->PID, atividade);
    }
  }

  for (int i = 0; i < tTrem->Atividades->count(); i++)
  {
    TTPAtividadePtr atividade = tTrem->Atividades->operator[](i);

    if(atvReativadas->IndexOf(atividade->PID)>-1)
    {
      if(TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID))
      {
        if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)
            ->AtividadesUpdate->IndexOf(atividade->PID) > -1)
           TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->remove
              (atividade->PID);
          TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesUpdate->add
            (atividade->PID, atividade);
      }
    }
  }

  TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, !FTremFilho_);
  if(!PlotarTremFilho(tTrem) && FTremFilho_)
    TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPResize(TObject *Sender)
{
  chrTTPLeft->Height =  chrTTP->Height;
  scbChartLeft->Top =  scbCharts->Top+2;
  scbChartLeft->Left = ((dtsInfos->Visible)?dtsInfos->Width:0) + 1;
  scbChartLeft->Height = scbCharts->Height-20;
  scbChartLeft->Width = chrTTPLeft->Width;

  chrTTPRight->Height =  chrTTP->Height;
  chrTTPRight->Width = 50;

  scbChartRight->Top =  scbCharts->Top+2;
  scbChartRight->Left = ((pnlInfos->Visible)?pnlInfos->Width:0) +  ((dtsInfos->Visible)?dtsInfos->Width:0) + scbCharts->Width - chrTTPRight->Width -((chrTTP->Height>scbCharts->Height)?20:5);
  scbChartRight->Height = scbCharts->Height-20;
  scbChartRight->Width = chrTTPRight->Width;

  scbChartLeft->VertScrollBar->Range = scbCharts->VertScrollBar->Range;
  scbChartRight->VertScrollBar->Range = scbCharts->VertScrollBar->Range;

  scbChartLeft->VertScrollBar->Position = scbCharts->VertScrollBar->Position;
  scbChartRight->VertScrollBar->Position = scbCharts->VertScrollBar->Position;

  chrTTPRight->Top = 0;
  chrTTPLeft->Top = 0;

  scbCharts->HorzScrollBar->Range = chrTTP->Width;

  if(!FIsMiminizedChart_)
  {
    FWhidtChart_ = chrTTP->Width;
    FHeight_ = chrTTP->Height;
  }

  pnlScrollTop->Visible = chrTTP->Zoomed;
  pnlScrollBot->Visible = chrTTP->Zoomed;

  if(pnlScrollTop->Visible)
  {
    pnlScrollTop->Top  = 0;
    pnlScrollTop->Left = chrTTP->Left;
    pnlScrollTop->Height = 20;
    pnlScrollTop->Width = chrTTP->Width - chrTTPLeft->Width;
    pnlScrollTop->Left += chrTTPLeft->Width;
    chrTTPTop->Refresh();

    pnlScrollBot->Top  = scbCharts->Height-35;
    pnlScrollBot->Left = chrTTP->Left;
    pnlScrollBot->Height = 20;
    pnlScrollBot->Width = chrTTP->Width - chrTTPLeft->Width;
    pnlScrollBot->Left += chrTTPLeft->Width;
    chrTTPBot->Refresh();
  }

  chrTTP->Refresh();

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPAfterDraw(TObject *Sender)
{
  SincyCharts();

  chrTTPLeft->AutoRepaint = false;
  chrTTPLeft->Width -=1;
  chrTTPLeft->AutoRepaint = true;

  chrTTPLeft->Width +=1;

  #ifdef BENCHMARK_
  TTPBenchmark::getInstance()->EndBenchmark(FRamal_->Nome+"DrawChart", GetTickCount());
  #endif
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::scbChartsEnter(TObject *Sender)
{
 int i = scbCharts->HorzScrollBar->Position;
 //Application->ProcessMessages();
 scbCharts->HorzScrollBar->Position = i;

 FPerdeuFocus_ = true;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGraficoResize(TObject *Sender)
{
  if(chrTTP->Visible)
    chrTTPResize(this);
  SincyCharts();
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::ScrollToOnZoom(double addX, double addY)
{
  if (!FISZoomed_ || (addX == 0 && addY == 0))
    return;

  FMouseYScroll_+= addY;
  FMouseXScroll_+= addX;

  scbCharts->HorzScrollBar->Position+= addX;
  scbCharts->VertScrollBar->Position+= addY;

  int tMeioX = scbCharts->HorzScrollBar->Range/2 - scbCharts->Width/2;
  int tMeioY = scbCharts->VertScrollBar->Range/2 - scbCharts->Height/2;

  if(abs(scbCharts->HorzScrollBar->Position - tMeioX) > scbCharts->HorzScrollBar->Range*0.22 ||
     abs(scbCharts->VertScrollBar->Position - tMeioY) > scbCharts->VertScrollBar->Range*0.22)
  {
    chrTTP->AutoRepaint = true;
    chrTTPTop->AutoRepaint = true;
    chrTTPBot->AutoRepaint = true;

    double t_ProporcaoAddX = (double)(scbCharts->HorzScrollBar->Position - tMeioX) / (double)scbCharts->HorzScrollBar->Range;
    double t_ProporcaoAddY = (double)(scbCharts->VertScrollBar->Position - tMeioY) / (double)scbCharts->VertScrollBar->Range;

    double t_maximumYNew = chrTTP->LeftAxis->Maximum;
    double t_minimumYNew = chrTTP->LeftAxis->Minimum;
    double t_maximumXNew = chrTTP->BottomAxis->Maximum;
    double t_minimumXNew = chrTTP->BottomAxis->Minimum;

    double sizeY = t_maximumYNew - t_minimumYNew;
    double sizeX = t_maximumXNew - t_minimumXNew;

    chrTTP->LeftAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTP->LeftAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTP->RightAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTP->RightAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTP->BottomAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTP->BottomAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    chrTTP->TopAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTP->TopAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    //---- *** ----//

    chrTTPTop->LeftAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTPTop->LeftAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTPTop->RightAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTPTop->RightAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTPTop->BottomAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTPTop->BottomAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    chrTTPTop->TopAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTPTop->TopAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    chrTTPBot->LeftAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTPBot->LeftAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTPBot->RightAxis->Minimum -=  sizeY*t_ProporcaoAddY;
    chrTTPBot->RightAxis->Maximum -=  sizeY*t_ProporcaoAddY;

    chrTTPBot->BottomAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTPBot->BottomAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    chrTTPBot->TopAxis->Minimum +=  sizeX*t_ProporcaoAddX;
    chrTTPBot->TopAxis->Maximum +=  sizeX*t_ProporcaoAddX;

    //---- *** ----//

    scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Range/2 - scbCharts->Width/2;
    scbCharts->VertScrollBar->Position = scbCharts->VertScrollBar->Range/2 - scbCharts->Height/2;

    FMouseYScroll_ = -1;
    FMouseXScroll_ = -1;

    scbCharts->Repaint();
    chrTTP->Repaint();
    chrTTPTop->Repaint();
    chrTTPBot->Repaint();
  }
  else
  {
    scbCharts->Repaint();
  }

  FHorarioCentralAtual_ =  chrTTP->BottomAxis->Minimum + (chrTTP->BottomAxis->Maximum - chrTTP->BottomAxis->Minimum)/2;

  ultimaPosicaoscbChartVert_ = scbCharts->VertScrollBar->Position;
  ultimaPosicaoscbCharts_    = scbCharts->HorzScrollBar->Position;
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::EnableDisableChart(bool val)
{
  chrTTP->Enabled = val;
  chrTTP->Visible = val;
  chrTTP->AutoRepaint=val;

  chrTTPTop->Enabled = val;
  chrTTPTop->Visible = val;

  chrTTPBot->Enabled = val;
  chrTTPBot->Visible = val;

  chrTTPRight->Enabled = val;
  chrTTPRight->Visible = val;

  chrTTPLeft->Enabled = val;
  chrTTPLeft->Visible = val;
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::cboEstadoTremEnter(TObject *Sender)
{
  FExecutouResetPosicao_ = false;
  FPerdeuFocus_ = false;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::cboTipoTremEnter(TObject *Sender)
{
  FExecutouResetPosicao_ = false;
  FPerdeuFocus_ = false;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  chrTTP->Repaint();
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acRefreshSceenExecute(TObject *Sender)
{
 if(!chrTTP->Visible)
  return;

 //Application->ProcessMessages();

 chrTTP->Repaint();
 chrTTPTop->Repaint();
 chrTTPBot->Repaint();
 chrTTPRight->Repaint();
 chrTTPLeft->Repaint();

 //this->Repaint();

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPClickSeries(TCustomChart *Sender, TChartSeries *Series,
          int ValueIndex, TMouseButton Button, TShiftState Shift, int X, int Y)
{
    if(!chrTTP->AutoRepaint)
      chrTTP->AutoRepaint = true;

    TChartSeries* t_clickedSerie;
    TChartSeries* t_serie    = Series;
    TTPTipoSerie t_tipoSerie = GetTipoSerieMP(t_serie);

    if(t_tipoSerie == tsDesconhecido)
     return;

    if(t_tipoSerie == tsMovimento && TTPFormsManager::getInstance()->MovimentosSerieMouseOver &&
       (TChartSeries*)TTPFormsManager::getInstance()->MovimentosSerieMouseOver != Series)
    {
      if(((TTPMovimentoSeries *) Series)->isValidClick())
      {
      TTPFormsManager::getInstance()->MovimentosSerieMouseOver = (TTPMovimentoSeries *) Series;
      TTPFormsManager::getInstance()->MovimentosSerieMouseOver->DoSeriesMouseEnter(this);
    }
    }

    FHabilitarPopup = true;//Shift.Contains(ssRight);

    // OBSERVACAO E PREFIXO
    if ((t_tipoSerie == tsObservacao) || (t_tipoSerie == tsPrefixo))
    {
     // Verifica se Alguma Mark foi clicada...
      if (t_serie->Marks->Clicked(X, Y) >= 0)
      {
          t_clickedSerie = t_serie;
      }
    }
    else
    {
      if (t_serie->Clicked(X, Y) >= 0)
      {
        t_clickedSerie = t_serie;

        if(!acSelecionarRestricao->Checked && !acSelecionar->Checked
          && !acCriarTrem->Checked && !acRestringir->Checked && !acInterditar->Checked )
        {
          if (t_tipoSerie == tsMovimento)
          {
            acSelecionar->Checked = true;
          }
         else if (t_tipoSerie == tsRestricao)
            acSelecionarRestricao->Checked = true;
        }
      }
    }

    if (t_clickedSerie && !Shift.Contains(ssDouble))
    {
      ClickMPSeries(t_clickedSerie, Shift, X, Y);
    }

    //Remover Trem da Restrio
    if (FSelecionarTremRemoverRestricao && t_tipoSerie == tsMovimento)
    {
       if(ListaTrensRemoverRestricao_->IndexOf(((TTPMovimentoSeries *) Series)->Trem->PID)==-1)
       {
         ListaTrensRemoverRestricao_->AddObject(((TTPMovimentoSeries *) Series)->Trem->PID,(TObject*)((TTPMovimentoSeries *) Series)->Trem);
       }
       FSelecionouSerieRemoverRestricao_ = true;
       if(!Shift.Contains(ssCtrl))
       {
         FSelecionarTremRemoverRestricao = false;
       }
    }

  if (FormWidgetGanttOcupacao && FormWidgetGanttOcupacao->Visible)
  {
     Application->ProcessMessages();
     FormWidgetGanttOcupacao->RedrawChart();
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPMouseEnter(TObject *Sender)
{
 // if (!FNoSetFocus_)
 //   chrTTP->SetFocus();

  FNoSetFocus_ = false;
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::RedimencionaChartToVisao()
{
  if(!FISZoomed_)
  {
    if (!FVisaoPlajemanto_)
    {
      if(FIsMiminizedChart_)
        MinimizarChart();
      else
      {
        chrTTP->AutoRepaint = false;
        chrTTP->Width = this->Width*PROPORCAO_TAMANHO_CHART_VISAO_PLANEJAMENTO;
        scbCharts->HorzScrollBar->Range = chrTTP->Width;
        chrTTP->Repaint();
        chrTTP->AutoRepaint = true;
      }
    }
    else
    {
      if(FIsMiminizedChart_)
        MinimizarChart();
      else
      {
        chrTTP->AutoRepaint = false;
        chrTTP->Width = this->Width*PROPORCAO_TAMANHO_CHART_VISAO_AMPLA;
        scbCharts->HorzScrollBar->Range = chrTTP->Width;
        chrTTP->Repaint();
        chrTTP->AutoRepaint = true;
      }
    }
  }

  chrTTPTop->Width = chrTTP->Width;
  chrTTPTop->Repaint();
  chrTTPBot->Width = chrTTP->Width;
  chrTTPBot->Repaint();
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::RestaurarChart()
{
  if(FIsMiminizedChart_)
  {
	TTPFormsManager::getInstance()->gravarLog("Incio: Restaurar Chart");
	bool enableChart = chrTTP->Enabled;
	EnableDisableChart(false);
	FIsMiminizedChart_ = false;

    RedimencionaChartToVisao();

    chrTTP->Width  = FWhidtChart_ ;
    chrTTP->Height = FHeight_ ;
    chrTTPTop->Width  = chrTTP->Width;
    chrTTPBot->Width  = chrTTP->Width;

    scbCharts->HorzScrollBar->Range = chrTTP->Width;

    if(FIsCtrlA_)
    {
      ScrollTo(NULL, 0);
      FIsCtrlA_ = false;
      ultimaPosicaoscbCharts_ = scbCharts->HorzScrollBar->Position;
    }
    else
    {
      scbCharts->HorzScrollBar->Position =  ultimaPosicaoscbCharts_;
    }

    EnableDisableChart(enableChart);
    //Application->ProcessMessages();

	chrTTP->AutoRepaint = true;
	chrTTPTop->AutoRepaint = true;
	chrTTPBot->AutoRepaint = true;
	chrTTPLeft->AutoRepaint = true;
	chrTTPRight->AutoRepaint = true;
	scbCharts->Repaint();
	chrTTP->Repaint();
	chrTTPTop->Repaint();
	chrTTPBot->Repaint();
	TTPFormsManager::getInstance()->gravarLog("Fim: Restaurar Chart");
  }
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::MinimizarChart()
{
  chrTTP->Width  = 10 ;
  chrTTP->Height = 10 ;

  chrTTP->AutoRepaint = true;
  scbCharts->Repaint();
  chrTTP->Repaint();

  EnableDisableChart(false);

  FIsMiminizedChart_ = true;
}

//---------------------------------------------------------------------------
void __fastcall TFormTP::acOficializarTremExecute(TObject *Sender)
{
  try
  {
    if(FSerieMovimentoSelecionada_ != NULL)
    {
      if (!FSerieMovimentoSelecionada_->Trem->IsSuprimido)
      {
        if (Confirme("Confirma a oficializao do trem : " + FSerieMovimentoSelecionada_->Trem->Prefixo + " na " + TTPFormsManager::getInstance()->Mesa + "?"))
        {
          TTPFormsManager::getInstance()->LimparXmlPublicacaoTrens();
        TXStringList* tremOf = new TXStringList();// pois  case sensitive
        tremOf->Add(FSerieMovimentoSelecionada_->Trem->PID);
		String result = TTPGerenteProgramacao::getInstance()->Oficializar
          (algorithm::CoreTMPlanner::getInstance()->getMesaControle(), TTPFormsManager::getInstance()->Trens,
          NULL, NULL, NULL, TTPFormsManager::getInstance()->Usuario.Codigo, true, false, FRamal_->CodigoOficializacaoZonaMesa, tremOf);
		  delete tremOf;
		  if(result.Length() > 0)
		   Informacao("Oficializao do trem " + result + " foi realizada parcialmente");
        }
      }
    }
  }
  catch(Exception &e)
  {
    Alerta(e.Message);
  }
}

//---------------------------------------------------------------------------

void TFormTP::AjustarEstadoControleMovimentosOficializadosEntreMesas()
{
  cboCarregamentoOficializacao->OnChange = NULL;
  if ( algorithm::CoreTMPlanner::getInstance()->isCarregarMovimentosOficializadosAutomaticoSelecionado)
  {
    cboCarregamentoOficializacao->ItemIndex = 0;
  }
  else
  {
    cboCarregamentoOficializacao->ItemIndex = 1;
  }
  cboCarregamentoOficializacao->OnChange = cboCarregamentoOficializacaoChange;
}

void __fastcall TFormTP::cboCarregamentoOficializacaoChange(TObject *Sender)
{
 algorithm::CoreTMPlanner::getInstance()->isCarregarMovimentosOficializadosAutomaticoSelecionado =
 cboCarregamentoOficializacao->ItemIndex == 0;

 TTPFormsManager::getInstance()->AjustarEstadoControleMovimentosOficializadosEntreMesas();
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPBeforeDrawSeries(TObject *Sender)
{
int para =0;

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPBeforeDrawChart(TObject *Sender)
{
    int para =0;
  #ifdef BENCHMARK_
  TTPBenchmark::getInstance()->StartBenchmark(FRamal_->Nome+"DrawChart", GetTickCount());
  #endif
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acAjustarRestricaoAoTremDinamicoExecute(TObject *Sender)

{
  if (acAjustarRestricaoAoTremDinamico->Checked == true)
  {
    acAjustarRestricaoAoTremDinamico->Checked = false;
  }
  else
  {
    acAjustarRestricaoAoTremDinamico->Checked = true;
  }

  acAjustarRestricaoAoTremExecute(Sender);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acLimparTremRestricaoDinamicaExecute(TObject *Sender)
{
  try
  {
    if (FSerieRestricaoSelecionada_)
    {
      acAtivaDesativaDataMaxFimRestricao->Checked = false;
      //acAtivaDesativaDataFimFixa->Checked = false;
      for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;

        algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
        core->SetTremRefInterdicao("", t_restricaoCirculacao->PID, "");

        int indexOf = TTPFormsManager::getInstance()->RestricoesDinamicas->IndexOf(t_restricaoCirculacao->PID);
        if(indexOf > -1)
        {
          TTPFormsManager::getInstance()->RestricoesDinamicas->remove(indexOf);
          t_restricaoCirculacao->Trem = NULL;

          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(t_restricaoCirculacao, TTPFormsManager::getInstance()->Usuario.Codigo);
            t_restricaoCirculacao->IsAlteradoUsuario = false;
          }
          else
          {
            t_restricaoCirculacao->IsAlteradoUsuario = true;
          }
        }
      }
      Application->ProcessMessages();
    }
  }
  catch (Exception& e)
  {
    Alerta(e.Message);
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::PlotarTrem(TTPTrem* pTrem, bool pPlotarPrefixo, bool pTremCopia, bool pAtualizar)
{
  RefreshAfterPlotarTrens_ = true;
  FArrastoSeries_->Visible = false;
  PlotarRotaTrem(pTrem, pPlotarPrefixo, pTremCopia, pAtualizar, pTrem->ItinerarioTrem->Movimentos);
}

void TFormTP::setMovimentoSelecionado(TTPMovimentoSeries* pSerieMovimentoSelecionada)
{
  if(fSerieMovimentoSelecionada_ && fSerieMovimentoSelecionada_!=pSerieMovimentoSelecionada)
  {
    fSerieMovimentoSelecionada_->SetTremSelecionado(false,true);
  }
  fSerieMovimentoSelecionada_ =  pSerieMovimentoSelecionada;
};

void __fastcall TFormTP::cxHintControllerShowHint(TObject *Sender, UnicodeString &HintStr,
          bool &CanShow, THintInfo &HintInfo)
{
   TdxScreenTipStyle* t_hintStyle = (TdxScreenTipStyle*) cxHintController->HintStyle;
  /*if (t_hintStyle->ScreenTipLinks->operator[](0)->Control == NULL)
   {
     HintStr =  "";
   }
  else
  {
    TTPBenchmark::getInstance()->EndBenchmark("HintChart", GetTickCount());
}
    */
  chrTTP->AutoRepaint = false;


  if(t_seriesGlobal->SeriesHint)
  {
    t_seriesGlobal->PreencheHint();
    #ifdef BENCHMARK_
    TTPBenchmark::getInstance()->EndBenchmark("HintChart", GetTickCount());
    #endif
  }
  else
  {
    if(HintStr.Length() < 9)
      HintStr = "";
    else
    {
      if(HintStr == FAROL_VERDE || HintStr == FAROL_AMARELO || HintStr == FAROL_VERMELHO)
      {
        t_seriesGlobal->PreencheHintFarolParametros(HintStr,HintStr == FAROL_VERDE ? tbtAlerta1: HintStr == FAROL_VERMELHO?tbtAlerta3:tbtAlerta2);
      }
    }
  }
}

//---------------------------------------------------------------------------
void  __fastcall TFormTP::ReordenarSeriesObservacao()
{
  bool alterarAutoRepaint = chrTTP->AutoRepaint;
  lblUltimoConflitoResolvido->Visible = false;
  if (algorithm::CoreTMPlanner::getInstance()->getIsUserCanceledCalcularTrensMalha())
  {
    pnlTitulo2->Color   =  clWebLemonChiffon;//TColor((254 * 65536) + (250 * 256) + 169);
    if( TTPFormsManager::getInstance()->ShowVisualizador)
    {
      lblUltimoConflitoResolvido->Visible = true;
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      double segundos = core->getTempoProgessoSolucionarConflito();

      String sTempoProgresso = TUteis::ConverterSeguntosEmStringHHMISS(segundos);

      lblUltimoConflitoResolvido->Caption = "Progresso da soluo de conflitos: "+sTempoProgresso+"    ";
      lblUltimoConflitoResolvido->Left =  pnlTitulo2->Width- lblUltimoConflitoResolvido->Width;
    }
    else
    {
      lblUltimoConflitoResolvido->Visible = false;
    }
  }
  else
  {
    pnlTitulo2->Color = clCream;
  }
  if(alterarAutoRepaint)
    chrTTP->AutoRepaint = false;

  int t_primeiraSerieObservacao= chrTTP->SeriesCount()-1;
  for (int i = chrTTP->SeriesCount(); i >0 ; i--)
  {
    TChartSeries* t_serie = chrTTP->Series[i];
    if (GetTipoSerieMP(t_serie) == tsMovimento)
    {
      chrTTP->ExchangeSeries(i, t_primeiraSerieObservacao);
      t_primeiraSerieObservacao--;
    }
  }

  t_primeiraSerieObservacao= chrTTP->SeriesCount()-1;
  for (int i = chrTTP->SeriesCount(); i >0 ; i--)
  {
    TChartSeries* t_serie = chrTTP->Series[i];
    if (GetTipoSerieMP(t_serie) == tsMovimento)
    {
       TTPMovimentoSeries* tMovimento = (TTPMovimentoSeries*) t_serie;
       if(tMovimento->IsOportunidadeSelecionada)
       {
        chrTTP->ExchangeSeries(i, t_primeiraSerieObservacao);
        t_primeiraSerieObservacao--;
       }
    }
  }

  if(alterarAutoRepaint)
    chrTTP->AutoRepaint = false;
}

void __fastcall TFormTP::acAcionarAutomaticoExecute(TObject *Sender)
{

  bool updTrem = false, updRestricao = false;

  for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
  {
    TTPTremPtr tTrem = TTPFormsManager::getInstance()->Trens->operator[](i);
    if (tTrem->AlterouMovimentoOrigem || TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf(tTrem->PID) >= 0)
    {
      updTrem = true;
      break;
    }
  }

  updRestricao = TTPFormsManager::getInstance()->RestricoesDel->count()>0;

  if(!updRestricao)
  {
    for (int i = 0; i < TTPFormsManager::getInstance()->Restricoes->count(); i++)
    {
      TTPRestricaoPtr tRestricao = TTPFormsManager::getInstance()->Restricoes->get(i);

      if (tRestricao->IsAlteradoUsuario ||  TTPFormsManager::getInstance()->RestricoesDinamicas->IndexOf(tRestricao->PID) > -1)
      {
        updRestricao = true;
        break;
      }
    }
  }

  FAcionarAutomaticoOk_ = true;

  if(updRestricao || updTrem)
  {
    FExibirMsgSalvarAltomatico_ = true;
    FAcionarAutomaticoOk_       = false;

    acPublicarEntreMesasExecute(this);
  }

  if(FAcionarAutomaticoOk_)
  {
    TTPFormsManager::getInstance()->tmrAtualizarOcializacao->Enabled = false;
    TTPFormsManager::getInstance()->AjustarEstadoAcionarAutomatico(false);
    TTPFormsManager::getInstance()->IdUltimaChamadaAutomatico = TDAO::getNextSeqControleLogPlanejamento();
    TTPGerenteComunicacaoAQ::getInstance()->postarMensagemFilaAutomatico(0,TTPFormsManager::getInstance()->Usuario.Codigo,TTPFormsManager::getInstance()->Mesa,TTPFormsManager::getInstance()->IdUltimaChamadaAutomatico );
    TDAO::inserirControleLogPlanejamento(TTPFormsManager::getInstance()->IdUltimaChamadaAutomatico, TTPFormsManager::getInstance()->Mesa, "ACMT_AUTO",
        TDAO::getCurrentDate(), NULL, 0, 0, "W", TTPFormsManager::getInstance()->Usuario.Codigo,  TDAO::getNumeroMesa(TTPFormsManager::getInstance()->Mesa));


    TTPFormsManager::getInstance()->IsEscutarFilaAutomatico = true;
    TTPFormsManager::getInstance()->tmrAtualizarOcializacao->Interval = 10;
    TTPFormsManager::getInstance()->tmrAtualizarOcializacao->Enabled = true;
  }
  FExibirMsgSalvarAltomatico_ = false;
}
//---------------------------------------------------------------------------

void TFormTP::AjustarEstadoAcionarAutomatico(bool pOnOff)
{
  acAcionarAutomatico->Enabled = pOnOff;
}

void __fastcall TFormTP::FormCreate(TObject *Sender)
{
  ConfigurarChartsLimitesHorizontaisDefault();
  ConfigurarGrafico();
  ConfigurarBotoes();

  PlotarLinhasDuplas();

  #ifndef BAIXADA_SANTISTA
  PriorizarDestinos1->Visible = false;
  #endif

  // Cria e esconde a srie que marcar o arrasto
  if (FArrastoSeries_ == NULL)
  {
	FArrastoSeries_                 = new TTPArrastoSeries(chrTTP, 0, 0, FSerieSBs_);
    FArrastoSeries_->SerieMovimento = NULL;
    FArrastoSeries_->Visible        = false;
    chrTTP->AddSeries(FArrastoSeries_);
  }

  chrTTP->Refresh();

}
//---------------------------------------------------------------------------
void __fastcall TFormTP::chrTTPMouseLeave(TObject *Sender)
{
  TTPFormsManager::getInstance()->DrawAllSeries = true;
  if(chrTTP->SeriesCount()>0)
      {
        chrTTP->Series[0]->Visible = false;
        chrTTP->AutoRepaint = true;
        chrTTP->Series[0]->Visible = true;
      }
  //FPanning_ = false;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlInfosResize(TObject *Sender)
{
 ForceRedrawChart();
}
//---------------------------------------------------------------------------


void __fastcall TFormTP::acAlertaEntrePlanosExecute(TObject *Sender)
{
  TCursor t_oldcursor = Screen->Cursor;
  Screen->Cursor = crHourGlass;
  try
  {
    TTPFormsManager::getInstance()->AjustarEstadoControles(false);
    TTPFormsManager::getInstance()->CompararPlanos();
    TTPFormsManager::getInstance()->AjustarEstadoAlertaEntrePlanos(false);
    Screen->Cursor = crHourGlass;
    if(!FormWidgetGridDiferencasEntrePlanos)
    {
      FormWidgetGridDiferencasEntrePlanos = new TFormWidgetGridDiferencasEntrePlanos(0);
    }

    FormWidgetGridDiferencasEntrePlanos->ManualDock(dtsInfos);
    FormWidgetGridDiferencasEntrePlanos->CompararOficializacoes();
    FormWidgetGridDiferencasEntrePlanos->Show();
    FNoSetFocus_  = true;
    FRedrawChart_ = true;
  }
  __finally
  {
   Screen->Cursor = t_oldcursor;
   TTPFormsManager::getInstance()->AjustarEstadoControles(true);

  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlInfosDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y)
{
TFormWidgetBase *tFormWidgetBase = reinterpret_cast<TFormWidgetBase *>(Source->Control);
  if(pnlInfos->DockClientCount==0)
  {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }
  else if(pnlInfos->DockClientCount==1 && tFormWidgetBase)
  {
    pnlInfos->Width =  tFormWidgetBase->WidthBase;
  }
  else
  {
    pnlInfos->Width = PNLINFO_WIDTH;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlInfosDragDrop(TObject *Sender, TObject *Source, int X,
          int Y)
{
if(pnlInfos->DockClientCount==1)
  {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }
  else
    pnlInfos->Width = PNLINFO_WIDTH;

     scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlInfosStartDock(TObject *Sender, TDragDockObject *&DragObject)

{
  if(pnlInfos->DockClientCount==0)
  {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }
  else
    pnlInfos->Width = DragObject->Control->Width;

     scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow)
{
if(pnlInfos->DockClientCount==1)
  {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }
  else
    pnlInfos->Width = PNLINFO_WIDTH;

     scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::dtsInfosDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y)
{
  dtsInfos->TabIndex = dtsInfos->Tabs->Count-1;

  if(pnlInfos->DockClientCount==0)
   {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }

   dtsInfos->Visible = true;

  //pnlGraficoResize(this);
  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::dtsInfosEndDock(TObject *Sender, TObject *Target, int X,
          int Y)
{
  if(pnlInfos->DockClientCount==1)
  {
      pnlInfos->Width = 0;

      ForceRedrawChart();
  }
  else
    pnlInfos->Width = PNLINFO_WIDTH;

     scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::dtsInfosTabRemoved(TObject *Sender)
{
 pnlInfos->Width = 0;


 if(dtsInfos->Tabs->Count==0)
   dtsInfos->Visible = false;

 scbChartsResize(this);


 ForceRedrawChart();

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::dtsInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow)
{
if(pnlInfos->DockClientCount==0 && dtsInfos->Tabs->Count==1)
   {
      pnlInfos->Width = 0;
      dtsInfos->Visible = false;
   }
   else
   dtsInfos->Visible = true;

  scbChartsResize(this);
}
//---------------------------------------------------------------------------
void __fastcall TFormTP::scbChartsResize(TObject *Sender)
{
  pnlGraficoResize(this);
  chrTTPLeft->AutoRepaint = true;
  chrTTPRight->AutoRepaint = true;


  //Application->ProcessMessages();

  scbChartLeft->Left = scbCharts->Left;
  scbChartRight->Left = scbChartLeft->Left+scbCharts->Width - scbChartRight->Width;

  chrTTPRight->AutoRepaint = true;
  chrTTPLeft->AutoRepaint = true;


  //Application->ProcessMessages();

  chrTTPLeft->Repaint();
  chrTTPRight->Repaint();

  //Application->ProcessMessages();
  scbChartRight->Refresh();
  scbChartLeft->Refresh();
  this->Canvas->Refresh();
  //Application->ProcessMessages();


  FIsMiminizedChart_ = false;

  RedimencionaChartToVisao();

}
void __fastcall TFormTP::dtsInfosMeasureTab(TObject *Sender, int Index, int &TabWidth)

{
  int i = 0;
}
//---------------------------------------------------------------------------


void __fastcall TFormTP::chrTTPEnter(TObject *Sender)
{
  if(FRedrawChart_)
  {
    scbChartsResize(this);
    FRedrawChart_ = false;
    FRedrawChartOnMouseMove_ = true;
  }
}
//---------------------------------------------------------------------------

void  __fastcall TFormTP::ForceRedrawChart()
{
  chrTTP->AutoRepaint = false;
  chrTTP->Width -=1;
  chrTTP->AutoRepaint = true;

  chrTTP->Width +=1;
  chrTTP->AutoRepaint = false;

  FRedrawChartOnMouseMove_ = false;
}

void __fastcall TFormTP::AtualizarAlertaEntrePlanos()
{
   if(FormWidgetGridDiferencasEntrePlanos)
     delete FormWidgetGridDiferencasEntrePlanos;

   FormWidgetGridDiferencasEntrePlanos =  NULL;
   pnlInfos->Width = 0;
//	 if(!FormWidgetGridDiferencasEntrePlanos)
//	 {
//		 FormWidgetGridDiferencasEntrePlanos = new TFormWidgetGridDiferencasEntrePlanos(0);
//	 }
//	 FormWidgetGridDiferencasEntrePlanos->CompararOficializacoes();

}
void __fastcall TFormTP::acAtivaDesativaDataMaxFimRestricaoExecute(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->Trem)
  {
    if(acAtivaDesativaDataMaxFimRestricao->Checked == True)
    {
      acAtivaDesativaDataMaxFimRestricao->Checked = false;
    }
    else
    {
      acAtivaDesativaDataMaxFimRestricao->Checked = true;
    }

    for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
    {
      TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
      TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;
      //Evitar dar o DrawValue - Erro GDI o mtodo AtualizarRestricoesDinamicas vai fazer o zervio
      AtualizarRestricoesServer(t_restricaoCirculacao->Trem, true);
    }
    TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    RetirarSelecao();
  }
}
//---------------------------------------------------------------------------
bool TFormTP::IsSerieValida(TChartSeries* serie)
{
  bool result = false;
  if(serie)
  {
    if(chrTTP->SeriesList->IndexOf(serie) > -1)
      result = true;
  }
  return result;
}
//---------------------------------------------------------------------------


void __fastcall TFormTP::acAdicionarTempoDataMaxRestricaoExecute(TObject *Sender)

{
if (FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->Trem)
  {
    String strTempoAdd = "";
    strTempoAdd = InputBox("Aumentar a Data Mxima de Trmino da Restrio", "Informe o tempo (nmero de minutos ou HH:MM) que desja adicionar a data mxima de trmino da Restrio",0 );
    int intTempoAdd = TUteis::ConverterStringEmMinutos(strTempoAdd);

    if(intTempoAdd > 0)
    {
      double tempoAdd = ((1.0/24.0)/60.0) * intTempoAdd;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;
        if(t_restricaoCirculacao->DataMaxFim > TDateTime(0))
        {

          TStringList *t_listServer = new TStringList();
          for (int z = 0; z < t_restricaoCirculacao->SBsRestricao->count(); z++)
          {
            t_listServer->Add(t_restricaoCirculacao->SBsRestricao->operator[](z)->NomeVia);
          }

          double novaData = t_restricaoCirculacao->DataMaxFim;
          novaData += tempoAdd;
          t_restricaoCirculacao->DataMaxFim = TDateTime(novaData);
          if(t_restricaoCirculacao->DataMaxFim > t_restricaoCirculacao->DataFim)
            t_restricaoCirculacao->DataFim = t_restricaoCirculacao->DataMaxFim;

          core->AlterarRestricao(t_restricaoCirculacao->DataInicio, t_restricaoCirculacao->DataFim, t_listServer, t_restricaoCirculacao->PID,
              t_restricaoCirculacao->VMA, t_restricaoCirculacao->DataInicioReal, t_restricaoCirculacao->DataFimReal, t_restricaoCirculacao->ListaConexoes, t_restricaoCirculacao->DataMinInicio, t_restricaoCirculacao->DataMaxFim);

          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(t_restricaoCirculacao, TTPFormsManager::getInstance()->Usuario.Codigo);
            t_restricaoCirculacao->IsAlteradoUsuario = false;
          }
          else
          {
            t_restricaoCirculacao->IsAlteradoUsuario = true;
          }

          delete t_listServer;
        }
      }
      RetirarSelecao();
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    }
    FSerieRestricaoSelecionada_ = NULL;
  }
}
//---------------------------------------------------------------------------


void __fastcall TFormTP::acAtivaDesativaDataFimFixaExecute(TObject *Sender)
{

if (FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->Trem)
  {
    if(acAtivaDesativaDataFimFixa->Checked == True)
    {
      acAtivaDesativaDataFimFixa->Checked = false;
    }
    else
    {
      acAtivaDesativaDataFimFixa->Checked = true;
    }

    for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
    {
      TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
      TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;
      //Evitar dar o DrawValue - Erro GDI o mtodo AtualizarRestricoesDinamicas vai fazer o zervio
      AtualizarRestricoesServer(t_restricaoCirculacao->Trem, true);
    }
    TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    RetirarSelecao();
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acAtivaDesativaDataFimFixaUpdate(TObject *Sender)
{
  if(acAtivaDesativaDataFimFixa->Checked == True)
  {
    acAtivaDesativaDataFimFixa->Caption = "Destravar Data Fim da Restrio";
  }
  else
  {
    acAtivaDesativaDataFimFixa->Caption = "Travar Data Fim da Restrio";
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acSetDuracaoRestricaoExecute(TObject *Sender)
{
if (FSerieRestricaoSelecionada_)
  {
    String strTempoAdd = "";
    strTempoAdd = InputBox("Ajustar durao da Restrio", "Informe o tempo total da Restrio (nmero de minutos ou HH:MM)",0 );
    int intTempoAdd = TUteis::ConverterStringEmMinutos(strTempoAdd);
    if(intTempoAdd > 15)
    {
      double tempoAdd = ((1.0/24.0)/60.0) * intTempoAdd;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;

        TStringList *t_listServer = new TStringList();
        for (int z = 0; z < t_restricaoCirculacao->SBsRestricao->count(); z++)
        {
          t_listServer->Add(t_restricaoCirculacao->SBsRestricao->operator[](z)->NomeVia);
        }

        double novaData = t_restricaoCirculacao->DataInicio;
        novaData += tempoAdd;
        if(t_restricaoCirculacao->DataMaxFim > TDateTime(0) && t_restricaoCirculacao->ISDataMaxFimAtiva && TDateTime(novaData) > t_restricaoCirculacao->DataMaxFim)
          t_restricaoCirculacao->DataFim = t_restricaoCirculacao->DataMaxFim;
        else
          t_restricaoCirculacao->DataFim = TDateTime(novaData);

        core->AlterarRestricao(t_restricaoCirculacao->DataInicio, t_restricaoCirculacao->DataFim, t_listServer, t_restricaoCirculacao->PID,
            t_restricaoCirculacao->VMA, t_restricaoCirculacao->DataInicioReal, t_restricaoCirculacao->DataFimReal, t_restricaoCirculacao->ListaConexoes, t_restricaoCirculacao->DataMinInicio, t_restricaoCirculacao->DataMaxFim);

        if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
        {
          TDAO::gravarRestricao(t_restricaoCirculacao, TTPFormsManager::getInstance()->Usuario.Codigo);
          t_restricaoCirculacao->IsAlteradoUsuario = false;
        }
        else
        {
          t_restricaoCirculacao->IsAlteradoUsuario = true;
        }

        delete t_listServer;
        FSerieRestricaoSelecionada_ = restSel;
        AtualizarRestricao(t_restricaoCirculacao);
        FSerieRestricaoSelecionada_ = NULL;
      }

      RetirarSelecao();
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    }
    else
    {
      if(intTempoAdd > 0)
        Alerta("Durao do intervalo inferior a 15 minutos");
    }
  }
}
//---------------------------------------------------------------------------


void __fastcall TFormTP::acReduzirTempoDataMinRestricaoExecute(TObject *Sender)
{
if (FSerieRestricaoSelecionada_ && FSerieRestricaoSelecionada_->Restricao->Trem)
  {
    String strTempoAdd = "";
    strTempoAdd = InputBox("Diminuir a Data Mnima de Incio da Restrio", "Informe o tempo (nmero de minutos ou HH:MM) que desja reduzir da data mnima de incio da Restrio",0 );
    int intTempoAdd = TUteis::ConverterStringEmMinutos(strTempoAdd);
    if(intTempoAdd > 0)
    {
      double tempoAdd = ((1.0/24.0)/60.0) * intTempoAdd;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;
        if(t_restricaoCirculacao->DataMaxFim > TDateTime(0))
        {

          TStringList *t_listServer = new TStringList();
          for (int z = 0; z < t_restricaoCirculacao->SBsRestricao->count(); z++)
          {
            t_listServer->Add(t_restricaoCirculacao->SBsRestricao->operator[](z)->NomeVia);
          }

          double novaData = t_restricaoCirculacao->DataMinInicio;
          novaData -= tempoAdd;
          t_restricaoCirculacao->DataMinInicio = TDateTime(novaData);
          core->AlterarRestricao(t_restricaoCirculacao->DataInicio, t_restricaoCirculacao->DataFim, t_listServer, t_restricaoCirculacao->PID,
              t_restricaoCirculacao->VMA, t_restricaoCirculacao->DataInicioReal, t_restricaoCirculacao->DataFimReal, t_restricaoCirculacao->ListaConexoes ,t_restricaoCirculacao->DataMinInicio, t_restricaoCirculacao->DataMaxFim);

          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(t_restricaoCirculacao, TTPFormsManager::getInstance()->Usuario.Codigo);
            t_restricaoCirculacao->IsAlteradoUsuario = false;
          }
          else
          {
            t_restricaoCirculacao->IsAlteradoUsuario = true;
          }

          delete t_listServer;
        }
      }
      RetirarSelecao();
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    }
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acRestaurarDuracaoOriginalExecute(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_)
  {
    {
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      for(int i = 0; i < FSeriesRestSelecionadas_->Count; i++)
      {
        TTPRestricaoSeries* restSel = (TTPRestricaoSeries*)FSeriesRestSelecionadas_->Objects[i];
        if(restSel->Restricao->DataMaxFimOriginal > TDateTime(0)
          && restSel->Restricao->DataMinInicioOriginal > TDateTime(0))
        {
          TTPRestricaoPtr t_restricaoCirculacao = restSel->Restricao;

          TStringList *t_listServer = new TStringList();
          for (int z = 0; z < t_restricaoCirculacao->SBsRestricao->count(); z++)
          {
            t_listServer->Add(t_restricaoCirculacao->SBsRestricao->operator[](z)->NomeVia);
          }

          double difOriginal =  ((double)t_restricaoCirculacao->DataMaxFimOriginal) - ((double) t_restricaoCirculacao->DataMinInicioOriginal);
          TDateTime novaData = t_restricaoCirculacao->DataInicio + difOriginal;

          if(t_restricaoCirculacao->DataMaxFim > TDateTime(0) && t_restricaoCirculacao->ISDataMaxFimAtiva && novaData > t_restricaoCirculacao->DataMaxFim)
            t_restricaoCirculacao->DataFim = t_restricaoCirculacao->DataMaxFim;
          else
            t_restricaoCirculacao->DataFim = novaData;

          core->AlterarRestricao(t_restricaoCirculacao->DataInicio, t_restricaoCirculacao->DataFim, t_listServer, t_restricaoCirculacao->PID,
              t_restricaoCirculacao->VMA, t_restricaoCirculacao->DataInicioReal, t_restricaoCirculacao->DataFimReal, t_restricaoCirculacao->ListaConexoes, t_restricaoCirculacao->DataMinInicio, t_restricaoCirculacao->DataMaxFim);

          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(t_restricaoCirculacao, TTPFormsManager::getInstance()->Usuario.Codigo);
            t_restricaoCirculacao->IsAlteradoUsuario = false;
          }
          else
          {
            t_restricaoCirculacao->IsAlteradoUsuario = true;
          }

          delete t_listServer;
          FSerieRestricaoSelecionada_ = restSel;
          AtualizarRestricao(t_restricaoCirculacao);
          FSerieRestricaoSelecionada_ = NULL;
        }
      }

      RetirarSelecao();
      TTPFormsManager::getInstance()->AtualizarRestricoesDinamicas();
    }
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acAtividadesAlteradasExecute(TObject *Sender)
{
 if(!FormWidgetGridAtividadesAlteradas)
 {
   FormWidgetGridAtividadesAlteradas = new TFormWidgetGridAtividadesAlteradas(0);
   FormWidgetGridAtividadesAlteradas->AtualizarGird();

 }

  FormWidgetGridAtividadesAlteradas->ManualDock(dtsInfos);

  FormWidgetGridAtividadesAlteradas->Show();
  FNoSetFocus_  = true;
  FRedrawChart_ = true;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acParametrosDesativadosTpExpExecute(TObject *Sender)
{
  //teste
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acReterExecute(TObject *Sender)
{
   acInterditarExecute(this);
   acReter->Checked = true;
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acOcupacaoPatiosExecute(TObject *Sender)
{
  if(chrTTP->Zoomed)
    return;

  if (!FormWidgetGanttOcupacao)
  {
    FormWidgetGanttOcupacao = new TFormWidgetGanttOcupacao(0, this, UMAHORA, UMDIA, TP_MAXX_PLAN);

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    MalhaFerroviaria* t_malha = core->getMalha();
    String siglaPatio = "-";
    for(int i = 0; i<this->FListSBs_->count(); i++)
    {
      int idxSB = t_malha->listaSBMalha->IndexOf(this->FListSBs_->get(i)->NomeVia);
      if (idxSB > -1)
      {
        SB* sb1 = (SB*)t_malha->listaSBMalha->Objects[idxSB];

        if (sb1->segmento && sb1->segmento->patioPertencente)
        {
          siglaPatio = sb1->segmento->patioPertencente->sigla;
        }

        if(siglaPatio!="" && siglaPatio!="-")
        {
          FormWidgetGanttOcupacao->SelecionarPatio(siglaPatio, this);
          break;
        }
      }
    }
  }
  FormWidgetGanttOcupacao->SetFTP(this);
  FormWidgetGanttOcupacao->Visible = false;
  FormWidgetGanttOcupacao->ManualDock(dtsGanttOcupacao);
  FormWidgetGanttOcupacao->Show();
  Application->ProcessMessages();
  FormWidgetGanttOcupacao->RefreshSeries();

  FNoSetFocus_ = true;
  FRedrawChart_ = true;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::dtsGanttOcupacaoDockDrop(TObject *Sender, TDragDockObject *Source, int X, int Y)
{
  ForceRedrawChart();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::dtsGanttOcupacaoEndDock(TObject *Sender, TObject *Target, int X, int Y)
{
  FMouseYSBs_ = 0;
  ForceRedrawChart();
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::dtsGanttOcupacaoUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget, bool &Allow)
{
  if (dtsGanttOcupacao->DockClientCount == 0 && dtsGanttOcupacao->Tabs->Count == 1)
  {
    dtsGanttOcupacao->Visible = false;
  }
  else
    dtsGanttOcupacao->Visible = true;

  scbChartsResize(this);
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPLeftMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
  FMouseYSBs_ = Y;
}
// ---------------------------------------------------------------------------

void __fastcall TFormTP::chrTTPLeftDblClick(TObject *Sender)
{
  if(chrTTP->Zoomed)
  return;

  TTPSBListPtr tListaSBs = new TTPSBList();
  TTPSBPtr t_sb = NULL;

  double coordY = FSerieSBs_->YScreenToValue(FMouseYSBs_);
  coordY = RoundTo(coordY, -3);
  double tY = FSerieSBs_->CalcYPosValue(coordY);

  t_sb = GetSBByY(coordY);
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha = core->getMalha();

  String siglaPatio = "-";
  if (t_sb)
  {
    int idxSB = t_malha->listaSBMalha->IndexOf(t_sb->NomeVia);
    if (idxSB > -1)
    {
      SB* sb1 = (SB*)t_malha->listaSBMalha->Objects[idxSB];

      if (sb1->segmento && sb1->segmento->patioPertencente)
      {
        siglaPatio = sb1->segmento->patioPertencente->sigla;
      }
      /*
       for(int i=0; i< this->FListSBs_->count();i++ )
       {
       TTPSBPtr t_sb1 = this->FListSBs_->operator[](i);
       idxSB = t_malha->listaSBMalha->IndexOf(t_sb1->NomeVia);
       if(idxSB>-1)
       {
       SB* sb2 = (SB*)t_malha->listaSBMalha->Objects[idxSB];
       if(tListaSBs->IndexOf(t_sb1->NomeVia)==-1 &&  sb1->segmento && sb2->segmento && sb1->segmento->patioPertencente && sb1->segmento->patioPertencente == sb2->segmento->patioPertencente)
       {
       tListaSBs->add(t_sb1->NomeVia,this->FListSBs_->operator[](i));
       }
       }
       } */
    }
  }

  if (siglaPatio != "-")
  {
    if (!FormWidgetGanttOcupacao)
    {
      FormWidgetGanttOcupacao = new TFormWidgetGanttOcupacao(0, this, UMAHORA, UMDIA, TP_MAXX_PLAN);
    }
    FormWidgetGanttOcupacao->SetFTP(this);
    FormWidgetGanttOcupacao->SelecionarPatio(siglaPatio, this);
    FormWidgetGanttOcupacao->ManualDock(dtsGanttOcupacao);

    FormWidgetGanttOcupacao->Show();

    FNoSetFocus_ = true;
    FRedrawChart_ = true;
  }
}
// ---------------------------------------------------------------------------


void __fastcall TFormTP::pnlGanttOcupacaoDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y)
{
  TFormWidgetBase *tFormWidgetBase = reinterpret_cast<TFormWidgetBase*>(Source->Control);
  if (pnlGanttOcupacao->DockClientCount == 0)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;
    //pnlControles->Height = 55;

    ForceRedrawChart();
  }
  else if (pnlGanttOcupacao->DockClientCount == 1 && tFormWidgetBase)
  {
    pnlGanttOcupacao->Height = tFormWidgetBase->HeightBase;
    sptGanttOcupacao->Height = 8;
  }
  else
  {
    pnlGanttOcupacao->Height = PNL_HEIGHT;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoDragDrop(TObject *Sender, TObject *Source,
          int X, int Y)
{
  if (pnlGanttOcupacao->DockClientCount == 1)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;

    ForceRedrawChart();
  }
  else
  {
    pnlGanttOcupacao->Height = PNL_HEIGHT;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoEndDock(TObject *Sender, TObject *Target,
          int X, int Y)
{
  if (pnlGanttOcupacao->DockClientCount == 1)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;

    ForceRedrawChart();
  }
  else
  {
    pnlGanttOcupacao->Height = PNL_HEIGHT;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoEndDrag(TObject *Sender, TObject *Target,
          int X, int Y)
{
  if (pnlGanttOcupacao->DockClientCount == 1)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;

    ForceRedrawChart();
  }
  else
  {
    pnlGanttOcupacao->Height = PNL_HEIGHT;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoResize(TObject *Sender)
{
  ForceRedrawChart();
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoStartDock(TObject *Sender, TDragDockObject *&DragObject)

{
  if (pnlGanttOcupacao->DockClientCount == 0)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;

    ForceRedrawChart();
  }
  else
  {
    pnlGanttOcupacao->Height = DragObject->Control->Height;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::pnlGanttOcupacaoUnDock(TObject *Sender, TControl *Client,
          TWinControl *NewTarget, bool &Allow)
{
  if (pnlGanttOcupacao->DockClientCount == 1)
  {
    pnlGanttOcupacao->Height = 0;
    sptGanttOcupacao->Height = 0;

    if(FormWidgetGanttOcupacao)
    {
      FormWidgetGanttOcupacao->Hide();
      FormWidgetGanttOcupacao->LimparGannt();


      FNoSetFocus_ = true;
      FRedrawChart_ = true;
    }
    //FormWidgetGanttOcupacao = NULL;

    ForceRedrawChart();
  }
  else
  {
    pnlGanttOcupacao->Height = PNL_HEIGHT;
    sptGanttOcupacao->Height = 8;
  }

  scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::dtsGanttOcupacaoTabRemoved(TObject *Sender)
{
  pnlGanttOcupacao->Height = 0;
  sptGanttOcupacao->Height = 0;

  if (dtsGanttOcupacao->Tabs->Count == 0)
    dtsGanttOcupacao->Visible = false;

  scbChartsResize(this);


  ForceRedrawChart();

}
//---------------------------------------------------------------------------
void TFormTP::setFormWidgetGanttOcupacao(TFormWidgetGanttOcupacao *pFormWidgetGanttOcupacao)
{
   FormWidgetGanttOcupacao = pFormWidgetGanttOcupacao;
}

void __fastcall TFormTP::NewScrollBoxWP(TMessage& AMsg)
{
  if (FormWidgetGanttOcupacao && AMsg.Msg == WM_HSCROLL)
  {
    FormWidgetGanttOcupacao->scbCharts->HorzScrollBar->Position = scbCharts->HorzScrollBar->Position;
    FormWidgetGanttOcupacao->FScrollBoxPos = scbCharts->HorzScrollBar->Position;
  }

  OldScrollBoxWP(AMsg);
}


void __fastcall TFormTP::acRemoverTrensRetencaoExecute(TObject *Sender)
{
   FSelecionarTremRemoverRestricao = true;
}
//---------------------------------------------------------------------------
 void TFormTP::SetSelecionarTremRemoverRestricao(bool pSelecionarTrem)
{
  if(!ListaTrensRemoverRestricao_)
  {
    ListaTrensRemoverRestricao_ = new TStringList();
  }

  FSelecionarTremRemoverRestricao_ = pSelecionarTrem;

  if(pSelecionarTrem)
  {
    ListaTrensRemoverRestricao_->Clear();
  }
  else
  {
    if (FSerieRestricaoSelecionada_)
    {
      if(ListaTrensRemoverRestricao_->Count == 0 || (!(FSerieRestricaoSelecionada_->Restricao->Tipo->ISPermiteOcupacao && FSerieRestricaoSelecionada_->Restricao->Tipo->ISPararTrem)) )
      {
        ListaTrensRemoverRestricao_->Clear();
        return;
      }

      TTPRestricaoSeries* restTemp = FSerieRestricaoSelecionada_;

      acAjustarRestricaoAoTrem->Checked = false;
      TTPFormsManager::getInstance()->RetirarSelecao();

      FSerieRestricaoSelecionada_              = restTemp;
      FSerieRestricaoSelecionada_->Selecionado = true;
      FHabilitarPopup                          = true;
      FPopupContexto_                          = pmnRestricoes;
      FTipoSelecaoAtual_                       = tselRestricao;
      FPIDObjetoSelecionado_                   = FSerieRestricaoSelecionada_->Restricao->PID;

      TTPRestricaoPtr t_restricao = FSerieRestricaoSelecionada_->Restricao;
      if (!t_restricao->GetSBInicio().isNull() && !t_restricao->GetSBFim().isNull())
      {
        TFormRestricao* t_formRestricao = new TFormRestricao(this, this->FListSBs_, t_restricao,
          t_restricao->GetSBInicio(), t_restricao->GetSBFim());
        String tCaptionForm = t_formRestricao->Caption;
        t_formRestricao->Caption = (t_restricao->Tipo->ISPararTrem ? "Gerenciamento de Interdio" :
          "Gerenciamento de Restrio") + tCaptionForm;

        t_formRestricao->SetListaTrensRemovidos(ListaTrensRemoverRestricao_);


        FSelecionouSerieRemoverRestricao_ = false;
        if (t_formRestricao->ShowModal() == mrOk)
        {
          Application->ProcessMessages();
          if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
          {
            TDAO::gravarRestricao(t_restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
            t_restricao->IsAlteradoUsuario = false;
          }
          TTPFormsManager::getInstance()->AtualizarRestricao(t_restricao);
        }
      }
    }
  }
}
void __fastcall TFormTP::acLimparTrensRemovidosRetencaoExecute(TObject *Sender)
{
  if (FSerieRestricaoSelecionada_)
  {
    FSerieRestricaoSelecionada_->Restricao->ListaTrensDesconsiderar->Clear();

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TStringList *t_listServer = new TStringList();
    for (int i = 0; i < FSerieRestricaoSelecionada_->Restricao->SBsRestricao->count(); i++)
    {
      t_listServer->Add(FSerieRestricaoSelecionada_->Restricao->SBsRestricao->operator[](i)->NomeVia);
    }

    core->AlterarRestricao(FSerieRestricaoSelecionada_->Restricao->DataInicio, FSerieRestricaoSelecionada_->Restricao->DataFim, t_listServer,
        FSerieRestricaoSelecionada_->Restricao->PID, FSerieRestricaoSelecionada_->Restricao->VMA, FSerieRestricaoSelecionada_->Restricao->DataInicioReal,
        FSerieRestricaoSelecionada_->Restricao->DataFimReal, FSerieRestricaoSelecionada_->Restricao->ListaConexoes, FSerieRestricaoSelecionada_->Restricao->DataMinInicio, FSerieRestricaoSelecionada_->Restricao->DataMaxFim,3,FSerieRestricaoSelecionada_->Restricao->ListaTrensDesconsiderar );
    FSerieRestricaoSelecionada_->DrawValue(0);

    FSerieRestricaoSelecionada_->Restricao->IsAlteradoUsuario = true;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acRetencaoDinamicaExecute(TObject *Sender)
{

  TAction* actionAux = (TAction*)Sender;
  String cmd = actionAux->Caption;

  TTPMenuDinamico* menuDin = (TTPMenuDinamico*) menusDinamicos_->Objects[menusDinamicos_->IndexOf(cmd)];

  TTPRestricaoPtr t_restricao = new TTPRestricao();

  t_restricao->Tipo = menuDin->RestricaoModelo->Tipo;

  for(int i = 0; i < menuDin->RestricaoModelo->SBsRestricao->count(); i++)
  {
    TTPSBPtr sb = menuDin->RestricaoModelo->SBsRestricao->get(i);
    t_restricao->SBsRestricao->add(sb->NomeVia, sb);
  }

  for(int i = 0; i < menuDin->RestricaoModelo->ListaConexoes->Count; i++)
  {
    domain::ConexaoSB* con = (domain::ConexaoSB*) menuDin->RestricaoModelo->ListaConexoes->Objects[i];
    t_restricao->ListaConexoes->AddObject(menuDin->RestricaoModelo->ListaConexoes->KeyNames[i], (TObject*) con);
  }

  TTPSBPtr sbInicio = TTPFormsManager::getInstance()->SBs->get(menuDin->SBInicio);
  TTPSBPtr sbFim    = TTPFormsManager::getInstance()->SBs->get(menuDin->SBFim);

  TFormRestricao* t_formRestricao = new TFormRestricao(this, TTPFormsManager::getInstance()->SBs, t_restricao, sbInicio, sbFim);
  t_formRestricao->Caption        = (menuDin->Caption);

  if (t_formRestricao->ShowModal() == mrOk)
  {
    TTPFormsManager::getInstance()->Restricoes->add(t_restricao->PID, t_restricao);
    TTPFormsManager::getInstance()->PlotarRestricao(t_restricao);

    AtualizarRestricao(t_restricao);
    TTPFormsManager::getInstance()->AtualizarRestricao(t_restricao);

    if (TTPFormsManager::getInstance()->Usuario.Nivel <= nivPadrao)
    {
      TDAO::gravarRestricao(t_restricao, TTPFormsManager::getInstance()->Usuario.Codigo);
      t_restricao->IsAlteradoUsuario = false;
    }

    TTPFormsManager::getInstance()->setFocus(t_restricao);
  }

  acSelecionar->Checked = true;
  acSelecionarExecute(this);

}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acLogIntegracaoExecute(TObject *Sender)
{
    TFormControleLogs    *fControleLogs  =  new TFormControleLogs(0);
    fControleLogs->Show();
}
//---------------------------------------------------------------------------
void TFormTP::AlterarIconeLog(bool checkError)
{
   try
   {
     if(checkError)
     {
            tbtLog->ImageIndex = 38;
     }else
     {
          tbtLog->ImageIndex = 39;
     }

  }
   catch (Exception& e)
   {
    Alerta(e.Message);
   }
}
//---------------------------------------------------------------------------
TTPTremPtr TFormTP::AddTremListaLocal(String pidTrem)
{
	TTPTremPtr t_trem  = TTPFormsManager::getInstance()->Trens->get(pidTrem);
	t_trem->IsTremGHP = true;

	FTrens_->add(t_trem->PID, t_trem);

	TTPFormsManager::getInstance()->PlotarTrem(&*t_trem, true);

	return t_trem;
}

TTPRestricaoPtr TFormTP::AddRestricaoListaLocal(TTPRestricaoPtr& pRestricao)
{
	 String codigo = pRestricao->Tipo->Codigo;
	//restricao de velocidade

	TTPFormsManager::getInstance()->Restricoes->add(pRestricao->PID, pRestricao);

	for (int i = 0; i < TTPFormsManager::getInstance()->Restricoes->count(); i++)
	{
	  TTPRestricaoPtr t_Restricao = TTPFormsManager::getInstance()->Restricoes->get(i);
	  if(t_Restricao->PID == pRestricao->PID)
	  {
		TTPFormsManager::getInstance()->PlotarRestricao(t_Restricao);
		return  t_Restricao;
	  }

	}
	// Plotar Restries
	return NULL;
}
void __fastcall TFormTP::GroupBox5Click(TObject *Sender)
{
  if(TTPFormsManager::getInstance()->getAmbienteDebug())
  {
	TFormSelecionarOficializacao *formSelecionarOficializacao;
	formSelecionarOficializacao = new TFormSelecionarOficializacao(this, true);
	formSelecionarOficializacao->ShowModal();
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acInfoExecute(TObject *Sender)
{
  if(FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;
    String tPID = tTrem->PID;
    String tPIDExt = tTrem->IDExterno;
    String tPrefixo = tTrem->Prefixo;
    String tFicha = "No encontrado";

    if(FSerieMovimentoSelecionada_->Movimento->ServerSegTremPlanejado)
    {
	   tFicha = FSerieMovimentoSelecionada_->Movimento->ServerSegTremPlanejado->fichaTrem->PID;
    }
    else if(FSerieMovimentoSelecionada_->Movimento->ServerSegTremOficializado)
    {
       tFicha = FSerieMovimentoSelecionada_->Movimento->ServerSegTremOficializado->getFichaTrem()->PID;
    }
    else if(FSerieMovimentoSelecionada_->Movimento->ServerSegTremRealizado)
    {
       tFicha = FSerieMovimentoSelecionada_->Movimento->ServerSegTremRealizado->fichaTrem->PID;
    }
    String mensagemAlerta = "TREM:\n";
    mensagemAlerta += "Prefixo: " +tPrefixo + "\n";
    mensagemAlerta += "PID: " +tPID + "\n";
    mensagemAlerta += "PID Externo: " +tPIDExt + "\n";
    mensagemAlerta += "PID Ficha: " +tFicha + "\n";
    Alerta(mensagemAlerta);
  }
  else if(FSerieRestricaoSelecionada_ != NULL)
  {
    TTPRestricaoPtr tRestricao = FSerieRestricaoSelecionada_->Restricao;
    String tPID = tRestricao->PID;
    String tPIDExt = tRestricao->IDExterno;
    String tTipo = tRestricao->Tipo->Nome;
    String mensagemAlerta = tTipo + ":\n";
    mensagemAlerta += "PID: " +tPID + "\n";
    mensagemAlerta += "PID Externo: " +tPIDExt + "\n";
    Alerta(mensagemAlerta);
  }
}
//---------------------------------------------------------------------------

void TFormTP::RedrawAllMovimentoSeries()
{
  for (int i = 0; i< chrTTP->SeriesCount(); i++)
  {
	TChartSeries* t_serie = chrTTP->Series[i];
	if (GetTipoSerieMP(t_serie) == tsMovimento)
    {
       TTPMovimentoSeries* tMovimento = (TTPMovimentoSeries*) t_serie;
       tMovimento->RedrawSerie(false);
    }
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acTelaWidgetDebugExecute(TObject *Sender)
{
  if(TTPFormsManager::getInstance()->getAmbienteDebug() || TTPFormsManager::getInstance()->Usuario.Nivel > nivPadrao)
   {
     if (!FormWidgetDebug)
     {
        FormWidgetDebug = new TFormWidgetDebug (this, this);
     }
   FormWidgetDebug->SetFTP (this);
   FormWidgetDebug->Visible = false;
   FormWidgetDebug->ManualDock(dtsGanttOcupacao);
   FormWidgetDebug->Show();

   FNoSetFocus_ = true;
   FRedrawChart_ = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TFormTP::acAtivarDesativarCalculoVelocidadeExecute(TObject *Sender)

{
  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* tTrem = FSerieMovimentoSelecionada_->Trem;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    if(tTrem->ISCalculoVelocidadeAtivo)
    {
      core->setIsCalculoVelocidadeAtivoTrem(tTrem->PID, false);
      tTrem->ISCalculoVelocidadeAtivo = false;
    }
    else
    {
      core->setIsCalculoVelocidadeAtivoTrem(tTrem->PID, true);
      tTrem->ISCalculoVelocidadeAtivo = true;
    }
  }

}
//---------------------------------------------------------------------------

void TFormTP::AdjustGroupBoxesPosition()
{

  if(!this->Visible)
  return;

  Panel2->Left = pnlControles->Width- Panel2->Width-5;
  GroupBox5->Left =  Panel2->Left-GroupBox5->Width-2;
  Panel2->Top = gbxAlerta->Top-3;

  if(gbxAlerta->Left+gbxAlerta->Width > Panel2->Left && std::abs(gbxAlerta->Top-Panel2->Top)<10)
  {
    Panel2->Top = Panel2->Top+Panel2->Height -3;
    GroupBox5->Top = Panel2->Top+3;
    GroupBox5->Left =  Panel2->Left-GroupBox5->Width;
  }
  else if(gbxAlerta->Left+gbxAlerta->Width > GroupBox5->Left)
  {
    GroupBox5->Top = Panel2->Top+Panel2->Height;
    GroupBox5->Left = Panel2->Left;
  }
  else
  {
    GroupBox5->Top = Panel2->Top+3;
  }

}
void __fastcall TFormTP::FormResize(TObject *Sender)
{
  AdjustGroupBoxesPosition();
  chrTTPResize(Sender);
  AdjustGroupBoxSize(GroupBox1);
  AdjustGroupBoxSize(grpBusca);
  AdjustGroupBoxSize(grpControles);
  AdjustGroupBoxSize(gbxAlerta);
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFCriarAtividadeTrem.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include <System.DateUtils.hpp>
#include "UFCriarAtividadeTrem.h"
#include "UTPTipoAtividade.h"
#include "UDAO.h"
#include "UTPAtividade.h"
#include "UDModuleMP.h"
#include "UFormsManager.h"
#include "UTPMovimento.h"
#include "UTPZonaControle.h"
#include "UTPItinerarioTrem.h"
#include "UTPSB.h"
#include "UUteis.h"
#include <boost/regex.hpp>
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include <../domain/RecursoCompartilhadoMalha.h>

// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TFormCriarAtividadeTrem *FormCriarAtividadeTrem;
String TextoEdit = "";

// ---------------------------------------------------------------------------
__fastcall TFormCriarAtividadeTrem::TFormCriarAtividadeTrem(TComponent* Owner, TTPAtividadePtr pAtividade,
  TTPSBListPtr pListaSBs) : TForm(Owner)       //editando
{
    FAtividade_   = pAtividade;
    TUteis::gravarLog("Editar Atividade - Trem: " + FAtividade_->Trem->PID + " - Atividade: " + FAtividade_->PID + " - Tipo: " + FAtividade_->Tipo->PID);
  domain::RecursoCompartilhadoMalha* recurso = FAtividade_->AtividadeServer->recursoCompatilhado;

  if(recurso)
  {

   gro->Caption = "Recurso: " + recurso->getNomeRecurso();
   lblDuracaoRecurso->Visible = true;
   medTempoRecurso->Visible = true;
   if(FAtividade_->DuracaoUtilizacaoRecurso > 0)
   {

      int hora = (int)FAtividade_->DuracaoUtilizacaoRecurso / 60;
      int min  = (int)FAtividade_->DuracaoUtilizacaoRecurso % 60;
      std::stringstream ssHora;
      ssHora << std::setfill('0') << std::setw(2) << hora;
      std::stringstream ssMin;
      ssMin << std::setfill('0') << std::setw(2) << min;

      medTempoRecurso->Text    = String(ssHora.str().c_str()) + ":" + String(ssMin.str().c_str());

   }else
   {
        medTempoRecurso->Clear();
        medTempoRecurso->Text = "00:00";

   }


  }else
  {
    gro->Caption = "";
    lblDuracaoRecurso->Visible = false;
    medTempoRecurso->Visible = false;
  }

	FIsAtualizar  = false;
	FTrem_ = FAtividade_->Trem;
  TextoEdit = "";

	bool isMovimentoOficializado = false;

  for(int j = 0; j< FTrem_->ItinerarioTrem->Movimentos->count(); j++)
	{
		if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->SB->NomeVia  == FAtividade_->SBAtual->NomeVia)
		{
		 if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->ServerSegTremOficializado)
			{
				 isMovimentoOficializado = true;
					break;
			}
		}
	}


	if(!isMovimentoOficializado)
		this->Caption = "Editar Atividade - Trem: " + FAtividade_->Trem->Prefixo;
	else
		this->Caption = "Atividade - Trem: " + FAtividade_->Trem->Prefixo;



	FMovimento_ = NULL;
	FListaSBs_  = pListaSBs;

  cboTipoLocal->ItemIndex = FAtividade_->TipoAtividadeAlgoritmo; // Posiciona no Patio
   lstSb1->Clear();
  cboTipoLocalChange(this);
  cboTipoLocal->Enabled = false;
	lstSb1->Enabled = false;
	lstSb2->Enabled = false;


  //lblPrefixo->Caption = FAtividade_->Trem->Prefixo;

  String t_Seguimeto = "";
  boost::cmatch nomePatio;
  std::string regexPatio = "^[A-Z]{3}";
  boost::regex getNomePatio(regexPatio);


  if (cboTipoLocal->ItemIndex ==1)
  {

   cboSegmento->Items->Add(FAtividade_->SBAtual->CodigoSegmento);
   cboSegmento->Text = FAtividade_->SBAtual->CodigoSegmento;
  }

  for (int i = 0; i < FListaSBs_->count(); i++)
  {
    TTPZonaControlePtr tZonaControleTemp = TTPFormsManager::getInstance()->ZonasControle->get(FListaSBs_->operator[](i)->ZonaControle);

    if(tZonaControleTemp)
    {
      if(tZonaControleTemp->Mesa == TTPFormsManager::getInstance()->Mesa)
      {
        std::string t_NomePatio = TUteis::narrow(FListaSBs_->operator[](i)->NomeVia.c_str());
				if (FListaSBs_->operator[](i)->CodigoSegmento.Pos("-")==0 && boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio))
        {
          std::string strNomePatio = nomePatio[0].str().c_str();
          if (cboPatio->Items->IndexOf(strNomePatio.c_str()) == -1)
            cboPatio->Items->Add(strNomePatio.c_str());
        }

        if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto)
        {
          t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
          cboPatio->Items->Add(FListaSBs_->operator[](i)->CodigoSegmento);
        }
        cboSB->Items->Add(FListaSBs_->operator[](i)->NomeVia);

      }
    }
  }

  cboSB->ItemIndex    = cboSB->Items->IndexOf(FAtividade_->SBAtual->NomeVia);
  //cboSB->Enabled = false;
  cboPatio->ItemIndex = cboPatio->Items->IndexOf(FAtividade_->SBAtual->NomeVia.SubString(1, 3));
 // cboPatioChange(this);
  //cboPatio->Enabled = false;

  // medDataInicio->Text = FAtividade_->DataInicio.FormatString("dd/mm/yyyy");
  // medHoraInicio->Text = FAtividade_->DataInicio.FormatString("hh:nn");
  cboTipoLocalChange(this);
  if (cboTipoLocal->ItemIndex ==2)
  {
    //lstSb1->Items->Clear();
    for (int l = 0; l < FAtividade_->SBs->count(); l++)
    {
      lstSb2->Items->Add(FAtividade_->SBs->operator[](l)->NomeVia);

    }

    for (int j = 0; j < lstSb2->Items->Count; j++)
    {
      for (int i = 0; i < lstSb1->Items->Count; i++)
      {
       if(lstSb1->Items->Strings[i]==lstSb2->Items->Strings[j])
        {
          lstSb1->Items->Delete(i);
           break;
        }
      }
    }
  }

  double tDataFimD = FAtividade_->DataFim;

  if (tDataFimD > 0)
  {
    medDataFim->Text = FAtividade_->DataFim.FormatString("dd/mm/yyyy");
    medHoraFim->Text = FAtividade_->DataFim.FormatString("hh:nn");
  }

	double tDataFimFila = FAtividade_->DataFimFila;
  if (tDataFimFila > 0)
  {
		medDataFila->Text = FAtividade_->DataFimFila.FormatString("dd/mm/yyyy");
		medHoraFila->Text = FAtividade_->DataFimFila.FormatString("hh:nn");

    lblRespFila->Caption = (!FAtividade_->FilaModificadaUsuario) ? "(Sistema)" : "(Usurio)";
    FIsFilaAtiva_        = FAtividade_->ISFiltaAtiva;
    // if(FAtividade_->ISFiltaAtiva)
    FFimFilaAnt_         = FAtividade_->DataFimFila;
    lblRespFila->Visible = FAtividade_->Trem->ISTremFila;
  }
  else
  {
    #ifdef BAIXADA_SANTISTA
    double tDataFimNecessidade = FAtividade_->DataHoraFimNecessidadeTerminal;
    if (tDataFimNecessidade >0 )
    {
      medDataFila->Text = FAtividade_->DataHoraFimNecessidadeTerminal.FormatString("dd/mm/yyyy");
		  medHoraFila->Text = FAtividade_->DataHoraFimNecessidadeTerminal.FormatString("hh:nn");

      medDataFila->Enabled = false;
      medHoraFila->Enabled = false;
      BitBtnFila->Enabled  = false;

      medDataFila->Visible = true;
      medHoraFila->Visible = true;
      lblFimFila->Visible  = true;

    }
    #endif
  }

  cbAtivarChegadaMinima->Enabled = FAtividade_->ISMeta;
  cbAtivarChegadaMinima->Visible = FAtividade_->ISMeta;
  cbAtivarSaidaMaxima->Enabled = FAtividade_->ISMeta;
  cbAtivarSaidaMaxima->Visible = FAtividade_->ISMeta;

  double tDataHoraMinimaChegada = FAtividade_->DataHoraMinimaChegada;
  if (tDataHoraMinimaChegada > 0)
  {
    medDataMinimaChegada->Text = FAtividade_->DataHoraMinimaChegada.FormatString("dd/mm/yyyy");
    medHoraMinimaChegada->Text = FAtividade_->DataHoraMinimaChegada.FormatString("hh:nn");
  }

  double tDataHoraMinimaSaida = FAtividade_->DataHoraMinimaSaida;
  if (tDataHoraMinimaSaida > 0)
  {
    medDataMinimaSaida->Text = FAtividade_->DataHoraMinimaSaida.FormatString("dd/mm/yyyy");
    medHoraMinimaSaida->Text = FAtividade_->DataHoraMinimaSaida.FormatString("hh:nn");
  }

  double tDataHoraMaximaSaida = FAtividade_->DataHoraMaximaSaida;
  if (tDataHoraMaximaSaida > 0)
  {
    medDataMaximaSaida->Text = FAtividade_->DataHoraMaximaSaida.FormatString("dd/mm/yyyy");
    medHoraMaximaSaida->Text = FAtividade_->DataHoraMaximaSaida.FormatString("hh:nn");
  }

  cbAtivarChegadaMinima->OnClick = NULL;
  cbAtivarSaidaMaxima->OnClick   = NULL;

  cbAtivarChegadaMinima->Checked =  FAtividade_->ISValidarDataMinimaChegadaAtivo;
  cbAtivarSaidaMaxima->Checked   = FAtividade_->ISValidarDataMaximaSaidaAtivo;

  cbAtivarChegadaMinima->OnClick = cbAtivarChegadaMinimaClick;
  cbAtivarSaidaMaxima->OnClick   = cbAtivarSaidaMaximaClick;

  FListaTiposAtividade_ = TTPTipoAtividadeListPtr(new TTPTipoAtividadeList()); // pListaTiposAtividades;

  PtrQuery qrTiposAtividade = TDAO::getTiposAtividade();

  // TTPTipoAtividadeListPtr tListaTiposAtividade = new TTPTipoAtividadeList();
  while (!qrTiposAtividade->Eof)
  {
    TTPTipoAtividadePtr temp           = new TTPTipoAtividade();
    temp->PID                          = qrTiposAtividade->FieldByName("ID_TIPO_ATVD_PLJM")->Text;
    temp->Nome                         = qrTiposAtividade->FieldByName("NM_TIPO_ATVD_PLJM")->Text;
    temp->Duracao                      = qrTiposAtividade->FieldByName("DU_PADR")->AsFloat;
    temp->CodigoControle               = qrTiposAtividade->FieldByName("CD_CTRL_SIST")->Text;
    temp->ISAtividadeHoraria           = qrTiposAtividade->FieldByName("IC_ATVD_HRAR")->Text.UpperCase() == "T";
    temp->ISAtividadeCaudaLogica       = qrTiposAtividade->FieldByName("IC_CAUDA_LOGI")->Text.UpperCase() == "T";
    temp->ISAtividadeCalculaVelocidade = qrTiposAtividade->FieldByName("IC_CALC_VE_DU_PCRS")->Text.UpperCase() == "T";
    temp->ISPermitidoExclusao          = qrTiposAtividade->FieldByName("IC_PRMS_EXCL_ATVD")->Text.UpperCase() == "T";
    temp->ISPermitidoAlterarDuracao = qrTiposAtividade->FieldByName("IC_PRMS_ALTR_DU_PRDA")->Text.UpperCase() == "T";

    FListaTiposAtividade_->add(temp->Nome, temp);

    TTPTipoAtividadePtr tipoAtividade = new TTPTipoAtividade(temp);
    cboTipo->Items->Add(tipoAtividade->Nome);

    qrTiposAtividade->Next();
  }

  cboTipo->ItemIndex = cboTipo->Items->IndexOf(FAtividade_->Tipo->Nome);
  cboTipo->Enabled = false;

  medDuracao->Text = FAtividade_->DuracaoFormatada;

  int hora = (int)FAtividade_->DuracaoPercurso / 60;
  int min  = (int)FAtividade_->DuracaoPercurso % 60;

  std::stringstream ssHora;
  ssHora << std::setfill('0') << std::setw(2) << hora;
  std::stringstream ssMin;
  ssMin << std::setfill('0') << std::setw(2) << min;

  medDuracaoPercurso->Text    = String(ssHora.str().c_str()) + ":" + String(ssMin.str().c_str());
  medDuracaoPercurso->Enabled = (hora > 0 || min > 0) && FAtividade_->Tipo->ISPermitidoAlterarDuracao;

  if (!FAtividade_->Tipo->ISPermitidoAlterarDuracao)
  {
		medDuracao->Enabled = false;
		medDataFim->Enabled = false;
		medHoraFim->Enabled = false;
  }
  else
  {
    medDuracao->Enabled = true;
    medDataFim->Enabled = true;
    medHoraFim->Enabled = true;
  }
  redDescricao->Text = FAtividade_->Descricao;
  bool TisPontoFila = isPontoDeFila(FAtividade_->SBAtual->NomeVia.SubString(1, 3));
  habilitaEdicaoFila(TisPontoFila);
  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
  {
		medDataMinimaChegada->Enabled = true;
    medDataMinimaSaida->Enabled   = true;
    medDataMaximaSaida->Enabled   = true;
    medHoraMaximaSaida->Enabled   = true;
    medHoraMinimaSaida->Enabled   = true;
		medHoraMinimaChegada->Enabled = true;
    cbxIsMeta->Visible            = true;

    cbxIsMeta->Checked            = FAtividade_->ISMeta;
  }

  cboSB->Enabled = false;
  cboPatio->Enabled = false;
  cboSegmento->Enabled = false;
  btnCarregaUm->Enabled = false;
  btnDescarregaUm->Enabled = false;
  btnCarregaTodos->Enabled = false;
	btnDescarregaTodos->Enabled = false;

	if(isMovimentoOficializado)
	{
		Panel1->Enabled = false;
		medDuracao->Enabled = false;
		medDataFim->Enabled = false;
		medHoraFim->Enabled = false;

    medDataFila->Enabled = false;
    medHoraFila->Enabled = false;

		medDataMinimaChegada->Enabled = false;
		medDataMinimaSaida->Enabled   = false;
		medDataMaximaSaida->Enabled   = false;
		medHoraMaximaSaida->Enabled   = false;
		medHoraMinimaSaida->Enabled   = false;
		medHoraMinimaChegada->Enabled = false;

    medTempoRecurso->Enabled = false;

		redDescricao->ReadOnly = true;
		redDescricao->Font->Color = clGrayText;
		 //redDescricao->ScrollBars = ssVertical;

		lstSb1->Enabled = false;
		lstSb2->Enabled = false;

		btnOk->OnClick = NULL;
		btnOk->ModalResult = mrCancel;

		FAtividade_ = NULL;
	}

}
// ---------------------------------------------------------------------------

__fastcall TFormCriarAtividadeTrem::TFormCriarAtividadeTrem(TComponent* Owner, TTPTrem* pTrem, TTPMovimento* pMovimento,
  TTPSBListPtr pListaSBs) : TForm(Owner) //criando
{
  this->Caption           = "Criar Atividade - Trem: " + pTrem->Prefixo;
  //lblPrefixo->Caption     = pTrem->Prefixo;
  FListaSBs_              = pListaSBs;
  FIsAtualizar            = false;
  cboTipoLocal->ItemIndex = etaPatio; // Posiciona no Patio
  cboTipoLocalChange(this);

  String t_Seguimeto = "";
  boost::cmatch nomePatio;
  std::string regexPatio = "^[A-Z]{3}";
  boost::regex getNomePatio(regexPatio);

  FTrem_ = pTrem;
	FMovimento_ = pMovimento;
  gro->Caption = "";
  lblDuracaoRecurso->Visible = false;
  medTempoRecurso->Visible = false;
  for (int i = 0; i < FListaSBs_->count(); i++)
  {
    TTPZonaControlePtr tZonaControleTemp = TTPFormsManager::getInstance()->ZonasControle->get(FListaSBs_->operator[](i)->ZonaControle);

    if(tZonaControleTemp)
    {
      if(tZonaControleTemp->Mesa == TTPFormsManager::getInstance()->Mesa)
      {
				std::string t_NomePatio = TUteis::narrow(FListaSBs_->operator[](i)->NomeVia.c_str());
				if (FListaSBs_->operator[](i)->CodigoSegmento.Pos("-")==0 && boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio))
        {
          std::string strNomePatio = nomePatio[0].str().c_str();
          if (cboPatio->Items->IndexOf(strNomePatio.c_str()) == -1)
            cboPatio->Items->Add(strNomePatio.c_str());
        }

        if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto)
        {
          t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
          cboSegmento->Items->Add(FListaSBs_->operator[](i)->CodigoSegmento);
        }

        cboSB->Items->Add(FListaSBs_->operator[](i)->NomeVia);
        lstSb1->Items->Add(FListaSBs_->operator[](i)->NomeVia);
      }
    }
  }

  int indexPatio = cboPatio->Items->IndexOf
  (pMovimento->SB->NomeVia.SubString(1, 3));

	int indexSegmento = cboSegmento->Items->IndexOf(pMovimento->SB->CodigoSegmento);

  cboPatio->ItemIndex = indexPatio;
	cboSegmento->ItemIndex = indexSegmento;

  if (cboPatio->ItemIndex > -1)
    {
    cboTipoLocal->ItemIndex = etaPatio;
			cboTipoLocalChange(this);
			cboPatioChange(this);
	}
	else if (cboSegmento->ItemIndex > -1)
	{
		cboTipoLocal->ItemIndex = etaSegmento;
		cboTipoLocalChange(this);
    }
	else if (cboPatio->ItemIndex == -1)
    {
    cboPatio->Text = pMovimento->SB->NomeVia;
    cboTipoLocal->ItemIndex = etaSB;
    cboTipoLocalChange(this);
    cboPatioChange(this);
  }


  // cboTipoChange(this);
  // medDataInicio->Text = pMovimento->DataChegada.FormatString("dd/mm/yyyy");
  // medHoraInicio->Text = pMovimento->DataChegada.FormatString("hh:nn");

  medDataFim->Text = "";
  medHoraFim->Text = "";

  FListaTiposAtividade_ = TTPTipoAtividadeListPtr(new TTPTipoAtividadeList()); // pListaTiposAtividades;

  PtrQuery qrTiposAtividade = TDAO::getTiposAtividade();

  // TTPTipoAtividadeListPtr tListaTiposAtividade = new TTPTipoAtividadeList();
  while (!qrTiposAtividade->Eof)
  {
    TTPTipoAtividadePtr temp           = new TTPTipoAtividade();
    temp->PID                          = qrTiposAtividade->FieldByName("ID_TIPO_ATVD_PLJM")->Text;
    temp->Nome                         = qrTiposAtividade->FieldByName("NM_TIPO_ATVD_PLJM")->Text;
    temp->Duracao                      = qrTiposAtividade->FieldByName("DU_PADR")->AsFloat;
    temp->CodigoControle               = qrTiposAtividade->FieldByName("CD_CTRL_SIST")->Text;
    temp->ISAtividadeHoraria           = qrTiposAtividade->FieldByName("IC_ATVD_HRAR")->Text.UpperCase() == "T";
    temp->ISAtividadeCaudaLogica       = qrTiposAtividade->FieldByName("IC_CAUDA_LOGI")->Text.UpperCase() == "T";
    temp->ISAtividadeCalculaVelocidade = qrTiposAtividade->FieldByName("IC_CALC_VE_DU_PCRS")->Text.UpperCase() == "T";
    temp->ISPermitidoExclusao          = qrTiposAtividade->FieldByName("IC_PRMS_EXCL_ATVD")->Text.UpperCase() == "T";
    temp->ISPermitidoAlterarDuracao = qrTiposAtividade->FieldByName("IC_PRMS_ALTR_DU_PRDA")->Text.UpperCase() == "T";

    FListaTiposAtividade_->add(temp->Nome, temp);

    TTPTipoAtividadePtr tipoAtividade = new TTPTipoAtividade(temp);
    cboTipo->Items->Add(tipoAtividade->Nome);

    qrTiposAtividade->Next();
  }

  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
  {
    medDataMinimaChegada->Enabled = true;
    medDataMinimaSaida->Enabled   = true;
    medDataMaximaSaida->Enabled   = true;
    medHoraMaximaSaida->Enabled   = true;
    medHoraMinimaSaida->Enabled   = true;
    medHoraMinimaChegada->Enabled = true;
  }


}

// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::cboTipoChange(TObject *Sender)
{
  if (cboTipo->ItemIndex > -1)
  {
    TTPTipoAtividadePtr t_tipo = FListaTiposAtividade_->operator[](cboTipo->ItemIndex);
    div_t divisao              = div(t_tipo->Duracao, 60);
    TDateTime *tempo = new TDateTime("01/01/2016 " + String(divisao.quot) + ":" + String(divisao.rem) + ":00");
    medDuracao->Text = tempo->FormatString("hh:nn");
    if (t_tipo->CodigoControle != "C" && t_tipo->CodigoControle != "D")
    {
      medDuracaoPercurso->Text    = "";
      medDuracaoPercurso->Enabled = false;
      medDuracaoPercurso->Visible = false;
      lblPercurso->Visible        = false;
    }
    else
    {
      medDuracaoPercurso->Enabled = true;
      medDuracaoPercurso->Visible = true;
      lblPercurso->Visible        = true;
    }
  }
  else
  {
    medDuracaoPercurso->Text    = "";
    medDuracaoPercurso->Enabled = false;
    medDuracaoPercurso->Visible = false;
    lblPercurso->Visible        = false;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::btnOkClick(TObject *Sender)
{
    String typeForm = "";
  try
  {
    if (cboTipoLocal->ItemIndex == -1)
      throw Exception("Local atividade invlido!");

    if (cboTipoLocal->ItemIndex == etaPatio && cboPatio->Items->IndexOf(cboPatio->Text) == -1) // Patio
        throw Exception("Ptio invlido!");

    if (cboTipoLocal->ItemIndex == etaSB && lstSb2->Items->Count<=0) // SB
      throw Exception("Selecione uma SB!");

    if (cboTipoLocal->ItemIndex == etaSegmento && cboSegmento->Items->IndexOf(cboSegmento->Text) == -1) // Segmento
        throw Exception("Segmento invlido!");

    if (cboTipo->ItemIndex == -1)
      throw Exception("Tipo atividade invlido!");

    int hora       = 0;
    int minutos    = 0;
    double duracao = 0;
    double duracaoRecurso = 0;

    if (medDuracao->Text != "" && medDuracao->Text != "  :  ")
    {
      hora    = medDuracao->Text.SubString(0, 2).ToInt();
      minutos = medDuracao->Text.SubString(4, 2).ToInt();
      duracao = (hora * 60) + minutos;
    }


    //codigo diego
     //domain::RecursoCompartilhadoMalha* recurso = FAtividade_->AtividadeServer->recursoCompatilhado;

    if( medTempoRecurso->Visible == true)
    {
      int duracaoAtividade = 0;
      int hora    = medDuracao->Text.SubString(0, 2).ToIntDef(0);
      int minutos = medDuracao->Text.SubString(4, 2).ToIntDef(0);
      duracaoAtividade = (hora * 60) + minutos;

      hora    = medTempoRecurso->Text.SubString(0, 2).ToIntDef(0);
      minutos = medTempoRecurso->Text.SubString(4, 2).ToIntDef(0);
      duracaoRecurso = (hora * 60) + minutos;

      if (duracaoRecurso > duracaoAtividade  )
      {
        medTempoRecurso->SetFocus();
        throw Exception("A durao do Recurso no pode ser maior que a durao da Atividade!");
      }
    }

    //fim diego



    if (duracao > 600 && !Confirme("Durao da atividade parece muito grande. Confirma a criao da atividade de " +
      String(duracao) + " minutos?"))
      throw Exception("Atividade no criada!");

    bool semDuracao  = (duracao <= 0);
    bool semDataFim  = false;
    bool semDataFila = false;
    bool semDataMinimaChegada = false;
    bool semDataMinimaSaida = false;
    bool semDataMaximaSaida = false;

    int horaPercurso    = 0;
    int minutosPercurso = 0;
    if (medDuracaoPercurso->Text != "" && medDuracaoPercurso->Text != "  :  ")
    {
      horaPercurso    = medDuracaoPercurso->Text.SubString(0, 2).ToInt();
      minutosPercurso = medDuracaoPercurso->Text.SubString(4, 2).ToInt();
    }
    double duracaoPercurso = (horaPercurso * 60) + minutosPercurso;

    if (duracaoPercurso > 800 && !Confirme
      ("O Percurso da atividade parece muito grande. Confirma a criao da atividade de " + String(duracao) +
      " minutos?"))
      throw Exception("Atividade no criada!");

    TDateTime data     = NULL;
    TDateTime dataFim  = NULL;
    TDateTime dataFila = NULL;
    TDateTime dataMinimaChegada = NULL;
    TDateTime dataMinimaSaida = NULL;
    TDateTime dataMaximaSaida = NULL;

    try
    {
      if (medDataFim->Text.Trim() == "/  /")
        semDataFim = true;
      else
      {
        dataFim = StrToDateTime(medDataFim->Text + " " + medHoraFim->Text + ":00");
      }
    }
    catch (Exception& e)
    {
      semDataFim = true;
    }

    try
    {
      #ifdef BAIXADA_SANTISTA
      // fora para no criar atividade de fila.
      semDataFila = true;
      #else
      if (medDataFila->Text.Trim() == "/  /")
        semDataFila = true;
      else
      {
        dataFila = StrToDateTime(medDataFila->Text + " " + medHoraFila->Text + ":00");
        semDataFila = false;
      }
      #endif
    }
    catch (Exception& e)
    {
      semDataFila = true;
    }

    try
    {
      if (medDataMinimaChegada->Text.Trim() == "/  /")
        semDataMinimaChegada = true;
      else
      {
        dataMinimaChegada = StrToDateTime(medDataMinimaChegada->Text + " " + medHoraMinimaChegada->Text + ":00");
      }
    }
    catch (Exception& e)
    {
      semDataMinimaChegada = true;
    }

    try
    {
      if (medDataMinimaSaida->Text.Trim() == "/  /")
        semDataMinimaSaida = true;
      else
      {
        dataMinimaSaida = StrToDateTime(medDataMinimaSaida->Text + " " + medHoraMinimaSaida->Text + ":00");
      }
    }
    catch (Exception& e)
    {
      semDataMinimaSaida = true;
    }

    try
    {
      if (medDataMaximaSaida->Text.Trim() == "/  /")
        semDataMaximaSaida = true;
      else
      {
        dataMaximaSaida = StrToDateTime(medDataMaximaSaida->Text + " " + medHoraMaximaSaida->Text + ":00");
      }
    }
    catch (Exception& e)
    {
      semDataMaximaSaida = true;
    }

    if (!semDataFim)
    {
      if (dataFim < TTPFormsManager::getInstance(this)->Data)
        throw Exception("Data da atividade no pode ser inferior a Data da linha do tempo!");

      if (dataFim > TTPFormsManager::getInstance(this)->DataLimiteGrafico)
        throw Exception("Data da atividade no pode ser posterior a : " + TTPFormsManager::getInstance(this)
        ->DataLimiteGrafico.DateTimeString());
    }

    if (semDuracao && semDataFim && semDataFila)
    {
      throw Exception("Atividade no possui Durao ou Data Fim vlida!");
    }

    // Se preencheu durao e data, vai como data...
    if (!semDuracao && !semDataFim)
      semDuracao = true;

    bool isValidarDataMinimaChegadaAtivo = cbAtivarChegadaMinima->Checked;
    bool isValidarDataSaidaMaximaAtivo   = cbAtivarSaidaMaxima->Checked;

    if(semDataFim)
      isValidarDataSaidaMaximaAtivo = false;

    if (FAtividade_ == NULL)
    {

      typeForm               = "Criar";
      TTPSBPtr tSB            = NULL;
      String pidPatio         = "";
      String tcodigoSegmento  = "";
      String tIcTipoAtividade = "patio";
      String codigoPatio = "";
      if (cboTipoLocal->ItemIndex == etaPatio) // Patio
      {

        if (TextoEdit == "")
        {
          codigoPatio = cboPatio->Text;
          pidPatio = algorithm::CoreTMPlanner::getInstance()->getPIDPatioBySigla(codigoPatio);
        tIcTipoAtividade = "patio";
          TextoEdit = codigoPatio;
      }
        else
      {
          codigoPatio = TextoEdit;
          pidPatio = algorithm::CoreTMPlanner::getInstance()->getPIDPatioBySigla(codigoPatio); //TDAO::getPIDPatio(codigoPatio);
          tIcTipoAtividade = "patio";
        }

      }
      else if (cboTipoLocal->ItemIndex == etaSB) // SB
      {
        // Loop no list view adding SBs

        for (int i = 0; i < lstSb2->Items->Count; i++)
        {
          tSB = FListaSBs_->get(lstSb2->Items->Strings[i]);

        if (!tSB.isNull())
          {
          pidPatio = TDAO::getPIDPatioByCodigoSegmento(tSB->CodigoSegmento);
            if (!pidPatio.IsEmpty())
            {
              break;
      }

          }
        }

        tIcTipoAtividade = "SB";
      }
      else if (cboTipoLocal->ItemIndex == etaSegmento) // Segmento
      {
         if (TextoEdit == "")
        {
        tcodigoSegmento  = cboSegmento->Text;
        tIcTipoAtividade = "segmento";
        pidPatio         = TDAO::getPIDPatioByCodigoSegmento(tcodigoSegmento);
          TextoEdit = tcodigoSegmento;
      }
        else
        {
          tcodigoSegmento = TextoEdit;
          tIcTipoAtividade = "segmento";
          pidPatio = TDAO::getPIDPatioByCodigoSegmento(tcodigoSegmento);
        }
      }

      if (pidPatio.Length() < 15)
      {
        if (tSB != NULL || tcodigoSegmento != "")
        {
          if (tSB)
          {
            for (int j = 0;
            j < FTrem_->ItinerarioTrem->Movimentos->count(); j++)
            {
              if (FTrem_->ItinerarioTrem->Movimentos->get(j)
                  ->SB->NomeVia == tSB->NomeVia)
              {
                for (int l = j + 1;
                l < FTrem_->ItinerarioTrem->Movimentos->count(); l++)
                {
                  pidPatio = TDAO::getPIDPatioByCodigoSegmento
                      (FTrem_->ItinerarioTrem->Movimentos->get(l)
                      ->SB->CodigoSegmento);
                  if (!pidPatio.IsEmpty())
                  {
                    break;
                  }
                }
                if (pidPatio.Length() < 15)
                {
        throw Exception("Ptio no localizado!");
                }
                break;
              }
            }
          }
          else
          {
            for (int j = 0;
            j < FTrem_->ItinerarioTrem->Movimentos->count(); j++)
            {
              if (FTrem_->ItinerarioTrem->Movimentos->get(j)
                  ->SB->CodigoSegmento == tcodigoSegmento)
              {
                for (int l = j + 1;
                l < FTrem_->ItinerarioTrem->Movimentos->count(); l++)
                {
                  pidPatio = TDAO::getPIDPatioByCodigoSegmento
                      (FTrem_->ItinerarioTrem->Movimentos->get(l)
                      ->SB->CodigoSegmento);
                  if (!pidPatio.IsEmpty())
                  {
                    break;
                  }
                }
                if (pidPatio.Length() < 15)
                {
                  throw Exception("Ptio no localizado!");
                }
                break;
              }
            }

          }
        }
        else
        {
          throw Exception("Ptio no localizado!");
        }

      }

      bool isErroMaisDeUmaAtvdSBPorSegmento = false;
      bool isErroMaisDeUmaAtvdPorSegmento   = false;
      bool isErroMaisDeUmaAtvdPorPatio      = false;

      for (int i = 0; i < FTrem_->Atividades->count(); i++)
      {
        TTPAtividadePtr tAtividade_ = FTrem_->Atividades->operator[](i);
        if (tAtividade_->IDPatio == pidPatio)
        {
          if (tcodigoSegmento != "" && tAtividade_->IDPatio == pidPatio)
          {
            if ((tAtividade_->SegmentosAtividade->IndexOf(tcodigoSegmento) > -1 ||
              tAtividade_->CodigoSegmento == tcodigoSegmento) && !isErroMaisDeUmaAtvdSBPorSegmento)
            {
              isErroMaisDeUmaAtvdPorSegmento = true;
            }
          }
          if (tIcTipoAtividade == "SB" && !isErroMaisDeUmaAtvdSBPorSegmento && !isErroMaisDeUmaAtvdPorSegmento)
          {
            for (int i = 0; i < lstSb2->Items->Count; i++)
            {
              tSB = FListaSBs_->get(lstSb2->Items->Strings[i]);

            if (!tSB.isNull())
              {

               if (tAtividade_->SegmentosAtividade->IndexOf(tSB->CodigoSegmento) > -1)
               {
                 isErroMaisDeUmaAtvdSBPorSegmento = true;
                 break;
               }
              }
            }
          }
          if (!isErroMaisDeUmaAtvdSBPorSegmento && !isErroMaisDeUmaAtvdPorSegmento && tIcTipoAtividade == "patio" &&
            tAtividade_->IDPatio == pidPatio)
          {
            isErroMaisDeUmaAtvdPorPatio = true;
          }
        }
      }

      if (isErroMaisDeUmaAtvdSBPorSegmento)

        throw Exception
          ("O OptMove no suporta mais de uma atividade de SB no mesmo Segmento. Favor agrupar os tempos em uma nica atividade de SB para este Segmento!"
          );
      if (isErroMaisDeUmaAtvdPorSegmento)

        throw Exception
          ("O OptMove no suporta mais de uma atividade no mesmo Segmento do ptio. Favor agrupar os tempos em uma nica atividade para este Segmento!"
          );
      if (isErroMaisDeUmaAtvdPorPatio)

        throw Exception
          ("O OptMove no suporta mais de uma atividade no mesmo ptio. Favor agrupar os tempos em uma nica atividade, para Ptios com vrios Segmentos pode-se criar por Segmento!"
          );

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      TTPTipoAtividadePtr tipo       = FListaTiposAtividade_->operator[](cboTipo->ItemIndex);

	  String tPID = "";
	  int idx = core->getMalha()->listaTrens->IndexOf(FTrem_->PID);

	  if (idx >= 0)
      tPID = FTrem_->PID;

    domain::AtividadePlanejamento *tAtividadeServer;

      if (cboTipoLocal->ItemIndex == etaPatio) // Patio
	  {
		    tAtividadeServer = core->CriarAtividade(tPID, dataMinimaChegada, dataFim, duracao * 60,
          NULL, "", pidPatio, tipo->PID, duracaoPercurso * 60, redDescricao->Text, dataFila, dataMinimaSaida, dataMaximaSaida,
          isValidarDataSaidaMaximaAtivo, isValidarDataMinimaChegadaAtivo, true);
          TUteis::gravarLog("Cria Atividade - Trem: " + tPID + " - Tipo: " + tipo->PID + " - Ptio: " + pidPatio);


        if (!tAtividadeServer || tAtividadeServer->segmentoTremPlanejado == NULL)
        {
          throw Exception("Atividade no foi criada. Ptio no localizado no itinerrio do trem!");
        }

        String tNomeSB = tAtividadeServer->segmentoTremPlanejado->getSB()->sb;
        TTPSBPtr tSBTemp = TTPFormsManager::getInstance()->SBs->get(tNomeSB);
        if (tSBTemp.isNull())
        {
          tNomeSB = TDAO::getSBValidaPorCodigoSegmento(cboPatio->Text);
          tSBTemp = TTPFormsManager::getInstance()->SBs->get(tNomeSB);
        }
      }
      else if (cboTipoLocal->ItemIndex == etaSB) // SB   Alterar SB por lista de SBs
      {

        TStringList *listaSbsSelecionadas = new TStringList();
        if (lstSb2->Visible == true && lstSb2->Items->Count > 0)
        {

          for (int i = 0; i < lstSb2->Items->Count; i++)
          {
            listaSbsSelecionadas->Add(lstSb2->Items->Strings[i]);
          }
        }
        else
        {
          throw Exception("Lista de SBs est vazia!");
        }
        tAtividadeServer = core->CriarAtividade(tPID, dataMinimaChegada, dataFim, duracao * 60,
          listaSbsSelecionadas, "", "", tipo->PID, duracaoPercurso * 60, redDescricao->Text,
        dataFila, dataMinimaSaida, dataMaximaSaida, isValidarDataSaidaMaximaAtivo, isValidarDataMinimaChegadaAtivo,true);

        TUteis::gravarLog("Cria Atividade - Trem: " + tPID + " - Tipo: " + tipo->PID + " - Ptios: " + listaSbsSelecionadas->CommaText);

        if (!tAtividadeServer || tAtividadeServer->segmentoTremPlanejado == NULL)
        {
          throw Exception("Atividade no foi criada. SB no localizada no itinerrio do trem!");
        }

        String tNomeSB = tAtividadeServer->segmentoTremPlanejado->getSB()->sb;
      }
      else if (cboTipoLocal->ItemIndex == etaSegmento) // Segmento
      {
          tAtividadeServer = core->CriarAtividade(tPID, dataMinimaChegada, dataFim, duracao * 60,
          NULL, cboSegmento->Text, "", tipo->PID, duracaoPercurso * 60, redDescricao->Text,
          dataFila, dataMinimaSaida, dataMaximaSaida, isValidarDataSaidaMaximaAtivo, isValidarDataMinimaChegadaAtivo, true);

          TUteis::gravarLog("Cria Atividade - Trem: " + tPID + " - Tipo: " + tipo->PID + " - Ptios: " + cboSegmento->Text);

        if (!tAtividadeServer || tAtividadeServer->segmentoTremPlanejado == NULL)
        {
          throw Exception("Atividade no foi criada. Segmento no localizado no itinerrio do trem!");
        }
        String tNomeSB = tAtividadeServer->segmentoTremPlanejado->getSB()->sb;

        TTPSBPtr tSBTemp = TTPFormsManager::getInstance()->SBs->get(tNomeSB);
        if (tSBTemp.isNull())
        {
          tNomeSB = TDAO::getSBValidaPorCodigoSegmento(cboSegmento->Text);
          tSBTemp = TTPFormsManager::getInstance()->SBs->get(tNomeSB);
        }
      }

      TTPFormsManager::getInstance()->SincronizarTremClientServer(FTrem_);
      TTPAtividadePtr atividade = FTrem_->Atividades->get(tAtividadeServer->PID);

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf(FTrem_->PID) <0)
      {
        TTPTremPtr TremPTR = TTPFormsManager::getInstance()->Trens->get(FTrem_->PID);// busca o trem pois o FTrem_ NAO e smatPtr
        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->add(TremPTR->PID,TremPTR);
      }
      FTrem_->AtividadesInsert->add(atividade->PID, atividade);

    }
    else // editando
    {
    typeForm = "Editar";

      if ((FAtividade_->DataFim.FormatString("dd/mm/yyyy hh:mm") == dataFim.FormatString("dd/mm/yyyy hh:mm")
        && FAtividade_->Duracao == duracao && FAtividade_->DataFimFila.FormatString("dd/mm/yyyy hh:mm") == dataFila.FormatString
        ("dd/mm/yyyy hh:mm") && FAtividade_->DataHoraMinimaChegada.FormatString("dd/mm/yyyy hh:mm")
        == dataMinimaChegada && FAtividade_->DataHoraMinimaSaida.FormatString("dd/mm/yyyy hh:mm")
        == dataMinimaSaida && FAtividade_->DataHoraMaximaSaida.FormatString("dd/mm/yyyy hh:mm") == dataMaximaSaida)
        && !FIsAtualizar)
        return;

        //valida se a data de fim de PAT  diferente da informada para
        //para permitir ou no a gravao das datas de grade
      if(!FAtividade_->ISAlterandoDatasAtividades)
        FAtividade_->ISAlterandoDatasAtividades = FAtividade_->DataFim != dataFim ||
                                                  FAtividade_->DataHoraMinimaChegada != dataMinimaChegada ||
                                                  FAtividade_->DataHoraMinimaSaida != dataMinimaSaida ||
                                                  FAtividade_->DataHoraMaximaSaida != dataMaximaSaida;

      TTPTipoAtividadePtr tipo = FListaTiposAtividade_->operator[](cboTipo->ItemIndex);
      FAtividade_->Tipo        = new TTPTipoAtividade(tipo);
      FAtividade_->Descricao   = redDescricao->Text;
      FAtividade_->DataFim     = dataFim;
      FAtividade_->Duracao     = duracao;
      FAtividade_->DataFimFila = dataFila;

      FAtividade_->DataHoraMinimaChegada = dataMinimaChegada;
      FAtividade_->DataHoraMinimaSaida   = dataMinimaSaida;
      FAtividade_->DataHoraMaximaSaida   = dataMaximaSaida;

      FAtividade_->ISValidarDataMinimaChegadaAtivo   = isValidarDataMinimaChegadaAtivo;
      FAtividade_->ISValidarDataMaximaSaidaAtivo   = isValidarDataSaidaMaximaAtivo;

      TDateTime tdataFilaAnt   = StrToDateTime(FFimFilaAnt_.FormatString("dd/mm/yyyy hh:mm") + ":00");

      if (tdataFilaAnt == dataFila)
      {
        dataFila = FFimFilaAnt_;
      }
      else
        FAtividade_->ISFiltaAtiva = false;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      core->AlterarAtividade(FAtividade_->PID, dataMinimaChegada, dataFim, duracao*60, duracaoPercurso * 60, redDescricao->Text, dataFila, dataMinimaSaida , dataMaximaSaida,
          isValidarDataSaidaMaximaAtivo, isValidarDataMinimaChegadaAtivo,duracaoRecurso*60);
       TUteis::gravarLog("Edita Atividade - Trem: " + FAtividade_->Trem->PID + " - Atividade: " + FAtividade_->PID + " - Tipo: " + FAtividade_->Tipo->PID);

      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer
          (FAtividade_->Trem);

      TTPAtividadePtr atividade = FAtividade_->Trem->Atividades->get
          (FAtividade_->PID);


      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf
          (atividade->Trem->PID) == -1)
      {
        TTPTremPtr TremPTR = TTPFormsManager::getInstance()->Trens->get(atividade->Trem->PID);// busca o trem pois o FTrem_ NAO e smatPtr
        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->add(TremPTR->PID,TremPTR);
      }

      if (FTrem_->AtividadesUpdate->IndexOf(atividade->PID) > -1)
      {
        if(atividade->ISAlterandoDatasAtividades)
          atividade->ISAlterandoDatasAtividades = true;

        if(atividade->ISReativarValidarDataMaximaSaidaAtivo && atividade->ISValidarDataMaximaSaidaAtivo)
          atividade->ISReativarValidarDataMaximaSaidaAtivo = true;

        FTrem_->AtividadesUpdate->remove(atividade->PID);// necessita remover pois foi recriado o objeto.
      }

      FTrem_->AtividadesUpdate->add(atividade->PID, atividade);
			//se a atividade for de fila e gerada pelo server, ela deve ser adicionada de lista de AtividadesInsert

			if(atividade->PID.Length()<15 && atividade->PIDPersistente.Length()<15 && TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(atividade->Trem->PID)->AtividadesInsert->IndexOf(atividade->PID) == -1)
			{
					bool atulizarAtividadeFila = algorithm::CoreTMPlanner::getInstance()->getParamByName("ATLZ_ATVD_FILA") == "TRUE";
					if(atulizarAtividadeFila)
						FTrem_->AtividadesInsert->add(atividade->PID, atividade);
			}

		}
  }
  catch (Exception& e)
  {
 	Alerta(e.Message);
	if(FAtividade_ && FAtividade_->Trem && FAtividade_->Tipo)
		TUteis::gravarLog(typeForm +" Atividade FALHOU - Trem: " + FAtividade_->Trem->PID + " - Atividade: " + FAtividade_->PID + " - Tipo: " + FAtividade_->Tipo->PID);
	else
		TUteis::gravarLog(typeForm + e.Message);
	ModalResult = mrNone;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::cboTipoLocalChange(TObject *Sender)
{
  lstSb1->Items->Clear();
  cboPatio->Visible = cboTipoLocal->ItemIndex == etaPatio;
  //cboSB->Visible = cboTipoLocal->ItemIndex == 1;
  cboSegmento->Visible = cboTipoLocal->ItemIndex == etaSegmento;
  //String patioTexto = cboPatio->Text;

  if (cboTipoLocal->ItemIndex == etaSB)
  {
    if (TextoEdit == "")
    {
      TextoEdit =  cboPatio->Text;
      cboPatioChange(this);
}
    else
    {
      cboPatio->Text = TextoEdit;
      cboPatioChange(this);
    }

    cboSB->Visible = false;
    cboSB->Enabled = false;

    cboPatio->Enabled = true;
    cboPatio->Visible = true;
    if(cboPatio->Items->IndexOf(cboPatio->Text)>-1)

    cboSegmento->Visible = false;
    cboSegmento->Enabled = false;

   // lstSb1->Items->Clear();
    boost::cmatch nomePatio;
    std::string regexPatio = "^[A-Z]{3}";
    boost::regex getNomePatio(regexPatio);
//    this->Width = 686;
    /*
    if (FTrem_)
    {

      for (int i = 0; i < FListaSBs_->count(); i++)
      {
      for (int j = 0; j < FTrem_->ItinerarioTrem->Movimentos->count(); j++)
        {
          if (FTrem_->ItinerarioTrem->Movimentos->get(j)->SB->NomeVia.SubString
              (0, 3) == FListaSBs_->operator[](i)->NomeVia.SubString(0, 3))
          {
            lstSb1->Items->Add(FListaSBs_->operator[](i)->NomeVia);
            break;
          }
        }

        std::string t_NomePatio = TUteis::narrow(FListaSBs_->operator[](i)->NomeVia.c_str());
        if (boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio))
        {
          std::string strNomePatio = nomePatio[0].str().c_str();
          if (cboPatio->Items->IndexOf(strNomePatio.c_str()) == -1)
            cboPatio->Items->Add(strNomePatio.c_str());
        }
      }


    }
     */

    TextoEdit = cboPatio->Text;
  }

  if (cboPatio->Text != "" && cboTipoLocal->ItemIndex == etaSegmento)
  {
    cboPatioChange(this);

    for (int k = 0; k < lstSb1->Items->Count; k++)
    {
      if (lstSb1->Items->operator[](k) == cboPatio->Text)
      {
        lstSb1->Selected[k] = true;
      }
    }
  }

  if (cboTipoLocal->ItemIndex == etaPatio)
  {
//    this->Width = 379;
    if (TextoEdit == "")
    {
       TextoEdit =  cboPatio->Text;
    }
    else
    {
        cboPatio->Text = TextoEdit;
    }


    if(cboPatio->Items->IndexOf(cboPatio->Text)==-1)
      cboPatio->Text = "";

    lstSb2->Items->Clear();
    cboPatio->Enabled = true;
    cboPatio->Visible = true;
    cboSB->Enabled = false;
    cboSB->Visible = false;
    cboSegmento->Enabled = false;
    cboSegmento->Visible = false;
    TextoEdit =  cboPatio->Text;

  }

  if (cboTipoLocal->ItemIndex == etaSegmento)
  {
    if (TextoEdit == "")
    {
     TextoEdit = cboSegmento->Text;
     cboSegmento->Text = TextoEdit;
    }
    else
    {
      cboSegmento->Text = TextoEdit;
    }

//    this->Width = 379;
    lstSb2->Items->Clear();
    cboSegmento->Enabled = true;
    cboSegmento->Visible = true;
    cboPatio->Enabled = false;
    cboPatio->Visible = false;
    cboSB->Enabled = false;
    cboSB->Visible = false;
		TextoEdit =  "";

  }
  acChangeFormExecute(NULL);
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medDataFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataFim->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataFim->Text = temp;
}

// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::medHoraFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraFim->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraFim->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medDuracaoKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDuracao->Text, Key, tfdDuracao);
  if (temp.Length() > 0)
    medDuracao->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::FormShow(TObject *Sender)
{
  if (FAtividade_ == NULL)
  {
   if(cboPatio->Visible && cboPatio->Enabled)
		cboPatio->SetFocus();
      else if(cboSegmento->Visible&& cboSegmento->Enabled)
       cboSegmento->SetFocus();
  }
  else if (medDataFim->Enabled)
    medDataFim->SetFocus();
    acChangeFormExecute(NULL);
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medDataFilaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataFila->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataFila->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medHoraFilaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraFila->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraFila->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::cboPatioChange(TObject *Sender)
{
  TextoEdit = cboPatio->Text;

  if (TextoEdit == "")
     {
     TextoEdit = cboPatio->Text;
   }
   else
   {
     cboPatio->Text = TextoEdit;
   }



   if (cboTipoLocal->ItemIndex == etaPatio)
   {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    TStringList *t_filas           = core->getFilas();

    bool tPontodeFila = false;

    for (int i = 0; i < t_filas->Count && !tPontodeFila; i++)
    {
      domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
      for (int j = 0; j < t_filaMalha->pontosFila->Count && !tPontodeFila; j++)
      {
        domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];
        String t_siglaAux = t_pontoFila->patioFila->sigla;
        tPontodeFila      = cboPatio->Text == t_siglaAux;
      }


    }
    habilitaEdicaoFila(tPontodeFila);

  }

  if (cboTipoLocal->ItemIndex == etaSB)
  {
    lstSb1->Items->Clear();
    lstSb2->Items->Clear();

    for (int i = 0; i < FListaSBs_->count(); i++)
    {
      TTPZonaControlePtr tZonaControleTemp = TTPFormsManager::getInstance()->ZonasControle->get(FListaSBs_->operator[](i)->ZonaControle);
      if(tZonaControleTemp)
      {
        if(tZonaControleTemp->Mesa == TTPFormsManager::getInstance()->Mesa)
        {
          if (FListaSBs_->operator[](i)->NomeVia.Pos(TextoEdit))
          {
            if (lstSb2->Items->IndexOf(FListaSBs_->operator[](i)->NomeVia) == -1)
            {
              lstSb1->Items->Add(FListaSBs_->operator[](i)->NomeVia);
            }
          }
        }
      }
    }

  }

  if(cboTipoLocal->ItemIndex == etaSegmento && cboSegmento->Text != "")
    TextoEdit = cboSegmento->Text;
  else
    TextoEdit = cboPatio->Text;
}

void __fastcall TFormCriarAtividadeTrem::habilitaEdicaoFila(bool habilitar)
{
  if (!habilitar)
  {
    if (medDataFila->Enabled)
    {
      medDataFila->Text = "";
      medHoraFila->Text = "";

      medDataFila->Enabled = false;
      medHoraFila->Enabled = false;
      BitBtnFila->Enabled  = false;

      medDataFila->Visible = false;
      medHoraFila->Visible = false;
      BitBtnFila->Visible  = false;
      lblFimFila->Visible  = false;
    }
  }
  else
  {
    if (!medDataFila->Enabled)
    {
      medDataFila->Enabled = true;
      medHoraFila->Enabled = true;
      BitBtnFila->Enabled  = true;

      medDataFila->Visible = true;
      medHoraFila->Visible = true;
      BitBtnFila->Visible  = true;
      lblFimFila->Visible  = true;
    }
  }
}

// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::cboSBChange(TObject *Sender)
{

  // aqui vai mudar o carregamento da listview de acordo com os patios

 algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();


  bool tPontodeFila = false;

  for (int i = 0; i < t_filas->Count && !tPontodeFila; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];

    for (int j = 0; j < t_filaMalha->pontosFila->Count && !tPontodeFila; j++)
    {
      domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];
      String t_siglaAux = t_pontoFila->patioFila->sigla;
      tPontodeFila      = cboSB->Text.SubString(1, 3) == t_siglaAux;
    }

  }
  habilitaEdicaoFila(tPontodeFila);

}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::cboSegmentoChange(TObject *Sender)
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();

  bool tPontodeFila = false;

  for (int i = 0; i < t_filas->Count && !tPontodeFila; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    for (int j = 0; j < t_filaMalha->pontosFila->Count && !tPontodeFila; j++)
    {
      domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];

      String t_siglaAux = t_pontoFila->patioFila->sigla;
      tPontodeFila      = cboSegmento->Text.SubString(1, 3) == t_siglaAux;
    }

  }
  habilitaEdicaoFila(tPontodeFila);
  TextoEdit = cboSegmento->Text;

}

// ---------------------------------------------------------------------------


void __fastcall TFormCriarAtividadeTrem::apagarDataHoraFilaExecute(TObject *Sender)

{
  medDataFila->Text = "  /  /    ";
  medHoraFila->Text = "  :  ";

}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::apagarDataHoraPATExecute(TObject *Sender)

{
  medDataFim->Text = "  /  /    ";
  medHoraFim->Text = "  :  ";

  cbAtivarSaidaMaxima->Checked = false;
}

// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::acChangeFormExecute(TObject *Sender)
{
// if(grpbxDescricao->Align == alRight)
// {
//   Height += 171;
//   Width -=355;
//   grpbxDescricao->Align = alBottom;
//   grpbxDescricao->Height = 171;
// }
// else
// {
//   Height -= 171;
//   Width +=355;
//   grpbxDescricao->Align = alRight;
//   grpbxDescricao->Width = 355;
// }
if (cboTipoLocal->ItemIndex != etaSB)
{
   pnlSelecaoSB->Visible = false;
//   Panel4->Width = Panel1->Width;
//   redDescricao->Width = Panel1->Width;
//   grpbxDescricao->Width = Panel1->Width;
}
else
{
  pnlSelecaoSB->Visible = true;
}
    redDescricao->Visible = false;
    grpbxDescricao->Visible = false;
    Panel4->Visible = false;
   Panel4->Visible = true;
   redDescricao->Visible = true;
 grpbxDescricao->Visible = true;


}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::apagarDataHoraSaidaMinimaExecute(TObject *Sender)
{
if(medDataMinimaSaida->Enabled)
 {
  medDataMinimaSaida->Text = "  /  /    ";
  medHoraMinimaSaida->Text = "  :  ";
}
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::apagarDataHoraSaidaMaximaExecute(TObject *Sender)
{
  if(medDataMaximaSaida->Enabled)
  {
  medDataMaximaSaida->Text = "  /  /    ";
  medHoraMaximaSaida->Text = "  :  ";
  }

  cbAtivarSaidaMaximaClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::apagarDataHoraMinimaChegadaExecute(TObject *Sender)
{
 if(medDataMinimaChegada->Enabled)
 {
  medDataMinimaChegada->Text = "  /  /    ";
  medHoraMinimaChegada->Text = "  :  ";
 }

  cbAtivarChegadaMinimaClick(this);
}
//---------------------------------------------------------------------------


void __fastcall TFormCriarAtividadeTrem::medDataMinimaChegadaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataMinimaChegada->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataMinimaChegada->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medHoraMinimaChegadaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraMinimaChegada->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraMinimaChegada->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medDataMinimaSaidaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataMinimaSaida->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataMinimaSaida->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medHoraMinimaSaidaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraMinimaSaida->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraMinimaSaida->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medDataMaximaSaidaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
   String temp = TUteis::preencherData(medDataMaximaSaida->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataMaximaSaida->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medHoraMaximaSaidaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraMaximaSaida->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraMaximaSaida->Text = temp;
}

//---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::cbAtivarChegadaMinimaClick(TObject *Sender)
{
  if(cbAtivarChegadaMinima->Checked && medDataMinimaChegada->Text.Trim() == "/  /")
    cbAtivarChegadaMinima->Checked = false;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::cbAtivarSaidaMaximaClick(TObject *Sender)
{

 if(cbAtivarSaidaMaxima->Checked && medDataMaximaSaida->Text.Trim() == "/  /")
    cbAtivarSaidaMaxima->Checked = false;

 if(cbAtivarSaidaMaxima->Checked)
 {
    medDataFim->Text = medDataMaximaSaida->Text;
    medHoraFim->Text = medHoraMaximaSaida->Text;
 }
}
//---------------------------------------------------------------------------


void __fastcall TFormCriarAtividadeTrem::medDataInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataInicio->Text, Key, tfdData);
  if (temp.Length() > 0)
    medDataInicio->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::medHoraInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
 String temp = TUteis::preencherData(medHoraInicio->Text, Key, tfdHora);
  if (temp.Length() > 0)
    medHoraInicio->Text = temp;
}

//---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::cboDefaultExit(TObject *Sender)
{
  int tIndex = ((TComboBox *)Sender)->Items->IndexOf(((TComboBox *)Sender)->Text);

  if(tIndex>-1)
   ((TComboBox *)Sender)->ItemIndex = tIndex;
}
//---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::FormCreate(TObject *Sender)
{
  // this->Width = 379;
  //cboPatio->Visible = cboTipoLocal->ItemIndex == 0;
}

// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::btnCarregaTodosClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lstSb1->Items->Count; i++)
    {
      lstSb2->Items->Add(lstSb1->Items->operator[](i));
    }
    lstSb1->Items->Clear();
  }
  catch (...)
  {
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::btnDescarregaTodosClick(TObject *Sender)

{
  try
  {
    for (int i = 0; i < lstSb2->Items->Count; i++)
    {
      lstSb1->Items->Add(lstSb2->Items->operator[](i));
    }
    lstSb2->Items->Clear();
  }
  catch (...)
  {
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormCriarAtividadeTrem::btnCarregaUmClick(TObject *Sender)
{

  if (lstSb1->ItemIndex >= 0)
  {
    for (int i = 0; i < lstSb1->Items->Count; i++)
    {
      if (lstSb1->Selected[i])
      {
        lstSb2->Items->Add(lstSb1->Items->operator[](i));

      }
    }

    for (int i = lstSb1->Items->Count - 1; i >= 0; i--)
    {
      if (lstSb1->Selected[i])
      {
        lstSb1->Items->Delete(i);

      }
    }
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::btnDescarregaUmClick(TObject *Sender)
{
  if (lstSb2->ItemIndex >= 0)
  {
    lstSb1->Items->Add(lstSb2->Items->operator[](lstSb2->ItemIndex));
    lstSb2->Items->Delete(lstSb2->ItemIndex);

  }
}
// ---------------------------------------------------------------------------
void __fastcall TFormCriarAtividadeTrem::lstSb2DblClick(TObject *Sender)
{
  if (lstSb2->ItemIndex >= 0)
  {
    for (int i = 0; i < lstSb2->Items->Count; i++)
    {
      if (lstSb2->Selected[i])
      {
        lstSb1->Items->Add(lstSb2->Items->operator[](i));

      }
    }

    for (int i = lstSb2->Items->Count - 1; i >= 0; i--)
    {
      if (lstSb2->Selected[i])
      {
        lstSb2->Items->Delete(i);

      }
    }
  }
}
//---------------------------------------------------------------------------


void __fastcall TFormCriarAtividadeTrem::medDuracaoExit(TObject *Sender)
{

  if(medTempoRecurso->Visible)
  {
    if (FAtividade_ && FAtividade_->AtividadeServer->recursoCompatilhado)
    {
      domain::RecursoCompartilhadoMalha* recurso = FAtividade_->AtividadeServer->recursoCompatilhado;

      int duracaoAtividade = 0,duracaoRecurso = 0;
      int hora    = medDuracao->Text.SubString(0, 2).ToIntDef(0);
      int minutos = medDuracao->Text.SubString(4, 2).ToIntDef(0);
      duracaoAtividade = (hora * 60) + minutos;

      hora    = medTempoRecurso->Text.SubString(0, 2).ToIntDef(0);
      minutos = medTempoRecurso->Text.SubString(4, 2).ToIntDef(0);
      duracaoRecurso = (hora * 60) + minutos;

      if (duracaoAtividade < duracaoRecurso)
      {
        medTempoRecurso->Text =  medDuracao->Text;
      }
    }
  }
}
//---------------------------------------------------------------------------



bool TFormCriarAtividadeTrem::isPontoDeFila(String sPatio){
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();
  if(FAtividade_ && !FAtividade_->ISFiltaAtiva)
    return false;
  bool tPontodeFila = false;

  for (int i = 0; i < t_filas->Count && !tPontodeFila; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    for (int j = 0; j < t_filaMalha->pontosFila->Count && !tPontodeFila; j++)
    {
      domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];

      String t_siglaAux = t_pontoFila->patioFila->sigla;
      tPontodeFila      = sPatio == t_siglaAux;
    }

  }
  return tPontodeFila;
}


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFFilas.h =====
#ifndef UFFilasH
#define UFFilasH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Mask.hpp>
#include <Vcl.ActnList.hpp>
#include "cxClasses.hpp"
#include <Data.DB.hpp>
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include "cxLabel.hpp"
#include "cxGridBandedTableView.hpp"
#include <Vcl.Dialogs.hpp>
#include <Vcl.Menus.hpp>
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
#include "cxImageList.hpp"

namespace domain
{
  class TremMalha;
}

using namespace domain;
//---------------------------------------------------------------------------
class TFormFilas : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel4;
  TPanel *Panel3;
  TPanel *Panel2;
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
  TPanel *Panel7;
  TLabel *Label1;
  TEdit *edtBuscarPrefixo;
  TButton *btnBuscarPrefixo;
  TLabel *Label2;
  TComboBox *cboFilas;
  TLabel *lblTituloDuracaoSeguranca;
  TLabel *lblDuracaoSeguranca;
  TLabel *lblTituloDuracaoUsuario;
	TButton *btnSalvarDuracaoUsuario;
	TMaskEdit *medDuracaoUsuario;
	TActionList *al;
	TAction *acInicializar;
	TAction *acSalvarDuracaoUsu;
	TButton *Button1;
	TAction *acEditarPontosFila;
	TAction *acCancelar;
  TDataSource *dsFilas;
  TClientDataSet *cdsFilas;
  TStringField *cdsFilasprefixo;
  TStringField *cdsFilastipo;
  TBooleanField *cdsFilasativa;
  TStringField *cdsFilasorigem;
  TStringField *cdsFilasdestino;
  TStringField *cdsFilaspatioAuxiliar;
  TStringField *cdsFilasduracaoSegAux;
  TStringField *cdsFilasduracaoUsuaAux;
  TStringField *cdsFilaspatioRegulador;
  TStringField *cdsFilasduracaoSegReg;
  TStringField *cdsFilasduracaoUsuaReg;
  TStringField *cdsFilasid;
  TStringField *cdsFilasidExterno;
  TStringField *cdsFilasfila;
  TBooleanField *cdsFilaseditavel;
  TStringField *cdsFilaspatioAtual;
  TDateTimeField *cdsFilasprevisaoSaida;
  TDataSetProvider *DataSetProvider1;
  TcxGridDBTableView *cxgFilasDBTableView1;
  TcxGridLevel *cxgFilasLevel1;
  TcxGrid *cxgFilas;
  TIntegerField *cdsFilasordemGeral;
  TStringField *cdsFilastabela;
  TcxStyleRepository *cxStyleRepositoryGrids;
  TcxStyle *cxHeader;
  TcxStyle *cxContentEven;
  TcxStyle *cxStyle21;
  TcxStyle *cxSelection;
  TcxStyle *cxBandHeader;
  TcxStyle *cxContent;
  TcxStyle *cxBandHeaderDesabilitado;
  TcxStyle *cxHeaderDesabilitado;
  TcxStyle *cxSLAExtrapoladoContent;
  TcxStyle *cxInterrompidoContent;
  TcxStyle *cxMapaVerde;
  TcxStyle *cxMapaVermelho;
  TcxStyle *cxEmAndamentoContent;
  TcxStyle *cxStyle22;
  TcxStyle *cxStyle23;
  TcxGridBandedTableViewStyleSheet *ssBandedTable;
  TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
  TcxGridTableViewStyleSheet *ssGridTable;
  TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
  TDateTimeField *cdsFilasdataPrevisaoChegadaTerminal;
  TPopupMenu *PopupMenu1;
  TImageList *il;
  TSaveDialog *SaveDialog;
  TAction *acExportarExcel;
  TMenuItem *ExportarExcel1;
  TcxStyle *cxErro;
  TcxStyle *cxDisabled;
  TBooleanField *cdsFilaspossuiCapacidade;
  TcxStyle *cxDefault;
  TcxStyle *cxFilaInativa;
  TStringField *cdsFilasmesaControle;
  TAction *acAtivarCalculoFila;
  TAction *acDesativarCalculoFila;
  TMenuItem *AtivarClculoFila1;
  TMenuItem *DesativarClculoFila1;
  TMenuItem *N1;
  TClientDataSet *ClientDataSet1;
  TIntegerField *ClientDataSet1ordemGeral;
  TStringField *ClientDataSet1fila;
  TStringField *ClientDataSet1destino;
  TIntegerField *ClientDataSet1ordem;
  TStringField *ClientDataSet1prefixo;
  TStringField *ClientDataSet1tabela;
  TStringField *ClientDataSet1tipo;
  TBooleanField *ClientDataSet1ativa;
  TStringField *ClientDataSet1origem;
  TStringField *ClientDataSet1patioAtual;
  TDateTimeField *ClientDataSet1previsaoSaida;
  TStringField *ClientDataSet1patioAuxiliar;
  TStringField *ClientDataSet1duracaoSegAux;
  TStringField *ClientDataSet1duracaoUsuaAux;
  TStringField *ClientDataSet1patioRegulador;
  TStringField *ClientDataSet1duracaoSegReg;
  TStringField *ClientDataSet1duracaoUsuaReg;
  TDateTimeField *ClientDataSet1dataPrevisaoChegadaTerminal;
  TStringField *ClientDataSet1id;
  TStringField *ClientDataSet1idExterno;
  TBooleanField *ClientDataSet1editavel;
  TBooleanField *ClientDataSet1possuiCapacidade;
  TStringField *ClientDataSet1mesaControle;
  TFloatField *cdsFilasordemOriginal;
  TFloatField *cdsFilasordem;
  TFloatField *cdsFilasordemCalculada;
  TcxGridDBColumn *cxgFilasDBTableView1ordemGeral;
  TcxGridDBColumn *cxgFilasDBTableView1fila;
  TcxGridDBColumn *cxgFilasDBTableView1destino;
  TcxGridDBColumn *cxgFilasDBTableView1ordem;
  TcxGridDBColumn *cxgFilasDBTableView1prefixo;
  TcxGridDBColumn *cxgFilasDBTableView1tabela;
  TcxGridDBColumn *cxgFilasDBTableView1tipo;
  TcxGridDBColumn *cxgFilasDBTableView1ativa;
  TcxGridDBColumn *cxgFilasDBTableView1origem;
  TcxGridDBColumn *cxgFilasDBTableView1patioAtual;
  TcxGridDBColumn *cxgFilasDBTableView1previsaoSaida;
  TcxGridDBColumn *cxgFilasDBTableView1patioAuxiliar;
  TcxGridDBColumn *cxgFilasDBTableView1duracaoSegAux;
  TcxGridDBColumn *cxgFilasDBTableView1duracaoUsuaAux;
  TcxGridDBColumn *cxgFilasDBTableView1patioRegulador;
  TcxGridDBColumn *cxgFilasDBTableView1duracaoSegReg;
  TcxGridDBColumn *cxgFilasDBTableView1duracaoUsuaReg;
  TcxGridDBColumn *cxgFilasDBTableView1dataPrevisaoChegadaTerminal;
  TcxGridDBColumn *cxgFilasDBTableView1ordemOriginal;
  TcxGridDBColumn *cxgFilasDBTableView1id;
  TcxGridDBColumn *cxgFilasDBTableView1idExterno;
  TcxGridDBColumn *cxgFilasDBTableView1editavel;
  TcxGridDBColumn *cxgFilasDBTableView1possuiCapacidade;
  TcxGridDBColumn *cxgFilasDBTableView1mesaControle;
  TcxGridDBColumn *cxgFilasDBTableView1ordemCalculada;
  TDateTimeField *cdsFilasdataChegadaRegulador;
  TcxGridDBColumn *cxgFilasDBTableView1dataChegadaRegulador;
  TBooleanField *cdsFilasfilaDesativadaUsuario;
  TcxStyle *cxFilaInativaUsu;
  TcxGridDBColumn *cxgFilasDBTableView1filaDesativadaUsuario;
	TcxStyle *cxStyle1;
	TcxStyleRepository *cxStyleRepository1;
	TcxStyle *cxStyle2;
  TcxImageList *cxImageList1;
  void __fastcall cboFilasChange(TObject *Sender);
  void __fastcall edtBuscarPrefixoEnter(TObject *Sender);
  void __fastcall edtBuscarPrefixoExit(TObject *Sender);
  void __fastcall btnBuscarPrefixoClick(TObject *Sender);
  void __fastcall edtBuscarPrefixoKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall medDuracaoUsuarioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall acSalvarDuracaoUsuExecute(TObject *Sender);
	void __fastcall acEditarPontosFilaExecute(TObject *Sender);
	void __fastcall acCancelarExecute(TObject *Sender);
	void __fastcall btnOkClick(TObject *Sender);
  void __fastcall cxgFilasDBTableView1KeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall ConfigurarGrid();
  void __fastcall acExportarExcelExecute(TObject *Sender);
  void __fastcall cxgFilasDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem,
          TcxStyle *&AStyle);
  void __fastcall cxgFilasDBTableView1ativaCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall cxgFilasDBTableView1possuiCapacidadeCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall FormCreate(TObject *Sender);
  void __fastcall acAtivarCalculoFilaExecute(TObject *Sender);
  void __fastcall acDesativarCalculoFilaExecute(TObject *Sender);
  void __fastcall cxgFilasContextPopup(TObject *Sender, TPoint &MousePos, bool &Handled);
  void __fastcall cxgFilasDBTableView1CellDblClick(TcxCustomGridTableView *Sender, TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);





private:	// User declarations
  bool FEditandoFilasInconsistentes_, FEditouOrdemFila_;
  TStringList* FFilas_;
  int FRowEditando_;
  TStringList* FTrensFilasInconsistentes_;
  TLocateOptions FLocate_;

public:		// User declarations
  __fastcall TFormFilas(TComponent* Owner);
  __fastcall TFormFilas(TComponent* Owner, TStringList* FilasInconsistentes);
  inline __fastcall ~TFormFilas(void);
  void __fastcall CarregarTrens();
  void __fastcall CarregarFilas();
  void __fastcall PreencheHorariosSegUsu(AnsiString drSeguranca, AnsiString drUsuario);
  void __fastcall SetRegistroEditavel();
  void __fastcall AtualizarPosicaoTrens(bool pIgnorarMesaAtual = false);


  //---------------------------------------------------------------------------
 struct TTremFila
  {
	public:
   TTremFila
   (
    TremMalha* ptremMalha,
    String    pfila,
    int       pordem,
    String    pprefixo,
    String    ptipo,
    bool      pativa,
    bool      pativaOriginal,
    String    porigem,
    String    pdestino,
    String    ppatioAtual,
    TDateTime pprevisaoSaida,
    String    ppatioAuxiliar,
    String    pduracaoSegurancaAuxiliar,
    String    pduracaoUsuarioAuxiliar,
    String    ppatioRegulador,
    String    pduracaoSegurancaRegulador,
    String    pduracaoUsuarioRegulador,
    String    pid,
    String    pidExterno,
    double    pordemOriginal,
    String    ptabela,
    TDateTime pdataChegadaTerminal,
    bool      ppossuiCapacidade,
    String    pmesaControle,
    double    pordemCalculada,
    TDateTime pdataRegulador
	)
	{
    tremMalha = ptremMalha,
    fila = pfila;
    ordem =  pordem;

    prefixo =  pprefixo;
    tipo =  ptipo;
    ativa =  pativa;
    ativaOriginal = pativaOriginal;
    origem =  porigem;
    destino =  pdestino;
    patioAtual = ppatioAtual;
    previsaoSaida = pprevisaoSaida;
    patioAuxiliar =  ppatioAuxiliar;
    duracaoSegurancaAuxiliar =  pduracaoSegurancaAuxiliar;
    duracaoUsuarioAuxiliar =  pduracaoUsuarioAuxiliar;
    patioRegulador =  ppatioRegulador;
    duracaoSegurancaRegulador =  pduracaoSegurancaRegulador;
    duracaoUsuarioRegulador =  pduracaoUsuarioRegulador;
    id =  pid;
    idExterno =  pidExterno;
    ordemOriginal = pordemOriginal;
    tabela = ptabela;
    dataChegadaTerminal =pdataChegadaTerminal;
    isOrdemErrada = pordemOriginal == 0;
    possuiCapacidade = ppossuiCapacidade;
    mesaControle = pmesaControle;
    ordemCalculada = pordemCalculada;
    dataRegulador = pdataRegulador;
	}

  TremMalha* tremMalha;
  String  fila;
	int     ordem;
	String  prefixo;
	String  tipo;
	bool    ativa;
  bool    ativaOriginal;
  bool isOrdemErrada;
	String  origem;
	String  destino;
  String    patioAtual;
  TDateTime previsaoSaida;
	String  patioAuxiliar;
	String  duracaoSegurancaAuxiliar;
	String  duracaoUsuarioAuxiliar;
	String  patioRegulador;
	String  duracaoSegurancaRegulador;
	String  duracaoUsuarioRegulador;
	String  id;
	String  idExterno;
  double     ordemOriginal;
  String  tabela;
  TDateTime dataChegadaTerminal;
  bool possuiCapacidade;
  String mesaControle;
  double ordemCalculada;
  TDateTime dataRegulador;
  };
};
 int __fastcall  SortPorOrdem(TStringList* List, int Index1, int Index2);

//---------------------------------------------------------------------------
extern PACKAGE TFormFilas *FormFilas;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGridMonitoramentoEntrePlanos.h =====
//---------------------------------------------------------------------------

#ifndef FWidgetGridMonitoramentoEntrePlanosH
#define FWidgetGridMonitoramentoEntrePlanosH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "FWidgetGridBase.h"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include "cxContainer.hpp"
#include "cxTextEdit.hpp"
#include "cxTimeEdit.hpp"
#include <Vcl.Mask.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
#include "cxImageList.hpp"
namespace domain
{
	 class Oficializacao;
	 class SegmentoTremOficializado;
	 class Comparacao;
}


//---------------------------------------------------------------------------
class TFormWidgetGridDiferencasEntrePlanos : public TFormWidgetGridBase
{
__published:	// IDE-managed Components
	TGroupBox *GroupBox2;
	TcxTextEdit *edtDestino;
	TcxTextEdit *edtPrefixo;
	TButton *btnBuscarPrefixo;
	TCheckBox *chbxCompTempoPerm;
	TGroupBox *GroupBox1;
	TMaskEdit *medOflz1;
	TMaskEdit *medOflz2;
	TcxGridDBColumn *cxgGridDBTableView1Prefixo;
	TcxGridDBColumn *cxgGridDBTableView1Local;
	TcxGridDBColumn *cxgGridDBTableView1DtChegPlan1;
	TcxGridDBColumn *cxgGridDBTableView1DtChegPlan2;
	TcxGridDBColumn *cxgGridDBTableView1DtSaidaPlan1;
	TcxGridDBColumn *cxgGridDBTableView1DtSaidaPlan2;
	TcxGridDBColumn *cxgGridDBTableView1Permanncia;
	TcxGridDBColumn *cxgGridDBTableView1Desvio;
	TcxGridDBColumn *cxgGridDBTableView1TipoComparacao;
	TcxGridDBColumn *cxgGridDBTableView1DataComparacao1;
	TcxGridDBColumn *cxgGridDBTableView1DataComparacao2;
	TAction *acAbrirViewer;
	TDataSource *DataSource1;
	TClientDataSet *cdsGrid2;
	TStringField *cdsGridPrefixo;
	TStringField *cdsGridLocal;
	TDateTimeField *cdsGridDtChegPlan1;
	TDateTimeField *cdsGridDtChegPlan2;
	TDateTimeField *cdsGridDtSaidaPlan1;
	TDateTimeField *cdsGridDtSaidaPlan2;
	TTimeField *cdsGridPermanencia;
	TTimeField *cdsGridDesvio;
	TStringField *cdsGridTipoComparacao;
	TStringField *cdsGridDataComparacao1;
	TStringField *cdsGridPIDTrem;
	TStringField *cdsGridDataComparacao2;
	TPanel *pnlChamarViewer;
	TCheckBox *chkExibirTremViewer;
  TFloatField *cdsGridDesvioTotal;
  TStringField *cdsGridDesvioTela;
	TcxImageList *cxImageList1;
	void __fastcall cxgGridDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
	void __fastcall acPesquisarPrefixoExecute(TObject *Sender);
	void __fastcall edtPrefixoExit(TObject *Sender);
	void __fastcall edtPrefixoKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall chbxCompTempoPermClick(TObject *Sender);
	void __fastcall acAbrirViewerExecute(TObject *Sender);






private:	// User declarations

	bool FisExecutarViewer_;
	std::clock_t FTickCountUltimoExecutaViewer_ ;
public:		// User declarations
	__fastcall TFormWidgetGridDiferencasEntrePlanos(TComponent* Owner);

	TStringList* ComparaOficializacoes(domain::Oficializacao *pOficializacao1, domain::Oficializacao *pOficializacao2, bool pCompararTempoPermanencia);
	void CompararOficializacoes(bool pCompararTempoPermanencia = false);
};

String FloatToHHMM(float tempo);

//---------------------------------------------------------------------------
extern PACKAGE TFormWidgetGridDiferencasEntrePlanos *FormWidgetGridDiferencasEntrePlanos;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFOrdemTremViewer.h =====
//---------------------------------------------------------------------------

#ifndef UFOrdemTremViewerH
#define UFOrdemTremViewerH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxContainer.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxDropDownEdit.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxMaskEdit.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "cxTextEdit.hpp"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <Vcl.Buttons.hpp>
#include <Vcl.ExtCtrls.hpp>
#include "cxGridBandedTableView.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include <Vcl.Dialogs.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
//---------------------------------------------------------------------------
class TFormOrdemTremViewer : public TForm
{
__published:	// IDE-managed Components
  TPanel *pnlFiltros;
  TLabel *lblLocal;
  TLabel *lblOficializacao;
  TComboBox *cboLocal;
  TcxComboBox *cbxDataOficializacaoFarolParametros;
  TPanel *pnlComandos;
  TButton *btnOk;
  TButton *btnCancelar;
  TClientDataSet *cdsOrdem;
  TStringField *cdsOrdemLocal;
  TStringField *cdsOrdemPrefixo;
  TStringField *cdsOrdemTabela;
  TStringField *cdsOrdemOrigem;
  TStringField *cdsOrdemDestino;
  TIntegerField *cdsOrdemOrdemOriginal;
  TStringField *cdsOrdemTremAFrente;
  TBooleanField *cdsOrdemOrdemFixa;
  TDataSetProvider *dtspGrid;
  TDataSource *dsGrid;
  TcxGridDBTableView *cxGridDBTableView1;
  TcxGridLevel *cxGridLevel1;
  TcxGrid *cxGrid;
  TcxGridDBColumn *cxGridDBTableView1Local;
  TcxGridDBColumn *cxGridDBTableView1Prefixo;
  TcxGridDBColumn *cxGridDBTableView1Tabela;
  TcxGridDBColumn *cxGridDBTableView1Origem;
  TcxGridDBColumn *cxGridDBTableView1Destino;
  TcxGridDBColumn *cxGridDBTableView1OrdemOriginal;
  TcxGridDBColumn *cxGridDBTableView1OrdemFixa;
  TcxGridDBColumn *cxGridDBTableView1TremAFrente;
  TcxStyleRepository *cxStyleRepositoryGrids;
  TcxStyle *cxHeader;
  TcxStyle *cxContentEven;
  TcxStyle *cxStyle21;
  TcxStyle *cxSelection;
  TcxStyle *cxBandHeader;
  TcxStyle *cxContent;
  TcxStyle *cxBandHeaderDesabilitado;
  TcxStyle *cxHeaderDesabilitado;
  TcxStyle *cxSLAExtrapoladoContent;
  TcxStyle *cxInterrompidoContent;
  TcxStyle *cxMapaVerde;
  TcxStyle *cxMapaVermelho;
  TcxStyle *cxEmAndamentoContent;
  TcxStyle *cxStyle22;
  TcxStyle *cxStyle23;
  TcxStyle *cxErro;
  TcxStyle *cxDisabled;
  TcxStyle *cxDefault;
  TcxStyle *cxFilaInativa;
  TcxStyle *cxFilaInativaUsu;
  TcxGridBandedTableViewStyleSheet *ssBandedTable;
  TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
  TcxGridTableViewStyleSheet *ssGridTable;
  TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
  TcxStyle *cxForaOrdemOriginal;
  TActionList *al;
  TAction *acExportarExcel;
  TImageList *il;
  TPopupMenu *PopupMenuGrid;
  TMenuItem *ExportarExcel1;
  TSaveDialog *SaveDialogGrid;
  TStringField *cdsOrdemOrdemAlterada;
  TcxGridDBColumn *cxGridDBTableView1OrdemAlterada;
  TDateTimeField *cdsOrdemDataRefencia;
  TStringField *cdsOrdemLocalRef;
  TcxGridDBColumn *cxGridDBTableView1DataRefencia;
  TcxGridDBColumn *cxGridDBTableView1LocalRef;
  TStringField *cdsOrdemOrdemAtiva;
  TcxGridDBColumn *cxGridDBTableView1OrdemAtiva;
  void __fastcall cbxDataOficializacaoFarolParametrosPropertiesChange(TObject *Sender);
  void __fastcall cxGridDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem,
          TcxStyle *&AStyle);
  void __fastcall cxGridDBTableView1CustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall cboLocalChange(TObject *Sender);
  void __fastcall acExportarExcelExecute(TObject *Sender);



private:	// User declarations
public:		// User declarations
  __fastcall TFormOrdemTremViewer(TComponent* Owner, TcxComboBox *cbxOficializacoes);
  void __fastcall CarregarGatilhos();
  void __fastcall CarregarTrens();
  TStringList *FGatilho_;

};
 int __fastcall  CustomSortChegada(TStringList* List, int Index1, int Index2);
 int __fastcall  CustomSortSaida(TStringList* List, int Index1, int Index2);
//---------------------------------------------------------------------------
extern PACKAGE TFormOrdemTremViewer *FormOrdemTremViewer;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFTestes.h =====
//---------------------------------------------------------------------------

#ifndef UFTestesH
#define UFTestesH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include "UFPrincipal.h"
#include "UTPAtividade.h"
//---------------------------------------------------------------------------

enum TipoMensagemExibicao {tmeResumo, tmeLog, tmeAmbos};

class TformTestes : public TForm
{
__published:	// IDE-managed Components

  TPanel *Panel1;
  TPanel *Panel2;
  TPanel *Panel3;
  TPanel *Panel4;
  TPanel *Panel5;
  TPanel *pnlBotoes;
  TListBox *lsbTestes;
  TMemo *memResult;
  TButton *btnStart;
  TButton *btnFinalizar;
  void __fastcall btnStartClick(TObject *Sender);
  void __fastcall btnFinalizarClick(TObject *Sender);
private:	// User declarations
  void PublicarMsg(String pMSG, TipoMensagemExibicao tipoMsgEx = tmeAmbos, bool pOK = false);
  TColor corDefault;
  TTPTremPtr t_tremTeste;

public:		// User declarations
  __fastcall TformTestes(TComponent* Owner);
  bool TesteCriarTrem(TFormTP *t_FormTP, String &pPID);
  bool TesteCriarRestricao(TFormTP *t_FormTP, String &pPID);
  bool TesteCriarInterdicao(TFormTP *t_FormTP);
  bool TesteCriarAtividade(TFormTP *t_FormTP, String pPIDTrem, String &pPID);
  bool TesteSuprimirTrem(TFormTP *t_FormTP);
  bool TesteExcluirAtividade(TFormTP *t_FormTP, String pPID);
  bool TesteExcluirRestricao(TFormTP *t_FormTP, String pPID);
  bool TesteAlterarAtividade(TFormTP *t_FormTP, String pPID);
  bool TesteAlterarRestricao(TFormTP *t_FormTP, String pPID);
};
//---------------------------------------------------------------------------
extern PACKAGE TformTestes *formTestes;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGridAtividadesAlteradas.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FWidgetGridAtividadesAlteradas.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FWidgetGridBase"
#pragma link "cxContainer"
#pragma link "cxTextEdit"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"

#include "UFormsManager.h"
#include "UTPAtividade.h"
#include "UTPTrem.h"
#include "UTPItinerarioTrem.h"
#include "UTPZonaControle.h"
#include "UTPSB.h"
#include "UTPMovimento.h"

#include "../domain/SegmentoTremOficializado.h"
#include "../domain/AtividadePlanejamento.h"

TFormWidgetGridAtividadesAlteradas *FormWidgetGridAtividadesAlteradas;
//---------------------------------------------------------------------------
__fastcall TFormWidgetGridAtividadesAlteradas::TFormWidgetGridAtividadesAlteradas(TComponent* Owner)
  : TFormWidgetGridBase(Owner)
{
  cdsGrid->CreateDataSet();
}
//---------------------------------------------------------------------------
void TFormWidgetGridAtividadesAlteradas::AtualizarGird()
{
  cdsGrid->Close();
  cdsGrid->CreateDataSet();
  cdsGrid->Open();
  cdsGrid->DisableControls();

	using namespace domain;

  TTPTremPtr tTrem = NULL;
  for (int i = 0; i <  TTPFormsManager::getInstance()->Trens->count() ;i++)
  {
    tTrem =  TTPFormsManager::getInstance()->Trens->get(i);

    for (int i = 0; i <  tTrem->Atividades->count() ;i++)
    {
      TTPAtividadePtr tAtividade = tTrem->Atividades->get(i);
      bool isInicioRealizado = false;

      if(tAtividade->ISAtividadeAlterada)
      {
        TTPZonaControlePtr tZonaControleTemp = TTPFormsManager::getInstance()->ZonasControle->get(tAtividade->SBAtual->ZonaControle);
        if (tZonaControleTemp)
        {
          if (tZonaControleTemp->Mesa == TTPFormsManager::getInstance()->Mesa)
					{
						for(int j = 0; j< tTrem->ItinerarioTrem->Movimentos->count(); j++)
            {
              if(tTrem->ItinerarioTrem->Movimentos->operator [](j)->SB->NomeVia  == tAtividade->SBAtual->NomeVia)
              {
                if(tTrem->ItinerarioTrem->Movimentos->operator [](j)->IsRealizado)
                {
                  isInicioRealizado = true;
                  //if(!TTPFormsManager::getInstance()->ShowVisualizador)
                    break ;
                }
                else
                {
                  if(TTPFormsManager::getInstance()->ShowVisualizador)
                  {
                    isInicioRealizado = false;
                    break ;
                  }
                }
              }
            }

            if(isInicioRealizado)
            {
              continue;
            }

            cdsGrid->Append();

            cdsGridPrefixoTrem->Text   = tTrem->Prefixo;
            cdsGridPIDTrem->Text       = tTrem->PID;
            cdsGridLocal->Text         = tAtividade->SBAtual->NomeVia;
            cdsGridSegmento->Text      = tAtividade->SBAtual->CodigoSegmento;

            if((double)tAtividade->DataFim>0)
             cdsGridDataFim->AsDateTime = tAtividade->DataFim;

            cdsGridDuracao->Text       = tAtividade->DuracaoFormatada;

            //campo para fazer a ordenao pela data de chegada
            cdsGridDataChegadaTrem->AsDateTime = tAtividade->AtividadeServer->segmentoTremPlanejado->getDataHoraChegadaCabecaTrem();

            cdsGrid->Post();
          }
        }
      }

    }
  }

  cdsGrid->First();
  cdsGrid->EnableControls();
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridAtividadesAlteradas::cxgGridDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  TTPFormsManager::getInstance()->SetFocusTremSegmento(cdsGridPIDTrem->Text,cdsGridSegmento->Text, false, true);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridAtividadesAlteradas::edtPrefixoExit(TObject *Sender)

{
  if (((TcxTextEdit *)Sender)->Text == "")
      ((TcxTextEdit *)Sender)->Clear();
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetGridAtividadesAlteradas::edtPrefixoKeyDown(TObject *Sender,
          WORD &Key, TShiftState Shift)
{
 acPesquisarPrefixoExecute(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridAtividadesAlteradas::acPesquisarPrefixoExecute(TObject *Sender)

{
  bool encontrei = false;
  cdsGrid->Close();
  cdsGrid->Filtered  = false;

  edtPrefixo->Text = (edtPrefixo->Text=="PREFIXO TREM")?(String)"": (String)edtPrefixo->Text;
  edtDestino->Text = (edtDestino->Text=="LOCAL")?(String)"": (String)edtDestino->Text;

  cdsGrid->Filter = " PrefixoTrem LIKE ('"+edtPrefixo->Text+"%') and Local LIKE ('"+edtDestino->Text+"%')";
  cdsGrid->Filtered  = True;
  cdsGrid->Open();

  edtPrefixoExit(edtPrefixo);
  edtPrefixoExit(edtDestino);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridAtividadesAlteradas::acAtualizarExecute(TObject *Sender)

{
  AtualizarGird();
}
//---------------------------------------------------------------------------



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFGradeTrens.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFGradeTrens.h"

#include "UFormsManager.h"
#include "UTPTrem.h"
#include "UTPItinerarioTrem.h"
#include "UDModuleMP.h"
#include "cxGridExportLink.hpp"
#include "UFEditarMovimento.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"

TFormGradeTrens *FormGradeTrens;

// ---------------------------------------------------------------------------
__fastcall TFormGradeTrens::TFormGradeTrens(TComponent* Owner) : TForm(Owner)
{
  this->IdxEncontrado         = -1;
  this->IdxPrimeiroEncontrado = -1;

  edtDestino->Clear();
  edtPrefixo->Clear();

}

// ---------------------------------------------------------------------------
void __fastcall TFormGradeTrens::CarregarTrens()
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  cdsGradeTrem->CreateDataSet();
  cdsGradeTrem->Open();
  cdsGradeTrem->DisableControls();

  TStringList *t_trens = core->getTrensCalculados();

  for (int i = 0; i < t_trens->Count; i++)
  {

    domain::TremMalha* tremCalc = (domain::TremMalha*)t_trens->Objects[i];

    cdsGradeTrem->Append();

    cdsGradeTremprefixo->Text = tremCalc->prefixoTrem;

    cdsGradeTremtipo->Text    = tremCalc->tipoTrem->nome;
    cdsGradeTremdestino->Text = tremCalc->destinoExtn;

    if (tremCalc->getPrimeiroMovimento() != NULL)
    {
      cdsGradeTremsegmento->Text        = tremCalc->getPrimeiroMovimento()->getSB()->sb;
      cdsGradeTremprevisaoPartida->Text =
        FormatDateTime("dd/mm/yyyy hh:mm", tremCalc->getPrimeiroMovimento()->getDataHoraFimParadaTrem());

      TTPSBPtr SBCliente = TTPFormsManager::getInstance()->SBs->get(tremCalc->getPrimeiroMovimento()->getSB()->sb);
      if (!SBCliente.isNull())
      {
        cdsGradeTremramal->Text        = SBCliente->Ramal;
        cdsGradeTremzonaControle->Text = SBCliente->ZonaControle;
      }
    }

    cdsGradeTremid->Text = tremCalc->PID;
    cdsGradeTremidExterno->Text = tremCalc->IDExterno;

    cdsGradeTrem->Post();
  }

  TStringList *t_trensNaoPlanejados = core->getTrensNaoPlanejados();

  for (int i = 0; i < t_trensNaoPlanejados->Count; i++)
  {
    cdsGradeTrem->Append();
    domain::TremMalha* tremCalc = (domain::TremMalha*)t_trensNaoPlanejados->Objects[i];
    cdsGradeTremprefixo->Text   = tremCalc->prefixoTrem + "(NP)";
    cdsGradeTremtipo->Text      = tremCalc->tipoTrem->nome;
    cdsGradeTremdestino->Text   = tremCalc->destinoExtn;

    cdsGradeTremid->Text        = tremCalc->PID;
    cdsGradeTremidExterno->Text = tremCalc->IDExterno;
    cdsGradeTrem->Post();
  }
  cdsGradeTrem->First();
  cdsGradeTrem->EnableControls();
}

// ---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::acCancelarExecute(TObject *Sender)
{
  this->Close();
}
// ---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::btnOkClick(TObject *Sender)
{
  this->Close();
}

// ---------------------------------------------------------------------------
void __fastcall TFormGradeTrens::acExportarExcelExecute(TObject *Sender)
{
  try
  {
    SaveDialog->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
    SaveDialog->Title  = "Exportar para Excel...";

    if (SaveDialog->Execute())
    {
      ExportGridToExcel(SaveDialog->FileName, cxgGradeTrem);
      MessageDlg("A planilha foi salva em " + SaveDialog->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
    }
  }
  catch (Exception& exception)
  {
    throw Exception("No foi possvel exportar para Excel");
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormGradeTrens::acEditarMovimentoOrigemExecute(TObject *Sender)
{
  try
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    String pidTrem = cdsGradeTremid->Value;
     // (cxgGradeTremDBTableView1->DataController->GetValue
     // (cxgGradeTremDBTableView1->Controller->SelectedRecords[0]->Index, cxgGradeTremDBTableView1id->Index));

    TTPTremPtr tremAlteracao = TTPFormsManager::getInstance()->Trens->get(pidTrem);
    if (tremAlteracao.isNull())
    {
      throw Exception("Trem no programado");
    }
    else if (TTPFormsManager::getInstance()->Mesa != tremAlteracao->GetMesaAtualProgramacao())
    {
      throw Exception("Trem encontra-se em outra mesa");
    }

    TTPMovimentoPtr tMovimento = tremAlteracao->ItinerarioTrem->GetMovimento(0);

    TFormEditarMovimento* t_formEditarMovimento = new TFormEditarMovimento(this, &*tremAlteracao, &*tMovimento, NULL, NULL,
      NULL, True);

    if (t_formEditarMovimento->ShowModal() == mrOk)
    {
      if (t_formEditarMovimento->chkEmanciparTremFilho->Checked)
            core->removerLinkTremPai(tremAlteracao->PID);

      timeTP::TimeTP dataSaida;
      dataSaida = tremAlteracao->PrimeiroMovimentoPrevisto->GetDataSaidaClient();

      if(tremAlteracao->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado)
        tremAlteracao->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->trem->setDataSaidaRotaTremUsuario(dataSaida,
          domain::SegmentoTremImpactado::SentidoConflito::SENTIDO_IGUAL, core->getDataHoraBaseCalculo());
      tremAlteracao->PrevisaoSaidaOriginal = dataSaida.asDateTime();
      ZerarParadasTrem(tremAlteracao);

      tremAlteracao = TTPFormsManager::getInstance()->Trens->get(tremAlteracao->PID);
        if (tremAlteracao->ItinerarioTrem->Movimentos->operator[](tremAlteracao->ItinerarioTrem->TotalMovimentos - 1)
          ->ServerSegTremPlanejado != NULL)
          tremAlteracao->ItinerarioTrem->Movimentos->operator[](tremAlteracao->ItinerarioTrem->TotalMovimentos - 1)
            ->ServerSegTremPlanejado->getPeriodoOcupacao();
      TTPFormsManager::getInstance()->PlotarTrem(&*tremAlteracao, false, false, true);
    }

    delete t_formEditarMovimento;
  }
  catch (Exception &e)
  {
    Alerta(e.Message);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::acPesquisarPrefixoExecute(TObject *Sender)
{
  bool encontrei = false;
  cdsGradeTrem->Close();
  cdsGradeTrem->Filtered  = false;

  edtPrefixo->Text = (edtPrefixo->Text=="PREFIXO TREM")?(String)"": (String)edtPrefixo->Text;
  edtDestino->Text = (edtDestino->Text=="DESTINO")?(String)"": (String)edtDestino->Text;

  cdsGradeTrem->Filter = " prefixo LIKE ('"+edtPrefixo->Text+"%') and destino LIKE ('"+edtDestino->Text+"%')";
  cdsGradeTrem->Filtered  = True;
  cdsGradeTrem->Open();

  edtDestinoExit(edtPrefixo);
  edtDestinoExit(edtDestino);

}
//---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::edtDestinoExit(TObject *Sender)
{
if (((TcxTextEdit *)Sender)->Text == "")
    ((TcxTextEdit *)Sender)->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::ZerarParadasTrem(TTPTremPtr pTrem)
{
  if (pTrem != NULL)
  {
   TTPMovimento* t_movimento = &*pTrem->ItinerarioTrem->GetMovimento(0);
   if(t_movimento->ServerSegTremPlanejado != NULL)
  {
    // FSerieMovimentoSelecionada_->Movimento->ServerSegTremPlanejado->zerarTemposMovimentos();
    TTPTrem* t_trem = t_movimento->Trem;

    timeTP::TimeTP tempo(boost::posix_time::not_a_date_time);

    TTPMovimento* tMovimentoNegocio       = &*t_movimento;
    TTPMovimento* tUltimoMovimentoNegocio = NULL;

    if (tMovimentoNegocio->MovimentoAnterior != NULL)
      tMovimentoNegocio = tMovimentoNegocio->MovimentoAnterior;

    if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      tMovimentoNegocio->ServerSegTremPlanejado->zerarTemposMovimentosSolicitadoUsuario();

    // Faremos o primeiro loop somente setando a data do arrasto nulo
    while (tMovimentoNegocio)
    {
      if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      {
        tMovimentoNegocio->ServerSegTremPlanejado->setDataPartidaUsuario(tempo);
      }
      tUltimoMovimentoNegocio = tMovimentoNegocio;
      tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
    }
    // Pede o perodo de ocupao do ltimo moviemtno para recalcular no Server
    if (tUltimoMovimentoNegocio->ServerSegTremPlanejado != NULL)
      tUltimoMovimentoNegocio->ServerSegTremPlanejado->getPeriodoOcupacao();

    tMovimentoNegocio = &*t_movimento;
    if (tMovimentoNegocio->MovimentoAnterior != NULL)
      tMovimentoNegocio = tMovimentoNegocio->MovimentoAnterior;
    // Seta nos cliente os valores dos movimento do Server
    String tNovaSB = "";
    while (tMovimentoNegocio)
    {
      if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      {
        tNovaSB = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
        if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
          tMovimentoNegocio->SB = TTPFormsManager::getInstance()->SBs->get(tNovaSB);

        if (tMovimentoNegocio->MovimentoPosterior != NULL)
        {
          tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
          tNovaSB           = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
          if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
            tMovimentoNegocio->SB = TTPFormsManager::getInstance()->SBs->get(tNovaSB);
        }
      }
      tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
    }

    TTPFormsManager::getInstance()->PlotarTrem(&*TTPFormsManager::getInstance()->Trens->get(t_trem->PID), false,
      false, true);
    }
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormGradeTrens::PopupMenu1Popup(TObject *Sender)
{
    String pidTrem = cdsGradeTremid->Value;

    TTPTremPtr tremAlteracao = TTPFormsManager::getInstance()->Trens->get(pidTrem);
    if (tremAlteracao.isNull() || tremAlteracao->IsSuprimido)
    {
      acEditarMovimentoOrigem->Enabled = false;
    }
    else
    {
      acEditarMovimentoOrigem->Enabled = true;
    }
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFPontosFila.h =====
//---------------------------------------------------------------------------

#ifndef UFPontosFilaH
#define UFPontosFilaH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include "UDAO.h"
#include <Vcl.ImgList.hpp>
#include <System.ImageList.hpp>
#include "cxGraphics.hpp"
#include "cxImageList.hpp"
//---------------------------------------------------------------------------
class TFormPontosFila : public TForm
{
__published:	// IDE-managed Components
	TPanel *Panel1;
	TPanel *Panel2;
	TPanel *Panel3;
	TPanel *Panel4;
	TPanel *Panel5;
	TPanel *Panel6;
	TButton *btnOk;
	TButton *btnAtivar;
	TButton *btnDetalhar;
	TStringGrid *stgPontosFila;
	TPanel *Panel7;
	TLabel *Label1;
	TEdit *edtBuscarPatio;
	TImageList *il;
	TButton *btnBuscarPrefixo;
	TcxImageList *cxImageList1;
	void __fastcall btnDetalharClick(TObject *Sender);
	void __fastcall btnAtivarClick(TObject *Sender);
	void __fastcall btnBuscarPrefixoClick(TObject *Sender);
	void __fastcall edtBuscarPatioEnter(TObject *Sender);
	void __fastcall edtBuscarPatioExit(TObject *Sender);
	void __fastcall edtBuscarPatioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall stgPontosFilaSelectCell(TObject *Sender, int ACol, int ARow, bool &CanSelect);


private:	// User declarations
public:		// User declarations
	__fastcall TFormPontosFila(TComponent* Owner);
	void __fastcall CarregarPontosFila();
	void __fastcall MudaTextoBtnAtivar(int ARow);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormPontosFila *FormPontosFila;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGridBase.h =====
//---------------------------------------------------------------------------

#ifndef FWidgetGridBaseH
#define FWidgetGridBaseH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "FWidgetBase.h"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include <System.Actions.hpp>
#include <Vcl.ActnList.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
//---------------------------------------------------------------------------
class TFormWidgetGridBase : public TFormWidgetBase
{
__published:	// IDE-managed Components
	TPopupMenu *PopupMenuGrid;
	TMenuItem *ExportarExcel1;
	TDataSetProvider *dtspGrid;
	TDataSource *dsGrid;
	TClientDataSet *cdsGrid;
	TImageList *il;
	TcxStyleRepository *cxStyleRepositoryGrids;
	TcxStyle *cxHeader;
	TcxStyle *cxContentEven;
	TcxStyle *cxStyle21;
	TcxStyle *cxSelection;
	TcxStyle *cxBandHeader;
	TcxStyle *cxContent;
	TcxStyle *cxBandHeaderDesabilitado;
	TcxStyle *cxHeaderDesabilitado;
	TcxStyle *cxSLAExtrapoladoContent;
	TcxStyle *cxInterrompidoContent;
	TcxStyle *cxMapaVerde;
	TcxStyle *cxMapaVermelho;
	TcxStyle *cxEmAndamentoContent;
	TcxStyle *cxStyle22;
	TcxStyle *cxStyle23;
	TcxStyle *cxErro;
	TcxStyle *cxDisabled;
	TcxStyle *cxDefault;
	TcxStyle *cxFilaInativa;
	TcxStyle *cxForaOrdemOriginal;
	TcxGridBandedTableViewStyleSheet *ssBandedTable;
	TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
	TcxGridTableViewStyleSheet *ssGridTable;
	TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
	TcxGrid *cxgGrid;
	TcxGridDBTableView *cxgGridDBTableView1;
	TcxGridLevel *cxgGridLevel1;
	TPanel *pnlFiltros;
	TActionList *al;
	TAction *acCancelar;
	TAction *acExportarExcel;
	TAction *acEditarMovimentoOrigem;
	TAction *acPesquisarPrefixo;
private:	// User declarations
public:		// User declarations
	__fastcall TFormWidgetGridBase(TComponent* Owner);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormWidgetGridBase *FormWidgetGridBase;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGridBase.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FWidgetGridBase.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FWidgetBase"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"
TFormWidgetGridBase *FormWidgetGridBase;
//---------------------------------------------------------------------------
__fastcall TFormWidgetGridBase::TFormWidgetGridBase(TComponent* Owner)
	: TFormWidgetBase(Owner)
{
}
//---------------------------------------------------------------------------

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetFarolIntrajornada.h =====
//---------------------------------------------------------------------------

#ifndef FWidgetFarolIntrajornadaH
#define FWidgetFarolIntrajornadaH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "FWidgetBase.h"
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ComCtrls.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.Dialogs.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include "cxGridBandedTableView.hpp"
#include "cxDropDownEdit.hpp"
#include "cxMaskEdit.hpp"
#include "cxContainer.hpp"
#include "cxTextEdit.hpp"
#include <Vcl.ToolWin.hpp>
#include <Vcl.Buttons.hpp>
//#include "UFPrincipal.h"
//#include "MalhaFerroviaria.h"
//#include "FichaTrem.h"
//#include "Equipagem.h"

#include "UUteis.h"
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
#include "cxImageList.hpp"
//---------------------------------------------------------------------------
class TFormWidgetFarolIntrajornada : public TFormWidgetBase
{
__published:	// IDE-managed Components
    TPageControl *pcMesas;
    TPanel *panelGridEquipagem;
    TcxGridDBTableView *cxgEquipagemDBTableView1;
    TcxGridLevel *cxgEquipagemLevel1;
    TcxGrid *cxgEquipagem;
    TAction *acExportarExcel;
    TSaveDialog *SaveDialogGrid;
    TDataSource *dsGrid;
    TImageList *il;
    TClientDataSet *cdsGrid;
    TDataSetProvider *dtspGrid;
    TPopupMenu *PopupMenuGrid;
    TMenuItem *ExportarExcel1;
    TStringField *cdsGridMatricula;
    TStringField *cdsGridNome;
    TStringField *cdsGridSede;
    TStringField *cdsGridAtividadeAtual;
    TStringField *cdsGridJornadaAtual;
    TStringField *cdsGridJornadaProjetada;
    TStringField *cdsGridTrem;
    TStringField *cdsGridOrigem;
    TStringField *cdsGridDestino;
    TStringField *cdsGridModeloIntra;
    TStringField *cdsGridPatioOptmove;
    TcxGridDBColumn *cxgEquipagemDBTableView1Matricula;
    TcxGridDBColumn *cxgEquipagemDBTableView1Nome;
    TcxGridDBColumn *cxgEquipagemDBTableView1Sede;
    TcxGridDBColumn *cxgEquipagemDBTableView1AtividadeAtual;
    TcxGridDBColumn *cxgEquipagemDBTableView1JornadaAtual;
    TcxGridDBColumn *cxgEquipagemDBTableView1JornadaProjetada;
    TcxGridDBColumn *cxgEquipagemDBTableView1Trem;
    TcxGridDBColumn *cxgEquipagemDBTableView1Origem;
    TcxGridDBColumn *cxgEquipagemDBTableView1Destino;
    TcxGridDBColumn *cxgEquipagemDBTableView1ModeloIntra;
    TcxGridDBColumn *cxgEquipagemDBTableView1PatioOptmove;
    TStringField *cdsGridAvaliacao;
    TcxGridDBColumn *cxgEquipagemDBTableView1Avaliacao;
    TStringField *cdsGridInicioAtividade;
    TcxGridDBColumn *cxgEquipagemDBTableView1InicioAtividade;
    TcxStyleRepository *cxStyleRepositoryGrids;
    TcxStyle *cxHeader;
    TcxStyle *cxContentEven;
    TcxStyle *cxStyle21;
    TcxStyle *cxSelection;
    TcxStyle *cxBandHeader;
    TcxStyle *cxContent;
    TcxStyle *cxBandHeaderDesabilitado;
    TcxStyle *cxHeaderDesabilitado;
    TcxStyle *cxSLAExtrapoladoContent;
    TcxStyle *cxInterrompidoContent;
    TcxStyle *cxMapaVerde;
    TcxStyle *cxMapaVermelho;
    TcxStyle *cxEmAndamentoContent;
    TcxStyle *cxStyle22;
    TcxStyle *cxStyle23;
    TcxStyle *cxErro;
    TcxStyle *cxDisabled;
    TcxStyle *cxDefault;
    TcxStyle *cxFilaInativa;
    TcxGridBandedTableViewStyleSheet *ssBandedTable;
    TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
    TcxGridTableViewStyleSheet *ssGridTable;
    TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
  TStringField *cdsGridmesa;
  TStringField *cdsGridpatioAtual;
  TcxGridDBColumn *cxgEquipagemDBTableView1mesa;
  TcxGridDBColumn *cxgEquipagemDBTableView1patioAtual;
  TAction *acRefresh;
  TcxTextEdit *edtBuscaPrefixo;
  TAction *acFiltraGrid;
  TStringField *cdsGriddestinoAssociado;
  TcxGridDBColumn *cxgEquipagemDBTableView1destinoAssociado;
  TStringField *cdsGridaberturaCaderno;
  TcxGridDBColumn *cxgEquipagemDBTableView1aberturaCaderno;
  TStringField *cdsGridpid;
  TcxGridDBColumn *cxgEquipagemDBTableView1pid;
  TStringField *cdsGriddataInicioAtividadeServico;
  TcxGridDBColumn *cxgEquipagemDBTableView1dataInicioAtividadeServico;
  TAction *acOficializar;
  TStringField *cdsGridpidEquipagem;
  TStringField *cdsGridpidTrecho;
  TcxGridDBColumn *cxgEquipagemDBTableView1pidEquipagem;
  TcxGridDBColumn *cxgEquipagemDBTableView1pidTrecho;
  TStringField *cdsGridUltimaOficializacao;
  TcxGridDBColumn *cxgEquipagemDBTableView1UltimaOficializacao;
    TMainMenu *MainMenu1;
    TToolBar *ToolBar1;
    TToolButton *ToolButton1;
    TToolButton *ToolButton2;
    TToolButton *ToolButton3;
    TAction *acExibirSemMaquinista;
    TAction *acExibirDuplado;
    TToolButton *ToolButton4;
  TBooleanField *cdsGridisReal;
  TcxGridDBColumn *cxgEquipagemDBTableView1isReal;
  TBooleanField *cdsGridrealizouIntra;
  TBooleanField *cdsGridisDuplado;
  TcxGridDBColumn *cxgEquipagemDBTableView1realizouIntra;
  TcxGridDBColumn *cxgEquipagemDBTableView1isDuplado;
  TToolButton *ToolButton5;
  TAction *acExibirReal;
  TToolButton *tbtnPlanejamentoOnOff;
  TAction *acFinalizarPlanejamento;
  TAction *acIniciarPlanejamento;
  TToolButton *ToolButton6;
  TToolButton *ToolButton7;
  TToolButton *ToolButton8;
  TAction *acExibirIntrajornada;
  TcxEditRepository *cxEditRepository1;
  TStringField *cdsGridobservacao;
  TcxGridDBColumn *cxgEquipagemDBTableView1observacao;
  TStringField *cdsGridobservacaoOflz;
  TBooleanField *cdsGridoficializado;
  TDateTimeField *cdsGriddataOflzMesa;
  TcxGridDBColumn *cxgEquipagemDBTableView1dataOflzMesa;
  TPanel *pnlGridFarol;
  TPanel *pnlGridFarolGrid;
  TPanel *pnlGridFarolDebug;
  TPanel *pnlOficializacoes;
  TPanel *pnlSituacaoTremFarol;
  TListView *ltvOficializacoes;
  TcxGridDBTableView *cxGrid1DBTableView1;
  TcxGridLevel *cxGrid1Level1;
  TcxGrid *cxGrid1;
  TcxGridDBTableView *cxgDebugDBTableView1;
  TcxGridLevel *cxgDebugLevel1;
  TcxGrid *cxgDebug;
  TToolButton *tbtSepDebug;
  TToolButton *ToolButton10;
  TAction *acHabilitarRastreamento;
  TToolButton *ToolButton11;
  TAction *acRastrearTrem;
  TActionList *ActionList;
  TLabel *lblRastreamento;
  TClientDataSet *cdsDebug;
  TDataSource *dsDebug;
  TStringField *cdsDebugREAL2;
  TStringField *cdsDebugID_FICHA;
  TIntegerField *cdsDebugNU_SEQC;
  TStringField *cdsDebugCD_SGMT;
  TStringField *cdsDebugMATRICULA_EQ;
  TStringField *cdsDebugNOME_EQ;
  TStringField *cdsDebugORIGEM_PLAN;
  TStringField *cdsDebugDEST_PLAN;
  TStringField *cdsDebugORIGEM_REAL;
  TStringField *cdsDebugDEST_REAL;
  TDateTimeField *cdsDebugDT_REAL;
  TDateTimeField *cdsDebugDT_ITNR;
  TcxGridDBColumn *cxgDebugDBTableView1REAL2;
  TcxGridDBColumn *cxgDebugDBTableView1ID_FICHA;
  TcxGridDBColumn *cxgDebugDBTableView1NU_SEQC;
  TcxGridDBColumn *cxgDebugDBTableView1CD_SGMT;
  TcxGridDBColumn *cxgDebugDBTableView1MATRICULA_EQ;
  TcxGridDBColumn *cxgDebugDBTableView1NOME_EQ;
  TcxGridDBColumn *cxgDebugDBTableView1ORIGEM_PLAN;
  TcxGridDBColumn *cxgDebugDBTableView1DEST_PLAN;
  TcxGridDBColumn *cxgDebugDBTableView1ORIGEM_REAL;
  TcxGridDBColumn *cxgDebugDBTableView1DEST_REAL;
  TcxGridDBColumn *cxgDebugDBTableView1DT_REAL;
  TcxGridDBColumn *cxgDebugDBTableView1DT_ITNR;
  TStringField *cdsDebugSISTEMA_INC_FICHA;
  TcxGridDBColumn *cxgDebugDBTableView1SISTEMA_INC_FICHA;
  TDateTimeField *cdsDebugDT_FICHA;
  TcxGridDBColumn *cxgDebugDBTableView1DT_FICHA;
  TStringField *cdsGridlistaSegmentoAtvPadrao;
  TBooleanField *cdsGridUsuarioEscolheuCriarAtv;
	TcxImageList *cxImageList1;
  void __fastcall acRefreshExecute(TObject *Sender);
  void __fastcall acFiltraGridExecute(TObject *Sender);
  void __fastcall edtBuscaPrefixoExit(TObject *Sender);
  void __fastcall cxgEquipagemDBTableView1JornadaAtualCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall cxgEquipagemDBTableView1AvaliacaoCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall acExportarExcelExecute(TObject *Sender);
    void __fastcall acOficializarExecute(TObject *Sender);
    void __fastcall acExibirSemMaquinistaExecute(TObject *Sender);
    void __fastcall acExibirDupladoExecute(TObject *Sender);
  void __fastcall acExibirRealExecute(TObject *Sender);
  void __fastcall acIniciarPlanejamentoExecute(TObject *Sender);
  void __fastcall acFinalizarPlanejamentoExecute(TObject *Sender);
  void __fastcall acExibirIntrajornadaExecute(TObject *Sender);
  void __fastcall cxgEquipagemDBTableView1PatioOptmoveGetProperties(TcxCustomGridTableItem *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomEditProperties *&AProperties);
  void __fastcall cxgEquipagemDBTableView1TremCustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall cdsGridAvaliacaoChange(TField *Sender);
  void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
  void __fastcall FormShow(TObject *Sender);
  void __fastcall cxgEquipagemDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall cxgEquipagemDBTableView1PatioOptmoveGetPropertiesForEdit(TcxCustomGridTableItem *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomEditProperties *&AProperties);
  void __fastcall cxgEquipagemDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cxgEquipagemDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall acHabilitarRastreamentoExecute(TObject *Sender);
  void __fastcall acRastrearTremExecute(TObject *Sender);


private:	// User declarations
  TStringList* FMesas_;
  bool habilitaDesabilitaEdicao(bool pForcarEdicao = false);


public:		// User declarations
    TStringList* TListaProperties;
    __fastcall TFormWidgetFarolIntrajornada(TComponent* Owner);
    void __fastcall PreencherGrid();
    void __fastcall CriarAbasMesas();
     void ThreadOficializarAtividades(TTheadResultado *pResult);

void AjustarEstadoControles();
void  SetFocoTremSelecionado();
};
//---------------------------------------------------------------------------
extern PACKAGE TFormWidgetFarolIntrajornada *FormWidgetFarolIntrajornada;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/MDIParent.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "MDIParent.h"
#include "MDIChild.h"
#include "UFormTabSheet.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TMDIParentForm *MDIParentForm;
//---------------------------------------------------------------------------
void __fastcall TMDIParentForm::CreateParams(TCreateParams &Params)
{
  TForm::CreateParams(Params);
  Params.ExStyle &= WS_EX_APPWINDOW;
  Params.WndParent = GetDesktopWindow();
}
//---------------------------------------------------------------------------
__fastcall TMDIParentForm::TMDIParentForm(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TMDIParentForm::CreateChild1Click(TObject *Sender)
{
  System::Classes::RegisterClass(__classid(TMDIChildForm));
    System::Classes::RegisterClass(__classid(TMDIParentForm));
	TMDIChildForm *form = new TMDIChildForm(this);
	form->Show();
}
//---------------------------------------------------------------------------
void __fastcall TMDIParentForm::PageControl1Change(TObject *Sender)
{
 if(PageControl1->PageCount > 1)
  {
    Application->ProcessMessages();
  }
  else
  {
  }

  if(PageControl1->ActivePage != NULL )
  {
    ((TFormTabSheet*)PageControl1->ActivePage)->Form->BringToFront();
  }
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FTV.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FTV.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxContainer"
#pragma link "cxControls"
#pragma link "cxEdit"
#pragma link "cxGraphics"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxTextEdit"
#pragma link "FTP"
#pragma link "VCLTee.TeeTools"
#pragma link "cxCheckBox"
#pragma link "cxCheckComboBox"
#pragma link "cxDropDownEdit"
#pragma link "cxMaskEdit"
#pragma link "cxClasses"
#pragma link "cxHint"
#pragma link "dxCustomHint"
#pragma link "dxScreenTip"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma link "cxButtons"
#pragma resource "*.dfm"

#include "UFRestricao.h"
#include "UFEditarMovimento.h"
#include "UFCriarTrem.h"
#include "UFFichaTrem.h"

#include "FSelecionarOficializacao.h"
#include "UFormTabSheet.h"
#include "FWidgetTrem.h"

#include "UFParametrosSistema.h"
#include "UGerenteProgramacao.h"
#include "UFResultadoProcessos.h"
#include "UGerenteComunicacaoAQ.h"
#include "FWidgetGridGradeTrens.h"
#include "FWidgetGridMonitoramentoEntrePlanos.h"

#include "UFFilasViewer.h"
#include "UFOrdemTremViewer.h"
#include "FWidgetGanttOcupacao.h"

#include "FWidgetFarolIntrajornada.h"
#include "UTPItinerarioTrem.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

TFormTV *FormTV;
TFormSelecionarOficializacao *formSelecionarOficializacao;
TFormWidgetGridGradeTrens *formWidgetGridGradeTrens;
//TFormWidgetGridDiferencasEntrePlanos *FormWidgetGridDiferencasEntrePlanos;
TFormWidgetTrem*  formWidgetTrem;
//TFormWidgetGanttOcupacao *FormWidgetGanttOcupacao;
//---------------------------------------------------------------------------
__fastcall TFormTV::TFormTV(TComponent* Owner, TTPRamalPtr pRamal)
	: TFormTP(Owner,pRamal)
{
  #ifdef BAIXADA_SANTISTA
    tbtFilaPriorizacao->Action = acPriorizarDestinos;
    tbtFilaPriorizacao->DropdownMenu = NULL;
  #endif
	pnlInfos->Width = 0;
	dtsInfos->Width = 25;
	FCarregarTrensFiltro_ = false;
	acShowWidgetTremExecute(this);
}
//---------------------------------------------------------------------------
void __fastcall TFormTV::acCarregarExecute(TObject *Sender)
{
  bool isSelecionarOficializacoesOK = false, isSetFocusMovimentoTremComparador = false, isNovasOficializacoes = true;
  if(formSelecionarOficializacao == NULL)
    formSelecionarOficializacao = new TFormSelecionarOficializacao(this);

  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada)
  {
    formSelecionarOficializacao->PreencherListaOficializacoesEnviadas();
    formSelecionarOficializacao->Hide();
    TTPFormsManager::getInstance()->IsAcionamentoComparador = false;
  }
  else
  {

    if(TTPFormsManager::getInstance()->IsAcionamentoComparador)
    {
      isSelecionarOficializacoesOK = true;
      isSetFocusMovimentoTremComparador = true;
      TTPFormsManager::getInstance()->IsAcionamentoComparador = false;
      bool isNovasOficializacoes = formSelecionarOficializacao->AddOficializacoesComparador(TTPFormsManager::getInstance()->DataOficializacao1,TTPFormsManager::getInstance()->DataOficializacao2);

      HWND  hwnd = FindWindow(NULL, L"OPTMOVE_VIEWER");
      if(hwnd)
        PostMessage(hwnd, VK_F11, 0, 0 ) ;

      if(!isNovasOficializacoes)
      {
        TTPFormsManager::getInstance()->SetFocusTremSegmento(TTPFormsManager::getInstance()->PIDTremComparador,TTPFormsManager::getInstance()->LocalComparador);
        isNovasOficializacoes = false;
        return;
      }
    }
    else
    {
      formSelecionarOficializacao->ShowModal();
      isSelecionarOficializacoesOK = formSelecionarOficializacao->ModalResult == mrOk;
    }

    if(isSelecionarOficializacoesOK)
      algorithm::CoreTMPlanner::getInstance()->setSystemProfile(TSystemProfile::tspVisualizador);
    else
      return;
  }
  TCursor t_oldcursor = Screen->Cursor;
  FCarregarTrensFiltro_ = true;

  bool lockMutex = false;

  try
  {
    /*
		 // Teste de Memoria para carregar o plano do OptMove
     const long convByte2Mb=1048576;
     const long mininoMemoriaOptMoveMb=600;
     MEMORYSTATUS memory ;
     memory.dwLength = sizeof (memory) ;
     GlobalMemoryStatus (&memory) ;

     long  LivreFisicaMb = memory.dwAvailPhys/convByte2Mb;
     if (LivreFisicaMb < mininoMemoriaOptMoveMb)
     {
     throw Exception("Neste momomento seu equipamento apresenta memoria fisica abaixo do mnimo necessrio, reinicie a aplicao.");
     }
     */

    FIsCtrlA_ = true;
    TTPFormsManager::getInstance()->gravarLog("Optmove Viewer");
		//TTPFormsManager::getInstance()->SetDataGrafico();
    TTPFormsManager::getInstance()->FecharFormsAbertos();
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    core->isCarregarMovimentosOficializadosAutomatico = core->isCarregarMovimentosOficializadosAutomaticoSelecionado;

    Application->ProcessMessages();
		Screen->Cursor = crHourGlass;
    TTPFormsManager::getInstance()->MinimizeOtherCharts(this);

    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Carregar Viewer :Tente novamente em alguns segundos","Carregar Viewer");

		lockMutex = true;
		TTPFormsManager::getInstance()->gravarLog("acCarregarExecute Mutex: lock");
		//TTPFormsManager::getInstance()->FecharFormsAbertos();
    Application->ProcessMessages();

		TTPFormsManager::getInstance()->EnableDisableTeechart(false);
		TTPFormsManager::getInstance()->AjustarLinhaTempo();
    Application->ProcessMessages();

		TTPFormsManager::getInstance()->AjustarEstadoControles(false);
		TTPGerenteProgramacao::getInstance()->checkProgramacaoEmCurso();
		FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

    //---------------------------------------------------------------
    String isSincronizarPlano = algorithm::CoreTMPlanner::getInstance()->getParamByName("CPTO_SNZC_PGMC_CTRL_A");
    if (TTPFormsManager::getInstance()->getAmbienteDebug() ) isSincronizarPlano = "FALSE";
    if (isSincronizarPlano.UpperCase()=="TRUE")
    {
//      try
//      {
//        TTheadResultado *tResult = new TTheadResultado();
//
//        boost:: thread threadProc(&this->ThreadSincronizarProgramacao, tResult);
//        Aguarde("Sincronizar Programao");
//        threadProc.join();
//        if (tResult->Status > 1)
//        {
//          TFormResultadoProcessos *fResultado = new TFormResultadoProcessos(this, tResult->ListaResultados);
//          fResultado->ShowModal();
//        }
//        delete tResult;
//        tResult = NULL;
//        Screen->Cursor = crDefault;
//      }
//      catch (Exception &e)
//      {
//        Screen->Cursor = crDefault;
//        Alerta(e.Message);
//        FExecutouResetPosicao_ = false;
//      }
//      catch (...)
//      {
//        Screen->Cursor = crDefault;
//        Alerta("Erro ao Sincronizar Programaao");
//      }
		}
    //---------------------------------------------------------------
      #ifndef MODO_MULT_THREAD
          TTheadResultado *tResultIcones = new TTheadResultado();
          ThreadCarregarIconesAtividades(tResultIcones);
      #else
          TTheadResultado *tResultIcones = new TTheadResultado();
          TFormTP * ff = this;
          boost:: thread threadCarregarIconesAtividades2(&TFormTP::ThreadCarregarIconesAtividades,&*ff, tResultIcones);
      #endif

    TTPFormsManager::getInstance()->AntialiasONOFF(false);

		TTPFormsManager::getInstance()->LimparGraficos();

#ifndef MODO_MULT_THREAD
    TTheadResultado *tResult = new TTheadResultado();
		ThreadCarregarTrensMalha(tResult);
#else
		TTheadResultado *tResult = new TTheadResultado();
		boost:: thread threadProcessamentoCalc(&this->ThreadCarregarTrensMalha, tResult);
#endif
#ifdef MODO_MULT_THREAD
    Aguarde("Carregando Trens");
		threadProcessamentoCalc.join();
#endif

		if (tResult->Status == terSucesso)
		{
			if (tResultIcones->Status == terSucesso)
      {
			delete tResultIcones;
      delete tResult;
			Application->ProcessMessages();
			#ifndef MODO_MULT_THREAD
						tResult = new TTheadResultado();
						ThreadCalcularTrens(tResult);
			#else
						tResult = new TTheadResultado();
						boost:: thread threadProcessamentoCalc(&TFormTP::ThreadCalcularTrens,&*ff, tResult);
			#endif

			#ifdef MODO_MULT_THREAD
						Aguarde("Programando");
						threadProcessamentoCalc.join();
			#endif

        if (tResult->Status == terSucesso)
        {
				 TTPFormsManager::getInstance()->SetDataGrafico();
							 #ifdef MODO_MULT_THREAD
        //  Aguarde("Carregando cones das Atividades");
          threadCarregarIconesAtividades2.join();
      #endif
          Aguarde("Plotando Grfico",false);
          TTPFormsManager::getInstance()->ServerCarregarFilas();

          TTPFormsManager::getInstance()->AjustarLinhaTempo();

          // Plotar Restries
          for (int i = 0; i < TTPFormsManager::getInstance()->Restricoes->count(); i++)
					{
            TTPRestricaoPtr t_Restricao = TTPFormsManager::getInstance()->Restricoes->get(i);
            TTPFormsManager::getInstance()->PlotarRestricao(t_Restricao);
					}

           //Atualiza o combo com as datas dos faris dos parametros
          cbxDataOficializacaoFarolParametros->Properties->OnChange = NULL;
          TTPFormsManager::getInstance()->ClearDataOficializacaoFarolParametros();
          for(int i=0; i< formSelecionarOficializacao->LstDatasOficalizacoes->Count; i++)
          {
            TDateTime* data =  (TDateTime*)formSelecionarOficializacao->LstDatasOficalizacoes->Objects[i];
            String indicadorOrigemOflz = "";
            if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada)
              indicadorOrigemOflz = formSelecionarOficializacao->LstDatasOficalizacoes->KeyNames[i].SubString(0,1);

            String dtOflz = data->DateTimeString();
            TTPFormsManager::getInstance()->AddDataOficializacaoFarolParametros(dtOflz, indicadorOrigemOflz);
          }
          cbxDataOficializacaoFarolParametros->ItemIndex = 0;
          if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspVisualizador)
          {
            cbxDataOficializacaoFarolParametros->Properties->OnChange = cbxDataOficializacaoFarolParametrosPropertiesChange;
            cbxDataOficializacaoFarolParametrosPropertiesChange(this);
          }


          PlotarTrens();

          filtrou_ = false;

          TTPFormsManager::getInstance()->VerificarConflitos();
          TTPFormsManager::getInstance()->AjustarPrefixos();

//         TTPFormsManager::getInstance()->SetInicializarFinalizarPlanejamento(FPlanoInicializado, this);

          TTPFormsManager::getInstance()->AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);

					TTPFormsManager::getInstance()->ServerSetSelecionar(true);

					TTPFormsManager::getInstance()->RefreshCharts();


          StopAguarde();
        }
      }
    }
    Screen->Cursor = t_oldcursor;

    if (tResult->Status == terErro)
    {
      Alerta(tResult->ListaResultados->Text);
      acCarregar->Enabled  = true;
      acCarregar->ShortCut = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;
    }
    else
    {
      Application->ProcessMessages();
			TTPFormsManager::getInstance()->AjustarEstadoControles(true);
			TTPFormsManager::getInstance()->EnableDisableTeechart(true);

			for(int i=0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
			{
			 if(	TTPFormsManager::getInstance()->Trens->get(i)->Prefixo == formSelecionarOficializacao->edtPrefixo->Text)
			 {
				TTPFormsManager::getInstance()->AddPrefixoTremFiltroViewer(TTPFormsManager::getInstance()->Trens->get(i)->PID);
				break;
       }
			}


    }
    delete tResult;

    //---
  }
  catch (Exception &e)
  {
    acCarregar->Enabled  = true;
    acCarregar->ShortCut = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;

    Screen->Cursor = t_oldcursor;
    Alerta(e.Message);
  }

  TTPFormsManager::getInstance()->gravarLog("acCarregarExecute Mutex: UNlock");
	if(lockMutex)
	TTPFormsManager::getInstance()->MutexProc->unlock();

  //RestaurarChart();
	Application->ProcessMessages();

 if(	isSetFocusMovimentoTremComparador)
 {
		TTPFormsManager::getInstance()->SetFocusTremSegmento(TTPFormsManager::getInstance()->PIDTremComparador,TTPFormsManager::getInstance()->LocalComparador);

 }
 isSetFocusMovimentoTremComparador = false;
 TTPFormsManager::getInstance()->AtualizarStatusFarolParametros();
	 //TFormTP::acCarregarExecute(Sender);


}
//---------------------------------------------------------------------------


void __fastcall TFormTV::chrTTPClickSeries(TCustomChart *Sender, TChartSeries *Series,
					int ValueIndex, TMouseButton Button, TShiftState Shift, int X,
          int Y)
{
	//if(Shift.Contains(ssRight))
	 //	return;

	TFormTP::chrTTPClickSeries(Sender, Series, ValueIndex, Button, Shift, X, Y);
	if(Shift.Contains(ssLeft) && cbVisualizarInfoTrem->Checked)
	{
		if(GetTipoSerieMP(Series) == tsMovimento)
		{
//			for(int i = 0 ; i < pnlInfos->ComponentCount; i++)
//			{
//				((TFormWidgetTrem*) pnlInfos->Components[i])->TremSelecionado == ((TTPMovimentoSeries*)Series)->Trem;
//				 return;
//			}
//
//			int index = 0;
//			for(int i = 0 ; i < dtsInfos->Tabs->Count; i++)
//			{
//				if(dtsInfos->Tabs->operator [](i).Pos(((TTPMovimentoSeries*)Series)->Trem->Prefixo)>0 )
//				{
//					dtsInfos->TabIndex = i;
//					return;
//				}
//
//			}

			TTPTrem* tTrem                   = ((TTPMovimentoSeries*)Series)->Trem;
			if(!formWidgetTrem)
			{
				 formWidgetTrem = new TFormWidgetTrem(dtsInfos, tTrem, &*((TTPMovimentoSeries*)Series)->Movimento);
			}
			else
			{
				formWidgetTrem->TremSelecionado = tTrem;
				formWidgetTrem->MovimentoSelecionado = &*((TTPMovimentoSeries*)Series)->Movimento;
				formWidgetTrem->Visible = false;

				if(formWidgetTrem->Parent != NULL)
				{
				 formWidgetTrem->Show();
				 formWidgetTrem->Visible = true;
				}

			}

			if(!formWidgetTrem->Visible)
			{
				formWidgetTrem->ManualDock(dtsInfos);
				formWidgetTrem->Show();
				scbChartsResize(this);
			}
		}

	}
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::chrTTPResize(TObject *Sender)
{
//	pnlInfos->Top = scbCharts->Top;
//	pnlInfos->Height = chrTTP->Height-1;
	TFormTP::chrTTPResize(Sender);


}
//---------------------------------------------------------------------------

void __fastcall TFormTV::pnlInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow)
{
	if(pnlInfos->DockClientCount==1)
	{
		pnlInfos->Width = 0;
		ForceRedrawChart();
	}
	else
		pnlInfos->Width = PNLINFO_WIDTH;

		 scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::pnlInfosEndDock(TObject *Sender, TObject *Target, int X,
          int Y)
{
	if(pnlInfos->DockClientCount==1)
	{
		pnlInfos->Width = 0;
		ForceRedrawChart();
	}
	else
		pnlInfos->Width = PNLINFO_WIDTH;

		 scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::pnlInfosStartDock(TObject *Sender, TDragDockObject *&DragObject)

{
	if(pnlInfos->DockClientCount==0)
	{
		pnlInfos->Width = 0;
		ForceRedrawChart();
	}
	else
		pnlInfos->Width = DragObject->Control->Width;

		 scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::pnlInfosDockDrop(TObject *Sender, TDragDockObject *Source,
					int X, int Y )
{
	TFormWidgetBase *tFormWidgetBase = reinterpret_cast<TFormWidgetBase *>(Source->Control);
	if(pnlInfos->DockClientCount==0)
	{
		pnlInfos->Width = 0;
		ForceRedrawChart();
	}
	else if(pnlInfos->DockClientCount==1 && tFormWidgetBase)
	{
		pnlInfos->Width =  tFormWidgetBase->WidthBase;
	}
	else
	{
		pnlInfos->Width = PNLINFO_WIDTH;
	}

	scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::dtsInfosDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y)
{
	dtsInfos->TabIndex = dtsInfos->Tabs->Count-1;

	if(pnlInfos->DockClientCount==0)
	{
		pnlInfos->Width = 0;
		ForceRedrawChart();
	}

	 dtsInfos->Visible = true;

	//pnlGraficoResize(this);
	scbChartsResize(this);

}
//---------------------------------------------------------------------------

void __fastcall TFormTV::scbChartsResize(TObject *Sender)
{
	pnlGraficoResize(this);
	chrTTPLeft->AutoRepaint = true;
	chrTTPRight->AutoRepaint = true;


	//Application->ProcessMessages();

	scbChartLeft->Left = scbCharts->Left;
	scbChartRight->Left = scbChartLeft->Left+scbCharts->Width - scbChartRight->Width;

	chrTTPRight->AutoRepaint = true;
	chrTTPLeft->AutoRepaint = true;


	//Application->ProcessMessages();

	chrTTPLeft->Repaint();
	chrTTPRight->Repaint();

	//Application->ProcessMessages();
	scbChartRight->Refresh();
	scbChartLeft->Refresh();
	this->Canvas->Refresh();
	//Application->ProcessMessages();


	FIsMiminizedChart_ = false;

	RedimencionaChartToVisao();


}
//---------------------------------------------------------------------------
void __fastcall TFormTV::PlotarTrem(TTPTrem* pTrem, bool pPlotarPrefixo, bool pTremCopia, bool pAtualizar)
{
	
  //gnorar a Rota 0 pois contem todas as rotas
	for(int i=1; i<pTrem->ItinerarioTrem->GetTotalRotas(); i++ )
	{
		PlotarRotaTrem(pTrem, pPlotarPrefixo, pTremCopia, pAtualizar, pTrem->ItinerarioTrem->getRota(i));
	}
}

void TFormTV::ThreadCarregarTrensMalha(TTheadResultado *&pResult)
{
	try
	{
#ifdef _DEBUG
		TTPFormsManager::getInstance()->gravarLog("Incio: Carregando Trens");
#endif

		TTPFormsManager::getInstance()->ServerCarregarTrensMalha(this,formSelecionarOficializacao->DateTimeLinhaTempo, formSelecionarOficializacao->LstDatasOficalizacoes);

    TTPFormsManager::getInstance()->gravarLog("--X Chamando Stop Aguarde");

		pResult->Status = terSucesso;
    StopAguarde();

#ifdef _DEBUG
    TTPFormsManager::getInstance()->gravarLog("Fim: Carregando Trens");
#endif
  }
  catch (Exception &e)
	{
		TObject *excecao = &e;
		pResult->Status = terErro;
		pResult->ListaResultados->Add(e.Message);
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog(e.Message);
	}
	catch (...)
	{
		pResult->Status = terErro;
		pResult->ListaResultados->Add("Erro no identificado");
		StopAguarde();
		TTPFormsManager::getInstance()->gravarLog("Erro no identificado.");
	}
}
//---------------------------------------------------------------------------
 void TFormTV::Inicializar(TTPRamalPtr pPainel, int DiasPassado)
 {
	TFormTP::Inicializar(pPainel, 0);
 }

void __fastcall TFormTV::acShowWidgetTremExecute(TObject *Sender)
{
 dtsInfos->Visible =	cbVisualizarInfoTrem->Checked;
 //pnlGraficoResize(this);
 scbChartsResize(this);
}

//---------------------------------------------------------------------------


void TFormTV::AjustarEstadoControles(bool pOnOff)
{

  #ifdef BAIXADA_SANTISTA
    tbtFilaPriorizacao->Action = acPriorizarDestinos;
    tbtFilaPriorizacao->DropdownMenu = NULL;
    tbtFilaPriorizacao->Style = tbsButton;
    gbxAlerta->Caption = "Oficializaes";
    gbxAlerta->Visible = true;
    ToolBarAlertas->Visible = false;
    cbxDataOficializacaoFarolParametros->Left =  ToolBarAlertas->Left;
  #endif

	TFormTP::AjustarEstadoControles(false);
	//if (pOnOff)
	{
    TActionListState state = al->State;
		al->State              = asNormal;

		this->acCarregar->ShortCut = shortCutCarregar > 0 ? shortCutCarregar : acCarregar->ShortCut;
		this->acCarregar->Enabled  = pOnOff;
		this->acGradeDeTrens->Enabled  = pOnOff;
		this->acPesquisarPrefixo->Enabled  = pOnOff;
		this->acRestaurarTremNaoPlanejado->Enabled  = pOnOff;
		this->acVisao->Enabled  = pOnOff;
		this->acAtividadesTrem->Enabled  = pOnOff;
		this->acCriarAtividade->Enabled  = pOnOff;
    this->acExibirParametrosSistema->Enabled = pOnOff;
		this->acVisaoAntesLinhaTempo->Enabled  = pOnOff;
    this->acOcupacaoPatios->Enabled = pOnOff;

		this->acPublicarEntreMesas->Enabled  = false;
		this->acOficializar->Enabled   = false;
		this->acAtualizarTrem->Enabled = false;
		this->acEditarMovimentoOrigem->Enabled = false;

		this->acPublicarEntreMesas->Visible  = false;
		this->acOficializar->Visible  = false;
		this->acGerarPlanilhaEquipagem->Visible  = false;
		this->acEditarMovimentoOrigem->Visible     = false;
		this->acEditarMovimentoOrigem->Enabled = false;

		this->acAlertaEntrePlanos->Visible     = false;
		this->acAlertaEntrePlanos->Enabled = false;

    this->acFilasTerminais->Enabled  = pOnOff && algorithm::CoreTMPlanner::getInstance()->getSystemProfile() != TSystemProfile::tspIntrajornada;
    this->acOrdemSaida->Enabled  = pOnOff && algorithm::CoreTMPlanner::getInstance()->getSystemProfile() != TSystemProfile::tspIntrajornada;

    this->acFarolIntrajornada->Enabled = pOnOff && algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada;

    al->State = state;
	}


  grpControles->Visible = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspVisualizador;

  #ifndef BAIXADA_SANTISTA
  ToolBarAlertas->Enabled = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspVisualizador;
  ToolBarAlertas->Visible = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspVisualizador;
  #endif

  gbxAlerta->Caption = "Plano";
  GroupBox1->Caption = "Aes";

  acFarolIntrajornada->Visible = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada;
  GroupBox6 ->Visible = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada;

  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada)
  {

    cbxDataOficializacaoFarolParametros->Left = 10;
    cbxDataOficializacaoFarolParametros->Enabled = false;
    acFilasTerminais->Enabled = false;
    acFilasTerminais->Visible = false;
  }

}
void __fastcall TFormTV::acGradeDeTrensExecute(TObject *Sender)
{
 if(!formWidgetGridGradeTrens)
 {
	 formWidgetGridGradeTrens = new TFormWidgetGridGradeTrens(0);
	 FCarregarTrensFiltro_ = true;
 }

	formWidgetGridGradeTrens->ManualDock(dtsInfos);
	if(FCarregarTrensFiltro_)
	{
		formWidgetGridGradeTrens->CarregarTrens();
    FCarregarTrensFiltro_ = false;
	}
	formWidgetGridGradeTrens->Show();




}
//---------------------------------------------------------------------------

void __fastcall TFormTV::dtsInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow)
{
if(pnlInfos->DockClientCount==0 && dtsInfos->Tabs->Count==1)
	 {
			pnlInfos->Width = 0;
			dtsInfos->Visible = false;
	 }
	 else
	 dtsInfos->Visible = true;

	scbChartsResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::acExibirRealizadosExecute(TObject *Sender)
{
	TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer = cbExibirRealizados->Checked;
	TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo = cbExibirRealizadosLinhaDoTempo->Checked;
	TTPFormsManager::getInstance()->RefreshCharts();
}
//---------------------------------------------------------------------------


void __fastcall TFormTV::chrTTPBeforeDrawSeries(TObject *Sender)
{
 if(formWidgetGridGradeTrens)
 {
	 formWidgetGridGradeTrens->EnableGrid(false);
 }
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::chrTTPAfterDraw(TObject *Sender)
{
 TFormTP::chrTTPAfterDraw(Sender);
 chrTTPLeft->AutoRepaint = false;
 chrTTPLeft->Width -=1;
 chrTTPLeft->AutoRepaint = true;

 chrTTPLeft->Width +=1;
	if(formWidgetGridGradeTrens)
	{
		formWidgetGridGradeTrens->EnableGrid(true);
	}
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::acVisaoAntesLinhaTempoExecute(TObject *Sender)
{
	if( TP_->DiasPassado == 0)
	{
		acVisaoAntesLinhaTempo->ImageIndex = 52;
		TP_->DiasPassado = 1;
	}
	else
	{
		acVisaoAntesLinhaTempo->ImageIndex = 51;
		TP_->DiasPassado = 0;
	}

	ConfigurarChartsLimitesHorizontaisDefault();
	ScrollTo(NULL,0);
}
//---------------------------------------------------------------------------
void __fastcall TFormTV::MontarPopupTrem()
{
	acEditarRestricao->Enabled  = FHabilitarPopup;
	acExcluirRestricao->Enabled = FHabilitarPopup;

  if (FSerieMovimentoSelecionada_ != NULL)
  {
    TTPTrem* t_tremSelecionado = FSerieMovimentoSelecionada_->Trem;
    mniPrefixo->Caption        = t_tremSelecionado->Prefixo;
		acExcluirTrem->Visible     = false;
		acSuprimirTrem->Visible     = false;
		acRestaurarTrem->Visible     = false;
		acEditarMovimento->Visible     = false;
		acExcluirMovimento->Visible     = false;
		acIncluirParada->Visible     = false;
		//acAtividadesTrem->Visible     = false;
		acCriarAtividade->Visible     = false;
		acPriorizarMovimentos->Visible     = false;
		acLimparMovimentosPriorizados->Visible     = false;
		acReexibirMovimentos->Visible     = false;
		acZerarParadasTrem->Visible     = false;
		acZerarParadasOcultandoMovimentos->Visible     = false;
		acEditarTrem->Visible     = false;
		acAtivarValidacaoHorGrade->Visible     = false;
		acDesativarValidacaoHorGrade->Visible     = false;
		acEditarMovimentoOrigem->Visible     = false;
		acOficializarTrem->Visible     = false;
		acDesativarCalculoFila->Visible     = false;
		acAtivarCalculoFila->Visible     = false;
		acAtualizarTrem->Visible = false;
    acAtivarDesativarCalculoVelocidade->Visible = false;
	}
}

void __fastcall TFormTV::edtPesquisarKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
	if (Key == 13)
  {
		acPesquisarPrefixo->Execute();
	}
}
//---------------------------------------------------------------------------



void __fastcall TFormTV::dtsInfosTabRemoved(TObject *Sender)
{
 pnlInfos->Width = 0;

 ForceRedrawChart();
}
//---------------------------------------------------------------------------



void __fastcall TFormTV::cbxDataOficializacaoFarolParametrosPropertiesChange(TObject *Sender)

{
  if(cbxDataOficializacaoFarolParametros->ItemIndex>-1)
  {
    TDateTime dtOflz = StrToDateTime(cbxDataOficializacaoFarolParametros->Text);
    TTPFormsManager::getInstance()->CarregarConfiguracaoOficializacao(dtOflz);
    TTPFormsManager::getInstance()->ReordenarSeriesObservacao();
  }
}
//---------------------------------------------------------------------------
void __fastcall TFormTV::chrTTPUndoZoom(TObject *Sender)
{
  TFormTP::chrTTPUndoZoom(Sender);
  chrTTPResize(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::acFilasTerminaisExecute(TObject *Sender)
{
   TFormFilasViewer *FormFilasViewer = new TFormFilasViewer(this,cbxDataOficializacaoFarolParametros);
   FormFilasViewer->ShowModal();

   delete FormFilasViewer;
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::acOrdemSaidaExecute(TObject *Sender)
{
  TFormOrdemTremViewer *FormOrdemTremViewer = new TFormOrdemTremViewer(this,cbxDataOficializacaoFarolParametros);
  FormOrdemTremViewer->ShowModal();

  delete FormOrdemTremViewer;
}
//---------------------------------------------------------------------------


void __fastcall TFormTV::pmnRestricoesPopup(TObject *Sender)
{
  //teste
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::acFarolIntrajornadaExecute(TObject *Sender)
{
  if (!FormWidgetFarolIntrajornada)
  {
    FormWidgetFarolIntrajornada = new  TFormWidgetFarolIntrajornada(0);
  }

  FormWidgetFarolIntrajornada->Visible = false;
  FormWidgetFarolIntrajornada->ManualDock(dtsGanttOcupacao);
  FormWidgetFarolIntrajornada->Show();
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::edtPesquisarEnter(TObject *Sender)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada)
  {
    acPesquisarPrefixo->ShortCut = 13;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormTV::edtPesquisarExit(TObject *Sender)
{
  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada)
  {
    acPesquisarPrefixo->ShortCut = 0;
  }
}
//---------------------------------------------------------------------------



void __fastcall TFormTV::acExibirParametrosSistemaExecute(TObject *Sender)
{

  TFormParametrosSistema* formParametros = new TFormParametrosSistema(this);

  try
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    formParametros->chkExibirRealizadoReal->Checked = TTPFormsManager::getInstance()->FParametros.ExibirRealizadoReal;
    formParametros->chkExibirDeteccaoConflitos->Checked =
      TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos;
    formParametros->chkAtivarAntialias->Checked      = TTPFormsManager::getInstance()->FParametros.AtivarAntialias;
    formParametros->chkExibirHints->Checked          = TTPFormsManager::getInstance()->FParametros.ExibirHints;
    formParametros->chkExibirCargaDescarga->Checked  = TTPFormsManager::getInstance()->FParametros.ExibirCargaDescarga;
    formParametros->chkParametroOperacional->Checked =
      TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais;
    //formParametros->chkDesativarCalculoFila->Checked = !CheckFilasAtivas();
    formParametros->chkIsCarregarOrdemGatilho->Checked = core->getIsCarregarOrdemGatilho();
    TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio = CheckGatilhoVazio();
    formParametros->chkIsCalculoVelocidadeAtivo->Checked = core->getIsCalculoVelocidadeAtivo();
    //preencher as filas

     preencherFilas();
      formParametros->FdataExpiracao_ = TTPFormsManager::getInstance()->FParametros.dtExpiracao;
     formParametros->carregarListaFilas(TTPFormsManager::getInstance()->FParametros.listaFilasAtivas,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);


    // TTPFormsManager::getInstance()->FParametros.DasativarCalculoFilas;
    formParametros->chkDesativarCadenciaVazio->Checked = TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio;
    if (formParametros->ShowModal() == mrOk)
    {
      TTPFormsManager::getInstance()->FParametros.ExibirRealizadoReal = formParametros->chkExibirRealizadoReal->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos =
        formParametros->chkExibirDeteccaoConflitos->Checked;
      TTPFormsManager::getInstance()->FParametros.AtivarAntialias = formParametros->chkAtivarAntialias->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirHints = formParametros->chkExibirHints->Checked;
      TTPFormsManager::getInstance()->FParametros.ExibirCargaDescarga = formParametros->chkExibirCargaDescarga->Checked;
      TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais =
        formParametros->chkParametroOperacional->Checked;
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
      core->setUtilizarParamentroOperacionalCapacidadeTerminal(formParametros->chkParametroOperacional->Checked);

      if(formParametros->chkIsCalculoVelocidadeAtivo->Checked != TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo)
      {
        core->setIsCalculoVelocidadeAtivo(formParametros->chkIsCalculoVelocidadeAtivo->Checked);
        TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo = core->getIsCalculoVelocidadeAtivo();
        TTPFormsManager::getInstance()->SincronizarTodosTrensClientServer();
      }
      if (formParametros->chkDesativarCadenciaVazio->Checked !=  TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio)
      {
        DesativarGatilhoVazio(formParametros->chkDesativarCadenciaVazio->Checked);
      }
      TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio = formParametros->chkDesativarCadenciaVazio->Checked ;
      core->setIsCarregarOrdemGatilho(formParametros->chkIsCarregarOrdemGatilho->Checked);
      TTPFormsManager::getInstance()->FParametros.CarregarOrdemGatilho = core->getIsCarregarOrdemGatilho();

      AntialiasONOFF(TTPFormsManager::getInstance()->FParametros.AtivarAntialias);

      core->manterEstadoFilas(false,TTPFormsManager::getInstance()->FParametros.listaFilasInativas);
      core->manterEstadoFilas(true,TTPFormsManager::getInstance()->FParametros.listaFilasAtivas);

      TTPFormsManager::getInstance()->AtualizarStatusFarolParametros();
      TTPFormsManager::getInstance()->SincronizarTodosTrensClientServer();
      // acPlotarAtualizar->Execute();
    }

  }
  __finally
  {
    if (formParametros)
    {
      delete formParametros;
      formParametros = NULL;
    }
  }
}
//---------------------------------------------------------------------------


void __fastcall TFormTV::FormCreate(TObject *Sender)
{
  TFormTP::FormCreate(Sender);

  AdjustGroupBoxSize(GroupBox6);
  AdjustGroupBoxSize(gbxAlerta);
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFMovimentosTrem.h =====
//---------------------------------------------------------------------------

#ifndef UFMovimentosTremH
#define UFMovimentosTremH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>

#include "UTPTrem.h"
#include <Datasnap.DBClient.hpp>
#include <Data.DB.hpp>
#include <Vcl.ActnList.hpp>
#include "cxClasses.hpp"

#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "cxGridBandedTableView.hpp"
#include <Vcl.Dialogs.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxCalendar.hpp"
#include "cxTextEdit.hpp"
#include <Datasnap.Provider.hpp>
#include <Vcl.ComCtrls.hpp>
#include "cxCheckBox.hpp"
#include "UFFichaTrem.h"
#include "cxGridChartView.hpp"
#include "cxGridDBChartView.hpp"
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"

class TFStringGrid: TStringGrid
{

};

namespace domain
{
  class TremMalha;
  class Equipagem;
}
//------------------------------------------------------------
class TFormMovimentosTrem : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel2;
  TPanel *Panel3;
  TPanel *Panel4;
  TDataSource *dsMovimentosTrem;
  TClientDataSet *cdsMovimentosTrem;
  TStringField *cdsMovimentosTremSB;
	TActionList *al;
	TAction *acCancelar;
  TStringField *cdsMovimentosTremtipo;
  TDateTimeField *cdsMovimentosTremdataOcupacao;
  TStringField *cdsMovimentosTremparada;
  TStringField *cdsMovimentosTremPAT;
  TDateTimeField *cdsMovimentosTremdataSaidaCabeca;
  TStringField *cdsMovimentosTremsbCBTC;
  TStringField *cdsMovimentosTremzonaControle;
  TStringField *cdsMovimentosTremramal;
  TStringField *cdsMovimentosTremcodSBCBTC;
  TIntegerField *cdsMovimentosTremcontador;
  TcxStyleRepository *cxStyleRepositoryGrids;
  TcxStyle *cxHeader;
  TcxStyle *cxContentEven;
  TcxStyle *cxStyle21;
  TcxStyle *cxSelection;
  TcxStyle *cxBandHeader;
  TcxStyle *cxContent;
  TcxStyle *cxBandHeaderDesabilitado;
  TcxStyle *cxHeaderDesabilitado;
  TcxStyle *cxSLAExtrapoladoContent;
  TcxStyle *cxInterrompidoContent;
  TcxStyle *cxMapaVerde;
  TcxStyle *cxMapaVermelho;
  TcxStyle *cxEmAndamentoContent;
  TcxStyle *cxStyle22;
  TcxStyle *cxStyle23;
  TcxStyle *cxErro;
  TcxStyle *cxDisabled;
  TcxStyle *cxDefault;
  TcxStyle *cxFilaInativa;
  TcxGridBandedTableViewStyleSheet *ssBandedTable;
  TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
  TcxGridTableViewStyleSheet *ssGridTable;
  TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
  TSaveDialog *SaveDialog;
  TPopupMenu *PopupMenu1;
  TMenuItem *ExportarExcel1;
  TImageList *il;
  TAction *acExportarExcel;
  TDateTimeField *cdsMovimentosTremfimOcupacao;
  TStringField *cdsMovimentosTremmovimentoPID;
  TDateTimeField *cdsMovimentosTremFimPAT;
  TFloatField *cdsMovimentosTremcomprimentoSB;
  TPageControl *PageControl1;
  TTabSheet *TabSheet1;
  TTabSheet *TabSheet2;
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
  TPanel *pnlStatus;
  TLabel *lblStatus;
  TcxGrid *cxgMovimentosTrem;
  TcxGridDBTableView *cxgMovimentosTremDBTableView1;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1contador;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1SB;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1tipo;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1dataOcupacao;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1fimOcupacao;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1parada;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1PAT;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1FimPAT;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1dataSaidaCabeca;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1sbCBTC;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1zonaControle;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1ramal;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1codSBCBTC;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1comprimentoSB;
  TcxGridLevel *cxgMovimentosTremLevel1;
  TClientDataSet *cdsGrid;
  TStringField *cdsGridPIDEquipagem;
  TStringField *cdsGridMatricula;
  TStringField *cdsGridNome;
  TStringField *cdsGridCargo;
  TStringField *cdsGridSede;
  TStringField *cdsGridOrigem;
  TStringField *cdsGridDestino;
  TStringField *cdsGridAtividade;
  TBooleanField *cdsGridRealizouIntrajornada;
  TDateTimeField *cdsGridAberturaCaderno;
  TDateTimeField *cdsGridInicioAtividade;
  TDataSource *dsGrid;
  TDataSetProvider *dtspGrid;
  TcxGrid *cxgGrid;
  TcxGridDBTableView *cxgGridDBTableView1;
  TcxGridDBColumn *cxgGridDBTableView1PIDEquipagem;
  TcxGridDBColumn *cxgGridDBTableView1Matricula;
  TcxGridDBColumn *cxgGridDBTableView1Nome;
  TcxGridDBColumn *cxgGridDBTableView1Cargo;
  TcxGridDBColumn *cxgGridDBTableView1Sede;
  TcxGridDBColumn *cxgGridDBTableView1Origem;
  TcxGridDBColumn *cxgGridDBTableView1Destino;
  TcxGridDBColumn *cxgGridDBTableView1Atividade;
  TcxGridDBColumn *cxgGridDBTableView1AberturaCaderno;
  TcxGridDBColumn *cxgGridDBTableView1InicioAtividade;
  TcxGridDBColumn *cxgGridDBTableView1RealizouIntrajornada;
  TcxGridLevel *cxgGridLevel1;
  TIntegerField *cdsGridnuItinerario;
  TcxGridDBColumn *cxgGridDBTableView1nuItinerario;
  TBooleanField *cdsGridNaoRealizado;
  TcxGridDBColumn *cxgGridDBTableView1NaoRealizado;
  TPopupMenu *PopupMenu2;
  TAction *acExibirNaoRealizados;
  TMenuItem *acExibirNaoRealizados1;
  TcxGridDBColumn *cxgGridDBTableView1InicioServico;
  TDateTimeField *cdsGridInicioServico;
  TTabSheet *tabFicha;
  TAction *acExibirFicha;
  TMenuItem *acExibirFicha1;
  TPanel *pnlFicha;
  TcxGridDBChartView *cxgMovimentosTremDBChartView1;
  TDataSource *dsGeometria;
  TClientDataSet *cdsGeometria;
  TStringField *cdsGeometriaSB;
  TFloatField *cdsGeometriaGrade;
  TFloatField *cdsGeometriaComprimento;
  TcxGridDBChartSeries *cxgMovimentosTremDBChartView1Series2;
  TcxGridLevel *cxgMovimentosTremLevel2;
  TcxGridLevel *cxgMovimentosTremLevel3;
  TcxGridDBTableView *cxgMovimentosTremDBTableView2;
  TcxGridDBColumn *cxgMovimentosTremDBTableView2SB;
  TcxGridDBColumn *cxgMovimentosTremDBTableView2Grade;
  TcxGridDBColumn *cxgMovimentosTremDBTableView2Comprimento;
	TIntegerField *cdsGeometriaSeqc;
	TcxGridDBColumn *cxgMovimentosTremDBTableView2Column1;
	TFloatField *cdsGeometriaaltitude;
	TcxGridDBChartSeries *cxgMovimentosTremDBChartView1Series1;
	TBooleanField *cdsMovimentosTremtemGrade;
	TcxGridDBColumn *cxgMovimentosTremDBTableView1movimentoPID;
	TcxGridDBColumn *cxgMovimentosTremDBTableView1temGrade;
  TFloatField *cdsMovimentosTremVMA;
  TFloatField *cdsMovimentosTremVMP;
  TFloatField *cdsMovimentosTremVMC;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1VMA;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1VMP;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1VMC;
  TStringField *cdsMovimentosTremSBKMInicial;
  TStringField *cdsMovimentosTremSBKMFinal;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1SBKMInicial;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1SBKMFinal;
  TStringField *cdsMovimentosTremCancOcupa;
  TcxGridDBColumn *cxgMovimentosTremDBTableView1CancOcupa1;
	void __fastcall stgMovimentosTremSelectCell(TObject *Sender, int ACol, int ARow,
          bool &CanSelect);
	void __fastcall acCancelarExecute(TObject *Sender);
	void __fastcall btnOkClick(TObject *Sender);
  void __fastcall acExportarExcelExecute(TObject *Sender);
  void __fastcall cxgMovimentosTremDBTableView1CellDblClick(TcxCustomGridTableView *Sender, TcxGridTableDataCellViewInfo *ACellViewInfo,
          TMouseButton AButton, TShiftState AShift, bool &AHandled);
  void __fastcall cxgMovimentosTremDBTableView1ColumnSizeChanged(TcxGridTableView *Sender, TcxGridColumn *AColumn);
  void __fastcall cxgGridDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem,
          TcxStyle *&AStyle);
  void __fastcall acExibirNaoRealizadosExecute(TObject *Sender);
  void __fastcall acExibirFichaExecute(TObject *Sender);
  void __fastcall PageControl1Change(TObject *Sender);
	void __fastcall cxgMovimentosTremDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem,
          TcxStyle *&AStyle);



private:	// User declarations
  TTPTrem* FTrem_;
  domain::TremMalha* FTremServer_;
  int indexUltimoRealizadoTrem;
  virtual void __fastcall stgMovimentosTremDrawCell(TObject *Sender, int Col,
	  int Row, TRect &Rect, TGridDrawState State);
  TColor HintColorOld_;
  TFormFichaTrem *FFormFichaTrem_;

public:		// User declarations
  __fastcall TFormMovimentosTrem(TComponent* Owner);
  __fastcall TFormMovimentosTrem(TComponent* Owner, TTPTrem* pTrem, TTPMovimento* pMovimentoAtual = NULL);
  void CarregarEquipagem();
  int RetornaIndiceApelidoSegmento(String pApelidoSegmento);
  bool ExisteFichaEquipagem( domain::Equipagem* pEquipe);

  void CarregarGeometriaSBL(TTPMovimentoPtr pMovimentoAtual);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormMovimentosTrem *FormMovimentosTrem;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFControleLogsIntegracao.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#include <sysutils.hpp>
#pragma hdrstop

#include "UFControleLogsIntegracao.h"
#include "../../../Foundation/UDBMP.h"
#include "UDAO.h"
#include "UFormsManager.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FGridBase"
#pragma link "cxMaskEdit"
#pragma link "cxCalendar"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"
TFormControleLogs *FormControleLogs;
//---------------------------------------------------------------------------
__fastcall TFormControleLogs::TFormControleLogs(TComponent* Owner)
  : TFormGridBase(Owner)
{
	_nMesa = TTPFormsManager::getInstance()->Mesa;
	_rangeTempo = StrToIntDef(algorithm::CoreTMPlanner::getInstance()->getParamByName("RETN_TP_CLIE"),12);
  lblTempoParametro->Caption = "TEMPO MDIO DAS CONSULTAS USANDO O PARMETRO DE " +  IntToStr(_rangeTempo) + " HORAS";
  String  msgtituloMesa ="MDIA DOS TEMPOS DE OFICIALIZAO DA " + _nMesa;
    //lblMediaMesa->Caption = "";
  //lblMediaMesa->Caption = msgtituloMesa;
  gbTempoMesa->Caption = msgtituloMesa;
  String  msgtituloMesaAutomatico ="MDIA DOS TEMPOS DE OFICIALIZAO DO AUTOMTICO:";
  gbTempoAutomatico->Caption = msgtituloMesaAutomatico;
  ConfigurarTemposOficializacao();
  CarregarTemposClient(_rangeTempo);


}


inline __fastcall TFormControleLogs::~TFormControleLogs(void)
{


}

void __fastcall TFormControleLogs::ConfigurarTemposOficializacao()
{
  String Resultado="";
  String pMesa="";
  try
  {
     //Automatico
     Resultado = TDAO::getTemposdeOficializacao("Automatico",1);
     lblUmaHoraParcial->Caption = TDAO::getResumoProgressoSolucaoConflitoAutomatico(1);
     lblSeisHoraParcial->Caption = TDAO::getResumoProgressoSolucaoConflitoAutomatico(6);
     lblDozeHoraParcial->Caption = TDAO::getResumoProgressoSolucaoConflitoAutomatico(12);
     if(Resultado != "")
     {
       lblAutoUmaHora->Caption = lblAutoUmaHora->Caption +  " " +Resultado + " Minutos";
     }
     else
     {
      lblAutoUmaHora->Caption =  lblAutoUmaHora->Caption + " Sem oficializaes no intervalo";
     }

     Resultado = TDAO::getTemposdeOficializacao("Automatico",6);
     if(Resultado != "")
     {
      lblSeisHoras->Caption = lblSeisHoras->Caption + Resultado + " Minutos";
     }
     else
     {
       lblSeisHoras->Caption =  lblSeisHoras->Caption + "Sem oficializaes no intervalo";
     }

     Resultado = TDAO::getTemposdeOficializacao("Automatico",12);
     if(Resultado != "")
     {
       lblAutoDozeHoras->Caption = lblAutoDozeHoras->Caption + Resultado + " Minutos";
     }
     else
     {
       lblAutoDozeHoras->Caption =  lblAutoDozeHoras->Caption + "Sem oficializaes no intervalo";
     }

     //mesa
     if(_nMesa=="MESA 1")
     {
        pMesa ="1";
     }
     else if(_nMesa=="MESA 2")
     {
        pMesa ="2";
     }else if(_nMesa=="MESA 3")
     {
        pMesa ="3";
     }

     if(pMesa=="1" || pMesa=="2" || pMesa=="3")
     {
       Resultado = TDAO::getTemposdeOficializacao(pMesa,1);
       if(Resultado != "")
       {
        lblMesaUmaHora->Caption =  lblMesaUmaHora->Caption + " " +Resultado + " Minutos";
       }
       else
       {
        lblMesaUmaHora->Caption =  lblMesaUmaHora->Caption + " Sem oficializaes no intervalo";
       }
       Resultado = TDAO::getTemposdeOficializacao(pMesa,6);
       if(Resultado != "")
       {
         lblMesaSeisHoras->Caption =  lblMesaSeisHoras->Caption + Resultado + " Minutos";
       }
       else
       {
          lblMesaSeisHoras->Caption =  lblMesaSeisHoras->Caption + "Sem oficializaes no intervalo";
       }
       Resultado = TDAO::getTemposdeOficializacao(pMesa,12);
       if(Resultado != "")
       {
         lblMesaDozeHoras->Caption =  lblMesaDozeHoras->Caption + Resultado + " Minutos";
       }else
       {
        lblMesaDozeHoras->Caption =  lblMesaDozeHoras->Caption+ "Sem oficializaes no intervalo";
       }
     }
  }
  catch(Exception& e)
  {
    ShowMessage(e.Message);
  }
}

void __fastcall TFormControleLogs::CarregarTemposClient(int pRangeTempo)
{
   try
   {

     String Resultado="";
   Resultado = TDAO::getTemposClient(_nMesa,"Programando",pRangeTempo);
     if(Resultado!="")
   {
     lblProgramando->Caption = "Tempo Mdio Programando:       " + Resultado + " Min";
     }
     else
   {
        lblProgramando->Caption = "Tempo Mdio Programando: indisponvel" ;
     }
     Resultado="";
   Resultado = TDAO::getTemposClient(_nMesa,"Plotando",pRangeTempo);
     if(Resultado!="")
   {
     lblPlotando->Caption = "Tempo Mdio Plotando:              " + Resultado+ " Min";
     }else
     {
     lblPlotando->Caption = "Tempo Mdio Plotando: indisponvel";
     }
     Resultado="";
   Resultado = TDAO::getTemposClient(_nMesa,"Carregando",pRangeTempo);
     if(Resultado!="")
     {
     lblCarregando->Caption = "Tempo mdio de Carregamento: " + Resultado+ " Min";
     }else
     {
          lblCarregando->Caption = "Tempo mdio de Carregamento: indisponvel" ;
     }

   }
    catch(Exception& e)
   {
      ShowMessage(e.Message);
   }

}



//---------------------------------------------------------------------------
void __fastcall TFormControleLogs::CarregarLinhas(String pNomeServico,String pICEvnt,int pRangeTempo)
{
   try
   {
    String IC;
        String sData;
        TDateTime  tdtdata;
        cxgGridDBTableView1->ApplyBestFit();
        cdsGrid->Close();

    PtrQuery query = TDAO::getLogsIntegracao(pNomeServico,pICEvnt,pRangeTempo);
        cdsGrid->CreateDataSet();
        cdsGrid->Open();
        cdsGrid->DisableControls();


        while (!query->Eof)
        {
          cdsGrid->Append();
          cdsGridNU_SEQL_EVNT->Text = StrToInt(query->FieldByName("numero_evento")->Text);
          tdtdata =  query->FieldByName("data_evento")->AsDateTime;
          sData =  query->FieldByName("data_evento")->Text;
          cdsGridDT_EVNT->Value = query->FieldByName("data_evento")->Text;
          cdsGridNM_SERV->Text = query->FieldByName("nome_servico")->Text;
          IC = IcEventosToString(query->FieldByName("indicador_evento")->Text);
          cdsGridIC_EVNT->Text = IC;
          cdsGridDS_EVNT->Text = query->FieldByName("descricao_evento")->Text;
          cdsGridDS_XML_INFO->Text = query->FieldByName("xml_descricao")->Text;
          cdsGridDT_CARGA_GERL->Value = query->FieldByName("data_carga_gerencial")->AsDateTime;
          query->Next();
          cdsGrid->Post();
        }


        if (cdsGrid->RecordCount > 0)
          cdsGrid->RecNo = 1;
          cdsGrid->EnableControls();

        ConfigurarGrid();

   }
   catch(Exception& e)
   {
      ShowMessage(e.Message);
   }


}
//---------------------------------------------------------------------------



void __fastcall TFormControleLogs::FormShow(TObject *Sender)
{

     CarregarComboServicos();
     CarregarComboICEventos();
     if (cmbServicos->ItemIndex == -1)
      cmbServicos->ItemIndex = 1;
     if (cmbIcEventos->ItemIndex == -1)
      cmbIcEventos->ItemIndex = 3;

   CarregarLinhas("Automatico","CR",_rangeTempo);

}
//---------------------------------------------------------------------------


void __fastcall TFormControleLogs::cmbServicosChange(TObject *Sender)
{

     String nomeServico  = cmbServicos->Text;
     String iCEvento = RetornaICEventos(cmbIcEventos->Text);
   CarregarLinhas(nomeServico,iCEvento,_rangeTempo);

}

void __fastcall TFormControleLogs::cmbIcEventosChange(TObject *Sender)
{

    String nomeServico  = cmbServicos->Text;
    String iCEvento = RetornaICEventos(cmbIcEventos->Text);
  CarregarLinhas(nomeServico,iCEvento,_rangeTempo);

}


void __fastcall TFormControleLogs::CarregarComboServicos()
{

     TStringList *SLNmServico  = new TStringList();
     SLNmServico->Add("Todos");
     SLNmServico->Add("Automatico");
     SLNmServico->Add("Step");
     SLNmServico->Add("Schedule");
     SLNmServico->Add("SendOficializacao");
     SLNmServico->Add("SendPlanning");
     SLNmServico->Add("PAT");
   SLNmServico->Add("Restriction");
     SLNmServico->Add("ExecuteTask");
     cmbServicos->Items->AddStrings(SLNmServico);
     delete SLNmServico;


}
 void __fastcall TFormControleLogs::CarregarComboICEventos()
 {
     TStringList *SLICEventos  = new TStringList();
     SLICEventos->Add("Todos");
     SLICEventos->Add("Erro");
   SLICEventos->Add("Aviso");
     SLICEventos->Add("Crtico");
   SLICEventos->Add("OK");
   SLICEventos->Add("Incio");
   SLICEventos->Add("Fim");
   SLICEventos->Add("Congelamento");
     cmbIcEventos->Items->AddStrings(SLICEventos);
     delete SLICEventos;

 }


//---------------------------------------------------------------------------

String TFormControleLogs::IcEventosToString(String pEvento)
{
  if(pEvento=="CR")
    {

      return "Crtico";
    }

    if(pEvento=="ER")
    {

      return "Erro";
    }

    if(pEvento=="WA")
    {

      return "Aviso";
    }

  if(pEvento=="OK")
    {

    return "OK";
    }

     if(pEvento=="ST")
    {

      return "Incio";
    }

   if(pEvento=="EN")
  {

      return "Fim";
  }

   if(pEvento=="FR")
  {

    return "Congelamento";
  }


    return "";

}

String TFormControleLogs::RetornaICEventos(String pICEvento)
{
    String escolhaIC = "";
    String pescolhaIC = "";
    escolhaIC = pICEvento;

  if(escolhaIC=="Todos")
    {
      pescolhaIC="Todos";
    return pescolhaIC;
    }
    if(escolhaIC=="Erro")
    {
      pescolhaIC="ER";
      return pescolhaIC;
    }
    if(escolhaIC=="Aviso")
    {
     pescolhaIC="WA";
     return pescolhaIC;
    }
    if(escolhaIC=="Crtico")
    {
      pescolhaIC="CR";
      return pescolhaIC;
    }
  if(escolhaIC=="OK")
    {
    pescolhaIC="OK";
      return pescolhaIC;
    }
    if(escolhaIC=="Incio")
    {
      pescolhaIC="ST";
      return pescolhaIC;
    }
  if(escolhaIC=="Fim")
  {
      pescolhaIC="EN";
    return pescolhaIC;
  }

  if(escolhaIC=="Congelamento")
  {
    pescolhaIC="FR";
    return pescolhaIC;
  }

    return "Todos";
}


 void  __fastcall TFormControleLogs::ConfigurarGrid()
 {
   cxgGridDBTableView1NM_SERV->Width = 220;
   cxgGridDBTableView1DT_EVNT->Width = 150;
   cxgGridDBTableView1IC_EVNT->Width = 50;
   cxgGridDBTableView1DS_EVNT->Width = 600;
   //AJustarDisplayTextDateTime(cxgGridDBTableView1DT_EVNT,cdsGridDT_EVNT,false);
 }

//---------------------------------------------------------------------------

void __fastcall TFormControleLogs::cxgGridDBTableView1CustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{

   if(AViewInfo->GridRecord->Values[cxgGridDBTableView1IC_EVNT->Index]=="Crtico")
   {
     ACanvas->Brush->Color = clWebSalmon ;
   }



}
//---------------------------------------------------------------------------

void __fastcall TFormControleLogs::FormClose(TObject *Sender, TCloseAction &Action)

{
this->Free();

}
//---------------------------------------------------------------------------

void __fastcall TFormControleLogs::btnOkClick(TObject *Sender)
{
this->Free();
}
//---------------------------------------------------------------------------

void __fastcall TFormControleLogs::btnCancelarClick(TObject *Sender)
{
this->Free();
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFFilasViewer.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFFilasViewer.h"

#include "FilaMalha.h"
#include "PontoFila.h"

#include "FTP.h"
#include "UFormsManager.h"
#include "UTPTrem.h"
#include "UTPItinerarioTrem.h"
#include "UDModuleMP.h"

#include "UTPMovimento.h"

#include "UFPontosFila.h"
#include "cxGridExportLink.hpp"
#include <DateTimeNull.h>
#pragma region Server
//#include "../domain/SegmentoTremOficializado.h"
//#include "../domain/SegmentoTremRealizado.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#pragma end_region
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLabel"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "UFFilas"
#pragma link "cxContainer"
#pragma link "cxDropDownEdit"
#pragma link "cxMaskEdit"
#pragma link "cxTextEdit"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"
TFormFilasViewer *FormFilasViewer;
//---------------------------------------------------------------------------
__fastcall TFormFilasViewer::TFormFilasViewer(TComponent* Owner, TcxComboBox *cbxOficializacoes)
  : TFormFilas(Owner)
{
  cbxDataOficializacaoFarolParametros->Properties->OnChange = NULL;
  cbxDataOficializacaoFarolParametros->Properties->Items->CommaText = cbxOficializacoes->Properties->Items->CommaText;
  cbxDataOficializacaoFarolParametros->ItemIndex = cbxOficializacoes->ItemIndex;
  cbxDataOficializacaoFarolParametros->Properties->OnChange = cbxDataOficializacaoFarolParametrosPropertiesChange;

  acEditarPontosFila->Enabled = false;
  acEditarPontosFila->Visible = false;

  acSalvarDuracaoUsu->Enabled = false;
  acSalvarDuracaoUsu->Visible = false;

  CarregarFilas();
  CarregarTrens();



}

//---------------------------------------------------------------------------
void __fastcall TFormFilasViewer::CarregarTrens()
{
  TStringList *t_movimentoTrensFila = new TStringList();

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();
  TStringList *t_trens           = core->getTrensCalculados();

  cdsFilas->Close();
  cdsFilas->CreateDataSet();
  cdsFilas->Open();

  Screen->Cursor = crHourGlass;

  Application->ProcessMessages();

  for (int i = 0; i < t_filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
    TTPFormsManager::getInstance()->Trens;

    if(cboFilas->Items->IndexOf(t_segmento->patioPertencente->sigla)==-1)
      continue;

    for(int j=0; j<TTPFormsManager::getInstance()->Trens->count();j++)
    {
      TTPTremPtr trem = TTPFormsManager::getInstance()->Trens->get(j);
      if (trem->ItinerarioTrem.isNull())
      {
       continue;
      }

			for(int k=1; k<trem->ItinerarioTrem->GetTotalRotas(); k++ )
      {
        TTPMovimentoListPtr Itnr = trem->ItinerarioTrem->getRota(k);
        if (!Itnr.isNull() && Itnr->count()>0)
        {
          TTPMovimentoPtr movimento =  Itnr->get(0);

          if(movimento->ServerSegTremOficializado)
          {
            domain::Oficializacao* oficializacao = movimento->ServerSegTremOficializado->oficializacao;

            if(oficializacao->segmentoFila && oficializacao->dataHoraBaseCarregamento.asDateTime() == StrToDateTime(cbxDataOficializacaoFarolParametros->Text)
              && oficializacao->segmentoFila == t_segmento)
            {
              t_movimentoTrensFila->AddObject("",(TObject*)movimento->ServerSegTremOficializado);

              break;
            }
          }
        }
      }
    }
  }

  t_movimentoTrensFila->CustomSort(CustomSort);

  cdsFilas->Close();
    cdsFilas->CreateDataSet();
    cdsFilas->Open();

    String tFilaAtual  = "";
    int tContadorGeral = 1;
    int tContadorGrupo = 1;
    for (int i = 0; i < t_movimentoTrensFila->Count; i++)
    {
      domain::SegmentoTremOficializado *segmentoOflz = (domain::SegmentoTremOficializado *) t_movimentoTrensFila->Objects[i];
      domain::Oficializacao* oficializacao = segmentoOflz->oficializacao;


        cdsFilas->Append();
        if (oficializacao->segmentoFila->segmento != tFilaAtual)
        {
          if (tFilaAtual != "")
          {
            cdsFilasordemGeral->Value = tContadorGeral;
            tContadorGeral++;
            tContadorGrupo         = 1;
            cdsFilasativa->Visible = false;
            cdsFilasativa->Value   = false;
            cdsFilas->Post();
            cdsFilas->Append();
          }
          tFilaAtual = oficializacao->segmentoFila->segmento;
        }

        cdsFilasordemGeral->Value = tContadorGeral;
        cdsFilasfila->Text    = oficializacao->segmentoFila->patioPertencente->sigla;
        cdsFilasordem->Text   = tContadorGrupo;
        cdsFilasprefixo->Text = segmentoOflz->getTrem()->prefixoTrem;
        cdsFilasativa->Value  = oficializacao->filaAtiva;



        cdsFilasordemOriginal->Text               = oficializacao->ordemFilaCalculada;
        cdsFilastabela->Text                      = oficializacao->tabelaTremOficializado;
        TDateTime chegadaTerminal = oficializacao->ordemChegadaFila;
        cdsFilasdataPrevisaoChegadaTerminal->Text = chegadaTerminal;

        cdsFilas->Post();

        tContadorGrupo++;
        tContadorGeral++;


    }

    cdsFilas->IndexName = "cdsFilasIndex1";
    cxgFilasDBTableView1ordemGeral->SortOrder = soAscending;

    SetRegistroEditavel();

    Screen->Cursor = crDefault;

}
//---------------------------------------------------------------------------
void __fastcall TFormFilasViewer::CarregarFilas()
{
  cboFilas->Clear();

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();
  domain::Oficializacao* oficializacao;
  bool breakLoop = false;
  for(int j=0; j<TTPFormsManager::getInstance()->Trens->count();j++)
  {
     TTPTremPtr trem = TTPFormsManager::getInstance()->Trens->get(j);
     for (int k = 0; k < trem->ItinerarioTrem->Movimentos->count(); k++)
     {
        TTPMovimentoPtr movimento =  trem->ItinerarioTrem->Movimentos->get(k);
        if(movimento->ServerSegTremOficializado)
        {
          oficializacao = movimento->ServerSegTremOficializado->oficializacao;
          if(oficializacao->dataHoraBaseCarregamento.asDateTime() == StrToDateTime(cbxDataOficializacaoFarolParametros->Text))
          {
            breakLoop = true;
            break;
          }
        }
     }
     if(breakLoop)
      break;
  }



  for (int i = 0; i < t_filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
    if (oficializacao->zonaResponsavelOficializacao ==  "MESAT" || ReplaceStr(t_segmento->codZonaControleResponsavel," ","") == oficializacao->zonaResponsavelOficializacao)
    {
      cboFilas->Items->Add(t_filaMalha->getPatioDestino()->sigla);
    }
  }

  cboFilas->Text = "FILAS";
}
//---------------------------------------------------------------------------
void __fastcall TFormFilasViewer::cbxDataOficializacaoFarolParametrosPropertiesChange(TObject *Sender)

{
  CarregarFilas();
  CarregarTrens();
}
//---------------------------------------------------------------------------
 int __fastcall  CustomSort(TStringList* List, int Index1, int Index2)
 {
   domain::SegmentoTremOficializado *sgmOf1 = (domain::SegmentoTremOficializado*)List->Objects[Index1];
   domain::SegmentoTremOficializado *sgmOf2 = (domain::SegmentoTremOficializado*)List->Objects[Index2];

   domain::Oficializacao* oficializacao1 = sgmOf1->oficializacao;
   domain::Oficializacao* oficializacao2 = sgmOf2->oficializacao;

   if (oficializacao1->segmentoFila->patioPertencente->sigla < oficializacao2->segmentoFila->patioPertencente->sigla)
    return 1;
  if (oficializacao2->segmentoFila->patioPertencente->sigla < oficializacao1->segmentoFila->patioPertencente->sigla)
    return -1;

  if (oficializacao1->ordemFilaCalculada > oficializacao2->ordemFilaCalculada)
    return 1;
  if (oficializacao2->ordemFilaCalculada > oficializacao1->ordemFilaCalculada)
    return -1;

    return 0;
 }

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFResultadoProcessos.h =====
//---------------------------------------------------------------------------

#ifndef UFResultadoProcessosH
#define UFResultadoProcessosH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include "UDAO.h"
//---------------------------------------------------------------------------
class TFormResultadoProcessos : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel2;
  TPanel *Panel3;
  TPanel *Panel4;
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TStringGrid *stgResultados;
  TPanel *pnlInfo;
  TComboBox *cbFiltro;
  TLabel *Label1;
  void __fastcall stgResultadosSelectCell(TObject *Sender, int ACol, int ARow, bool &CanSelect);
  void __fastcall stgResultadosDblClick(TObject *Sender);
  void __fastcall cbFiltroChange(TObject *Sender);

private:	// User declarations
int rowSelect;
PtrQuery Consulta;
public:		// User declarations
  __fastcall TFormResultadoProcessos(TComponent* Owner, TStringList *pLista);
  __fastcall TFormResultadoProcessos(TComponent* Owner, PtrQuery pConsulta);
  void CarregarResultado();
};
//---------------------------------------------------------------------------
extern PACKAGE TFormResultadoProcessos *FormResultadoProcessos;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFPaineis.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop


#include "UFPaineis.h"
#include "UTPZonaControle.h"
#include "UFControleAcesso.h"
#include "UUTeis.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "dxGDIPlusClasses"
#pragma resource "*.dfm"
#include <boost/thread.hpp>
//#include <boost/asio.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/bind.hpp>
#include <gdiplus.h>
using namespace Gdiplus;
#pragma comment (lib,"Gdiplus.lib")


TformPaineis *formPaineis;

inline __fastcall TformPaineis::~TformPaineis(void)
 {


//   delete core;
   delete FResultCarregamentoServer_;
   delete FRamais_;
     FZonas_ = NULL;
   TTPFormsManager::freeInstance();
   algorithm::CoreTMPlanner::freeInstance();
 }

__fastcall TformPaineis::TformPaineis(TComponent* Owner) : TForm(Owner)
{
  FRamais_ = new TXStringList();
  FZonas_  = TTPZonaControleListPtr(new TTPZonaControleList());

  formsManager = TTPFormsManager::getInstance(this);
	formsManager->IsAcionamentoComparador = false;

	this->WindowProc = WndProc;


//  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
//    cboLegenda->Items->Add("TESTE AUTOMATIZADO");

  //Aplicao executada pelo  comparador de planos
	FIsAbrirViewer_ = ParamCount()>5;
	if(FIsAbrirViewer_)
	{
		String paramertos;
		for(int i=0; i<=ParamCount(); i++ )
		{
			paramertos += ReplaceStr(ParamStr(i),"_","")+"\n";
		}

		FUsuario_.Codigo = ParamStr(1);
		FUsuario_.Nome = ReplaceStr(ParamStr(2),"_"," ");
		FUsuario_.Nivel = (TTPNivelUsuario)StrToInt(ParamStr(3));
		FUsuario_.Password  = ParamStr(4);
		FMesaViewer_ = ReplaceStr(ParamStr(5),"_"," ");

		formsManager->DataOficializacao1 = StrToDateTime(ReplaceStr(ParamStr(6),"_"," "));
		formsManager->DataOficializacao2 = StrToDateTime(ReplaceStr(ParamStr(7),"_"," "));
		formsManager->LinhaTempoComparador = (ReplaceStr(ParamStr(6),"_"," "));

		formsManager->PIDTremComparador  =    ParamStr(8);
		formsManager->LocalComparador =   ParamStr(9);
		formsManager->IsAcionamentoComparador= true;

        cboLegenda->Text = "VISUALIZADOR";

	}
	else
        this->Caption = "OptMove - Verso: " + TUteis::getVersaoExe();

	formsManager->getDataModule();

    TStringList* listaVaza = new TStringList();

	wchar_t buf[30];
	DWORD bufSize = sizeof(buf);
	String userName = ::GetUserName(buf, &bufSize);

	String nomeAplicacao = Application->Name; //GetApplicationName();
	userName = String(buf);

	if(algorithm::CoreTMPlanner::getInstance()->BUGREPORTPATH != "")
	{
		TTPFormsManager::getInstance()->gravarLog("Erro TformPaineis(TComponent* Owner) - " + algorithm::CoreTMPlanner::getInstance()->BUGREPORTPATH);
	}

		//boost::thread_group  poolCarregamentoLocal;
    boost::asio::io_service::work working(serviceLocal);
    FResultCarregamentoServer_ = new TTheadResultado();

    poolCarregamento.create_thread(boost::bind(workerThreadClient, &serviceLocal, FResultCarregamentoServer_));
    serviceLocal.post(boost::bind(&TTPFormsManager::ServerInicializar,formsManager));
    //poolCarregamento= &poolCarregamentoLocal;
    serviceLocal.stop() ;

    //DModuleMP->poolCarregamento.create_thread(boost::bind(workerThreadClient, &DModuleMP->service));
    //DModuleMP->service.post(boost::bind(&TTPFormsManager::ServerInicializar,formsManager));
    //formsManager->ServerInicializar();
    FormatSettings.DateSeparator     = '/';
    FormatSettings.ShortDateFormat   = "dd/MM/yyyy";
    FormatSettings.TimeSeparator     = ':';
    FormatSettings.LongTimeFormat    = "hh:mm:ss";
    FormatSettings.ThousandSeparator = '.';
    FormatSettings.DecimalSeparator  = ',';

    DModuleMP->ActivateUserDB();

    PtrQuery qrZonas = TDAO::getZonasControle();

    while (!qrZonas->Eof)
    {
    TTPZonaControlePtr zona = new TTPZonaControle();
    zona->Nome              = qrZonas->FieldByName("NM_ZONA_CTRL")->Text;
    zona->Mesa              = qrZonas->FieldByName("DC_MESA_OPER")->Text;

    #ifdef BAIXADA_SANTISTA
        if(zona->Mesa == "MESA 4")
        {
          FZonas_->add(zona->Nome, zona);
          lswPaineis->AddItem(qrZonas->FieldByName("NM_ZONA_CTRL")->Text, this);
        }
    #else
        if(zona->Mesa != "MESA 4")
        {
          FZonas_->add(zona->Nome, zona);
          lswPaineis->AddItem(qrZonas->FieldByName("NM_ZONA_CTRL")->Text, this);
        }
    #endif

    qrZonas->Next();
  }


  cboMesa->Clear();
  for (int i = 0; i < formsManager->MesasPlanejamento->Count; i++)
  {
    #ifdef BAIXADA_SANTISTA
        if(formsManager->MesasPlanejamento->Names[i] == "MESA 4")
          cboMesa->Items->Add(formsManager->MesasPlanejamento->Names[i]);
    #else
        if(formsManager->MesasPlanejamento->Names[i] != "MESA 4")
          cboMesa->Items->Add(formsManager->MesasPlanejamento->Names[i]);
    #endif
  }

  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
  {
    #ifndef BAIXADA_SANTISTA
    cboLegenda->Items->Add("TESTE AUTOMATIZADO");
    #endif
  }
	cboLegenda->ItemIndex = 0;

  TUteis::gravarLog("Optmove Iniciado versao: "+  TUteis::getVersaoExe());
}

// ---------------------------------------------------------------------------
void __fastcall TformPaineis::btnOkClick(TObject *Sender)
{
	bool selecionouZona = false;

  if (cboLegenda->ItemIndex < 0)
    Alerta("Selecione um perfil para visualizao das SBs!");
  else if (cboMesa->ItemIndex < 0 && (cboLegenda->Text != "VISUALIZADOR"
    && cboLegenda->Text != "TESTE AUTOMATIZADO") && cboLegenda->Text != "PROG. INTRAJORNADA")
    Alerta("Selecione uma mesa de controle!");
  else
  {
    if(cboMesa->ItemIndex < 0 && (cboLegenda->Text == "VISUALIZADOR"
        || cboLegenda->Text == "TESTE AUTOMATIZADO" || cboLegenda->Text == "PROG. INTRAJORNADA"))
    {
      cboMesa->ItemIndex  = cboMesa->Items->IndexOf("AUTOMACAO");
      if(cboLegenda->Text == "TESTE AUTOMATIZADO")
      {
        lswPaineis->ItemIndex  = 0;
        btnAddClick(this);
      }
    }
    formsManager->TipoLegenda = (TTPTipoLegendaSB)(cboLegenda->ItemIndex > -1 ? cboLegenda->ItemIndex : 0);

    for (int i = 0; i < lswPaineisSelecionados->Items->Count; i++)
    {
      // if(lswPaineisSelecionados->Items->Item[i]->Selected)
      {
        selecionouZona = true;
        formsManager->ZonasControle->add(lswPaineisSelecionados->Items->Item[i]->Caption, FZonas_->get(lswPaineisSelecionados->Items->Item[i]->Caption));
      }
    }

    if (!selecionouZona)
      Alerta("Selecione uma Zona de Controle!");
    else
    {
      try
      {
        if(cboLegenda->Text == "VISUALIZADOR")
        {
          algorithm::CoreTMPlanner::getInstance()->setSystemProfile(TSystemProfile::tspVisualizador);
        }
        else if(cboLegenda->Text == "PROG. INTRAJORNADA")
        {
          algorithm::CoreTMPlanner::getInstance()->setSystemProfile(TSystemProfile::tspIntrajornada);
        }
        else if(cboLegenda->Text == "TESTE AUTOMATIZADO")
        {
          algorithm::CoreTMPlanner::getInstance()->setSystemProfile(TSystemProfile::tspTeste);
        }
        else
        {
          algorithm::CoreTMPlanner::getInstance()->setSystemProfile(TSystemProfile::tspNormal);
        }
				Screen->Cursor = crHourGlass;

				TTPFormsManager::getInstance()->FParametros.ExibirDeteccaoConflitos = true;
				TTPFormsManager::getInstance()->FParametros.AtivarAntialias = true;
				TTPFormsManager::getInstance()->FParametros.ExibirHints = true;
				TTPFormsManager::getInstance()->FParametros.ExibirCargaDescarga = true;
				TTPFormsManager::getInstance()->FParametros.ExibirTrensAderenciaFila = true;
				TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais = true;
				algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
				core->setUtilizarParamentroOperacionalCapacidadeTerminal
						(TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais);

        String tParamCalcVeloc = core->getParamByName("IS_CALC_VE_ATIVO_PADR");
        TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo = tParamCalcVeloc == "T";
        core->setIsCalculoVelocidadeAtivo(TTPFormsManager::getInstance()->FParametros.IsCalculoVelovidadeAtivo);

				TTPFormsManager::getInstance()->ServerSetMesaPlan(cboMesa->Text == "AUTOMACAO"
          || cboLegenda->Text == "VISUALIZADOR" || cboLegenda->Text == "PROG. INTRAJORNADA" ? String(""):cboMesa->Text);

				if (formsManager->ZonasControle->count() > 0)
				{
					// Carregando o client
					formsManager->CarregarZonas();
					formsManager->CarregarTiposTrem();
					formsManager->CarregarTiposRestricao();
					formsManager->CarregarDadosCBTC();
					formsManager->CarregarGruposVMP();

					if(!FIsAbrirViewer_)
					this->Hide();

					if(formsManager->ShowVisualizador)
					{
						this->Caption = "OPTMOVE VISUALIZADOR";
						formsManager->CarregarViewer();
						this->Width = 0;
						this->Height = 0;
					}

				}

//        this->service->stop();
				this->poolCarregamento.join_all();
				if(FResultCarregamentoServer_->Status > 1 && !FIsAbrirViewer_)
				{
					Alerta (FResultCarregamentoServer_->Resultado);
				}
			}
      __finally
      {
        Screen->Cursor = System::Uitypes::crDefault;
      }
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::btnAddClick(TObject *Sender)
{
	try
  {
		lswPaineisDblClick(this);
  }
  catch (...)
  {
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::brnRemoveClick(TObject *Sender)
{
  try
  {

    TStringList *t_deletados = new TStringList();

    for (int i = 0; i < lswPaineisSelecionados->Items->Count; i++)
    {
      if (lswPaineisSelecionados->Items->Item[i]->Selected)
      {
        lswPaineis->AddItem(lswPaineisSelecionados->Items->Item[i]->Caption, lswPaineisSelecionados->Items->Item[i]);
        t_deletados->Add(lswPaineisSelecionados->Items->Item[i]->Caption);
      }
    }

    // Apaga os item selecinados
    for (int z = 0; z < t_deletados->Count; z++)
    {
      for (int i = 0; i < lswPaineisSelecionados->Items->Count; i++)
      {
        if (lswPaineisSelecionados->Items->Item[i]->Caption == t_deletados->operator[](z))
        {
          lswPaineisSelecionados->Items->Item[i]->Delete();
          break;
        }
      }
    }
    delete t_deletados;
  }
  catch (...)
  {
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::btnAddAllClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswPaineis->Items->Count; i++)
    {
      lswPaineisSelecionados->AddItem(lswPaineis->Items->Item[i]->Caption, lswPaineis->Items->Item[i]);
    }
    lswPaineis->Items->Clear();
  }
  catch (...)
  {
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::btnRemoveAllClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswPaineisSelecionados->Items->Count; i++)
    {
      lswPaineis->AddItem(lswPaineisSelecionados->Items->Item[i]->Caption, lswPaineisSelecionados->Items->Item[i]);
    }
    lswPaineisSelecionados->Items->Clear();
  }
  catch (...)
  {
  }
}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::lswPaineisDblClick(TObject *Sender)
{

  if (cboMesa->ItemIndex > -1)
  {
    if (lswPaineis->Selected)
    {
			if (FZonas_->get(lswPaineis->Selected->Caption)->Mesa != cboMesa->Text
        && cboLegenda->Text != "VISUALIZADOR" && cboLegenda->Text != "PROG. INTRAJORNADA")
      {
        btnRemoveAllClick(this);
        cboMesa->ItemIndex = cboMesa->Items->IndexOf(FZonas_->get(lswPaineis->Selected->Caption)->Mesa);
      }
      lswPaineisSelecionados->AddItem(lswPaineis->Selected->Caption, lswPaineis->Selected);
      lswPaineis->Items->Delete(lswPaineis->ItemIndex);
    }
  }
  else
  {

    if (lswPaineis->Selected)
    {
      cboMesa->ItemIndex = cboMesa->Items->IndexOf(FZonas_->get(lswPaineis->Selected->Caption)->Mesa);

      lswPaineisSelecionados->AddItem(lswPaineis->Selected->Caption, lswPaineis->Selected);
      lswPaineis->Items->Delete(lswPaineis->ItemIndex);
    }
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::lswPaineisSelecionadosDblClick(TObject *Sender)
{

  if (lswPaineisSelecionados->Selected)
  {
    lswPaineis->AddItem(lswPaineisSelecionados->Selected->Caption, lswPaineisSelecionados->Selected);
    lswPaineisSelecionados->Items->Delete(lswPaineisSelecionados->ItemIndex);
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::cboMesaChange(TObject *Sender)
{

  if (!lswPaineis->Selected && !lswPaineisSelecionados->Selected)
  {
    btnRemoveAllClick(this);

    if (cboMesa->ItemIndex > -1)
    {

      TStringList *t_selecionados = new TStringList();

      for (int i = 0; i < FZonas_->count(); i++)
      {
        if (FZonas_->operator[](i)->Mesa == cboMesa->Text)
        {
          lswPaineisSelecionados->AddItem(FZonas_->operator[](i)->Nome, NULL);
          t_selecionados->Add(FZonas_->operator[](i)->Nome);
        }
      }

      // Apaga os item selecinados
      for (int z = 0; z < t_selecionados->Count; z++)
      {
        for (int i = 0; i < lswPaineis->Items->Count; i++)
        {
          if (lswPaineis->Items->Item[i]->Caption == t_selecionados->operator[](z))
          {
            lswPaineis->Items->Item[i]->Delete();
            break;
          }
        }
      }

      delete t_selecionados;
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::FormShow(TObject *Sender)
{
  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
  {
    char Usuario[40];
    const unsigned long BUFSIZE = 255;
    unsigned long dwSize        = BUFSIZE;
    wchar_t pbuf[BUFSIZE + 1];
    if (GetUserName(pbuf, &dwSize))
    {
      strcpy(Usuario, AnsiString(pbuf).c_str());
      TTPFormsManager::getInstance(this)->Usuario.Codigo = Usuario;
    }

    TTPFormsManager::getInstance(this)->Usuario.Nome = "DEBUG";
		TTPFormsManager::getInstance(this)->Usuario.Nivel = nivManutencao;
		TTPFormsManager::getInstance(this)->Usuario.Password = "DEBUG";
    Panel6->Visible = false;
    tmrfiltro->Enabled = true;

		if(FIsAbrirViewer_)
		{
			int nivel = -1;
			cboMesa->ItemIndex = cboMesa->Items->IndexOf(FMesaViewer_);
			cboLegenda->Text = "VISUALIZADOR";
			cboMesaChange(this);
  }
  }
  else
  {
    TFormControleAcesso* controleAcesso = new TFormControleAcesso(this, DModuleMP->dmDB, DModuleMP->dmAmbiente);
    controleAcesso->PopupMode           = pmExplicit;
    controleAcesso->PopupParent         = this;

		bool acessoOK = false;
		if(FIsAbrirViewer_)
    {
			int nivel = -1;
			cboMesa->ItemIndex = cboMesa->Items->IndexOf(FMesaViewer_);
			cboLegenda->Text = "VISUALIZADOR";
			cboMesaChange(this);

			controleAcesso->NomeUsuario        = FUsuario_.Nome;
			controleAcesso->CodigoUsuario      = FUsuario_.Codigo;
			controleAcesso->NivelAcessoUsuario =  FUsuario_.Nivel;
			acessoOK = controleAcesso->VerificarAcessoAD(FUsuario_.Codigo,FUsuario_.Password,FUsuario_.Nome, nivel)  ;
		}
		else
		{
			acessoOK = controleAcesso->ShowModal() == mrOk;
    }


		if (!acessoOK)
    {
      Application->Terminate();
    }
    else
    {

      TTPFormsManager::getInstance(this)->Usuario.Codigo = controleAcesso->CodigoUsuario;
      TTPFormsManager::getInstance(this)->Usuario.Nome = controleAcesso->NomeUsuario;
			TTPFormsManager::getInstance(this)->Usuario.Nivel = (TTPNivelUsuario)controleAcesso->NivelAcessoUsuario;
			TTPFormsManager::getInstance(this)->Usuario.Password  = controleAcesso->edtSenha->Text;
		}
    delete controleAcesso;
  }
	if (TTPFormsManager::getInstance(this)->Usuario.Nivel >= nivManutencao)
  {
    btnAddAll->Enabled    = true;
		btnRemoveAll->Enabled = true;
		cboMesa->Items->Add("AUTOMACAO");
	}

	if(TTPFormsManager::getInstance(this)->Usuario.Nivel == nivVisualizador)
	{
		cboLegenda->Clear();
	}

  if(TTPFormsManager::getInstance(this)->Usuario.Nivel >= nivVisualizador)
	{
			cboLegenda->Items->Add("VISUALIZADOR");
			#ifndef BAIXADA_SANTISTA
      cboLegenda->Items->Add("PROG. INTRAJORNADA");
      #endif
  }

  if(TTPFormsManager::getInstance(this)->Usuario.Nivel == nivVisualizador)
	{
		cboLegenda->ItemIndex = 0;
	}

  if(FIsAbrirViewer_)
  {
    btnOkClick(this);
  }

}
// ---------------------------------------------------------------------------

void __fastcall TformPaineis::tmrfiltroTimer(TObject *Sender)
{
  bool tsetFocus = true;
  #ifdef _DEBUG
  if (TTPFormsManager::getInstance(this)->getAmbienteDebug())
  {
    TXStringList *tZonas = TTPFormsManager::getInstance(this)->getZonasDebugMode();
    if(tZonas->Count>0)
    {
      btnRemoveAllClick(this);
      for (int i = 0; i < tZonas->Count; i++)
      {

        lswPaineisSelecionados->AddItem(tZonas->operator [](i), NULL);

      }
     String tMesa = TTPFormsManager::getInstance(this)->getMesaByNomesRamais();

     if(tMesa!="")
     {
       cboMesa->ItemIndex =  cboMesa->Items->IndexOf(tMesa);
     }
     else
       cboMesa->ItemIndex = 1;
     tmrfiltro->Enabled = false;
     btnOkClick(this);
     tsetFocus = false;
    }
    delete tZonas;
  }
  #endif

  tmrfiltro->Enabled = false;
  Panel6->Visible = true;
  if(tsetFocus)
    cboMesa->SetFocus();
}
//---------------------------------------------------------------------------

void __fastcall TformPaineis::Image2Click(TObject *Sender)
{
//  this->Close();

Application->Terminate();
}
//---------------------------------------------------------------------------
void __fastcall TformPaineis::WndProc(TMessage &Message)
{

	if(Message.Msg == WM_COPYDATA)
	{
		COPYDATASTRUCT* cds = (COPYDATASTRUCT*) Message.LParam;

		TStringList *p_comparador = new TStringList();
		p_comparador->CommaText = (char *)cds->lpData;

		if(p_comparador->Count==4)
		{
			formsManager->DataOficializacao1 = StrToDateTime(p_comparador->Strings[0]);
			formsManager->DataOficializacao2 = StrToDateTime(p_comparador->Strings[1]);
			formsManager->LinhaTempoComparador = p_comparador->Strings[0];

			formsManager->PIDTremComparador  = p_comparador->Strings[2];
			formsManager->LocalComparador =  p_comparador->Strings[3];
			formsManager->IsAcionamentoComparador= true;

			if(formsManager->ShowVisualizador)
				formsManager->CarregarViewer();

			this->Width = 0;
			this->Height = 0;
		}
	}

	if(Message.Msg == VK_F11)
	{
		this->Width = 0;
		this->Height = 0;
		//this->Visible = false;
	}
	TForm::WndProc(Message);
}

void __fastcall TformPaineis::cboLegendaChange(TObject *Sender)
{
    if (!lswPaineis->Selected && !lswPaineisSelecionados->Selected)
    {
        if(cboLegenda->ItemIndex > -1)
        {
            if( cboLegenda->Text == "PROG. INTRAJORNADA")
            {
                btnRemoveAllClick(this);
                btnAddAllClick(NULL);
                cboMesa->ItemIndex = -1;
                cboMesa->Text  = "INTRAJORNADA";
            }
            else
            {
                cboMesa->Text  = "";
                btnRemoveAllClick(this);
                cboMesa->ItemIndex = -1;
            }
        }
    }
}

//---------------------------------------------------------------------------



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFGatilhos.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop
#include "UFormsManager.h"
#include "UFGatilhos.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FGridBase"
#pragma link "cxLabel"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"

TformGatilhos2 *formGatilhos2;
//---------------------------------------------------------------------------
__fastcall TformGatilhos2::TformGatilhos2(TComponent* Owner)
  : TFormGridBase(Owner)
{
  CarregarGatilhos();
}
//---------------------------------------------------------------------------
void __fastcall TformGatilhos2::CarregarGatilhos()
{

  using namespace domain;

	algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  cdsGrid->Close();
  cdsGrid->CreateDataSet();
  cdsGrid->Open();
  cdsGrid->DisableControls();

  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    cdsGrid->Append();
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    cdsGridcodigoGatilho->Text = t_gatilhoMalha->getCodigoGatilho();
    cdsGridtipoGatilho->Text = t_gatilhoMalha->getDescricao();
    cdsGridsegmento->Text = t_gatilhoMalha->getSegmentoParada()->segmento;
    cdsGridgatilhoOrdenacao->Value = t_gatilhoMalha->isGatilhoOrdenacao();
    cdsGridvalidarMesmoSentido->Value = t_gatilhoMalha->isValidarMesmoSentido();
    cdsGridgatilhoDinamico->Value = t_gatilhoMalha->getGatilhoDinamico();
    cdsGridaplicarDestino->Value = t_gatilhoMalha->getIsAplicarDestino();
    cdsGridmanterOrdenacao->Value = t_gatilhoMalha->getManterOrdenacao();
    cdsGridativoUsuario->Value = !t_gatilhoMalha->getIsDesativadoUsuario();
    cdsGridqtdadeFixOrdem->Value = t_gatilhoMalha->getLimiteOrdemSalva();
    cdsGrid->Post();
  }

  cdsGrid->First();
  cdsGrid->EnableControls();
}
//---------------------------------------------------------------------------
void __fastcall TformGatilhos2::acDesabilitarGatilhoExecute(TObject *Sender)
{
  using namespace domain;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  String codigoGatilho = cdsGridcodigoGatilho->Value;
  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    if(t_gatilhoMalha->getCodigoGatilho() == codigoGatilho)
    {
      core->desabilitarGatilho(t_gatilhoMalha);
      break;
    }
  }
  CarregarGatilhos();
}
//---------------------------------------------------------------------------

void __fastcall TformGatilhos2::acHabilitarGatilhoExecute(TObject *Sender)
{
  using namespace domain;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  String codigoGatilho = cdsGridcodigoGatilho->Value;
  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    if(t_gatilhoMalha->getCodigoGatilho() == codigoGatilho)
    {
      core->habilitarGatilho(t_gatilhoMalha);
      break;
    }
  }

  CarregarGatilhos();
}
//---------------------------------------------------------------------------


void __fastcall TformGatilhos2::PopupMenuGridPopup(TObject *Sender)
{
  acHabilitarGatilho->Enabled = cdsGridgatilhoDinamico->Value && !cdsGridativoUsuario->Value;
  acHabilitarGatilho->Visible = cdsGridgatilhoDinamico->Value && !cdsGridativoUsuario->Value;
  acDesabilitarGatilho->Enabled = cdsGridgatilhoDinamico->Value && cdsGridativoUsuario->Value;
  acDesabilitarGatilho->Visible = cdsGridgatilhoDinamico->Value && cdsGridativoUsuario->Value;
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFPriorizarDestino.cpp =====

// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#ifdef BAIXADA_SANTISTA
#endif
#include "UFPriorizarDestino.h"
#include "FilaMalha.h"
#include "PontoFila.h"

#include "FTP.h"
#include "UFormsManager.h"
#include "UTPTrem.h"

//#include "UFPontosFila.h"
#include "cxGridExportLink.hpp"
#include <DateTimeNull.h>
#pragma region Server
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/SegmentoTremRealizado.h"
#include <../domain/PrioridadeParametrizada.h>
#pragma end_region
#pragma resource "*.dfm"
TFormPriorizarDestinos *FormPriorizarDestinos;

//domain::FilaMalha *FFilaMalha_;

#pragma region Construtores_Destrutores
  // ---------------------------------------------------------------------------
  __fastcall TFormPriorizarDestinos::TFormPriorizarDestinos(TComponent* Owner) : TForm(Owner)
  {

    m_oficializacoes = false;

    lblOficializacao->Visible = false;
    cboOficializacao->Visible = false;

    acEditarPontosFila->Enabled = false;
    acEditarPontosFila->Visible = false;

    if (TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista)
    {
      acEditarPontosFila->Enabled = true;
      acEditarPontosFila->Visible = true;
    }

    ConfigurarGrid();
  }

  // ---------------------------------------------------------------------------
  inline __fastcall TFormPriorizarDestinos::~TFormPriorizarDestinos(void)
  {
    //
  }

  // ---------------------------------------------------------------------------
  __fastcall TFormPriorizarDestinos::TFormPriorizarDestinos(TComponent* Owner, TStringList* Oficializacoes) : TForm(Owner)
  {

    m_oficializacoes = Oficializacoes;

    lblOficializacao->Visible = true;
    cboOficializacao->Visible = true;

    if(m_oficializacoes)
    {
      for(int i = 0; i<m_oficializacoes->Count; i++)
      {
        cboOficializacao->Items->Add(m_oficializacoes->Strings[i]);
      }
      cboOficializacao->ItemIndex = 0;
    }

    acEditarPontosFila->Enabled = false;
    acEditarPontosFila->Visible = false;

    acSalvarDuracaoUsu->Enabled        = false;
    acSalvarDuracaoUsu->Visible        = false;

    ConfigurarGrid();

    cxgPatioDBTableView->Styles->ContentEven = cxDefault;
    cxgPatioDBTableView->Styles->Content     = cxDefault;
    cxgPatioDBTableView->Styles->Selection->RestoreDefaults();
  }
#pragma end_region

#pragma region Eventos
  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::FormCreate(TObject *Sender)
  {
    IniciarDialog();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::acCancelarExecute(TObject * Sender)
  {
    this->Close();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::btnOkClick(TObject * Sender)
  {
    if(!TTPFormsManager::getInstance()->ShowVisualizador)
    {
      SalvarNoServer();
    }

    this->Close();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::cxgPatioDBTableViewKeyDown(TObject * Sender, WORD & Key, TShiftState Shift)
  {
    GridOnKeyDownExecute(Key, Shift);
  }

  //---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::cxgPatioDBTableViewNavigatorButtonsButtonClick(TObject *Sender, int AButtonIndex, bool &ADone)
  {
    GridOnButtomClick(AButtonIndex, ADone);
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::acExportarExcelExecute(TObject *Sender)
  {
    GridOnExportarExcel();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::cxgPatioDBTableViewCanFocusRecord(TcxCustomGridTableView *Sender, TcxCustomGridRecord *ARecord, bool &AAllow)
  {
    AAllow = !m_editMode;
  }

  //---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::cxgPatioDBTableViewEditValueChanged(TcxCustomGridTableView *Sender, TcxCustomGridTableItem *AItem)
  {
    GridOnEdit();
  }

  //---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::cmdExcluirTodosClick(TObject *Sender)
  {
    LimparDataSet();
  }

  void __fastcall TFormPriorizarDestinos::cboOficializacaoChange(TObject *Sender)
  {
    if(TTPFormsManager::getInstance()->ShowVisualizador)
    {
      if(cboOficializacao->ItemIndex > -1 && cboOficializacao->Text.Length() > 0)
      {
        TDateTime dtOflz;
        TryStrToDateTime(cboOficializacao->Text, dtOflz);
        if(dtOflz > TDateTime(0))
        {
          TTPFormsManager::getInstance()->CarregarConfiguracaoOficializacao(dtOflz);
          PreencherGridPatios();
        }
      }
    }
  }
  //---------------------------------------------------------------------------

#pragma end_region // Eventos

#pragma region Methodos Privados
  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::IniciarDialog()
  {
    m_core = algorithm::CoreTMPlanner::getInstance();

    m_editMode = false;
    m_newRow = false;
    m_editRow  = 0;

    m_pularevento = false;

    if(TTPFormsManager::getInstance()->ShowVisualizador)
    {
      cboOficializacao->Text = TTPFormsManager::getInstance()->DataAtualParametrosOficializadosViewer;
    }

    cdsPatio->CreateDataSet();

    ConfigurarGrid();

    if (CarregarPatio())
      PreencherComboPatio();

    if(CarregarProduto())
      PreencherComboProduto();

    if(CarregarTerminal())
      PreencherComboTerminal();

    PreencherGridPatios();

    SetNavigatorButtons(true, m_hasData, false, false, true);
    SetButtons(true, true, true);
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::ConfigurarGrid()
  {
    TcxEditValidationOptions AValidationOptions;

    cxgPatioDBTableView->OptionsCustomize->ColumnFiltering = false;
    cxgPatioDBTableView->OptionsCustomize->ColumnGrouping  = false;
    cxgPatioDBTableView->OptionsCustomize->ColumnHidingOnGrouping = false;
    cxgPatioDBTableView->OptionsCustomize->ColumnSorting = false;

    cxgPatioDBTableView->DataController->DataModeController->SyncMode = true;

    AValidationOptions << evoShowErrorIcon;

    cxgPatioDBTableViewNM_PATIO->Properties->ValidationOptions = AValidationOptions;
    cxgPatioDBTableViewORI_DEST->Properties->ValidationOptions = AValidationOptions;
    cxgPatioDBTableViewLOTACAO->Properties->ValidationOptions = AValidationOptions;


    if (!TTPFormsManager::getInstance()->getAmbienteDebug() )
      chkSwitchItensOrdenados->Visible = false;
  }

  //----------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::PreencherComboPatio()
  {
    m_queryPatio->First();

    TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgPatioDBTableViewNM_PATIO->Properties;
    columnProperties->Items->Add(""); // Primeiro registro  vazio

    while (!m_queryPatio->Eof)
    {
      columnProperties->Items->Add(m_queryPatio->FieldByName("SG_PATIO_PLJM")->Text);

      m_queryPatio->Next();
    }
  }

  // ---------------------------------------------------------------------------
  bool __fastcall TFormPriorizarDestinos::CarregarPatio()
  {
    bool ret = false;

    try
    {
      m_queryPatio = TDAO::getPatiosPorRamal("ICZ-ISN Baixada Conceio-Santos");

      ret = true;

    }
    catch (Exception& exception)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'ptios' por Ramal", L"Erro", MB_ICONWARNING | MB_OK);
    }
    catch(...)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'ptios' por Ramal", L"Erro", MB_ICONWARNING | MB_OK);
    }

    return ret;
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::PreencherComboProduto()
  {
    m_queryProduto->First();

    TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgPatioDBTableViewPRODUTO->Properties;
    columnProperties->Items->Add(""); // Primeiro registro  vazio

    while (!m_queryProduto->Eof)
    {
      columnProperties->Items->Add(m_queryProduto->FieldByName("DC_PROD")->Text);

      m_queryProduto->Next();
    }
  }

  // ---------------------------------------------------------------------------
  bool __fastcall TFormPriorizarDestinos::CarregarProduto()
  {
    bool ret = false;

    try
    {
      m_queryProduto = TDAO::getProdutos(true);

      ret = true;

    }
    catch (Exception& exception)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'produtos' ", L"Erro", MB_ICONWARNING | MB_OK);
    }
    catch(...)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'produtos'", L"Erro", MB_ICONWARNING | MB_OK);
    }

    return ret;
  }


  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::PreencherComboTerminal()
  {
    m_queryTerminal->First();

    TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgPatioDBTableViewTERMINAL->Properties;
    columnProperties->Items->Add(""); // Primeiro registro  vazio

    while (!m_queryTerminal->Eof)
    {
      columnProperties->Items->Add(m_queryTerminal->FieldByName("DC_TERM")->Text);

      m_queryTerminal->Next();
    }
  }

  // ---------------------------------------------------------------------------
  bool __fastcall TFormPriorizarDestinos::CarregarTerminal()
  {
    bool ret = false;

    try
    {
      m_queryTerminal = TDAO::getTerminais(true);

      ret = true;

    }
    catch (Exception& exception)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'terminais' ", L"Erro", MB_ICONWARNING | MB_OK);
    }
    catch(...)
    {
      MessageBoxW(this->Handle, L"No foi possvel acessar 'terminais'", L"Erro", MB_ICONWARNING | MB_OK);
    }

    return ret;
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::RecarregarGridDoBancoDeDados()
  {
    m_core->refreshListaPrioridadeParametrizadaOrdenada();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::PreencherGridPatios()
  {
    bool beditMode = false;

    TStringList* listPrioridadeParametrizada;

    if (chkSwitchItensOrdenados->Checked)
      listPrioridadeParametrizada = m_core->getListaPrioridadeParametrizadaOrdenada();
    else
      listPrioridadeParametrizada = m_core->getListaPrioridadeParametrizada();

    LimparDataSet();
    cdsPatio->Close();
    cdsPatio->Open();

    for(int i = 0; i < listPrioridadeParametrizada->Count; i++)
    {
      beditMode = true;
      cdsPatio->Append();

      domain::ItemPrioridadeParametrizada* itemPrioridadeParametrizada = (domain::ItemPrioridadeParametrizada*)listPrioridadeParametrizada->Objects[i];
      String segmento = itemPrioridadeParametrizada->getSegmento();
      String lotacao;
      String tipoMovimento;
      String produto;
      String terminal;

      if (itemPrioridadeParametrizada->getTipoMovimentoPrioridade() == domain::eTipoMovimentoPrioridade::Origem)
        tipoMovimento = "Origem";
      else if (itemPrioridadeParametrizada->getTipoMovimentoPrioridade() == domain::eTipoMovimentoPrioridade::Destino)
        tipoMovimento = "Destino";
      else
        tipoMovimento = "";

      if (itemPrioridadeParametrizada->getLotacaoPrioritaria() == domain::eLotacaoPrioridade::Carregado)
        lotacao = "Carregado";
      else if (itemPrioridadeParametrizada->getLotacaoPrioritaria() == domain::eLotacaoPrioridade::Vazio)
        lotacao = "Vazio";
      else
        lotacao = "";

      produto = itemPrioridadeParametrizada->getProdutoPrioritario();
      terminal = itemPrioridadeParametrizada->getTerminalPrioritario();

      cdsPatioNM_PATIO->Text  = segmento;
      cdsPatioORI_DEST->Text  = tipoMovimento;
      cdsPatioLOTACAO->Text   = lotacao;
      cdsPatioPRODUTO->Text   = produto;
      cdsPatioTERMINAL->Text  = terminal;
    }
    if (beditMode)
      cdsPatio->Post();

    if (cdsPatio->RecordCount > 0)
    {
      cdsPatio->RecNo = 1;
      m_hasData = true;
    }
    else
    {
      m_hasData = false;
    }
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordEditPatio()
  {
    int nRow;
    if (cdsPatio->RecNo < 0)
      nRow = cdsPatio->RecordCount;
    else
      nRow = cdsPatio->RecNo;

    int nCol = cxgPatioDBTableViewNM_PATIO->Index;

    String textEdit = VarToStr(cxgPatioDBTableView->ViewData->EditingRecord->DisplayTexts[nCol]);

    return textEdit;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordEditOrigemDestino()
  {
    int nRow;
    if (cdsPatio->RecNo < 0)
      nRow = cdsPatio->RecordCount;
    else
      nRow = cdsPatio->RecNo;

    int nCol = cxgPatioDBTableViewORI_DEST->Index;

    String textEdit = VarToStr(cxgPatioDBTableView->ViewData->EditingRecord->DisplayTexts[nCol]);

    return textEdit;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordEditLotacao()
  {
    int nRow;
    if (cdsPatio->RecNo < 0)
      nRow = cdsPatio->RecordCount;
    else
      nRow = cdsPatio->RecNo;

    int nCol = cxgPatioDBTableViewLOTACAO->Index;

    String textEdit = VarToStr(cxgPatioDBTableView->ViewData->EditingRecord->DisplayTexts[nCol]);

    return textEdit;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordEditProduto()
  {
    int nRow;
    if (cdsPatio->RecNo < 0)
      nRow = cdsPatio->RecordCount;
    else
      nRow = cdsPatio->RecNo;

    int nCol = cxgPatioDBTableViewPRODUTO->Index;

    String textEdit = VarToStr(cxgPatioDBTableView->ViewData->EditingRecord->DisplayTexts[nCol]);

    return textEdit;
  }

  // ---------------------------------------------------------------------------

  String __fastcall TFormPriorizarDestinos::GetRecordEditTerminal()
  {
    int nRow;
    if (cdsPatio->RecNo < 0)
      nRow = cdsPatio->RecordCount;
    else
      nRow = cdsPatio->RecNo;

    int nCol = cxgPatioDBTableViewTERMINAL->Index;

    String textEdit = VarToStr(cxgPatioDBTableView->ViewData->EditingRecord->DisplayTexts[nCol]);

    return textEdit;
  }

  // ---------------------------------------------------------------------------

  String __fastcall TFormPriorizarDestinos::GetRecordPatio(int row)
  {
    int col = cxgPatioDBTableViewNM_PATIO->Index;

    String value = VarToStr(cxgPatioDBTableView->ViewData->Rows[row]->DisplayTexts[col]);

    return value;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordOrigemDestino(int row)
  {
    int col = cxgPatioDBTableViewORI_DEST->Index;

    String value = VarToStr(cxgPatioDBTableView->ViewData->Rows[row]->DisplayTexts[col]);

    return value;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordLotacao(int row)
  {
    int col = cxgPatioDBTableViewLOTACAO->Index;

    String value = VarToStr(cxgPatioDBTableView->ViewData->Rows[row]->DisplayTexts[col]);

    return value;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordProduto(int row)
  {
    int col = cxgPatioDBTableViewPRODUTO->Index;

    String value = VarToStr(cxgPatioDBTableView->ViewData->Rows[row]->DisplayTexts[col]);

    return value;
  }

  // ---------------------------------------------------------------------------
  String __fastcall TFormPriorizarDestinos::GetRecordTerminal(int row)
  {
    int col = cxgPatioDBTableViewTERMINAL->Index;

    String value = VarToStr(cxgPatioDBTableView->ViewData->Rows[row]->DisplayTexts[col]);

    return value;
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::LimparDataSet()
  {
    bool beditMode = false;

    cdsPatio->First();
    while(!cdsPatio->Eof)
    {
      beditMode = true;
      cdsPatio->Delete();
      cdsPatio->First();
    }
//    if (beditMode)
//      cdsPatio->Post();
  }

  void __fastcall TFormPriorizarDestinos::CancelEdit()
  {
      if(cxgPatioDBTableView->Controller->EditingController->Edit != NULL)
        cxgPatioDBTableView->Controller->EditingController->Edit->PostEditValue();

      cxgPatioDBTableView->Controller->EditingController->HideEdit(true);
      cdsPatio->Cancel();

      m_hasData = cdsPatio->RecordCount != 0;
      SetNavigatorButtons(true, m_hasData, false, false, true);
      SetButtons(true, true, true);
      m_editMode = false;
      m_newRow = false;
  }

  bool __fastcall TFormPriorizarDestinos::ValidarDados()
  {
    if (!m_editMode)
      return false;

    int editRow = cxgPatioDBTableView->ViewData->RecordCount - 1;

    if (m_newRow)
      editRow = cxgPatioDBTableView->ViewData->RecordCount - 1;
    else
      editRow = m_editRow -1;

    if (cxgPatioDBTableView->Controller->EditingController->Edit != NULL)
      cxgPatioDBTableView->Controller->EditingController->Edit->PostEditValue();

    String editNM_PATIO = GetRecordEditPatio();
    String editORI_DEST = GetRecordEditOrigemDestino();
    String editLOTACAO  = GetRecordEditLotacao();
    String editProduto  = GetRecordEditProduto();
    String editTerminal  = GetRecordEditTerminal();

    if (editNM_PATIO == "" && editORI_DEST == "" && editLOTACAO == "" && editProduto == "" && editTerminal == "")
    {
      MessageBoxW(this->Handle, L" obrigatrio informar o(s) campo(s) para priorizao!", L"Validao", MB_ICONWARNING | MB_OK);
      CancelEdit();
      return false;
    }

    if ((editNM_PATIO != "" && editORI_DEST == "") || (editNM_PATIO == "" && editORI_DEST != ""))
    {
      MessageBoxW(this->Handle, L"'Ptio' e 'Origem/Destino' possuem dependncia mtua!", L"Validao", MB_ICONWARNING | MB_OK);
      return false;
    }

    for (int row=0; row < cxgPatioDBTableView->ViewData->RecordCount; row++)
    {
      if(editRow == row)
        continue;

      String valueNM_PATIO  = GetRecordPatio(row);
      String valeuORI_DEST  = GetRecordOrigemDestino(row);
      String valeuLOTACAO   = GetRecordLotacao(row);
      String valuePRODUTO   = GetRecordProduto(row);
      String valueTERMINAL  = GetRecordTerminal(row);

      if(editNM_PATIO == valueNM_PATIO && editORI_DEST == valeuORI_DEST && editLOTACAO == valeuLOTACAO
          && valuePRODUTO == editProduto && valueTERMINAL == editTerminal)
      {
        MessageBoxW(this->Handle, L"J existe uma uma prioridade com esses valores!", L"Validao", MB_ICONWARNING | MB_OK);
        return false;
      }
    }

    return true;
  }

  void __fastcall TFormPriorizarDestinos::SalvarNoServer()
  {
    TStringList* listaItemPrioridade = m_core->getListaPrioridadeParametrizada();

    m_core->limparItensPrioridadeParametrizada();

    cdsPatio->First();
    int nRecords = cdsPatio->RecordCount;

    for(int nIndex = 1; nIndex <= nRecords; nIndex++)
    {
      ItemPrioridadeParametrizada* itemPrioridade = new ItemPrioridadeParametrizada();
      domain::eTipoMovimentoPrioridade tipoMovimento;
      domain::eLotacaoPrioridade lotacao;

      itemPrioridade->setOrdem(nIndex);
      itemPrioridade->setSegmento(cdsPatioNM_PATIO->Text);

      if(cdsPatioORI_DEST->Text == "Origem")
        itemPrioridade->setTipoMovimentoPrioridade(domain::eTipoMovimentoPrioridade::Origem);
      else if (cdsPatioORI_DEST->Text == "Destino")
        itemPrioridade->setTipoMovimentoPrioridade(domain::eTipoMovimentoPrioridade::Destino);
      else
        itemPrioridade->setTipoMovimentoPrioridade(domain::eTipoMovimentoPrioridade::TipoMovimentoNulo);

      if(cdsPatioLOTACAO->Text == "Vazio")
        itemPrioridade->setLotacaoPrioritaria(domain::eLotacaoPrioridade::Vazio);
      else if(cdsPatioLOTACAO->Text == "Carregado")
        itemPrioridade->setLotacaoPrioritaria(domain::eLotacaoPrioridade::Carregado);
      else
        itemPrioridade->setLotacaoPrioritaria(domain::eLotacaoPrioridade::LotacaoNulo);

      itemPrioridade->setProdutoPrioritario(cdsPatioPRODUTO->Text);
      itemPrioridade->setTerminalPrioritario(cdsPatioTERMINAL->Text);

      listaItemPrioridade->AddObject(IntToStr(nIndex), (TObject*) itemPrioridade);

      cdsPatio->Next();
    }

   if(listaItemPrioridade->Count > 0)
    m_core->setListaPrioridadeParametrizadaOrdenada();
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::SetNavigatorButtons(bool addnewEnabled, bool removeEnabled, bool confimeEnabled, bool CancelEditEnabled, bool refreshEnabled)
  {
    if(TTPFormsManager::getInstance()->ShowVisualizador)
    {
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[0]->Enabled = false;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[1]->Enabled = false;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[2]->Enabled = false;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[3]->Enabled = false;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[4]->Enabled = false;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[5]->Enabled = false;
    }
    else
    {
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[0]->Enabled = addnewEnabled;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[1]->Enabled = removeEnabled;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[2]->Enabled = confimeEnabled;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[3]->Enabled = CancelEditEnabled;
      cxgPatioDBTableView->NavigatorButtons->CustomButtons->Items[4]->Enabled = refreshEnabled;
    }
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::SetButtons(bool okEnabled, bool cancelEnabled, bool removeItemsEnabled)
  {
    btnOk->Enabled            = okEnabled;
    btnCancelar->Enabled      = cancelEnabled;
    if(TTPFormsManager::getInstance()->ShowVisualizador)
    {
      chkSwitchItensOrdenados->Visible = false;
      chkSwitchItensOrdenados->Enabled = false;
      cmdExcluirTodos->Visible = false;
      cmdExcluirTodos->Enabled = false;
    }
    else
      cmdExcluirTodos->Enabled = removeItemsEnabled;
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::GridOnEdit()
  {
    m_editMode = true;
    m_editRow = cdsPatio->RecNo;

    SetNavigatorButtons(false, false, true, true, false);
    SetButtons(false, true, false);
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::GridOnExportarExcel()
  {
     /* try
    {
      SaveDialog->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
      SaveDialog->Title  = "Exportar para Excel...";

      if (SaveDialog->Execute())
      {
        ExportGridToExcel(SaveDialog->FileName, cxgFilas);
        MessageDlg("A planilha foi salva em " + SaveDialog->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
      }
    }
    catch (Exception& exception)
    {
      throw Exception("No foi possvel exportar para Excel");
    }
    */
  }

  void __fastcall TFormPriorizarDestinos::GridOnButtomClick(int AButtonIndex, bool &ADone)
  {
    m_editRow = cdsPatio->RecNo;
    switch(AButtonIndex)
    {
      case NAVIGATEGRIDBUTTONS::AddNewRecord:
        cdsPatio->Append();
        m_editMode = true;
        m_newRow = true;
        SetNavigatorButtons(false, false, true, true, false);
        SetButtons(false, true, false);
        ADone = true;
        break;
      case NAVIGATEGRIDBUTTONS::RemoveRecord:
        cdsPatio->Delete();
        m_hasData = cdsPatio->RecordCount != 0;
        SetNavigatorButtons(true, m_hasData, false, false, true);
        SetButtons(true, true, true);
        m_editMode = false;
        m_newRow = false;
        ADone = true;
        break;
      case NAVIGATEGRIDBUTTONS::ConfirmeRecord:
        if(ValidarDados())
        {
          cdsPatio->Post();
          m_hasData = cdsPatio->RecordCount != 0;
          SetNavigatorButtons(true, m_hasData, false, false, true);
          SetButtons(true, true, true);
          m_editMode = false;
          m_newRow = false;
          ADone = true;
        }
        break;
      case NAVIGATEGRIDBUTTONS::CancelEditRecord:
        CancelEdit();
        ADone = true;
        break;
      case NAVIGATEGRIDBUTTONS::RefreshRecord:
        PreencherGridPatios();
        m_hasData = cdsPatio->RecordCount != 0;
        SetNavigatorButtons(true, m_hasData, false, false, true);
        SetButtons(true, true, true);
        m_editMode = false;
        m_newRow = false;
        m_editRow = 0;
        ADone = true;
        break;
      case NAVIGATEGRIDBUTTONS::RefreshRecordInDatabase:
        RecarregarGridDoBancoDeDados();
        PreencherGridPatios();
        m_hasData = cdsPatio->RecordCount != 0;
        SetNavigatorButtons(true, m_hasData, false, false, true);
        SetButtons(true, true, true);
        m_editMode = false;
        m_newRow = false;
        m_editRow = 0;
        ADone = true;
        break;
      default:
        ADone = true;
    }
  }

  // ---------------------------------------------------------------------------
  void __fastcall TFormPriorizarDestinos::GridOnKeyDownExecute(WORD & Key, TShiftState Shift)
  {
    /*__try
    {
      try
      {
        cxgPatioDBTableView->OnFocusedRecordChanged = NULL;
        if (Shift.Contains(ssCtrl))
        {
          int indexRow     = cxgPatioDBTableView->Controller->SelectedRecords[0]->Index;
          bool permiteAcao = !((indexRow == 0 && Key == vkUp) || (indexRow == cdsPatio->RecordCount - 1 && Key == vkDown));

          if (permiteAcao && (Key == vkUp || Key == vkDown))
          {

            int    nOrderm        = cxgPatioDBTableView->DataController->GetValue(indexRow, cxgPatioDBTableViewNUM_ORDEM->Index);
            String siglapatio     = VarToStr(cxgPatioDBTableView->DataController->GetValue(indexRow, cxgPatioDBTableViewSG_PATIO_PLJM->Index));
            String descricaopatio = VarToStr(cxgPatioDBTableView->DataController->GetValue(indexRow, cxgPatioDBTableViewDC_PATIO_PLJM->Index));

            if(siglapatio=="")
            return;

            int moveTo = (Key == vkUp) ? -1 : 1;

            Variant key[1] = {siglapatio};
            TLocateOptions t_locateOpt;

            cdsPatio->RecNo = cdsPatio->RecNo - moveTo;
            cdsPatio->Edit();
            cdsPatio->Post();

            cdsPatio->Locate("indexRota;id", VarArrayOf(key, 1), t_locateOpt);
          }
        }

      }
      catch(...)
      {
          throw -1;
      }
    }
    __finally
    {
       cxgPatioDBTableView->OnFocusedRecordChanged = cxgPatioDBTableViewFocusedRecordChanged;
    }*/
  }
  //#endif
#pragma end_region


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFOrdemTrem.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFOrdemTrem.h"

#include "UFormsManager.h"
#include "UDModuleMP.h"
#pragma region Server
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/SegmentoTremRealizado.h"
#pragma end_region
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FGridBase"
#pragma link "cxLabel"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"
TformOrdemTrem *formOrdemTrem;

// ---------------------------------------------------------------------------
__fastcall TformOrdemTrem::TformOrdemTrem(TComponent* Owner) : TFormGridBase(Owner)
{
  cxgGridDBTableView1->OnFocusedRecordChanged = NULL;

  FLocaisGatilho_     = new TStringList();
  FLocaisGatilhoAux_  = new TStringList();
	FListaTrocasOrdem_  = new TStringList();
  FListaTremsRefresh_ = TTPTremListPtr(new TTPTremList());
  FTrensAlterados_    = new TStringList();

  FisFixarOrdemOn = false;
  CarregarGatilhos();
//  lblParametroSalvarOrdem->Visible = FisFixarOrdemOn;

  cboLocal->ItemIndex = 0;
  CarregarTrens();
  cxgGridDBTableView1->OnFocusedRecordChanged = cxgGridDBTableView1FocusedRecordChanged;
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::CarregarGatilhos()
{
  cboLocal->Clear();
  TStringList* t_listaLocais, *t_listaLocaisAux;
  cboLocal->Items->Add("Ordem");
  String locaisLabel = "";

  for (int i = 0; i < FLocaisGatilho_->Count; i++)
  {
    t_listaLocais = (TStringList*) FLocaisGatilho_->Objects[i];
    t_listaLocais->Clear();

    t_listaLocais = (TStringList*) FLocaisGatilhoAux_->Objects[i];
    t_listaLocais->Clear();
  }
  FLocaisGatilho_->Clear();
  FLocaisGatilhoAux_->Clear();

  using namespace domain;

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* t_malha      = core->getMalha();

  for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
  {
    GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
    if (t_gatilhoMalha->isGatilhoOrdenacao())
    {
     // t_gatilhoMalha->
      //FListaGatilhosOrdemMalha_->AddObject()

      int tLimiteSalvar = t_gatilhoMalha->getLimiteOrdemSalva();
      if(tLimiteSalvar > 0)
      {
        locaisLabel += (locaisLabel.Length() > 0 ? "|" : "(") + t_gatilhoMalha->getSegmentoParada()->segmento + "->" + tLimiteSalvar + " trens";
        FisFixarOrdemOn = core->getIsCarregarOrdemGatilho();
      }

      for (int j = 0; j < t_gatilhoMalha->gatilhosItinerario->Count; j++)
      {
        GatilhoItinerario *t_gatilhoItinerario = (GatilhoItinerario*)t_gatilhoMalha->gatilhosItinerario->Objects[j];

        if (t_gatilhoItinerario->segmentoTremParada->segmentoOcupado->codZonaControleResponsavel ==
          TTPFormsManager::getInstance()->Mesa)
        {
          t_gatilhoItinerario->segmentoTremParada->trem;
          t_gatilhoItinerario->segmentoTremParada->indexRotaTrem;
          t_gatilhoItinerario->segmentoTremParada->getOrdemSaida();

          String t_sigla = t_gatilhoMalha->getNomeLocal() ;
//          t_gatilhoItinerario->segmentoTremParada->segmentoOcupado->patioPertencente ? t_gatilhoItinerario->segmentoTremParada->segmentoOcupado->patioPertencente->sigla
//            : t_gatilhoItinerario->segmentoTremParada->segmentoOcupado->segmento;

          int t_index    = FLocaisGatilho_->IndexOf(t_sigla);
          int t_indexAux = FLocaisGatilhoAux_->IndexOf(t_sigla);

          if (t_index < 0)
          {
            t_listaLocais = new TStringList();
            t_listaLocais->CaseSensitive = true;
            FLocaisGatilho_->AddObject(t_sigla, (TObject *)t_listaLocais);
            t_listaLocaisAux = new TStringList();
            FLocaisGatilhoAux_->AddObject(t_sigla, (TObject *)t_listaLocaisAux);
            t_listaLocaisAux->CaseSensitive = true;
            cboLocal->Items->Add(t_sigla);
          }
          else
          {
            t_listaLocais    = (TStringList*) FLocaisGatilho_->Objects[t_index];
            t_listaLocaisAux = (TStringList*) FLocaisGatilhoAux_->Objects[t_indexAux];
          }

          t_listaLocais->AddObject(t_gatilhoItinerario->segmentoTremParada->trem->PID +
            IntToStr(t_gatilhoItinerario->segmentoTremParada->indexRotaTrem), (TObject *)t_gatilhoItinerario);

          if (t_listaLocaisAux->IndexOf(t_gatilhoItinerario->segmentoTremParada->trem->PID +
            IntToStr(t_gatilhoItinerario->segmentoTremParada->indexRotaTrem)) == -1)
          {
            t_listaLocaisAux->AddObject(t_gatilhoItinerario->segmentoTremParada->trem->PID +
              IntToStr(t_gatilhoItinerario->segmentoTremParada->indexRotaTrem), (TObject *)t_gatilhoItinerario);
          }
        }
      }
    }
  }

//  lblParametroSalvarOrdem->Caption = "Quantidade de trens possveis fixar ordem:" + locaisLabel + ")";
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::CarregarTrens()
{
  try
  {
   using namespace domain;

    FindexLocalAnterior_ = cboLocal->ItemIndex;
    Screen->Cursor       = crHourGlass;
    using namespace domain;

    int t_index = FLocaisGatilho_->IndexOf(cboLocal->Text);
    TStringList *t_listaLocais, *t_listaLocaisAux;

    int indexI, indexF;

    if (t_index > -1)
    {
      indexI = t_index;
      indexF = t_index + 1;
    }
    else
    {
      indexI = 0;
      indexF = FLocaisGatilho_->Count;
    }

    cdsGrid->Close();
    cdsGrid->CreateDataSet();
    cdsGrid->Open();
    cdsGrid->DisableControls();

    for (int j = indexI; j < indexF; j++)
    {
      t_listaLocais    = (TStringList*) FLocaisGatilho_->Objects[j];
      t_listaLocaisAux = (TStringList*) FLocaisGatilhoAux_->Objects[j];

      t_listaLocais->CustomSort(SortPorOrdemSaida);
      t_listaLocaisAux->CustomSort(SortPorOrdemChegada);
//      if (j < indexF || indexI == j)
      {
        cdsGrid->Append();
        cdsGridordemGeral->Value        = cdsGrid->RecordCount;
        if (t_listaLocais->Count <=0)
        {
          cdsGridordemGeralInicial->Value = cdsGrid->RecordCount;
          cdsGrid->Post();
        }
      }
       int cntOrdemFixa=0;
      for (int i = 0; i < t_listaLocais->Count; i++)
      {
        GatilhoItinerario *  t_gatilhoItinerario = (GatilhoItinerario*) t_listaLocais->Objects[i];
        TremMalha *t_trem                      = t_gatilhoItinerario->segmentoTremParada->trem;
        if (i == 0)
        {
          if (t_gatilhoItinerario->gatilhoPai && t_gatilhoItinerario->gatilhoPai->getLimiteOrdemSalva() > 0 )
          {
            cdsGridprefixo->Value = FLocaisGatilho_->operator[](j) +" Quantidade de trens possiveis de fixar ordem: "+String( t_gatilhoItinerario->gatilhoPai->getLimiteOrdemSalva());
          }
          cdsGridordemGeralInicial->Value = cdsGrid->RecordCount;
          cdsGrid->Post();
        }

        cdsGrid->Append();
        cdsGridlocal->Value     = FLocaisGatilho_->operator[](j);
        cdsGridprefixo->Value   = t_trem->prefixoTrem;
        cdsGridid->Value        = t_trem->PID;
        cdsGridindexRota->Value = t_gatilhoItinerario->segmentoTremParada->indexRotaTrem;
        cdsGridtabela->Value    = t_trem->codigoTabela;

        cdsGridorigem->Value = (t_trem->origem->patioPertencente ? t_trem->origem->patioPertencente->sigla :
          t_trem->origem->segmento);

        cdsGriddestino->Value = (t_trem->destino->patioPertencente ? t_trem->destino->patioPertencente->sigla :
          t_trem->destino->segmento);

        cdsGridtabela->Value = t_trem->codigoTabela;

        String tPatioAtual = "";
        TDateTime tDataRef = NULL;
        if (t_gatilhoItinerario->tipoGatilho == GatilhoItinerario::Gatilho_Ordenacao_Chegada)
        {

          if (t_trem->possuiRealizado())
          {
            tPatioAtual = ((SegmentoTremRealizado*)t_trem->rotaRealizada->Objects[t_trem->rotaRealizada->Count - 1])->getSB()
              ->segmento->segmento;
          }
          else
          {
            tPatioAtual = (t_trem->origem->patioPertencente ? t_trem->origem->patioPertencente->sigla : String(""));
          }

          timeTP::TimeTP chegada =  t_gatilhoItinerario->segmentoTremDisparo->getPeriodoOcupacao()->begin();
            tDataRef = chegada.asDateTime();

        }
        else
        {
          if (t_trem->possuiRealizado())
          {
            tPatioAtual = ((SegmentoTremRealizado*)t_trem->rotaRealizada->Objects[t_trem->rotaRealizada->Count - 1])->getSB()
              ->segmento->segmento;
            tDataRef = t_trem->getdataUltimoRealizado()->asDateTime();
          }
          else
          {
            tPatioAtual = (t_trem->origem->patioPertencente ? t_trem->origem->patioPertencente->sigla : String(""));
            tDataRef    = t_trem->getPrimeiroMovimento()->getDataHoraFimCursoTrem();
          }
        }

        cdsGridpatioAtual->Value = tPatioAtual;
        cdsGridprevisaoSaida->Value     = tDataRef;
        cdsGridordemGeral->Value        = cdsGrid->RecordCount;
        cdsGridordemGeralInicial->Value = cdsGrid->RecordCount;
        cdsGridordemTela->Value         = i + 1;
        cdsGridativa->Value =t_gatilhoItinerario->isGatilhoAtivo;
        cdsGridTremFrente->Value  = t_gatilhoItinerario->segmentoTremParada->possuiOrdemTremAFrente() ? t_gatilhoItinerario->segmentoTremParada->getSegmetoTremOrdemAFrente()->trem->prefixoTrem : t_gatilhoItinerario->segmentoTremParada->getIsPrimeiroTremOrdem()? String("*"): String("");
        // t_listaLocais->CustomSort(SortPorOrdemChegada);

        cdsGridordemOriginal->Value =
          t_listaLocaisAux->IndexOf(t_trem->PID + IntToStr(t_gatilhoItinerario->segmentoTremParada->indexRotaTrem)) + 1;
        int idx = t_gatilhoItinerario->gatilhoPai->listaOrdemPersonalizada->IndexOfName(t_trem->PID);
        if (cdsGridativa->Value)
          cntOrdemFixa++;
        cdsGridordemFixa->Value = (FisFixarOrdemOn && idx > -1 && cntOrdemFixa <= t_gatilhoItinerario->gatilhoPai->getLimiteOrdemSalva());
        // t_listaLocais->CustomSort(SortPorOrdemSaida);

        cdsGrid->Post();
      }


    }
  }
  __finally
  {
    cdsGrid->IndexName = "cdsFilasIndex1";
    EnableControls();
    cdsGrid->First();
    FLocalCellAnt_ = cdsGridlocal->Value;
    Screen->Cursor = crDefault;
  }
}

// ---------------------------------------------------------------------------
int __fastcall SortPorOrdemSaida(TStringList* List, int Index1, int Index2)
{
  using namespace domain;

   TimeTP ordemsaida1 ;
  TimeTP ordemsaida2 ;
   if (((GatilhoItinerario*)List->Objects[Index1])->tipoGatilho == GatilhoItinerario::Gatilho_Ordenacao_Chegada)
  {
      GatilhoItinerario* gatCadenc= ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->getGatilho(GatilhoItinerario::Gatilho_Cadencia,false);
    GatilhoItinerario* gatCadenc2= ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->getGatilho(GatilhoItinerario::Gatilho_Cadencia,false);
    bool isUtilizarDataReal =  !gatCadenc || !gatCadenc2;
    if (!isUtilizarDataReal)
    {
    ordemsaida1 =((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->getOrdemSaida(isUtilizarDataReal);
    ordemsaida2 =((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->getOrdemSaida(isUtilizarDataReal);
    }
    else
    {
    ordemsaida1 =((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->getPeriodoOcupacao()->begin();
    ordemsaida2 =((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->getPeriodoOcupacao()->begin();
    }
  }
  else
  {
   ordemsaida1 = ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->getOrdemSaida();
  ordemsaida2 = ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->getOrdemSaida();
   }
  if (ordemsaida1 < ordemsaida2)
    return -1;
  if (ordemsaida2 < ordemsaida1)
    return 1;

  return 0;
}

// ---------------------------------------------------------------------------
int __fastcall SortPorOrdemChegada(TStringList* List, int Index1, int Index2)
{
  using namespace domain;
  TimeTP ordemchegada1 ;
  TimeTP ordemchegada2 ;
  if (((GatilhoItinerario*)List->Objects[Index1])->tipoGatilho == GatilhoItinerario::Gatilho_Ordenacao_Chegada)
  {
    GatilhoItinerario* gatCadenc= ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->getGatilho(GatilhoItinerario::Gatilho_Cadencia,false);
    GatilhoItinerario* gatCadenc2= ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->getGatilho(GatilhoItinerario::Gatilho_Cadencia,false);

    double DistanciaKm = 0;
    int tempo = 0;
    if(gatCadenc && (gatCadenc->segmentoTremParada->possuiOrdemTremAFrente()
        || gatCadenc->segmentoTremParada->getIsPrimeiroTremOrdem())
    )
    {
//      ordemchegada1=  gatCadenc->segmentoTremParada->getDataChegadaNoUltimoPatio(true);
        SegmentoTrem* segGatParadaInicioPatio =   gatCadenc->segmentoTremParada;
        int tempoAtividade = 0;
        TimeTP dataSaidaAtividadeHoraria;
       do
       {
        tempoAtividade += segGatParadaInicioPatio->getTempoParadaAtividade();
        if (!segGatParadaInicioPatio->getDataSaidaAtividadeHoraria()->is_not_a_date_time() &&
        *segGatParadaInicioPatio->getDataSaidaAtividadeHoraria() > dataSaidaAtividadeHoraria)
          dataSaidaAtividadeHoraria = *segGatParadaInicioPatio->getDataSaidaAtividadeHoraria() ;


        if (  !segGatParadaInicioPatio->segmentoTremAnterior ||
        (!segGatParadaInicioPatio->segmentoTremAnterior->segmentoOcupado->patioPertencente ||
        segGatParadaInicioPatio->segmentoTremAnterior->segmentoOcupado->patioPertencente !=
                 segGatParadaInicioPatio->segmentoOcupado->patioPertencente) )
           break;
        segGatParadaInicioPatio = segGatParadaInicioPatio->segmentoTremAnterior;
       }        while (true )  ;


       ordemchegada1=  segGatParadaInicioPatio->getPeriodoOcupacao()->begin();
       ordemchegada1=ordemchegada1+ addSeconds(tempoAtividade);
       if (!dataSaidaAtividadeHoraria.is_not_a_date_time() && ordemchegada1 < dataSaidaAtividadeHoraria)
         ordemchegada1=dataSaidaAtividadeHoraria;
       if (!gatCadenc->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem().is_not_a_date_time() &&ordemchegada1<gatCadenc->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem())
         ordemchegada1=gatCadenc->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem();

//      DistanciaKm = std::fabs(((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->segmentoOcupado->kmInicial -
//      gatCadenc->segmentoTremParada->segmentoOcupado->kmInicial);
      tempo = (((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->getPeriodoOcupacao()->begin() - gatCadenc->segmentoTremParada->getFimParadaTrem()).total_seconds();
//      tempo = (DistanciaKm /((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->velocidadeCalculada  )* SECONDS;
      //
    }
    else
    {
//      int idxLista = -1;
//      SegmentoTrem *  segChegada = ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->trem->getPrimeiroMovimento();
//      if (gatCadenc2)
//      {
//        idxLista = ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->trem->rotaTrem->IndexOf(gatCadenc2->segmentoTremParada->segmentoOcupado->segmento);
//      }
//      if (idxLista > -1 )
//      {
//       segChegada =  (SegmentoTrem*)((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->trem->rotaTrem->Objects[idxLista];
//      }
//      else
//      {
//        SegmentoTrem*  SegmentoEncontrado =  segChegada;
//
//        if(gatCadenc2)
//        {
//          SegmentoTrem* sgocp = gatCadenc2->segmentoTremParada->segmentoOcupado->getTremOcupando(segChegada->trem);
//          if (sgocp)
//           SegmentoEncontrado = sgocp;
//        }
//
//
//        SegmentoTrem* segmentoProcurado = SegmentoEncontrado->segmentoOcupado->getTremOcupando(((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->trem);
//        while (!segmentoProcurado && SegmentoEncontrado && SegmentoEncontrado->indexRotaTrem <  ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->indexRotaTrem)
//        {
//          segmentoProcurado = SegmentoEncontrado->segmentoOcupado->getTremOcupando(((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->trem);
//          if (!segmentoProcurado)
//            SegmentoEncontrado = SegmentoEncontrado->segmentoTremPosterior;
//        }
//        if (SegmentoEncontrado)
//        {
//          segChegada = SegmentoEncontrado;
//        }
//      }
//
//      ordemchegada1 = segChegada->getDataChegadaNoUltimoPatio(true);
////      DistanciaKm = std::fabs(segChegada->segmentoOcupado->kmInicial -
////      ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->segmentoOcupado->kmInicial);
//      tempo = (((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->getPeriodoOcupacao()->begin() - segChegada->getFimParadaTrem()).total_seconds();
          ordemchegada1=  ((GatilhoItinerario*)List->Objects[Index1])->segmentoTremDisparo->getPeriodoOcupacao()->begin();
    }
//    tempo = (DistanciaKm /(double)20) * SECONDS;  //calcula um transit time padro para manter a ordem a medida que o trem anda.
    ordemchegada1 = ordemchegada1 + addSeconds(tempo);


    if(gatCadenc2&& (gatCadenc2->segmentoTremParada->possuiOrdemTremAFrente()
    || gatCadenc2->segmentoTremParada->getIsPrimeiroTremOrdem()))
    {
//      ordemchegada2=  gatCadenc2->segmentoTremParada->getDataChegadaNoUltimoPatio(true);

      SegmentoTrem* segGatParadaInicioPatio =   gatCadenc2->segmentoTremParada;
      int tempoAtividade = 0;
      TimeTP dataSaidaAtividadeHoraria;
       do
       {
        tempoAtividade += segGatParadaInicioPatio->getTempoParadaAtividade();
        if (!segGatParadaInicioPatio->getDataSaidaAtividadeHoraria()->is_not_a_date_time() &&
        *segGatParadaInicioPatio->getDataSaidaAtividadeHoraria() > dataSaidaAtividadeHoraria)
          dataSaidaAtividadeHoraria = *segGatParadaInicioPatio->getDataSaidaAtividadeHoraria() ;


        if (  !segGatParadaInicioPatio->segmentoTremAnterior ||
        (!segGatParadaInicioPatio->segmentoTremAnterior->segmentoOcupado->patioPertencente ||
        segGatParadaInicioPatio->segmentoTremAnterior->segmentoOcupado->patioPertencente !=
                 segGatParadaInicioPatio->segmentoOcupado->patioPertencente) )
           break;
        segGatParadaInicioPatio = segGatParadaInicioPatio->segmentoTremAnterior;
       }        while (true )  ;




      ordemchegada2=  segGatParadaInicioPatio->getPeriodoOcupacao()->begin();
       ordemchegada2=ordemchegada2+ addSeconds(tempoAtividade);
       if (!dataSaidaAtividadeHoraria.is_not_a_date_time() && ordemchegada2 < dataSaidaAtividadeHoraria)
         ordemchegada2=dataSaidaAtividadeHoraria;
       if (!gatCadenc2->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem().is_not_a_date_time() &&ordemchegada2<gatCadenc2->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem())
         ordemchegada2=gatCadenc2->segmentoTremParada->trem->getdataMinimaPrimeiroMovimentoTrem();



//      DistanciaKm = std::fabs(((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->segmentoOcupado->kmInicial -
//      gatCadenc2->segmentoTremParada->segmentoOcupado->kmInicial);
      tempo = (((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->getPeriodoOcupacao()->begin() - gatCadenc2->segmentoTremParada->getFimParadaTrem()).total_seconds();
//         tempo = (DistanciaKm /((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->velocidadeCalculada  )* SECONDS;

    }

    else
    {
//      int idxLista = -1;
//      SegmentoTrem *  segChegada = ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->trem->getPrimeiroMovimento();
//
//      if (gatCadenc)
//      {
//        idxLista = ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->trem->rotaTrem->IndexOf(gatCadenc->segmentoTremParada->segmentoOcupado->segmento);
//      }
//      if (idxLista > -1 )
//      {
//       segChegada =  (SegmentoTrem*)((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->trem->rotaTrem->Objects[idxLista];
//      }
//      else
//      {
//
//        SegmentoTrem*  SegmentoEncontrado =  segChegada;
//
//        if(gatCadenc)
//        {
//          SegmentoTrem* sgocp = gatCadenc->segmentoTremParada->segmentoOcupado->getTremOcupando(segChegada->trem);
//          if (sgocp)
//           SegmentoEncontrado = sgocp;
//        }
//
//
//        SegmentoTrem* segmentoProcurado = SegmentoEncontrado->segmentoOcupado->getTremOcupando(((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->trem);
//        while (!segmentoProcurado && SegmentoEncontrado && SegmentoEncontrado->indexRotaTrem <  ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->indexRotaTrem)
//        {
//          segmentoProcurado = SegmentoEncontrado->segmentoOcupado->getTremOcupando(((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->trem);
//          if (!segmentoProcurado)
//            SegmentoEncontrado = SegmentoEncontrado->segmentoTremPosterior;
//        }
//        if (SegmentoEncontrado)
//        {
//          segChegada = SegmentoEncontrado;
//        }


//      }



//      ordemchegada2 = segChegada->getDataChegadaNoUltimoPatio(true);
////      DistanciaKm = std::fabs(segChegada->segmentoOcupado->kmInicial -
////      ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->segmentoOcupado->kmInicial);
//      tempo = (((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->getPeriodoOcupacao()->begin() - segChegada->getFimParadaTrem()).total_seconds();

            ordemchegada2=  ((GatilhoItinerario*)List->Objects[Index2])->segmentoTremDisparo->getPeriodoOcupacao()->begin();
        tempo = 0;
    }
//    tempo = (DistanciaKm /(double)20) * SECONDS;  //calcula um transit time padro para manter a ordem a medida que o trem anda.
    ordemchegada2 = ordemchegada2 + addSeconds(tempo);

  }
  else
  {
    ordemchegada1 =((GatilhoItinerario*)List->Objects[Index1])->segmentoTremParada->getDataChegadaNoUltimoPatio(true);
    ordemchegada2 =((GatilhoItinerario*)List->Objects[Index2])->segmentoTremParada->getDataChegadaNoUltimoPatio(true);
  }
  if (ordemchegada1 < ordemchegada2)
    return -1;
  if (ordemchegada2 < ordemchegada1)
    return 1;

  return 0;
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::cboLocalChange(TObject *Sender)
{
  if (cboLocal->ItemIndex == -1)
    cboLocal->ItemIndex = 0;

  if (cboLocal->ItemIndex == FindexLocalAnterior_)
    return;

  int tIndexAux       = cboLocal->ItemIndex;
  int tAuxRecNo       = cdsGrid->RecNo;
  cboLocal->ItemIndex = FindexLocalAnterior_;

  if (ValidarTrocasOrdemPendente())
  {
    cdsGrid->RecNo = tAuxRecNo;
    int tResposta  = ConfirmeCancelar("Deseja salvar as trocas feitas nas ordens dos trens?");

    if (tResposta == IDCANCEL)
      return;
    if (tResposta == IDYES)
      SalvarOrdem();
  }
  cboLocal->ItemIndex = tIndexAux;
  cxgGrid->SetFocus();
  CarregarTrens();
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::cxgGridDBTableView1KeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  cxgGridDBTableView1->OnFocusedRecordChanged = NULL;
  if (Shift.Contains(ssCtrl)) // && FEditandoFilasInconsistentes_)
  {
    int indexRow     = cxgGridDBTableView1->Controller->SelectedRecords[0]->Index;
    bool permiteAcao = !((indexRow == 0 && Key == vkUp) || (indexRow == cdsGrid->RecordCount - 1 && Key == vkDown) ||
      cdsGridlocal->Value == "" ) ;

    if (permiteAcao && (Key == vkUp || Key == vkDown))
    {
      int moveTo = (Key == vkUp) ? -1 : 1;

      FUltLocalTroca_    = cdsGridlocal->Value;
      int indexRotaTrem1 = cdsGridindexRota->Value;
      String PIDTrem1    = cdsGridid->Value;
      String PrefixoTrem1= cdsGridprefixo->Value;
      bool isAtivaCadenc =  cdsGridativa->Value;
      cdsGrid->RecNo = cdsGrid->RecNo + moveTo;

      int indexRotaTrem2 = cdsGridindexRota->Value;
      String PIDTrem2    = cdsGridid->Value;
      String PrefixoTrem2= cdsGridprefixo->Value;

      Variant key[2] =
      {indexRotaTrem2, PIDTrem2};
      TLocateOptions t_locateOpt;
      t_locateOpt.Clear();

      using namespace domain;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      bool permite = false;

      permite = PIDTrem2 != "" && isAtivaCadenc;

      if (permite)
      {
        if (Key == vkUp)
          permite = core->verificaAlteracaoOrdem(PIDTrem2, indexRotaTrem2, PIDTrem1, indexRotaTrem1);
        else
		  permite = core->verificaAlteracaoOrdem(PIDTrem1, indexRotaTrem1, PIDTrem2, indexRotaTrem2);

	   TUteis::gravarLog("--> Troca ordem " + PIDTrem1 + "com "+ PIDTrem2);
	  }
	  if (!permite)
      {
        int indexAlteracao = TTPFormsManager::getInstance()->TrensOrdemAlterada->IndexOfName(PIDTrem1);
        if(indexAlteracao>-1)
        {
          if(FUltLocalTroca_ != TTPFormsManager::getInstance()->TrensOrdemAlterada->ValueFromIndex[indexAlteracao])
          {
           Informacao("A ordem do trem "+PrefixoTrem1+" s pode ser alterada aps Programar (CTRL+P) para consolidar a alterao de ordem anterior em "+TTPFormsManager::getInstance()->TrensOrdemAlterada->ValueFromIndex[indexAlteracao]);
          }
        }
        else
        {
          indexAlteracao = TTPFormsManager::getInstance()->TrensOrdemAlterada->IndexOfName(PIDTrem2);
          if(indexAlteracao>-1)
          {
            if(FUltLocalTroca_ != TTPFormsManager::getInstance()->TrensOrdemAlterada->ValueFromIndex[indexAlteracao])
            {
               Informacao("A ordem do trem "+PrefixoTrem2+" s pode ser alterada aps Programar (CTRL+P) para consolidar a alterao de ordem anterior em "+TTPFormsManager::getInstance()->TrensOrdemAlterada->ValueFromIndex[indexAlteracao]);
            }
          }
        }

        cdsGrid->MoveBy(-moveTo*2);
        cxgGridDBTableView1->OnFocusedRecordChanged = cxgGridDBTableView1FocusedRecordChanged;
        return;
      }

      cdsGrid->RecNo = cdsGrid->RecNo - moveTo;
      cdsGrid->Edit();
      cdsGridordemGeral->Value = cdsGridordemGeral->Value + moveTo;
      cdsGridordemTela->Value  = cdsGridordemTela->Value + moveTo;
      cdsGrid->Post();

      cdsGrid->Locate("indexRota;id", VarArrayOf(key, 1), t_locateOpt);

      cdsGrid->Edit();
      cdsGridordemGeral->Value = cdsGridordemGeral->Value - moveTo;
      cdsGridordemTela->Value  = cdsGridordemTela->Value - moveTo;
      cdsGrid->Post();

    }
  }
  cxgGridDBTableView1->OnFocusedRecordChanged = cxgGridDBTableView1FocusedRecordChanged;
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::SalvarOrdem()
{
  try
  {
    cdsGrid->DisableControls();
    Screen->Cursor = crHourGlass;
    cdsGrid->First();

    while (!cdsGrid->Eof)
    {
      if (cdsGridlocal->Value != FUltLocalTroca_)
        cdsGrid->Next();
      else
        break;
    }

    if (cdsGrid->Eof)
    {
      EnableControls();
      return;
    }

    using namespace domain;

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    int indexRotaTrem1 = cdsGridindexRota->Value;
    int indexOrdemTela1 = cdsGridordemTela->Value;
    int indexOrdemOrig1 = cdsGridordemOriginal->Value;
    int indexOrdemOrig1Tela = cdsGridordemOriginal->Value;
    GatilhoItinerario *t_gatilhoAnterior;

    String PIDTrem1    = cdsGridid->Value;
    String chaveBusca = PIDTrem1 + IntToStr(indexRotaTrem1);

    int t_index = FLocaisGatilho_->IndexOf(FUltLocalTroca_);
    TStringList *t_listaLocais;

    if (t_index > -1)
    {
      t_listaLocais = (TStringList*) FLocaisGatilho_->Objects[t_index];
    }
    else
      return;
    t_gatilhoAnterior = (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];

    core->limparOrdenacaoSaidaSegmento(t_gatilhoAnterior->segmentoTremDisparo->segmentoOcupado->segmento, false);

    cdsGrid->Next();

    TStringList* trensAlterados = new TStringList();
    int limiteAmaracaoTrens = 0;
    int alterouDentroLimite = 0;

    while (!cdsGrid->Eof)
    {
      if (cdsGridlocal->Value != FUltLocalTroca_ || cdsGridlocal->Value == "")
        break;
      if (cdsGridativa->Value != true )
      {
        cdsGrid->Next();
          continue;
      }
      int indexRotaTrem2 = cdsGridindexRota->Value;
      int indexOrdemTela2 = cdsGridordemTela->Value;
      int indexOrdemOrig2 = indexOrdemOrig1+1; //cdsGridordemOriginal->Value;
      int indexOrdemOrig2Tela =cdsGridordemOriginal->Value;

      String PIDTrem2    = cdsGridid->Value;

      chaveBusca = cdsGridid->Value + IntToStr(cdsGridindexRota->Value);

      GatilhoItinerario *t_gatilhoAtual = (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];

      if (indexOrdemTela2 != indexOrdemOrig2Tela
        || (t_gatilhoAnterior->segmentoTremParada->getOrdemSaida() >= t_gatilhoAtual->segmentoTremParada->getOrdemSaida()))
      {
//        if(indexOrdemOrig2 <= t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva()
//          || indexOrdemOrig1 <= t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
//        {
//          alterouDentroLimite = (indexOrdemOrig2Tela > indexOrdemOrig1Tela ? indexOrdemOrig2Tela : indexOrdemOrig1Tela);
//          if (alterouDentroLimite < indexOrdemOrig2 && indexOrdemOrig2 <= t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
//          {
//            alterouDentroLimite = indexOrdemOrig2;
//          }
//          if (alterouDentroLimite < indexOrdemOrig1 && indexOrdemOrig1 <= t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
//          {
//            alterouDentroLimite = indexOrdemOrig1;
//          }
//          if (limiteAmaracaoTrens < alterouDentroLimite)
//          {
//            limiteAmaracaoTrens = alterouDentroLimite;
//          }
//
//        }
//
//        if(indexOrdemOrig2Tela > limiteAmaracaoTrens)
//          limiteAmaracaoTrens = indexOrdemOrig2Tela;
//        if(indexOrdemOrig1Tela > limiteAmaracaoTrens)
//          limiteAmaracaoTrens = indexOrdemOrig1Tela;
//        if (limiteAmaracaoTrens >   t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
//          limiteAmaracaoTrens =    t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva();

        limiteAmaracaoTrens = (indexOrdemTela2 > indexOrdemTela1 ? indexOrdemTela2 : indexOrdemTela1);
        if (limiteAmaracaoTrens >   t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
          alterouDentroLimite =    t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva();
        else
          alterouDentroLimite = limiteAmaracaoTrens;

        trensAlterados->Add(PIDTrem2 + "|" + PIDTrem1);

        TTPFormsManager::getInstance()->TrensOrdemAlterada->AddPair(PIDTrem1,FUltLocalTroca_);
        TTPFormsManager::getInstance()->TrensOrdemAlterada->AddPair(PIDTrem2,FUltLocalTroca_);
      }

      PIDTrem1 = PIDTrem2;
      indexRotaTrem1    = indexRotaTrem2;
      indexOrdemTela1   = indexOrdemTela2;
      indexOrdemOrig1   = indexOrdemOrig2;
      indexOrdemOrig1Tela = indexOrdemOrig2Tela;
      t_gatilhoAnterior = t_gatilhoAtual;

      cdsGrid->Next();
    }

    if(trensAlterados->Count > 0)
    {
      if(limiteAmaracaoTrens > t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva())
        limiteAmaracaoTrens = t_gatilhoAnterior->gatilhoPai->getLimiteOrdemSalva();

      cdsGrid->First();
      indexRotaTrem1 = 0;//cdsGridindexRota->Value;
      indexOrdemTela1 = 0;// cdsGridordemTela->Value;
      String PIDTrem1    = "";//cdsGridid->Value;
      String chaveBusca = "";//PIDTrem1 + IntToStr(indexRotaTrem1);
//      cdsGrid->Next();
//      if (cdsGridlocal->Value != "" && PIDTrem1 != "")
//        GatilhoItinerario * gatilhoAnterior= (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];
      while (!cdsGrid->Eof)
      {
        if (cdsGridlocal->Value != FUltLocalTroca_ || cdsGridlocal->Value == "")
        {
          PIDTrem1 = "";
          cdsGrid->Next();
          indexOrdemTela1 = 0;
          continue;
        }
        if (cdsGridativa->Value != true )
        {
        cdsGrid->Next();
          continue;
        }
        if (PIDTrem1 == "")
        {
          indexRotaTrem1 = cdsGridindexRota->Value;
//          indexOrdemTela1 = cdsGridordemTela->Value;
          indexOrdemTela1 ++;
          PIDTrem1    = cdsGridid->Value;
          chaveBusca = PIDTrem1 + IntToStr(indexRotaTrem1);
          t_gatilhoAnterior = (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];
          cdsGrid->Next();
          continue;
        }

        int indexRotaTrem2 = cdsGridindexRota->Value;
        int indexOrdemTela2 = indexOrdemTela1+1;//cdsGridordemTela->Value;

        String PIDTrem2    = cdsGridid->Value;

        chaveBusca = cdsGridid->Value + IntToStr(cdsGridindexRota->Value);

        GatilhoItinerario *t_gatilhoAtual  = (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];
//        int indexOfKey =  trensAlterados->IndexOf(PIDTrem2 + "|" + PIDTrem1);
        if ((t_gatilhoAnterior->segmentoTremParada->getOrdemSaida() >= t_gatilhoAtual->segmentoTremParada->getOrdemSaida()) ||

//        indexOfKey > -1 ||


        (indexOrdemTela2 <= limiteAmaracaoTrens && indexOrdemTela2 <= alterouDentroLimite))
        {
          core->AlterarOrdemSaidaSegmento(PIDTrem2, indexRotaTrem2, indexOrdemTela2, PIDTrem1, indexRotaTrem1,indexOrdemTela1,indexOrdemTela1 == 1 );
          FTrensAlterados_->Add(cdsGridlocal->Value+PIDTrem1);
          FTrensAlterados_->Add(cdsGridlocal->Value+PIDTrem2);

          if (FListaTremsRefresh_->IndexOf(PIDTrem2) == -1)
          {
            FListaTremsRefresh_->add(PIDTrem1, TTPFormsManager::getInstance()->Trens->operator[]
              (TTPFormsManager::getInstance()->Trens->IndexOf(PIDTrem1)));
            FListaTremsRefresh_->add(PIDTrem2, TTPFormsManager::getInstance()->Trens->operator[]
              (TTPFormsManager::getInstance()->Trens->IndexOf(PIDTrem2)));
          }
        }
        PIDTrem1 = PIDTrem2;
        indexRotaTrem1    = indexRotaTrem2;
        indexOrdemTela1   = indexOrdemTela2;
        t_gatilhoAnterior = t_gatilhoAtual;

        cdsGrid->Next();
      }
    }
  }
  __finally
  {
    EnableControls();
    Screen->Cursor = crDefault;
  }
  TUteis::gravarLog("--> Salva ordem de sada trens");
}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::acDesfazerExecute(TObject *Sender)
{
  try
  {
    cxgGridDBTableView1->OnFocusedRecordChanged = NULL;
    using namespace domain;

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    int t_index = FLocaisGatilho_->IndexOf(cboLocal->Text);
    TStringList *t_listaLocais;

    int indexI, indexF;

    if (t_index > -1)
    {
      indexI = t_index;
      indexF = t_index + 1;
    }
    else
    {
      indexI = 0;
      indexF = FLocaisGatilho_->Count;
    }

    for (int j = indexI; j < indexF; j++)
    {
      int t_index = FLocaisGatilho_->IndexOf(FLocaisGatilho_->operator[](j));
      TStringList *t_listaLocais;

      if (t_index > -1)
      {
        t_listaLocais = (TStringList*) FLocaisGatilho_->Objects[t_index];
      }
      else continue;
      if (t_listaLocais->Count < 1 )
        continue;

      GatilhoItinerario *t_gatilho = (GatilhoItinerario*) t_listaLocais->Objects[0];

      core->desfazerAlterecaoOrdemSaida(t_gatilho->segmentoTremDisparo->segmentoOcupado->segmento);
      core->limparOrdenacaoSaidaSegmento(t_gatilho->segmentoTremDisparo->segmentoOcupado->segmento, true);
    }
    AddAllListaTremsRefresh();
    CarregarGatilhos();
    CarregarTrens();
     TTPFormsManager::getInstance()->TrensOrdemAlterada->Clear();
    cxgGridDBTableView1->OnFocusedRecordChanged = cxgGridDBTableView1FocusedRecordChanged;
  }
  __finally
  {
    Screen->Cursor = crDefault;
  }
}

// ---------------------------------------------------------------------------
bool __fastcall TformOrdemTrem::ValidarTrocasOrdemPendente()
{
  cdsGrid->DisableControls();
  cdsGrid->First();
  while (!cdsGrid->Eof)
  {
    if (cdsGridordemGeral->Value != cdsGridordemGeralInicial->Value
          && FTrensAlterados_->IndexOf(cdsGridlocal->Value+cdsGridid->Value) == -1)
    {
      EnableControls();
      return true;
    }
    cdsGrid->Next();
  }
  EnableControls();
  return false;

}

// ---------------------------------------------------------------------------
void __fastcall TformOrdemTrem::AddAllListaTremsRefresh()
{
  cdsGrid->DisableControls();
  cdsGrid->First();
  while (!cdsGrid->Eof)
  {
    String PIDTrem = cdsGridid->Value;
    if (PIDTrem != "")
    {
      if (FListaTremsRefresh_->IndexOf(PIDTrem) == -1 && cdsGridordemOriginal->Value != cdsGridordemTela->Value)
      {
        FListaTremsRefresh_->add(PIDTrem, TTPFormsManager::getInstance()->Trens->operator[]
          (TTPFormsManager::getInstance()->Trens->IndexOf(PIDTrem)));
      }
    }
    cdsGrid->Next();
  }
  EnableControls();

}

void __fastcall TformOrdemTrem::cxgGridDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
  TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem, TcxStyle *&AStyle)
{


  if (VarToStr(ARecord->Values[cxgGridDBTableView1prefixo->Index]).Length() == 0 ||
  VarToStr(ARecord->Values[cxgGridDBTableView1ativa->Index]).Length() == 0  )
  {


    AStyle = cxDisabled;
  }
  else if ( ! ARecord->Values[cxgGridDBTableView1ativa->Index])
  {
   AStyle = cxDisabled;
  }
  else
  {
    using namespace domain;
    String chaveBusca = VarToStr(ARecord->Values[cxgGridDBTableView1id->Index]) +
      (VarToStr(ARecord->Values[cxgGridDBTableView1indexRota->Index]));
    int t_index = FLocaisGatilho_->IndexOf(VarToStr(ARecord->Values[cxgGridDBTableView1local->Index]));

    TStringList *t_listaLocais;

    if (t_index > -1)
    {
      t_listaLocais = (TStringList*) FLocaisGatilho_->Objects[t_index];
    }
    else
      return;

    GatilhoItinerario *t_gatilho = (GatilhoItinerario*) t_listaLocais->Objects[t_listaLocais->IndexOf(chaveBusca)];
    int indexTela = ARecord->Values[cxgGridDBTableView1ordemTela->Index];
    int indexOriginal = ARecord->Values[cxgGridDBTableView1ordemOriginal->Index];
//    if (t_gatilho->tipoGatilho ==  domain::GatilhoItinerario::Gatilho_Ordenacao_Chegada)
//    {
//      if ( (ARecord->RecordIndex+1 < ARecord->ViewData->RecordCount && VarToStr(ARecord->ViewData->Records[ARecord->RecordIndex+1]->Values[cxgGridDBTableView1TremFrente->Index]) == VarToStr(ARecord->Values[cxgGridDBTableView1prefixo->Index]))
//          ||t_gatilho->segmentoTremParada->possuiOrdemTremAFrente())
//          {
//          AStyle = cxForaOrdemOriginal;
//          }
//
//    }
//    else
    {
    if (t_gatilho->segmentoTremParada->getIsPrimeiroTremOrdem()|| t_gatilho->segmentoTremParada->possuiOrdemTremAFrente() || indexTela != indexOriginal)
      AStyle = cxForaOrdemOriginal;
    }
  }
}

// ---------------------------------------------------------------------------

void __fastcall TformOrdemTrem::cxgGridDBTableView1FocusedRecordChanged(TcxCustomGridTableView *Sender,
  TcxCustomGridRecord *APrevFocusedRecord, TcxCustomGridRecord *AFocusedRecord, bool ANewItemRecordFocusingChanged)
{
  int index = cxgGridDBTableView1->Controller->TopRowIndex;
  if (cdsGridlocal->Value == FLocalCellAnt_ || cdsGridlocal->Value == "")
    return;

  cdsGrid->DisableControls();
  FLocalCellAnt_ = cdsGridlocal->Value;

  cxgGridDBTableView1->OnFocusedRecordChanged = NULL;

  FLocalCellAnt_ = cdsGridlocal->Value;
  int tAuxRecNo  = cdsGrid->RecNo;

  if (ValidarTrocasOrdemPendente())
  {
    int tResposta = ConfirmeCancelar("Deseja salvar as trocas feitas nas ordens dos trens?");

    if (tResposta == IDCANCEL)
    {
      cdsGrid->RecNo                               = FIndexAnterior_;
      FLocalCellAnt_                               = cdsGridlocal->Value;
      cxgGridDBTableView1->Controller->TopRowIndex = index;
      cxgGridDBTableView1->OnFocusedRecordChanged  = cxgGridDBTableView1FocusedRecordChanged;
      return;
    }
    else if (tResposta == IDYES)
      SalvarOrdem();
    else if (tResposta == IDNO)
    {
        algorithm::CoreTMPlanner::getInstance()->desfazerAlterecaoOrdemSaida(FLocalCellAnt_);
    }
  }
  CarregarTrens();
  cdsGrid->DisableControls();
  cdsGrid->RecNo  = tAuxRecNo;
  FLocalCellAnt_  = cdsGridlocal->Value;
  FIndexAnterior_ = cdsGrid->RecNo;
  EnableControls();

  cxgGridDBTableView1->Controller->TopRowIndex = index;
  cxgGridDBTableView1->OnFocusedRecordChanged  = cxgGridDBTableView1FocusedRecordChanged;

}
// ---------------------------------------------------------------------------

void __fastcall TformOrdemTrem::EnableControls()
{
  while (cdsGrid->ControlsDisabled())
    cdsGrid->EnableControls();
}



void __fastcall TformOrdemTrem::FormClose(TObject *Sender, TCloseAction &Action)
{

if (Action != mrCancel &&  ValidarTrocasOrdemPendente()  )
  {
    int tResposta = ConfirmeCancelar("Deseja salvar as trocas feitas nas ordens dos trens?");

    if (tResposta == IDCANCEL)
    {
      Action = (TCloseAction)mrNone;
      return;
    }
    else if (tResposta == IDYES)
      SalvarOrdem();
    else if (tResposta == IDNO)
    {
        algorithm::CoreTMPlanner::getInstance()->desfazerAlterecaoOrdemSaida(FLocalCellAnt_);
    }
  }






}
//---------------------------------------------------------------------------


void __fastcall TformOrdemTrem::cxgGridDBTableView1CustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{
  if ((AViewInfo->GridRecord->Values[cxgGridDBTableView1local->Index].IsNull()
       ||AViewInfo->GridRecord->Values[cxgGridDBTableView1local->Index].IsEmpty())
   &&
  /*(AViewInfo->RecordViewInfo->Index > 2) &&*/ (AViewInfo->Item->Index != cxgGridDBTableView1local->Index))
	{
		ACanvas->FillRect(AViewInfo->Bounds,ACanvas->Brush->Color );
//		AViewInfo->Borders = [bTop, bBottom];
    TRect ABounds;
		if (AViewInfo->Item->IsFirst)
			ABounds.Left = AViewInfo->Bounds.Left;
		if (AViewInfo->Item->IsLast)
			ABounds.Right = AViewInfo->Bounds.Right;
			ABounds.Top =AViewInfo->Bounds.Top;
			ABounds.Bottom =AViewInfo->Bounds.Bottom;
//		if (AViewInfo->Item->IsLast)
  //			AViewInfo->Borders = AViewInfo->Borders + bRight;
		ADone = true;
    if (!AViewInfo->GridRecord->Values[cxgGridDBTableView1prefixo->Index].IsNull())
    {
      String texto = AViewInfo->GridRecord->Values[cxgGridDBTableView1prefixo->Index];
      Sender->Site->Canvas->DrawTexT(texto, ABounds,cxAlignHCenter);
    }
	}
}
//---------------------------------------------------------------------------




================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFParametrosSistema.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "UFormsManager.h"
#include <System.DateUtils.hpp>
#include "UDAO.h"
#include <cxGridStrs.hpp>
#pragma hdrstop

#include "UFParametrosSistema.h"

#pragma region Server
#include "../domain/FilaDemandaTerminal.h"
#include "../domain/SlotDemandaTerminal.h"
#pragma end_region
// ---------------------------------------------------------------------------
#pragma package(smart_init)

#pragma link "cxDropDownEdit"
#pragma link "dxUIAClasses"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"

TFormParametrosSistema *FormParametrosSistema;

void __fastcall TFormParametrosSistema::RetornarFilas()
{

     TTPFormsManager::getInstance()->FParametros.listaFilasInativas->Clear();
     TTPFormsManager::getInstance()->FParametros.listaFilasAtivas->Clear();

     for(int i =0; i < lstbAtivas->Items->Count;i++)
     {
       TTPFormsManager::getInstance()->FParametros.listaFilasAtivas->Add(lstbAtivas->Items->operator[](i));
     }

     for(int i =0; i < lstbInativas->Items->Count;i++)
     {
       TTPFormsManager::getInstance()->FParametros.listaFilasInativas->Add(lstbInativas->Items->operator [](i));
     }

}


void __fastcall TFormParametrosSistema::carregarListaFilas(TStringList* ativas, TStringList*inativas )
{
  LimpezaLists();
  chkDesativarCalculoFila->OnClick = NULL;

    for(int k =0;k< ativas->Count;k++)
    {
       lstbAtivas->Items->Add(ativas->operator [](k));
    }
    for(int k =0;k< inativas->Count;k++)
    {
       lstbInativas->Items->Add(inativas->operator [](k));
    }


  if((int)FdataExpiracao_ != NULL)
  {
    //String data_expiracao = ;
    lblDesativadas->Visible = true;
    String data_expiracao = FdataExpiracao_.DateTimeString();
    lblDesativadas->Caption = "Data de Expirao: " + data_expiracao;
  }else
  {
   lblDesativadas->Visible = false;
  }

  if(inativas->Count > 0)
  {
  chkDesativarCalculoFila->Checked = true;
  }

  if (chkDesativarCalculoFila->Checked == true)
  {
    if (lstbInativas->Items->Count == 0)
    {
      btnDescarregaTodos->OnClick(this);
      lblDesativadas->Visible = false;
    }
  } else
  {
  chkDesativarCalculoFila->Checked = false;
  lblDesativadas->Visible = false;

  }

  chkDesativarCalculoFila->OnClick = chkDesativarCalculoFilaClick;
  monitoraCheckBox();

}

void __fastcall TFormParametrosSistema::monitoraCheckBox()
{
  if ((chkDesativarCalculoFila->Checked == false))
  {
        lstbAtivas->Font->Color = clGray;
        lstbAtivas->OnDblClick = NULL;
        btnCarregaUm->Enabled = false;
        btnCarregaTodos->Enabled = false;
        btnDescarregaUm->Enabled = false;
        btnDescarregaTodos->Enabled = false;
        lblDesativadas->Visible = false;
        if(lstbInativas->Items->Count > 0)
        {
          descarregarTodos();
        }
  }
  else
  {
    lstbAtivas->Enabled = true;
    chkDesativarCalculoFila->Checked == true;
    lstbAtivas->Font->Color = clWindowText;
    lstbAtivas->OnDblClick = lstbAtivasDblClick;
    btnCarregaUm->Enabled = true;
    btnCarregaTodos->Enabled = true;
    btnDescarregaUm->Enabled = true;
    btnDescarregaTodos->Enabled = true;
  }

}

//
 void __fastcall TFormParametrosSistema::GridRules()
 {
    GDTVGRUPO->Options->Editing = false;
    GDTVORIG->Options->Editing = false;
    GDTVcd_parametro->Options->Editing = false;
    GDTVdc_parametro->Options->Editing = false;
    GDTVvalor_parametro->Options->Editing = false;
    GDTVic_tipo_parametro->Options->Editing = false;
    GDTVic_tipo_parametro->Options->Editing = false;
    btnAddNewRowGrid->Enabled = false;
    btnAddNewRowGrid->Visible = false;


    btnInserirPatioExportacao->Enabled = false;
    btnExcluirPatioExportacao->Enabled = false;
    btnConfirmarPatioExportacao->Enabled = false;
    btnCancelarPatioExportacao->Enabled = false;

    btnInserirPatioImportacao->Enabled = false;
    btnExcluirPatioImportacao->Enabled = false;
    btnConfirmarPatioImportacao->Enabled = false;
    btnCancelarPatioImportacao->Enabled = false;

    btnInserirSlotExportacao->Enabled = false;
    btnExcluirSlotExportacao->Enabled = false;
    btnConfirmarSlotExportacao->Enabled = false;
    btnCancelarSlotExportacao->Enabled = false;

    btnInserirSlotImportacao->Enabled = false;
    btnExcluirSlotImportacao->Enabled = false;
    btnConfirmarSlotImportacao->Enabled = false;
    btnCancelarSlotImportacao->Enabled = false;

    FieldTPCadenciamento->Enabled = false;

    if(TTPFormsManager::getInstance()->ShowVisualizador)
      return;

    if (TTPFormsManager::getInstance()->Usuario.Nivel == nivEspecialista)
    {
      GDTVcd_parametro->Options->Editing = true;
      GDTVvalor_parametro->Options->Editing = true;
      FieldTPCadenciamento->Enabled = true;

    }
    else if (TTPFormsManager::getInstance()->Usuario.Nivel > nivEspecialista)
    {
      GDTVORIG->Options->Editing = true;
      GDTVcd_parametro->Options->Editing = true;
      GDTVdc_parametro->Options->Editing = true;
      GDTVvalor_parametro->Options->Editing = true;
      GDTVic_tipo_parametro->Options->Editing = true;
      GDTVic_tipo_parametro->Options->Editing = true;
      btnAddNewRowGrid->Enabled = true;
      btnAddNewRowGrid->Visible = true;
      FieldTPCadenciamento->Enabled = true;
    }

 }
 void __fastcall TFormParametrosSistema::CarregarParametrosGrid()
{
  cdsParam->Close();
	cdsParam->DisableControls();
	PtrQuery query_ = TDAO::getParamsSistema();
	cdsParam->CreateDataSet();
	cdsParam->Open();

	while (!query_->Eof)
	{

    cdsParam->Append();
    cdsParamORIG->Text = query_->FieldByName("ORIG")->Text;
    cdsParamGRUPO->Text = query_->FieldByName("GRUPO")->Text;
    cdsParamcd_parametro->Text = query_->FieldByName("cd_parametro")->Text;
    cdsParamcd_prmt_old->Text = query_->FieldByName("cd_parametro")->Text;
    cdsParamdc_parametro->Text = query_->FieldByName("dc_parametro")->Text;
    cdsParamvalor_parametro->Text = query_->FieldByName("valor_parametro")->Text;
    cdsParamic_tipo_parametro->Text = query_->FieldByName("ic_tipo_parametro")->Text;
    cdsParamic_parametro_ativo->Text = query_->FieldByName("ic_parametro_ativo")->Text;
    cdsParamcd_usuario->Text = query_->FieldByName("cd_usuario")->Text;
    cdsParamdata_atualizacao->Text = query_->FieldByName("data_atualizacao")->Text;
    cdsParamregex_v->Text = query_->FieldByName("regex_v")->Text;
    cdsParamrow_id->Text =  query_->FieldByName("row_id")->Text;
		query_->Next();
	}
	cdsParam->Post();
//
	if (cdsParam->RecordCount > 0)
		cdsParam->RecNo = 1;
		cdsParam->EnableControls();

  if(TTPFormsManager::getInstance()->ShowVisualizador)
  {
    this->TabSheet2->Visible = false;
    this->TabSheet2->TabVisible = false;
    this->TabSheet2->Enabled = false;
    this->GroupBox1->Visible = false;
  }
}
// ---------------------------------------------------------------------------
__fastcall TFormParametrosSistema::TFormParametrosSistema(TComponent* Owner) : TForm(Owner)
{

    //eliminar linha abaixo do form tb(parte visual)
    cxSetResourceString(&_scxGridGroupByBoxCaption,"Arraste as colunas aqui para agrupa-las");
    CarregarParametrosGrid();
    GridRules();
    NullStrictConvert = false;
//    this->ClientWidth = 411;
//    if(!TTPFormsManager::getInstance()->ShowVisualizador)
//    {
//       this->Height = 683;
//    } else {
//
//      this->Height = 528;
//      PageControl2->Top = 2;
//    }
    ResizeFormulario();
}

 inline __fastcall TFormParametrosSistema::~TFormParametrosSistema(void)
 {

 }

// ---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCarregaUmClick(TObject *Sender)
{
  if (lstbAtivas->ItemIndex >= 0)
  {
    for (int i = 0; i < lstbAtivas->Items->Count; i++)
    {
      if (lstbAtivas->Selected[i])
      {
        lstbInativas->Items->Add(lstbAtivas->Items->operator[](i));
      }
    }

    for (int i = lstbAtivas->Items->Count - 1; i >= 0; i--)
    {
      if (lstbAtivas->Selected[i])
      {
        lstbAtivas->Items->Delete(i);
      }
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCarregaTodosClick(TObject *Sender)
{
	for (int i = 0; i < lstbAtivas->Items->Count; i++)
	{
		lstbInativas->Items->Add(lstbAtivas->Items->operator[](i));
	}
	lstbAtivas->Items->Clear();
}
// ---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnDescarregaUmClick(TObject *Sender)
{
  if (lstbInativas->ItemIndex >= 0)
  {
    lstbAtivas->Items->Add(lstbInativas->Items->operator[](lstbInativas->ItemIndex));
    lstbInativas->Items->Delete(lstbInativas->ItemIndex);
  }
}
// ---------------------------------------------------------------------------
void __fastcall TFormParametrosSistema::descarregarTodos()
{
   for (int i = 0; i < lstbInativas->Items->Count; i++)
	{
		lstbAtivas->Items->Add(lstbInativas->Items->operator[](i));
	}
	lstbInativas->Items->Clear();
}
void __fastcall TFormParametrosSistema::btnDescarregaTodosClick(TObject *Sender)
{
   descarregarTodos();
}


void __fastcall TFormParametrosSistema::FormActivate(TObject *Sender)
{
   PageControl1->ActivePage = TabSheet1;
   if(TTPFormsManager::getInstance()->ShowVisualizador)
   {
     #ifdef BAIXADA_SANTISTA
       chkIsCalculoVelocidadeAtivo->Enabled = false;
       chkAtvOfclzAuto->Enabled = false;
       chkAtvPlnParcial->Enabled = false;
       FieldTPPlnAuto->Enabled = false;
       FieldTPPlnRslMin->Enabled = false;
       FieldTPTimeoutPln->Enabled = false;
       chkDesativarGestaoFilaExportacao->Enabled = false;
       chkDesativarGestaoFilaImportacao->Enabled = false;
     #endif

     TabSheet4->Enabled = false;
     TabSheet5->Enabled = false;
   }

//		if (TTPFormsManager::getInstance()->Usuario.Nivel < nivEspecialista)
//		{
//				PageControl1->Pages[1]->TabVisible = False;
//		}
//
//    if (cxgExportacaoPatioDBTableView1->DataController->RecordCount > 0)
//    {
//        cxgExportacaoPatioDBTableView1->Controller->FocusedRowIndex = 0;
//
//                // Focar na primeira linha
//        cxgExportacaoPatioDBTableView1->DataController->FocusedRowIndex = 0;
//
//        // Certificar-se de que a linha est visvel
//        cxgExportacaoPatioDBTableView1->Controller->FocusedRow->MakeVisible();
//
//
//
//    }
//
//    if (cxgImportacaoPatioDBTableView1->DataController->RecordCount > 0)
//    {
//        cxgImportacaoPatioDBTableView1->Controller->FocusedRowIndex = 0;
//    }
   // carregarListaFilas();



}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::lstbAtivasDblClick(TObject *Sender)
{
		TFormParametrosSistema::btnCarregaUm->OnClick(Sender);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::lstbInativasDblClick(TObject *Sender)
{
	 TFormParametrosSistema::btnDescarregaUm->OnClick(Sender);
}
//---------------------------------------------------------------------------


void __fastcall TFormParametrosSistema::GDTVCustomDrawCell(TcxCustomGridTableView *Sender,
  TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone)
{


    if (AViewInfo->Item->Index > 1)
   {
        if(AViewInfo->Focused == true)
        {
           ACanvas->Brush->Color = clActiveCaption;
        }
        else if (AViewInfo->GridRecord->Selected)
              {
                ACanvas->Brush->Color = clGradientActiveCaption;
              }
          else
              {
               
               String preenchido = VarToStr((AViewInfo->GridRecord->Values[0]));
               if (preenchido == "")
               {
                  preenchido = BoolToStr(false);
               }

               
               if (preenchido != "" && StrToBool(preenchido) == true)
               {
                    ACanvas->Brush->Color = clYellow;
               }
               else
               {
                    if (AViewInfo->GridRecord->RecordIndex % 2 == 0)
                    {
                      ACanvas->Brush->Color = clWhite;
                    }
                    else
                    {
                      ACanvas->Brush->Color = clCream;
                    }
               }
               String ativo = AViewInfo->GridRecord->Values[7];
               if(((StrToBool(preenchido))==false) && ativo == "F")
               {
                 ACanvas->Brush->Color = clGray;
               }

              }

         int colCod = GDTVcd_parametro->Index;
         int colAtivo = GDTVic_parametro_ativo->Index;
         int colGrupo = GDTVGRUPO->Index;

         for (int i = 0; i < GDTV->DataController->RecordCount; i++)
              {
                if ((i != AViewInfo->GridRecord->RecordIndex)
                     &&
                    (GDTV->DataController->GetValue(AViewInfo->GridRecord->RecordIndex, colCod) == (GDTV->DataController->GetValue(i,colCod)))
                     &&
                    (GDTV->DataController->GetValue(AViewInfo->GridRecord->RecordIndex, colGrupo) == ((GDTV->DataController->GetValue(i,
                    colGrupo)))
                    &&
                    ((GDTV->DataController->GetValue(i,colAtivo) == "T"))))
                {
    
                  ACanvas->Brush->Color = clMoneyGreen;
                  break;
                }
    
              }
      
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::GDTVEditValueChanged(TcxCustomGridTableView *Sender
        , TcxCustomGridTableItem *AItem)
{

         cdsParam->DisableControls();
         cdsParamlinha_modificada->Value = true;
         cdsParam->EnableControls();

}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnOkClick(TObject *Sender)
{
  if(TTPFormsManager::getInstance()->ShowVisualizador)
    return;
  bool testFilasOK = true;
  try
  {

    for (unsigned int x= 0; x < filas.size(); x++)
    {
      const domain::Fila& fila = filas[x];
      if (fila.slots.size() <= 0)
      {

        UnicodeString msgFaltaPatio;
        msgFaltaPatio = "Ptio :" + fila.patio + " sem slot cadastrado. Favor preencher ou excluir-lo.";
        ShowMessage(msgFaltaPatio);
        testFilasOK = false;
      }
    }

    if (!testFilasOK)
    {
      ModalResult = mrNone;
      return;
    }


    //CheckFilasAtivas();
    RetornarFilas();
    cdsParam->DisableControls();
    cdsParam->First();
    while (!cdsParam->Eof)
    {
        if(cdsParamlinha_modificada->Value == true)
        {

         if(cdsParamrow_id->Text == NULL || cdsParamrow_id->Text == "")
         {
           String sOrig             =   cdsParamORIG->Text;
           String sGrupo            =   cdsParamGRUPO->Text;
           String sCdParam          =   cdsParamcd_parametro->Text;
           String sDcParam          =   cdsParamdc_parametro->Text;
           String sValor_Parametro  =   cdsParamvalor_parametro->Text;
           String sIc_Tipo_Param    =   cdsParamic_tipo_parametro->Text;
           String sIc_Param_Ativo   =   cdsParamic_parametro_ativo->Text;
           String sCd_Usuario       =   cdsParamcd_usuario->Text;
           String sData_atualizacao =   cdsParamdata_atualizacao->Text;
           String sRegex            =   cdsParamregex_v->Text;
           String sCd_prmt_old      =   cdsParamcd_prmt_old->Text;
           //insert duplicado em parametros antigos pois no aceitam valores nulos
           String sDEPRECATED_CD_GRUPO_PRMT_SIS = cdsParamGRUPO->Text;
           String sDEPRECATED_NM_PRMT_SIST      = cdsParamcd_parametro->Text;
           String sDEPRECATED_DC_PRMT_SIST      = cdsParamdc_parametro->Text;
           String sDEPRECATED_IC_TIPO_PRMT_SIST = cdsParamic_tipo_parametro->Text;
           String sDEPRECATED_VL_PRMT_SIST      = cdsParamvalor_parametro->Text;


           PtrQuery query_ = TDAO::InsertParamSistema(sOrig,sGrupo,sCdParam,sDcParam,sValor_Parametro,
                                                  sIc_Tipo_Param,sIc_Param_Ativo,sRegex,sDEPRECATED_CD_GRUPO_PRMT_SIS,
                                                  sDEPRECATED_NM_PRMT_SIST,sDEPRECATED_DC_PRMT_SIST,
                                                  sDEPRECATED_IC_TIPO_PRMT_SIST,sDEPRECATED_VL_PRMT_SIST);

         }else
         {
           String sOrig             =   cdsParamORIG->Text;
           String sGrupo            =   cdsParamGRUPO->Text;
           String sCdParam          =   cdsParamcd_parametro->Text;
           String sDcParam          =   cdsParamdc_parametro->Text;
           String sValor_Parametro  =   cdsParamvalor_parametro->Text;
           String sIc_Tipo_Param    =   cdsParamic_tipo_parametro->Text;
           String sIc_Param_Ativo   =   cdsParamic_parametro_ativo->Text;
           String sCd_Usuario       =   cdsParamcd_usuario->Text;
           String sData_atualizacao =   cdsParamdata_atualizacao->Text;
           String sRegex            =   cdsParamregex_v->Text;
           String sCd_prmt_old      =   cdsParamcd_prmt_old->Text;
           String sRow_id           =   cdsParamrow_id->Text;
           PtrQuery query_ = TDAO::updateParamSistema(sOrig,sGrupo,sCdParam,sDcParam,sValor_Parametro,
                                                  sIc_Tipo_Param,sIc_Param_Ativo,sRegex,sCd_prmt_old,sRow_id);
         }

        }
      cdsParam->Next();
    }

    AtualizaTPCadenciamento();
    bool activeImprtChanged = chkDesativarGestaoFilaImportacao->Checked != m_activeImportacao;
    bool activeExprtChanged = chkDesativarGestaoFilaExportacao->Checked != m_activeExportacao;

    VerificaAlteracoesAutomatico();
    AtualizaFilasAtivas(chkDesativarGestaoFilaExportacao->Checked, true, "IS_FILA_EXPRT_NOT_ATIVO", "Indicador ativo para filas de exportao");
    AtualizaFilasAtivas(chkDesativarGestaoFilaImportacao->Checked, false, "IS_FILA_IMPRT_NOT_ATIVO", "Indicador ativo para filas de importao");
		#ifdef BAIXADA_SANTISTA
		if(activeImprtChanged || activeExprtChanged)
			m_core->getInstance()->GestaoFilasDemandaTerminal();

    InserirItensServer(filasDeletadas, listaFilasDeletadasServer);
    for(int j = 0; j < listaFilaServer->Count; j++)
    {
      if(listaFilasDeletadasServer->IndexOf(listaFilaServer->Strings[j]) != -1)
      {
        listaFilaServer->Delete(j);
      }
    }
    InserirItensServer(filas, listaFilaServer);

    m_core->getInstance()->AdequarFilasDeletadas();
    #endif
    cdsParam->EnableControls();

  }
  catch(Exception& e)
  {
    throw(e.Message);
  }
  
}

void __fastcall TFormParametrosSistema::VerificaAlteracoesAutomatico()
{
  bool ativarGeracaoChanged = m_AtivoPlnAutomatico != chkAtvOfclzAuto->Checked;
  bool ativarGeracaoParcialChanged = m_AtivoPlnParcial != chkAtvPlnParcial->Checked;
  bool tpPlnAutoChanged = m_TPPlnAutomatico != (StrToIntDef(FieldTPPlnAuto->Text,00));
  bool tpTimeoutChanged = m_TPTimeoutPln != (StrToIntDef(FieldTPTimeoutPln->Text,00));
  bool tpParcChanged = m_PlnTPRslMin != (StrToIntDef(FieldTPPlnRslMin->Text,0000));

  if(ativarGeracaoChanged)
  {
    if(chkAtvOfclzAuto->Checked)
      AtualizaParamAuto("ATIVAR_GERAR_PLANOS_AUTO", "T","S", "Ativa gerao de planos optmove automtico");
    else
      AtualizaParamAuto("ATIVAR_GERAR_PLANOS_AUTO", "F","S", "Ativa gerao de planos optmove automtico");
  }

  if(ativarGeracaoParcialChanged)
  {
    if(chkAtvPlnParcial->Checked)
      AtualizaParamAuto("ATIVAR_CANCELAR_SOLUCAO_CONFLITO_AUTO", "T","S");
    else
      AtualizaParamAuto("ATIVAR_CANCELAR_SOLUCAO_CONFLITO_AUTO", "F","S");
  }

  if(tpPlnAutoChanged)
    AtualizaParamAuto("INTERVALO_EXECUCAO_AUTO_PLAN", FieldTPPlnAuto->Text,"N");

  if(tpTimeoutChanged)
    AtualizaParamAuto("TIMEOUT_AUTO_PLAN", FieldTPTimeoutPln->Text,"N");

  if(tpParcChanged)
    AtualizaParamAuto("TEMPO_PROGRESSO_SOLUCAO_VALIDO", FieldTPPlnRslMin->Text,"N");

}

void __fastcall TFormParametrosSistema::AtualizaParamAuto(String paramName, String paramValue, String paramType, String paramDesc, String paramGroup)
{

  String cdUsuario = TTPFormsManager::getInstance()->Usuario.Codigo;
  String sOrig     = m_core->getInstance()->DB_SCHEMA_ADM;
  String sValor_Parametro = paramValue;

  if(m_core->getInstance()->getParamByName(paramName, "SISTEMA") == "")
  {
    String sGrupo            =   paramGroup;
    String sCdParam          =   paramName;
    String sDcParam          =   paramDesc;

    String sIc_Tipo_Param    =   paramType;
    String sIc_Param_Ativo   =   "T";
    String sData_atualizacao =   "";
    String sRegex            =   "";
    String sCd_prmt_old      =   "";
   //insert duplicado em parametros antigos pois no aceitam valores nulos
    String sDEPRECATED_CD_GRUPO_PRMT_SIS = sGrupo;
    String sDEPRECATED_NM_PRMT_SIST      = sCdParam;
    String sDEPRECATED_DC_PRMT_SIST      = sDcParam;
    String sDEPRECATED_IC_TIPO_PRMT_SIST = sIc_Tipo_Param;
    String sDEPRECATED_VL_PRMT_SIST      = sValor_Parametro;
    PtrQuery query = TDAO::InsertParamSistema(sOrig,sGrupo,sCdParam,sDcParam,sValor_Parametro,
                                                  sIc_Tipo_Param,sIc_Param_Ativo,sRegex,sDEPRECATED_CD_GRUPO_PRMT_SIS,
                                                  sDEPRECATED_NM_PRMT_SIST,sDEPRECATED_DC_PRMT_SIST,
                                                  sDEPRECATED_IC_TIPO_PRMT_SIST,sDEPRECATED_VL_PRMT_SIST);
  }
  else
  {
     PtrQuery query = TDAO::UpdateParamValueByName(sOrig, paramName, sValor_Parametro, cdUsuario);
  }

}

void __fastcall TFormParametrosSistema::AtualizaFilasAtivas(bool chkBoxFila, bool isExportacao, String paramName, String paramDesc)
{

  if(isExportacao)
  {
    if(chkBoxFila == m_activeExportacao)
      return;

    m_activeExportacao = chkBoxFila;
  }
  else
  {
    if(chkBoxFila == m_activeImportacao)
      return;

    m_activeImportacao = chkBoxFila;
  }

  String cdUsuario = TTPFormsManager::getInstance()->Usuario.Codigo;
  String sOrig     = m_core->getInstance()->DB_SCHEMA_ADM;
  String sValor_Parametro = "";

  if(chkBoxFila)
    sValor_Parametro = "T";
  else
    sValor_Parametro = "F";

  if(m_core->getInstance()->getParamByName(paramName, "SISTEMA") == "")
  {
    String sGrupo            =   "SISTEMA";
    String sCdParam          =   paramName;
    String sDcParam          =   paramDesc;

    String sIc_Tipo_Param    =   "S";
    String sIc_Param_Ativo   =   "T";
    String sData_atualizacao =   "";
    String sRegex            =   "";
    String sCd_prmt_old      =   "";
   //insert duplicado em parametros antigos pois no aceitam valores nulos
    String sDEPRECATED_CD_GRUPO_PRMT_SIS = sGrupo;
    String sDEPRECATED_NM_PRMT_SIST      = sCdParam;
    String sDEPRECATED_DC_PRMT_SIST      = sDcParam;
    String sDEPRECATED_IC_TIPO_PRMT_SIST = sIc_Tipo_Param;
    String sDEPRECATED_VL_PRMT_SIST      = sValor_Parametro;
    PtrQuery query = TDAO::InsertParamSistema(sOrig,sGrupo,sCdParam,sDcParam,sValor_Parametro,
                                                  sIc_Tipo_Param,sIc_Param_Ativo,sRegex,sDEPRECATED_CD_GRUPO_PRMT_SIS,
                                                  sDEPRECATED_NM_PRMT_SIST,sDEPRECATED_DC_PRMT_SIST,
                                                  sDEPRECATED_IC_TIPO_PRMT_SIST,sDEPRECATED_VL_PRMT_SIST);
  }
  else
  {
     PtrQuery query = TDAO::UpdateParamValueByName(sOrig, paramName, sValor_Parametro, cdUsuario);
  }

}


void __fastcall TFormParametrosSistema::ResizeFormulario()
{
  #ifdef BAIXADA_SANTISTA
    pnlLegado->Visible = false;
//    this->Height = this->Height - pnlLegado->Height;
  #else
    pnlParametrosAutomatico->Visible = false;
    TabSheet5->TabVisible = false;
//    this->Height = this->Height - pnlParametrosAutomatico->Height;
//    TabSheet5->Visible = false;
  #endif
//  this->AutoSize = true;
  int size = 0;
  ResizeComponentByChildSizes((TWinControl*)this,size);
}


void __fastcall  TFormParametrosSistema::AjustarctiveTabSize(TPageControl *PageControl)
{
    int MaxWidth = 0;
    int MaxHeight = 0;

    TTabSheet *ActiveTab = PageControl->ActivePage;


    if (ActiveTab)
    {
     	ActiveTab->Height = ActiveTab->Height +1;
        for (int i = 0; i < ActiveTab->ControlCount; i++)
        {
            TControl *Control = ActiveTab->Controls[i];

            if (!Control->Visible)
                continue;

            if (dynamic_cast<TPageControl*>(Control))
            {
              // O controle  um TPageControl
              TPageControl *PageControl = static_cast<TPageControl*>(Control);
              AjustarctiveTabSize(PageControl);
            }

            MaxWidth = std::max(MaxWidth, Control->Left + Control->Width);

            MaxWidth = std::max(MaxWidth, Control->Left + Control->Constraints->MinWidth);
            MaxHeight = std::max(MaxHeight, Control->Top + Control->Height);
            MaxWidth = std::max(MaxHeight, Control->Top + Control->Constraints->MinHeight);
        }

        int MarginWidth = 20;
        int MarginHeight = 40;

        PageControl->Width = MaxWidth + MarginWidth;
        PageControl->Height = MaxHeight + MarginHeight;
    }
     PageControl->Realign();
         PageControl->Invalidate();


}


void __fastcall TFormParametrosSistema::AtualizaTPCadenciamento()
{

  int newTp = StrToIntDef(FieldTPCadenciamento->Text,40);

  if(newTp == m_tpCdnc)
    return;

  String cdUsuario = TTPFormsManager::getInstance()->Usuario.Codigo;
  String sOrig     = m_core->getInstance()->DB_SCHEMA_ADM;
  if(m_core->getInstance()->getParamByName("TP_CDNC_DMND_TERM", "SISTEMA") == "")
  {
    String sGrupo            =   "SISTEMA";
    String sCdParam          =   "TP_CDNC_DMND_TERM";
    String sDcParam          =   "Tempo de Cadenciamento de Trens em ZPG para filas";
    String sValor_Parametro = "";

    if(FieldTPCadenciamento->Text == NULL || FieldTPCadenciamento->Text == "00")
      sValor_Parametro  = "40";
    else
      sValor_Parametro  = FieldTPCadenciamento->Text;

    String sIc_Tipo_Param    =   "N";
    String sIc_Param_Ativo   =   "T";
    String sData_atualizacao =   "";
    String sRegex            =   "";
    String sCd_prmt_old      =   "";
   //insert duplicado em parametros antigos pois no aceitam valores nulos
    String sDEPRECATED_CD_GRUPO_PRMT_SIS = sGrupo;
    String sDEPRECATED_NM_PRMT_SIST      = sCdParam;
    String sDEPRECATED_DC_PRMT_SIST      = sDcParam;
    String sDEPRECATED_IC_TIPO_PRMT_SIST = sIc_Tipo_Param;
    String sDEPRECATED_VL_PRMT_SIST      = sValor_Parametro;
    PtrQuery query = TDAO::InsertParamSistema(sOrig,sGrupo,sCdParam,sDcParam,sValor_Parametro,
                                                  sIc_Tipo_Param,sIc_Param_Ativo,sRegex,sDEPRECATED_CD_GRUPO_PRMT_SIS,
                                                  sDEPRECATED_NM_PRMT_SIST,sDEPRECATED_DC_PRMT_SIST,
                                                  sDEPRECATED_IC_TIPO_PRMT_SIST,sDEPRECATED_VL_PRMT_SIST);

  }
  else
  {
     PtrQuery query = TDAO::UpdateParamValueByName(sOrig,"TP_CDNC_DMND_TERM", FieldTPCadenciamento->Text, cdUsuario);
  }
  m_tpCdnc = newTp;

}

void __fastcall TFormParametrosSistema::LimpezaLists()
{
  lstbAtivas->Clear();
  lstbInativas->Clear();
}


//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::GDTVCellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
GDTV->OptionsBehavior->ImmediateEditor = true;  
}
//---------------------------------------------------------------------------




void __fastcall TFormParametrosSistema::GDTVFocusedRecordChanged(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *APrevFocusedRecord, TcxCustomGridRecord *AFocusedRecord,
          bool ANewItemRecordFocusingChanged)
{
GDTV->OptionsBehavior->ImmediateEditor = false;
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnAddNewRowGridClick(TObject *Sender)
{
addNewLine(GDTV);
}


void __fastcall TFormParametrosSistema::addNewLine(TcxGridDBTableView *AView)
{
   GDTVORIG->Options->CellMerging = false;

   GDTVGRUPO->Options->Editing = true;
   AView->DataController->Append();
   GDTV->Controller->FocusedItem = AView->VisibleItems[0];
   cdsParamic_parametro_ativo->Text = "F";
   GDTVORIG->Options->Editing = true;

}
//---------------------------------------------------------------------------




void __fastcall TFormParametrosSistema::GDTVEditKeyDown(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, TcxCustomEdit *AEdit,
          WORD &Key, TShiftState Shift)
{

    if (Key == VK_TAB || Key == VK_RETURN )
      {
            GDTV->Controller->FocusNextCell(true);
            GDTV->Controller->FocusedColumn->Options->Editing;
      }


       if(Key == VK_ESCAPE)
       {

          GDTV->DataController->Cancel();
       }

  // VarIsNull
      Key = 0;
  }
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::GDTVFocusedItemChanged(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *APrevFocusedItem, TcxCustomGridTableItem *AFocusedItem)

{
//foco mudou v se alinha est completamente em branco e pega o index dela
}
//---------------------------------------------------------------------------



void __fastcall TFormParametrosSistema::PageControl1Change(TObject *Sender)
{
	// Obter a aba ativa
	TTabSheet *activeTab = PageControl1->ActivePage;

	// Exibir mensagem com o nome da aba ativa
	if (activeTab != NULL)
		{
			if(PageControl1->ActivePage->TabIndex ==0)
			{
				this->ClientWidth = 411;
			}
			else
			{
				this->ClientWidth = 850;
			}
		}

 //   AjustarctiveTabSize(PageControl1);
    int size = 0;
    ResizeComponentByChildSizes((TWinControl*)this,size);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::chkDesativarCalculoFilaClick(TObject *Sender)

{
  monitoraCheckBox();
}
//---------------------------------------------------------------------------

#pragma region Eventos

void __fastcall TFormParametrosSistema::FormCreate(TObject *Sender)
{
  IniciarDialog();
  AdjustParamAuto();
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnInserirPatioExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnInserirPatioExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnExcluirPatioExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnExcluirPatioExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnConfirmarPatioExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnConfirmarPatioExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCancelarPatioExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnCancelarPatioExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnInserirSlotExportacaoClick(TObject *Sender)

{
    ButtonAction(BUTTONS_ACTIONS::btnInserirSlotExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnExcluirSlotExportacaoClick(TObject *Sender)

{
    ButtonAction(BUTTONS_ACTIONS::btnExcluirSlotExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnConfirmarSlotExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnConfirmarSlotExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCancelarSlotExportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnCancelarSlotExportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnInserirPatioImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnInserirPatioImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnExcluirPatioImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnExcluirPatioImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnConfirmarPatioImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnConfirmarPatioImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCancelarPatioImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnCancelarPatioImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnInserirSlotImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnInserirSlotImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnExcluirSlotImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnExcluirSlotImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnConfirmarSlotImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnConfirmarSlotImportacao);
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::btnCancelarSlotImportacaoClick(TObject *Sender)

{
  ButtonAction(BUTTONS_ACTIONS::btnCancelarSlotImportacao);
}
//---------------------------------------------------------------------------


void __fastcall TFormParametrosSistema::cxgExportacaoPatioDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow)
{
  AAllow = m_AllowEditingPatioExportacao;
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgExportacaoPatioDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow)
{

  AAllow = !m_editModePatioExportacao;

}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgExportacaoSlotsDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaExportacao->Checked)
    {
      AAllow = m_AllowEditingSlotExportacao;
    }
    else
    {
      AAllow = false;
    }
  }
  else
  {
    AAllow = false;
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgExportacaoSlotsDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaExportacao->Checked)
    {
      AAllow = !m_editModeSlotExportacao;
    }
    else
    {
      AAllow = false;
    }
  }
  else
  {
    AAllow = false;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoPatioDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow)
{
  AAllow = m_AllowEditingPatioImportacao;
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoPatioDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    AAllow = !m_editModePatioImportacao;
  }
//  if (!chkDesativarGestaoFilaImportacao->Checked)
//  {
//    AAllow = !m_editModePatioImportacao;
//  }
//  else
//  {
//    AAllow = false;
//  }


}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoSlotsDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow)
{
  //AAllow = m_AllowEditingSlotImportacao;
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaImportacao->Checked)
    {
      AAllow = m_AllowEditingSlotImportacao;
    }
    else
    {
      AAllow = false;
    }
  }
  else
  {
    AAllow = false;
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoSlotsDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow)
{
  //AAllow = !m_editModeSlotImportacao;

  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaImportacao->Checked)
    {
      AAllow = !m_editModeSlotImportacao;
    }
    else
    {
      AAllow = false;
    }
  }
  else
  {
    AAllow = false;
  }      
}
//---------------------------------------------------------------------------


void __fastcall TFormParametrosSistema::cxgExportacaoPatioDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  ExportacaoPatioCellClick();
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgExportacaoSlotsDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    ExportacaoSlotsCellClick();
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoPatioDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{

  ImportacaoPatioCellClick();

}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cxgImportacaoSlotsDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    ImportacaoSlotsCellClick();
  }
}
//---------------------------------------------------------------------------

#pragma end_region


#pragma region Methodos Privados
void __fastcall TFormParametrosSistema::IniciarDialog()
{
  ConfigGrids();
  if(!TTPFormsManager::getInstance()->ShowVisualizador){
    ConfigEditing();
    ConfigNavigatorButtons();
  }

  if(CarregarFilaServer())
  {
    PreencherGrids();
  }
}

void __fastcall TFormParametrosSistema::AdjustParamAuto()
{

  String ativoAuto = m_core->getInstance()->getParamByName("ATIVAR_GERAR_PLANOS_AUTO", "SISTEMA");
  String ativoParcial = m_core->getInstance()->getParamByName("ATIVAR_CANCELAR_SOLUCAO_CONFLITO_AUTO", "SISTEMA");
  String tpAuto = m_core->getInstance()->getParamByName("INTERVALO_EXECUCAO_AUTO_PLAN", "SISTEMA");
  String tpTimeout = m_core->getInstance()->getParamByName("TIMEOUT_AUTO_PLAN", "SISTEMA");
  String tpPlnParc = m_core->getInstance()->getParamByName("TEMPO_PROGRESSO_SOLUCAO_VALIDO", "SISTEMA");

  if(ativoAuto == "T")
    m_AtivoPlnAutomatico = true;
  else
    m_AtivoPlnAutomatico = false;

  if(ativoParcial == "T")
    m_AtivoPlnParcial = true;
  else
    m_AtivoPlnParcial = false;

  chkAtvOfclzAuto->Checked = m_AtivoPlnAutomatico;
  chkAtvPlnParcial->Checked = m_AtivoPlnParcial;


  if(!chkAtvOfclzAuto->Checked)
  {
    FieldTPPlnAuto->Enabled = false;
  }
  else
  {
    FieldTPPlnAuto->Enabled = true;
  }
  m_TPPlnAutomatico = StrToIntDef(tpAuto,00);
  FieldTPPlnAuto->Text = m_TPPlnAutomatico;

  if(!chkAtvPlnParcial->Checked)
  {
    FieldTPTimeoutPln->Enabled = false;
    FieldTPPlnRslMin->Enabled = false;
  }
  else
  {
    FieldTPTimeoutPln->Enabled = true;
    FieldTPPlnRslMin->Enabled = true;
  }
   m_TPTimeoutPln = StrToIntDef(tpTimeout,00);
   FieldTPTimeoutPln->Text = m_TPTimeoutPln;
   m_PlnTPRslMin = StrToIntDef(tpPlnParc,0000);
   FieldTPPlnRslMin->Text = m_PlnTPRslMin;

   if(TTPFormsManager::getInstance()->Usuario.Nivel < nivEspecialista)
   {
     chkAtvPlnParcial->Enabled = false;
     chkAtvOfclzAuto->Enabled = false;
     FieldTPTimeoutPln->Enabled = false;
     FieldTPPlnRslMin->Enabled = false;
     FieldTPPlnAuto->Enabled = false;
   }

}


void __fastcall TFormParametrosSistema::SetNavigatorButtonsPatioExportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaExportacao->Checked)
    {
      btnInserirPatioExportacao->Enabled = addEnabled;
      btnExcluirPatioExportacao->Enabled = deleteEnabled;
      btnConfirmarPatioExportacao->Enabled = confirmEnabled;
      btnCancelarPatioExportacao->Enabled = cancelEnabled;
    }
  }
}

void __fastcall TFormParametrosSistema::SetNavigatorButtonsPatioImportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaImportacao->Checked)
    {
      btnInserirPatioImportacao->Enabled = addEnabled;
      btnExcluirPatioImportacao->Enabled = deleteEnabled;
      btnConfirmarPatioImportacao->Enabled = confirmEnabled;
      btnCancelarPatioImportacao->Enabled = cancelEnabled;
    }
  }
}

void __fastcall TFormParametrosSistema::SetNavigatorButtonsSlotExportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaExportacao->Checked)
    {
      btnInserirSlotExportacao->Enabled = addEnabled;
      btnExcluirSlotExportacao->Enabled = deleteEnabled;
      btnConfirmarSlotExportacao->Enabled = confirmEnabled;
      btnCancelarSlotExportacao->Enabled = cancelEnabled;
    }
  }
}

void __fastcall TFormParametrosSistema::SetNavigatorButtonsSlotImportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled)
{
  if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
  {
    if (!chkDesativarGestaoFilaImportacao->Checked)
    {
      btnInserirSlotImportacao->Enabled = addEnabled;
      btnExcluirSlotImportacao->Enabled = deleteEnabled;
      btnConfirmarSlotImportacao->Enabled = confirmEnabled;
      btnCancelarSlotImportacao->Enabled = cancelEnabled;
    }
  }
}

void __fastcall TFormParametrosSistema::PreencherComboPatioExportacao()
{
  m_queryPatio->First();

  TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgExportacaoPatioDBTableView1Destino->Properties;
  columnProperties->Items->Add(""); // Primeiro registro  vazio

  while (!m_queryPatio->Eof)
  {
    columnProperties->Items->Add(m_queryPatio->FieldByName("SG_PATIO_PLJM")->Text);
    m_queryPatio->Next();
  }
}

void __fastcall TFormParametrosSistema::PreencherComboPatioImportacao()
{
  m_queryPatio->First();

  TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgImportacaoPatioDBTableView1Origem->Properties;
  columnProperties->Items->Add(""); // Primeiro registro  vazio

  while (!m_queryPatio->Eof)
  {
    columnProperties->Items->Add(m_queryPatio->FieldByName("SG_PATIO_PLJM")->Text);
    m_queryPatio->Next();
  }
}

void __fastcall TFormParametrosSistema::PreencherComboSlotExportacao()
{
  m_querySlots->First();

  TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgExportacaoSlotsDBTableView1Slots->Properties;
  columnProperties->Items->Add(""); // Primeiro registro  vazio

  while (!m_querySlots->Eof)
  {
    columnProperties->Items->Add(m_querySlots->FieldByName("NM_SBL")->Text);
    m_querySlots->Next();
  }
}

void __fastcall TFormParametrosSistema::PreencherComboSlotImportacao()
{
  m_querySlots->First();

  TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgImportacaoSlotsDBTableView1Slots->Properties;
  columnProperties->Items->Add(""); // Primeiro registro  vazio

  while (!m_querySlots->Eof)
  {
    columnProperties->Items->Add(m_querySlots->FieldByName("NM_SBL")->Text);
    m_querySlots->Next();
  }
}

void __fastcall TFormParametrosSistema::PreencherComboBox(PtrQuery query, TcxComboBoxProperties* comboBoxProperties, const String& fieldName)
{
  query->First();

  comboBoxProperties->Items->Add(""); // Primeiro registro  vazio

  while (!query->Eof)
  {
    comboBoxProperties->Items->Add(query->FieldByName(fieldName)->Text);
    query->Next();
  }
}


bool __fastcall TFormParametrosSistema::CarregarPatios()
{
  bool ret = false;

  try
  {
    m_queryPatio = TDAO::getPatiosPorRamal("ICZ-ISN Baixada Conceio-Santos");
    ret = true;
  }
  catch (Exception& exception)
  {
    MessageBoxW(this->Handle, L"No foi possvel acessar 'ptios' por Ramal", L"Erro", MB_ICONWARNING | MB_OK);
  }
  catch(...)
  {
    MessageBoxW(this->Handle, L"No foi possvel acessar 'ptios' por Ramal", L"Erro", MB_ICONWARNING | MB_OK);
  }

  return ret;
}

bool __fastcall TFormParametrosSistema::CarregarSlots()
{
  bool ret = false;

  try
  {
    m_querySlots = TDAO::getSBsPorZonasControle("'Baixada Santista'");
    ret = true;
  }
  catch (Exception& exception)
  {
    MessageBoxW(this->Handle, L"No foi possvel acessar 'slots'", L"Erro", MB_ICONWARNING | MB_OK);
  }
  catch(...)
  {
    MessageBoxW(this->Handle, L"No foi possvel acessar 'slots'", L"Erro", MB_ICONWARNING | MB_OK);
  }

  return ret;
}

void __fastcall TFormParametrosSistema::ConfigEditing()
{
  m_editModePatioExportacao = false;
  m_editModeSlotExportacao = false;
  m_editModePatioImportacao = false;
  m_editModeSlotImportacao = false;

  m_AllowEditingPatioExportacao = false;
  cxgExportacaoPatioDBTableView1->OptionsData->Editing = true;
  cxgExportacaoPatioDBTableView1->OnEditing = cxgExportacaoPatioDBTableView1Editing;

  m_AllowEditingSlotExportacao = true;
  cxgExportacaoSlotsDBTableView1->OptionsData->Editing = true;
  cxgExportacaoSlotsDBTableView1->OnEditing = cxgExportacaoSlotsDBTableView1Editing;

  m_AllowEditingPatioImportacao = false;
  cxgImportacaoPatioDBTableView1->OptionsData->Editing = true;
  cxgImportacaoPatioDBTableView1->OnEditing = cxgImportacaoPatioDBTableView1Editing;

  m_AllowEditingSlotImportacao = true;
  cxgImportacaoSlotsDBTableView1->OptionsData->Editing = true;
  cxgImportacaoSlotsDBTableView1->OnEditing = cxgImportacaoSlotsDBTableView1Editing;
}

void __fastcall TFormParametrosSistema::ConfigEditingSlot()
{
  m_editModePatioExportacao = false;
  m_editModeSlotExportacao = false;
  m_editModePatioImportacao = false;
  m_editModeSlotImportacao = false;

  m_AllowEditingPatioExportacao = false;
  cxgExportacaoPatioDBTableView1->OptionsData->Editing = false;
  cxgExportacaoPatioDBTableView1->OnEditing = cxgExportacaoPatioDBTableView1Editing;

  m_AllowEditingSlotExportacao = true;
  cxgExportacaoSlotsDBTableView1->OptionsData->Editing = true;
  cxgExportacaoSlotsDBTableView1->OnEditing = cxgExportacaoSlotsDBTableView1Editing;

  m_AllowEditingPatioImportacao = false;
  cxgImportacaoPatioDBTableView1->OptionsData->Editing = false;
  cxgImportacaoPatioDBTableView1->OnEditing = cxgImportacaoPatioDBTableView1Editing;

  m_AllowEditingSlotImportacao = true;
  cxgImportacaoSlotsDBTableView1->OptionsData->Editing = true;
  cxgImportacaoSlotsDBTableView1->OnEditing = cxgImportacaoSlotsDBTableView1Editing;
}

void __fastcall TFormParametrosSistema::ConfigNavigatorButtons()
{
  SetNavigatorButtonsPatioExportacao(true, false, false, false);
  SetNavigatorButtonsSlotExportacao(false, false, false, false);
  SetNavigatorButtonsPatioImportacao(true, false, false, false);
  SetNavigatorButtonsSlotImportacao(false, false, false, false);
}

void __fastcall TFormParametrosSistema::ConfigGrids()
{
  if(CarregarPatios())
  {
    TcxComboBoxProperties* columnProperties = (TcxComboBoxProperties*)cxgExportacaoPatioDBTableView1Destino->Properties;
    PreencherComboBox(m_queryPatio, columnProperties, "SG_PATIO_PLJM");
    PreencherComboBox(m_queryPatio, (TcxComboBoxProperties*)cxgImportacaoPatioDBTableView1Origem->Properties, "SG_PATIO_PLJM");
//    PreencherComboPatioExportacao();
//    PreencherComboPatioImportacao();
  }

  if(CarregarSlots())
  {
    PreencherComboBox(m_querySlots, (TcxComboBoxProperties*)cxgExportacaoSlotsDBTableView1Slots->Properties, "NM_SBL");
    PreencherComboBox(m_querySlots, (TcxComboBoxProperties*)cxgImportacaoSlotsDBTableView1Slots->Properties, "NM_SBL");
//    PreencherComboSlotExportacao();
//    PreencherComboSlotImportacao();
  }
  if(!TTPFormsManager::getInstance()->ShowVisualizador)
  {
    String tpCdnc = m_core->getInstance()->getParamByName("TP_CDNC_DMND_TERM", "SISTEMA");
    String notActiveExprt = m_core->getInstance()->getParamByName("IS_FILA_EXPRT_NOT_ATIVO", "SISTEMA");
    String notActiveImprt = m_core->getInstance()->getParamByName("IS_FILA_IMPRT_NOT_ATIVO", "SISTEMA");

    if(!(tpCdnc == ""))
      FieldTPCadenciamento->Text = tpCdnc;
    else
      FieldTPCadenciamento->Text = "40";

    if(notActiveExprt == "T")
      chkDesativarGestaoFilaExportacao->Checked = true;
    else
      chkDesativarGestaoFilaExportacao->Checked = false;

    if(notActiveImprt == "T")
      chkDesativarGestaoFilaImportacao->Checked = true;
    else
      chkDesativarGestaoFilaImportacao->Checked = false;

    m_tpCdnc = StrToIntDef(tpCdnc, 40);

    m_activeImportacao = chkDesativarGestaoFilaImportacao->Checked;
    m_activeExportacao = chkDesativarGestaoFilaExportacao->Checked;
  }
  cdsExportacaoPatio->CreateDataSet();
  cdsExportacaoSlots->CreateDataSet();
  cdsImportacaoPatio->CreateDataSet();
  cdsImportacaoSlots->CreateDataSet();
}

void __fastcall TFormParametrosSistema::ButtonAction(BUTTONS_ACTIONS action)
 {

  String nmSlot = "";
  String patioRef = "";
  String pidFilaRef = "";
  bool deletadoUltimoSlot = false;
  switch (action)
  {
    case BUTTONS_ACTIONS::btnInserirPatioExportacao:
      ConfigEditing();
      IniciarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioExportacao, cdsExportacaoPatio, m_editModePatioExportacao, m_AllowEditingPatioExportacao);
      break;

    case BUTTONS_ACTIONS::btnInserirSlotExportacao:
      ConfigEditingSlot();
      IniciarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
      break;

    case BUTTONS_ACTIONS::btnInserirPatioImportacao:
      ConfigEditing();
      IniciarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioImportacao, cdsImportacaoPatio, m_editModePatioImportacao, m_AllowEditingPatioImportacao);
      break;

    case BUTTONS_ACTIONS::btnInserirSlotImportacao:
      ConfigEditingSlot();
      IniciarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
      break;

    case BUTTONS_ACTIONS::btnExcluirPatioExportacao:
      SetNavigatorButtonsPatioExportacao(false, false, true, true);
      break;

    case BUTTONS_ACTIONS::btnExcluirSlotExportacao:
      //OcultarLinhaSelecionada(false, true,cdsExportacaoSlots->Fields->Fields[0]->Text);
      patioRef = cdsExportacaoPatio->Fields->Fields[0]->Text;
      pidFilaRef = cdsExportacaoPatio->Fields->Fields[1]->Text;
      nmSlot = cdsExportacaoSlots->Fields->Fields[1]->Text;
      deletadoUltimoSlot = DeletarSlotEmPatio(filas, patioRef, true, nmSlot);
      if(deletadoUltimoSlot)
      {
        ExcluirLinhaSelecionada(false, true, cdsExportacaoSlots->Fields->Fields[0]->Text);
        DeletarPatio(filas, patioRef, true,pidFilaRef);
        ExcluirLinhaSelecionada(true, true, cdsExportacaoPatio->Fields->Fields[0]->Text);
        SetNavigatorButtonsSlotExportacao(false, false, false, false);
      }
      else
      {
        ExcluirLinhaSelecionada(false, true, cdsExportacaoSlots->Fields->Fields[0]->Text);
        SetNavigatorButtonsSlotExportacao(true, true, false, false);
      }
        ConfigEditing();
//      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, m_editModeSlotExportacao, m_AllowEditingSlotExportacao, GRIDS::slotExportacao);

      break;

    case BUTTONS_ACTIONS::btnExcluirPatioImportacao:
      SetNavigatorButtonsPatioImportacao(false, false, true, true);
      break;

    case BUTTONS_ACTIONS::btnExcluirSlotImportacao:
      //OcultarLinhaSelecionada(false, false, cdsImportacaoSlots->Fields->Fields[0]->Text);
      patioRef = cdsImportacaoPatio->Fields->Fields[0]->Text;
      pidFilaRef = cdsExportacaoPatio->Fields->Fields[1]->Text;
      nmSlot = cdsImportacaoSlots->Fields->Fields[1]->Text;
      deletadoUltimoSlot = DeletarSlotEmPatio(filas, patioRef, false, nmSlot);
      if(deletadoUltimoSlot)
      {
        ExcluirLinhaSelecionada(false, false, cdsImportacaoSlots->Fields->Fields[0]->Text);
        DeletarPatio(filas, patioRef, false,pidFilaRef);
        ExcluirLinhaSelecionada(true, false, cdsImportacaoPatio->Fields->Fields[0]->Text);
        SetNavigatorButtonsSlotImportacao(false, false, false, false);
      }
      else
      {
        ExcluirLinhaSelecionada(false, false, cdsImportacaoSlots->Fields->Fields[0]->Text);
        SetNavigatorButtonsSlotImportacao(true, true, false, false);
      }
      ConfigEditing();
//      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, m_editModeSlotImportacao, m_AllowEditingSlotImportacao, GRIDS::slotImportacao);

      break;

    case BUTTONS_ACTIONS::btnConfirmarPatioExportacao:
      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsPatioExportacao, cdsExportacaoPatio, m_editModePatioExportacao, m_AllowEditingPatioExportacao, GRIDS::patioExportacao);
      break;

    case BUTTONS_ACTIONS::btnConfirmarSlotExportacao:
      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, m_editModeSlotExportacao, m_AllowEditingSlotExportacao, GRIDS::slotExportacao);
      break;

    case BUTTONS_ACTIONS::btnConfirmarPatioImportacao:
      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsPatioImportacao, cdsImportacaoPatio, m_editModePatioImportacao, m_AllowEditingPatioImportacao, GRIDS::patioImportacao);
      break;

    case BUTTONS_ACTIONS::btnConfirmarSlotImportacao:
      Confirmar(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, m_editModeSlotImportacao, m_AllowEditingSlotImportacao, GRIDS::slotImportacao);
      break;

    case BUTTONS_ACTIONS::btnCancelarPatioExportacao:
      CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioExportacao, cdsExportacaoPatio, cxgExportacaoPatioDBTableView1, m_editModePatioExportacao, m_AllowEditingPatioExportacao);
      break;

    case BUTTONS_ACTIONS::btnCancelarSlotExportacao:
      if (m_editModeSlotExportacao)
      {
        CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, cxgExportacaoSlotsDBTableView1, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
      }
      else
      {
        ExibirLinhas(false, true);
      }
      break;

    case BUTTONS_ACTIONS::btnCancelarPatioImportacao:
      CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioImportacao, cdsImportacaoPatio, cxgImportacaoPatioDBTableView1, m_editModePatioImportacao, m_AllowEditingPatioImportacao);
      break;

    case BUTTONS_ACTIONS::btnCancelarSlotImportacao:
      if (m_editModeSlotImportacao)
      {
        CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, cxgImportacaoSlotsDBTableView1, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
      }
      else
      {
        ExibirLinhas(false, false);
      }
      break;

    default:
      break;
  }
}

void __fastcall TFormParametrosSistema::ExportacaoPatioCellClick()
{
  LimparGridSlotExportacao();
  PreencherSlotsPorPatioSelecionado(true);

  if(!m_editModePatioExportacao && !TTPFormsManager::getInstance()->ShowVisualizador)
  {
    SetNavigatorButtonsPatioExportacao(true, true, false, false);
    SetNavigatorButtonsSlotExportacao(true, false, false, false);
  }
}

void __fastcall TFormParametrosSistema::ExportacaoSlotsCellClick()
{
  if(!m_editModeSlotExportacao && !TTPFormsManager::getInstance()->ShowVisualizador)
  {
    //SetNavigatorButtonsSlotExportacao(true, true, false, false);


    if (!chkDesativarGestaoFilaExportacao->Checked)
    {
      m_editModeSlotExportacao = true;
      SetNavigatorButtonsSlotExportacao(true, true, true, true);
      //m_AllowEditingSlotExportacao = true;
      m_AllowEditingSlotExportacao = true;
      cxgExportacaoSlotsDBTableView1->OptionsData->Editing = true;

    }
    else
    {
      m_AllowEditingSlotExportacao = false;
      cxgExportacaoSlotsDBTableView1->OptionsData->Editing = false;
    }

  }
  else
  {
  }
}

void __fastcall TFormParametrosSistema::ImportacaoPatioCellClick()
{
  LimparGridSlotImportacao();
  PreencherSlotsPorPatioSelecionado(false);

  if(!m_editModePatioImportacao && !TTPFormsManager::getInstance()->ShowVisualizador)
  {
    SetNavigatorButtonsPatioImportacao(true, true, false, false);
    SetNavigatorButtonsSlotImportacao(true, false, false, false);
  }
}

void __fastcall TFormParametrosSistema::ImportacaoSlotsCellClick()
{
  if(!m_editModeSlotImportacao && !TTPFormsManager::getInstance()->ShowVisualizador)
  {
    m_editModeSlotImportacao = true;
    if ( !chkDesativarGestaoFilaImportacao->Checked)
    {
      SetNavigatorButtonsSlotImportacao(true, true, true, true);
      //ConfigEditing();
    }
  }
}

void __fastcall TFormParametrosSistema::IniciarEdicao(FuncPtr navigationButtons, TClientDataSet *cds, bool &editMode, bool &allowEditing) {
  editMode = true;
  allowEditing = true;

  cds->Append();
  cds->Edit();

  (this->*navigationButtons)(false, false, true, true);
}

void __fastcall TFormParametrosSistema::Confirmar(FuncPtr navigationButtons, TClientDataSet *cds, bool &editMode, bool &allowEditing, GRIDS grid) {
  // Confirmar edio
  if (editMode) {
    editMode = false;
    //allowEditing = false;
    bool isExportacao2;
    try
    {
      if (cds->State == dsEdit || cds->State == dsInsert)
      {
        String cellValue;
        String patioRef;
        String PIDFilaRef;
        Fila fila;
        bool isPatio = false;
        bool isExportacao = false;

        switch (grid)
        {
          case GRIDS::patioExportacao:
            isPatio = true;
            fila.isExportacao = true;
            isExportacao = true;
            break;

          case GRIDS::slotExportacao:
            cellValue = cds->Fields->Fields[1]->Text;
            patioRef = cdsExportacaoPatio->Fields->Fields[0]->Text;
            PIDFilaRef= cdsExportacaoPatio->Fields->Fields[1]->Text;
            isExportacao = true;
            break;

          case GRIDS::patioImportacao:
            isPatio = true;
            fila.isExportacao = false;
            isExportacao = false;
            break;

          case GRIDS::slotImportacao:
            cellValue = cds->Fields->Fields[1]->Text;
            patioRef = cdsImportacaoPatio->Fields->Fields[0]->Text;
            PIDFilaRef= cdsImportacaoPatio->Fields->Fields[1]->Text;
            isExportacao = false;
            break;

          default:
            break;
        }

        if(isPatio)
        {
          cellValue = cds->Fields->Fields[0]->Text;

          if (!ExistePatio(filas, cellValue, isExportacao,PIDFilaRef))
          {
            if(cellValue == "")
            {
              if(isExportacao)
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioExportacao, cdsExportacaoPatio, cxgExportacaoPatioDBTableView1, m_editModePatioExportacao, m_AllowEditingPatioExportacao);
              }
              else
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioImportacao, cdsImportacaoPatio, cxgImportacaoPatioDBTableView1, m_editModePatioImportacao, m_AllowEditingPatioImportacao);
              }

              ShowMessage("No  possvel inserir um patio vazio.");
            }
            else
            {
              fila.patio = cellValue;
              fila.PID = String(this->getMaiorSequencialFilaCriado());//  TDAO::PIDFactor("T_FILA_NCSD_TERM");
              cds->Fields->Fields[1]->Text = fila.PID;
              fila.isAlterado = true;
              fila.isAtivo = true;
              fila.tempoCadenciamento = m_tpCdnc;
              filas.push_back(fila);
              cds->Post();
              ConfigEditingSlot();
            }
          }
          else
          {
            if(isExportacao)
            {
              CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioExportacao, cdsExportacaoPatio, cxgExportacaoPatioDBTableView1, m_editModePatioExportacao, m_AllowEditingPatioExportacao);
            }
            else
            {
              CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsPatioImportacao, cdsImportacaoPatio, cxgImportacaoPatioDBTableView1, m_editModePatioImportacao, m_AllowEditingPatioImportacao);
            }

            ShowMessage("Esse patio j existe.");
          }
        }
        else
        {
          if (!ExisteSlotEmFila(filas, patioRef, isExportacao, cellValue,PIDFilaRef))
          {

            if ( VerificaSlotDestinoFila (filas, patioRef, isExportacao, cellValue,PIDFilaRef))
            {
                 if(isExportacao)
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, cxgExportacaoSlotsDBTableView1, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
              }
              else
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, cxgImportacaoSlotsDBTableView1, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
              }

              ShowMessage("No  possivel cadastrar Slot  igual ao destino da Fila");
            }
            else if(cellValue == "")
            {
              if(isExportacao)
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, cxgExportacaoSlotsDBTableView1, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
              }
              else
              {
                CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, cxgImportacaoSlotsDBTableView1, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
              }

              ShowMessage("No  possvel inserir um slot vazio");
            }
            else
            {
              if (!(cds->State == dsEdit))
              {
                int sequencia = inserirSlotEmPatio(filas, patioRef, isExportacao, cellValue,PIDFilaRef);
                cds->Fields->Fields[0]->AsInteger = sequencia;
                cds->Post();
              }
              else
              {
                int sequencia = cds->Fields->Fields[0]->AsInteger;
                alterarSlotEmPatio(filas, patioRef, isExportacao, cellValue, sequencia,PIDFilaRef);
                cds->Post();  // Aqui ver com Nicolas
              }
            }
          }
          else
          {
            if(isExportacao)
            {
              CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, cxgExportacaoSlotsDBTableView1, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
            }
            else
            {
              CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, cxgImportacaoSlotsDBTableView1, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
            }

            ShowMessage("Esse slot j existe.");
            //m_editModeSlotExportacao = false;
            ConfigEditingSlot();


          }
        }
      }
      else
      {
        ShowMessage("Nenhuma alterao a ser salva");
      }
    }
    catch (Exception &e)
    {
      ShowMessage("Erro ao salvar as alteraes: " + e.Message);
    }
  }
  // Confirmar deletar
  else
  {
    String cellValue;
    String patioRef;
    String PIDFilaRef;
    bool isPatio;
    bool isExportacao = false;
    switch (grid)
    {
      case GRIDS::patioExportacao:
        cellValue = cds->Fields->Fields[0]->Text;
        PIDFilaRef =cds->Fields->Fields[1]->Text;
        DeletarPatio(filas, cellValue, true,PIDFilaRef);
        LimparGridSlotExportacao();
        isPatio = true;
        isExportacao = true;
        break;

      case GRIDS::slotExportacao:
        cellValue = cds->Fields->Fields[1]->Text;
        patioRef = cdsExportacaoPatio->Fields->Fields[0]->Text;
        PIDFilaRef =cdsExportacaoPatio->Fields->Fields[1]->Text;
        isPatio = false;
        isExportacao = true;
        break;

      case GRIDS::patioImportacao:
        cellValue = cds->Fields->Fields[0]->Text;
        PIDFilaRef =cds->Fields->Fields[1]->Text;
        DeletarPatio(filas, cellValue, false,PIDFilaRef);
        LimparGridSlotImportacao();
        isPatio = true;
        isExportacao = false;
        break;

      case GRIDS::slotImportacao:
        cellValue = cds->Fields->Fields[1]->Text;
        patioRef = cdsImportacaoPatio->Fields->Fields[0]->Text;
        DeletarSlotEmPatio(filas, patioRef, false, cellValue);
        isPatio = false;
        isExportacao = false;
        break;

      default:
        break;
    }

    ExcluirLinhaMarcada(cds, cellValue, isPatio, isExportacao);

    //cds->Delete();
  }

  (this->*navigationButtons)(true, false, false, false);
}

void __fastcall TFormParametrosSistema::CancelarEdicao(FuncPtr navigationButtons, TClientDataSet *cds, TcxGridDBTableView *tableView,  bool &editMode, bool &allowEditing)
{
  editMode = false;
  allowEditing = false;

  if(tableView->Controller->EditingController->Edit != NULL)
  {
    tableView->Controller->EditingController->Edit->PostEditValue();
  }

  tableView->Controller->EditingController->HideEdit(true);
  cds->Cancel();

  (this->*navigationButtons)(true, false, false, false);
}

void __fastcall TFormParametrosSistema::LimparGridSlotExportacao()
{
  if(m_editModeSlotExportacao)
  {
    CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotExportacao, cdsExportacaoSlots, cxgExportacaoSlotsDBTableView1, m_editModeSlotExportacao, m_AllowEditingSlotExportacao);
  }

  try
  {
    cdsExportacaoSlots->EmptyDataSet();
  }
  catch (Exception &e)
  {
    ShowMessage("Erro ao limpar o dataset: " + e.Message);
  }
}

void __fastcall TFormParametrosSistema::LimparGridSlotImportacao()
{
  if(m_editModeSlotImportacao)
  {
    CancelarEdicao(&TFormParametrosSistema::SetNavigatorButtonsSlotImportacao, cdsImportacaoSlots, cxgImportacaoSlotsDBTableView1, m_editModeSlotImportacao, m_AllowEditingSlotImportacao);
  }

  try
  {
    cdsImportacaoSlots->EmptyDataSet();
  }
  catch (Exception &e)
  {
    ShowMessage("Erro ao limpar o dataset: " + e.Message);
  }
}

int __fastcall TFormParametrosSistema::inserirSlotEmPatio(std::vector<Fila>& filaToInsert, const String& patio, bool isExportacao, const String& slotName,String PIDFila)
{

  

  for (size_t i = 0; i < filaToInsert.size(); ++i)
  {
//    if (filaToInsert[i].patio == patio && filaToInsert[i].isExportacao == isExportacao)
    if (filaToInsert[i].PID == PIDFila)
    {
      int nextSequencia = 1;

      if (!filaToInsert[i].slots.empty())
      {
        Slot atualizaSequencia = filaToInsert[i].slots.back();
        int cont = filaToInsert[i].slots.size()-1;
        while(atualizaSequencia.indicadorDel)
        {
          atualizaSequencia = filaToInsert[i].slots[cont];
          cont--;
        }
        nextSequencia = atualizaSequencia.sequencia + 1;
      }

      Slot novoSlot = { nextSequencia, slotName };

      novoSlot.PID = "";
      novoSlot.indicadorDel = false;
      filaToInsert[i].isAlterado = true;

      filaToInsert[i].slots.push_back(novoSlot);

      return nextSequencia;
    }
  }
}

void __fastcall TFormParametrosSistema::alterarSlotEmPatio(std::vector<Fila>& filaToAlter, const String& patio, bool isExportacao, const String& slotName, int sequenciaToAlter,String PIDFila)
{
   using namespace domain;
 

  for (size_t i = 0; i < filaToAlter.size(); ++i)
  {
//    if (filaToAlter[i].patio == patio && filaToAlter[i].isExportacao == isExportacao)
    if (filaToAlter[i].PID == PIDFila)
    {
      if (!filaToAlter[i].slots.empty())
      {
        Fila* fila = &filaToAlter[i];
        for(unsigned int j = 0; j < fila->slots.size(); j++)
        {
          Slot *toAlter = &fila->slots[j];
          if(toAlter->sequencia == sequenciaToAlter)
          {
            toAlter->slot = slotName;
            fila->isAlterado = true;
            break;
          }
        }
      }
    }
  }
}

bool __fastcall TFormParametrosSistema::DeletarSlotEmPatio(std::vector<Fila>& filaToDelete, const String& patio, bool isExportacao, const String& slotName)
{
    using namespace domain;

 for (std::vector<Fila>::iterator filaIt = filaToDelete.begin(); filaIt != filaToDelete.end(); ++filaIt)
  {
    if (filaIt->patio == patio && filaIt->isExportacao == isExportacao)
    {
      std::vector<Slot>& slots = filaIt->slots;
      for (std::vector<Slot>::iterator slotIt = slots.begin(); slotIt != slots.end(); /* note no increment here*/)
      {
        if (slotIt->slot == slotName && !slotIt->indicadorDel)
        {
          filaIt->isAlterado = true;
          slotIt->indicadorDel = true;
          break;
        }
        ++slotIt; // Apenas incrementa se no excluir
      }
        // Reindexar os slots restantes
      int sequencia = 0;
      int contadorSequencia = 0;
      for (std::vector<Slot>::iterator reindexIt = slots.begin(); reindexIt != slots.end(); ++reindexIt)
      {
        if(!reindexIt->indicadorDel)
        {
          reindexIt->sequencia = ++sequencia;
//          contadorSequencia++;
        }
        else
          reindexIt->sequencia = reindexIt->sequencia;
      }

      //Caso tentar deletar ultimo slot da fila
      if(sequencia == 0)
      {
        ShowMessage("ltimo slot da fila deletado!");
        return true;
      }

      return false; // Sair da funo aps excluir e reindexar

    }
  }

}

void __fastcall TFormParametrosSistema::DeletarPatio(std::vector<Fila>& filaToDelete, const String& patio, bool isExportacao,String PIDFila)
{

  for (std::vector<Fila>::iterator filaIt = filaToDelete.begin(); filaIt != filaToDelete.end(); ++filaIt)
  {
//    if (filaIt->patio == patio && filaIt->isExportacao == isExportacao)
    if (filaIt->PID ==  PIDFila)
    {
      if (!ExistePatio(filasDeletadas, patio, isExportacao,PIDFila))
      {
        if(filaIt->PID.Length() >= 15)//ja persistido na base
          filasDeletadas.push_back(*filaIt);
      }

      filaToDelete.erase(filaIt);
      return;
    }
  }
}

bool __fastcall TFormParametrosSistema::ExistePatio(const std::vector<Fila>& filas, const String& patio, bool isExportacao,String PIDFila)
{
  for (std::vector<Fila>::const_iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt)
  {
    if (filaIt->patio == patio && filaIt->isExportacao == isExportacao)
      return true;
  }

  //REFACTOR ExistePatio
//  TStringList* dummyList;
//  for(int i = 0; i < dummyList->Count; i++)
//  {
//    FilaDemandaTerminal* fdt = (FilaDemandaTerminal*)dummyList->Objects[i];
//    bool fdtIsExprt = false;
//
//    if(fdt->getTipoSentidoFila() == FilaDemandaTerminal::SENTIDO_EXPORTACAO)
//      fdtIsExprt = true;
//
//    if(fdtIsExprt == isExportacao)
//    {
//      if(fdt->patioDestino->sigla == patio)
//        return true;
//    }
//    else
//    {
//      if(fdt->patioOrigem->sigla == patio)
//        return true;
//    }
//
//  }

  return false;
}

bool __fastcall TFormParametrosSistema::ExisteSlotEmFila(const std::vector<Fila>& filas, const String& patio, bool isExportacao, const String& slotName,String PIDFila)
{
  for (std::vector<Fila>::const_iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt)
  {
//    if (filaIt->patio == patio && filaIt->isExportacao == isExportacao)
    if (filaIt->PID == PIDFila)
    {
      for (std::vector<Slot>::const_iterator slotIt = filaIt->slots.begin(); slotIt != filaIt->slots.end(); ++slotIt)
      {
        if (slotIt->slot == slotName && !slotIt->indicadorDel)
        {
          return true;
        }
      }
    }
  }

  //REFACTOR ExisteSlotEmFila
//  for(int i = 0; i < listaFilaServer->Count; i++)
//  {
//    FilaDemandaTerminal* fdt = (FilaDemandaTerminal*)listaFilaServer->Objects[i];
//    bool fdtIsExprt = false;
//    bool checkPatio = false;
//
//    if(fdt->getTipoSentidoFila() == FilaDemandaTerminal::SENTIDO_EXPORTACAO)
//      fdtIsExprt = true;
//
//    if(fdtIsExprt == isExportacao)
//    {
//      if(fdt->patioDestino->sigla == patio)
//        checkPatio = true;
//    }
//    else
//    {
//      if(fdt->patioOrigem->sigla == patio)
//        checkPatio = true;
//    }
//
//    if(!checkPatio)
//      continue;
//
//    for(int j = 0; j < fdt->slotsFila->Count; j++)
//    {
//      SlotDemandaTerminal* sdt = (SlotDemandaTerminal*)fdt->slotsFila->Objects[j];
//      if(sdt->slot->sb == slotName)
//        return true;
//    }
//
//  }

  return false;
}

void __fastcall TFormParametrosSistema::PreencherSlotsPorPatioSelecionado(bool isExportacao)
{
  std::vector<Slot> currentSlot;
  String patioSelecionado;
  String PID;

  if(isExportacao)
  {
    patioSelecionado = cdsExportacaoPatioDestino->Text;
    PID = cdsExportacaoPatioPIDFila->Text;
  }
  else
  {
    patioSelecionado = cdsImportacaoPatioOrigem->Text;
    PID = cdsImportacaoPatioPIDFila->Text;
  }

  //REFACTOR PreencherSlotsPorPatioSelecionado
//  for(int i = 0; i < listaFilaServer->Count; i++)
//  {
//    FilaDemandaTerminal* fdt = (FilaDemandaTerminal*)listaFilaServer->Objects[i];
//    bool filaExp = false;
//
//    if(fdt->getTipoSentidoFila() == FilaDemandaTerminal::SENTIDO_EXPORTACAO)
//      filaExp = true;
//
//    if(filaExp == isExportacao)
//    {
//      if(fdt->patioDestino->sigla == patioSelecionado)
//      {
//        cxgExportacaoSlotsDBTableView1->DataController->RecordCount = 0;
//
//        for(int j = 0; j < fdt->slotsFila->Count; j++)
//        {
//          SlotDemandaTerminal * sdt = (SlotDemandaTerminal*)fdt->slotsFila->Objects[j];
//          cxgExportacaoSlotsDBTableView1->DataController->AppendRecord();
//          SelecionaComboBoxItemSlot(sdt->slot->sb.c_str()	, isExportacao, sdt->sequencia);
//        }
//        break;
//      }
//    }
//    else
//    {
//      if(fdt->patioOrigem->sigla == patioSelecionado)
//      {
//        cxgImportacaoSlotsDBTableView1->DataController->RecordCount = 0;
//
//        for(int k = 0; k < fdt->slotsFila->Count; k++)
//        {
//          SlotDemandaTerminal * sdt = (SlotDemandaTerminal*)fdt->slotsFila->Objects[k];
//          cxgImportacaoSlotsDBTableView1->DataController->AppendRecord();
//          SelecionaComboBoxItemSlot(sdt->slot->sb.c_str()	, isExportacao, sdt->sequencia);
//        }
//        break;
//      }
//    }
//
//  }

  for (std::vector<Fila>::iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt)
  {
//    if (filaIt->patio == patioSelecionado && filaIt->isExportacao == isExportacao)
    if (filaIt->PID == PID)
    {
      currentSlot = filaIt->slots;
      if (!currentSlot.empty())
      {

        if (isExportacao)
        {
          cxgExportacaoSlotsDBTableView1->DataController->RecordCount = 0;
        }
        else
        {
          cxgImportacaoSlotsDBTableView1->DataController->RecordCount = 0;
        }

        int rowIndex = 0;
        for (std::vector<Slot>::iterator slotIt = currentSlot.begin(); slotIt != currentSlot.end(); ++slotIt)
        {
          if(slotIt->indicadorDel)
            continue;
          if (isExportacao)
          {
            cxgExportacaoSlotsDBTableView1->DataController->AppendRecord();
          }
          else
          {
            cxgImportacaoSlotsDBTableView1->DataController->AppendRecord();
          }

          SelecionaComboBoxItemSlot(slotIt->slot.c_str(), isExportacao, slotIt->sequencia);
        }
      }
      break;
    }
  }
}

void __fastcall TFormParametrosSistema::SelecionaComboBoxItemPatio(const UnicodeString &itemText, bool isExportacao,Fila fila)
{
  if (isExportacao)
  {
    if (cdsExportacaoPatio->State != dsEdit && cdsExportacaoPatio->State != dsInsert)
    {
      cdsExportacaoPatio->Edit();
    }

    cdsExportacaoPatio->Close();
    cdsExportacaoPatio->Open();

    cdsExportacaoPatio->Append();
    cdsExportacaoPatioPIDFila->Text = fila.PID;
    cdsExportacaoPatioDestino->Text =  itemText;
    cdsExportacaoPatio->Post();
  }
  else
  {
    if (cdsImportacaoPatio->State != dsEdit && cdsImportacaoPatio->State != dsInsert)
    {
      cdsImportacaoPatio->Edit();
    }

    cdsImportacaoPatio->Close();
    cdsImportacaoPatio->Open();

    cdsImportacaoPatio->Append();
    cdsImportacaoPatioPIDFila->Text = fila.PID;
    cdsImportacaoPatioOrigem->Text =  itemText;
    cdsImportacaoPatio->Post();
  }
}
void __fastcall TFormParametrosSistema::SelecionaComboBoxItemSlot(const UnicodeString &itemText, bool isExportacao, int sequencia)
{
  if (isExportacao)
  {
    if (cdsExportacaoSlots->State != dsEdit && cdsExportacaoSlots->State != dsInsert)
    {
      cdsExportacaoSlots->Edit();
    }

    cdsExportacaoSlots->Close();
    cdsExportacaoSlots->Open();

    cdsExportacaoSlots->Append();
    cdsExportacaoSlotsSequencia->Text =  sequencia;
    cdsExportacaoSlotsSlots->Text =  itemText;
    cdsExportacaoSlots->Post();
  }
  else
  {
    if (cdsImportacaoSlots->State != dsEdit && cdsImportacaoSlots->State != dsInsert)
    {
      cdsImportacaoSlots->Edit();
    }

    cdsImportacaoSlots->Close();
    cdsImportacaoSlots->Open();

    cdsImportacaoSlots->Append();
    cdsImportacaoSlotsSequencia->Text =  sequencia;
    cdsImportacaoSlotsSlots->Text =  itemText;
    cdsImportacaoSlots->Post();
  }
}

bool __fastcall TFormParametrosSistema::CarregarFilaServer()
{
#ifdef BAIXADA_SANTISTA
  listaFilaServer = m_core->getInstance()->getFilasDemandaTerminal();
  listaFilasDeletadasServer = m_core->getInstance()->getFilasDeletadasDemandaTerminal();
  bool ativoExport = false;
  bool ativoImport = false;
  int tpCdnc = 0;
  for (int i = 0; i < listaFilaServer->Count; ++i)
  {
    FilaDemandaTerminal* filaServer = (FilaDemandaTerminal*)listaFilaServer->Objects[i];

    TStringList* slotsServer = filaServer->slotsFila;
    Fila filaLocal;
    std::vector<Slot> slotsLocal;

    filaLocal.PID = filaServer->PID;

   for (int j = 0; j < slotsServer->Count; ++j)
    {
      SlotDemandaTerminal* slot = (SlotDemandaTerminal*)slotsServer->Objects[j];
      Slot slotLocal;
      if(slot->indicadorDel)
        continue;
      slotLocal.sequencia = slot->sequencia;
      slotLocal.slot = slot->slot->sb;
      slotLocal.indicadorDel = false;
      if(slot->PID.Length()	< 15)
        slotLocal.PID = "";
      else
        slotLocal.PID = slot->PID;
      slotsLocal.push_back(slotLocal);
    }

    filaLocal.slots = slotsLocal;

    if(filaServer->tipoSentidoFila == FilaDemandaTerminal::SENTIDO_EXPORTACAO)
    {
      filaLocal.isExportacao = true;
      filaLocal.patio = filaServer->patioDestino->sigla;
      filaLocal.isAtivo = filaServer->getIsAtivo();
      filaLocal.tempoCadenciamento = filaServer->tempoCadenciamento;
      ativoExport = filaLocal.isAtivo;
    }
    else
    {
      filaLocal.isExportacao = false;
      filaLocal.patio = filaServer->patioOrigem->sigla;
      filaLocal.isAtivo = filaServer->getIsAtivo();
      filaLocal.tempoCadenciamento = filaServer->tempoCadenciamento;
      tpCdnc = filaLocal.tempoCadenciamento;
      ativoImport = filaLocal.isAtivo;
    }

    //filaLocal.patio = filaServer->patioDestino->sigla;
    filaLocal.isAlterado = false;

    filas.push_back(filaLocal);
  }

  if(TTPFormsManager::getInstance()->ShowVisualizador)
  {
    chkDesativarGestaoFilaExportacao->Checked = !ativoExport;
    chkDesativarGestaoFilaImportacao->Checked = !ativoImport;
    FieldTPCadenciamento->Text = tpCdnc;
  }

  if(!filas.empty())
  {
    return true;
	}
  #endif
	return false;
}

void __fastcall TFormParametrosSistema::PreencherGrids()
{
  cxgExportacaoSlotsDBTableView1->DataController->RecordCount = 0;
  cxgExportacaoPatioDBTableView1->DataController->RecordCount = 0;
  cxgImportacaoSlotsDBTableView1->DataController->RecordCount = 0;
  cxgExportacaoPatioDBTableView1->DataController->RecordCount = 0;

  //REFACTOR PreencherGrids
//  for(int i = 0; i < listaFilaServer->Count; i++)
//  {
//    FilaDemandaTerminal* fdt = (FilaDemandaTerminal*)listaFilaServer->Objects[i];
//
//    String patio = "";
//    bool isExportacao = false;
//
//    if(fdt->getTipoSentidoFila() == FilaDemandaTerminal::SENTIDO_EXPORTACAO)
//    {
//      patio = fdt->patioDestino->sigla;
//      isExportacao = true;
//    }
//    else
//    {
//      patio = fdt->patioOrigem->sigla;
//      isExportacao = false;
//    }
//
//    SelecionaComboBoxItemPatio(patio, isExportacao);
//  }

  for (std::vector<Fila>::iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt) {
    String patio = filaIt->patio;
    bool isExportacao = filaIt->isExportacao;

    if(isExportacao)
    {
      SelecionaComboBoxItemPatio(patio, true,*filaIt);
    }
    else
    {
      SelecionaComboBoxItemPatio(patio, false,*filaIt);
    }
  }
}

void __fastcall TFormParametrosSistema::InserirItensServer(const std::vector<Fila>& filas, TStringList* listaFilaServer)
{
  for (size_t i = 0; i < filas.size(); ++i)
  {
    const domain::Fila& fila = filas[i];

    // Verifica se a fila j est no servidor
    int index = VerificaItemNoServer(fila, listaFilaServer);

    if (index != -1)
    {
      // Atualiza o indicador e os slots se a fila foi alterada
      FilaDemandaTerminal* filaExistenteNoServer = (FilaDemandaTerminal*)listaFilaServer->Objects[index];
      filaExistenteNoServer->tempoCadenciamento = m_tpCdnc;

      if (fila.isAlterado)
      {
        filaExistenteNoServer->indicadorAltr = true;
        filaExistenteNoServer->limparSlotDemandaTerminal();

        for (size_t j = 0; j < fila.slots.size(); ++j)
        {
          SlotDemandaTerminal* slotTerminal = new SlotDemandaTerminal();
          const domain::Slot& slot = fila.slots[j];
          slotTerminal->PID = slot.PID;
          slotTerminal->sequencia = slot.sequencia;
          slotTerminal->slot = m_core->getInstance()->getSBPorSigla(slot.slot);
          slotTerminal->indicadorDel = slot.indicadorDel;

          filaExistenteNoServer->slotsFila->AddObject(slotTerminal->PID, (TObject*)slotTerminal);
        }
      }
    }
    else
    {
      // Adiciona uma nova fila se no estiver no servidor
      FilaDemandaTerminal* filaTerminal = new FilaDemandaTerminal();
      filaTerminal->slotsFila = new TStringList();

      filaTerminal->PID = fila.PID;

      for (size_t j = 0; j < fila.slots.size(); ++j)
      {
        SlotDemandaTerminal* slotTerminal = new SlotDemandaTerminal();
        const domain::Slot& slot = fila.slots[j];

        slotTerminal->sequencia = slot.sequencia;
        slotTerminal->slot = m_core->getInstance()->getSBPorSigla(slot.slot);
        slotTerminal->PID = slot.PID;
        filaTerminal->slotsFila->AddObject(slotTerminal->PID, (TObject*)slotTerminal);
      }

      if (fila.isExportacao)
      {
        filaTerminal->patioOrigem  = m_core->getInstance()->getPatioPorSigla("ZPG");
        filaTerminal->patioDestino = m_core->getInstance()->getPatioPorSigla(fila.patio);
        filaTerminal->tipoSentidoFila = FilaDemandaTerminal::SENTIDO_EXPORTACAO;
      }
      else
      {
        //filaTerminal->patioDestino->sigla = ;
        filaTerminal->patioOrigem = m_core->getInstance()->getPatioPorSigla(fila.patio);
        filaTerminal->patioDestino = m_core->getInstance()->getPatioPorSigla("ZPG");
        filaTerminal->tipoSentidoFila = FilaDemandaTerminal::SENTIDO_IMPORTACAO;
      }

      filaTerminal->indicadorAltr = false;
      filaTerminal->setIsAtivo(fila.isAtivo);
      filaTerminal->tempoCadenciamento = m_tpCdnc;
      listaFilaServer->AddObject(filaTerminal->PID, (TObject*)filaTerminal);
    }
  }
}

int __fastcall TFormParametrosSistema::VerificaItemNoServer(const Fila& fila, TStringList* listaFilaServer)
{
//  for (int i = 0; i < listaFilaServer->Count; ++i)
//  {
//    FilaDemandaTerminal* filaExistente = (FilaDemandaTerminal*)listaFilaServer->Objects[i];
//
//    if (filaExistente != NULL)
//    {
//      if (fila.isExportacao)
//      {
//        if (filaExistente->tipoSentidoFila == FilaDemandaTerminal::SENTIDO_EXPORTACAO && filaExistente->patioDestino->sigla == fila.patio)
//        {
//          return i;
//        }
//      }
//      else
//      {
//        if (filaExistente->tipoSentidoFila == FilaDemandaTerminal::SENTIDO_IMPORTACAO && filaExistente->patioOrigem->sigla == fila.patio)
//        {
//          return i;
//        }
//      }
//    }
//  }

//  return -1; // Retorna -1 se no encontrar o item

   return listaFilaServer->IndexOf(fila.PID);
}

void __fastcall TFormParametrosSistema::OcultarLinhaSelecionada(bool isPatio, bool isExportacao, String identificador = "")
{
  String chavePrimaria;
  TClientDataSet* cds;

  if (isPatio)
  {
    cds = isExportacao ? cdsExportacaoPatio : cdsImportacaoPatio;
  }
  else
  {
    cds = isExportacao ? cdsExportacaoSlots : cdsImportacaoSlots;
  }

  if (!cds->Active || cds->IsEmpty())
    return;

  cds->Filtered = false; // Desativa filtros ativos

  if (isPatio)
  {
    if (isExportacao)
    {
      chavePrimaria = cds->FieldByName("Destino")->AsString;
      cds->Filter = "Destino <> " + QuotedStr(chavePrimaria);
    }
    else
    {
      chavePrimaria = cds->FieldByName("Origem")->AsString;
      cds->Filter = "Origem <> " + QuotedStr(chavePrimaria);
    }

  }
  else
  {
    while(!cds->Eof)
    {
      chavePrimaria = cds->FieldByName("Sequencia")->AsString;
      if(chavePrimaria == identificador)
        break;
      cds->Next();
    }

    cds->Filter = "Sequencia <> " + QuotedStr(chavePrimaria);
  }

  cds->Filtered = true; // Ativa o novo filtro

  // Debug: Verificar qual registro est sendo ocultado
  ShowMessage("Ocultando registro com chave primria: " + chavePrimaria);
}

void __fastcall TFormParametrosSistema::ExcluirLinhaSelecionada(bool isPatio, bool isExportacao, String identificador = "")
{
  String chavePrimaria;
  TClientDataSet* cds;

  if (isPatio)
  {
    cds = isExportacao ? cdsExportacaoPatio : cdsImportacaoPatio;
  }
  else
  {
    cds = isExportacao ? cdsExportacaoSlots : cdsImportacaoSlots;
  }

  if (!cds->Active || cds->IsEmpty())
    return;

  //cds->Filtered = false; // Desativa filtros ativos

  if (isPatio)
  {
    if (isExportacao)
    {
      cds->Locate("Destino", identificador, TLocateOptions());
      cds->Delete();
    }
    else
    {
      cds->Locate("Origem", identificador, TLocateOptions());
      cds->Delete();
    }

  }
  else
  {
    if (isExportacao)
    {
      cds->Locate("Sequencia", identificador, TLocateOptions());
      cds->Delete();
    }
    else
    {
      cds->Locate("Sequencia", identificador, TLocateOptions());
      cds->Delete();
    }

    if (cds->Active && !cds->IsEmpty())
    {
        int index = 1; // ndice inicial
        cds->DisableControls(); // Desativa a atualizao de controles visuais para melhorar a performance
        try
        {
            cds->First(); // Move para o primeiro registro
            while (!cds->Eof)
            {
                // Edita o registro atual
                cds->Edit();
                cds->FieldByName("sequencia")->AsInteger = index;
                cds->Post(); // Confirma a edio

                index++; // Incrementa o ndice
                cds->Next(); // Move para o prximo registro
            }
        }
        __finally
        {
            cds->EnableControls(); // Reativa a atualizao de controles visuais
        }
    }
  }





  // Debug: Verificar qual registro est sendo ocultado
  //ShowMessage("Ocultando registro com chave primria: " + chavePrimaria);
}

void __fastcall TFormParametrosSistema::ExibirLinhas(bool isPatio, bool isExportacao)
{
  TClientDataSet* cds;

  if (isPatio)
  {
    cds = isExportacao ? cdsExportacaoPatio : cdsImportacaoPatio;
  }
  else
  {
    cds = isExportacao ? cdsExportacaoSlots : cdsImportacaoSlots;
  }

  if (!cds->Active || cds->IsEmpty())
    return;

  // Remove o filtro para exibir todas as linhas novamente
  cds->Filtered = false;
}

void __fastcall TFormParametrosSistema::ExcluirLinhaMarcada(TClientDataSet *cds, const String& identificador, bool isPatio, bool isExportacao)
{
//    cds->First();
//    while (!cds->Eof)
//    {
//        if (isPatio)
//        {
//            if (cds->FieldByName("Patio")->AsString == identificador)
//            {
//                cds->Delete();
//                break;
//            }
//        }
//        else
//        {
//            if (cds->FieldByName("Sequencia")->AsString == identificador)
//            {
//                cds->Delete();
//                break;
//            }
//        }
//        cds->Next();
//    }

//  cds->First();
//  while (!cds->Eof)
//  {
//    bool encontrado = false;
//
//    if (isPatio)
//    {
//      if (cds->FieldByName("Patio")->AsString == identificador)
//      {
//        encontrado = true;
//      }
//    }
//    else
//    {
//      if (cds->FieldByName("Sequencia")->AsString == identificador)
//      {
//        encontrado = true;
//      }
//    }
//
//    if (encontrado)
//    {
//      cds->Delete();
//      break; // Adiciona um break para sair do loop aps a excluso
//    }
//
//    cds->Next();
//  }


//  cds->First();
//  while (!cds->Eof)
//  {
//    bool encontrado = false;
//
//    if (isPatio)
//    {
//      if (cds->FieldByName("Patio")->AsString == identificador)
//      {
//        encontrado = true;
//      }
//    }
//    else
//    {
//      if (cds->FieldByName("Sequencia")->AsString == identificador)
//      {
//        encontrado = true;
//      }
//    }
//
//    if (encontrado)
//    {
//      cds->Delete();
//      break; // Adiciona um break para sair do loop aps a excluso
//    }
//
//    cds->Next();
//  }
//
//  // Reindexar os registros aps a excluso
//  if (!isPatio)
//  {
//    cds->First();
//    int sequencia = 1;
//    while (!cds->Eof)
//    {
//      cds->Edit();
//      cds->FieldByName("Sequencia")->AsInteger = sequencia;
//      cds->Post();
//      cds->Next();
//
//      sequencia++;
//    }
//  }


  cds->First();
  bool registroExcluido = false;

  while (!cds->Eof)
  {
    bool encontrado = false;

    if (isPatio)
    {
      if (isExportacao)
      {
        if (cds->FieldByName("Destino")->AsString == identificador)
        {
          encontrado = true;
        }
      }
      else
      {
        if (cds->FieldByName("Origem")->AsString == identificador)
        {
          encontrado = true;
        }
      }

    }
    else
    {
      if (cds->FieldByName("Sequencia")->AsString == identificador)
      {
        encontrado = true;
      }
    }

    if (encontrado)
    {
      cds->Delete();
      registroExcluido = true;

      // AKI atualizar os slots associados ao ptio.


      break; // Sair do loop aps excluir o registro
    }

    cds->Next();
  }

  // Reindexar os registros aps a excluso
  if (!isPatio && registroExcluido)
  {
    cds->First();
    int sequencia = 1;
    while (!cds->Eof)
    {
      cds->Edit();
      cds->FieldByName("Sequencia")->AsInteger = sequencia++;
      cds->Post();
      cds->Next();
    }
  }

  // Debug: Verificar reindexao
  if (registroExcluido)
  {
//    cds->First();
//    while (!cds->Eof)
//    {
//      ShowMessage("Registro: " + cds->FieldByName("Sequencia")->AsString);
//      cds->Next();
//    }
  }

}

#pragma end_region



//---------------------------------------------------------------------------
void __fastcall TFormParametrosSistema::ExportacaoSlotsDoubleCellClick()
{
//  if(!m_editModeSlotExportacao)
//  {
//    m_editModeSlotExportacao = true;
//    SetNavigatorButtonsSlotExportacao(true, true, true, false);
//  }
}


void __fastcall TFormParametrosSistema::chkDesativarGestaoFilaExportacaoClick(TObject *Sender)

{
  if (chkDesativarGestaoFilaExportacao->Checked)
  {
    btnInserirPatioExportacao->Enabled = false;
    btnExcluirPatioExportacao->Enabled = false;
    btnConfirmarPatioExportacao->Enabled = false;
    btnCancelarPatioExportacao->Enabled = false;

    btnInserirSlotExportacao->Enabled = false;
    btnExcluirSlotExportacao->Enabled = false;
    btnConfirmarSlotExportacao->Enabled = false;
    btnCancelarSlotExportacao->Enabled = false;
    m_editModeSlotExportacao = true;

//    try
//    {
//      cdsExportacaoSlots->EmptyDataSet();
//    }
//    catch (Exception &e)
//    {
//      ShowMessage("Erro ao limpar o dataset: " + e.Message);
//    }


  }
  else
  {
    if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
    {

      btnInserirPatioExportacao->Enabled = true;
  //    btnExcluirPatioExportacao->Enabled = true;
  //    btnConfirmarPatioExportacao->Enabled = true;
  //    btnCancelarPatioExportacao->Enabled = true;

  //    btnExcluirSlotExportacao->Enabled = false;
  //    btnConfirmarSlotExportacao->Enabled = false;
  //    btnCancelarSlotExportacao->Enabled = false;
      m_editModeSlotExportacao = false;

      m_AllowEditingSlotExportacao = false;
      cxgExportacaoSlotsDBTableView1->OptionsData->Editing = false;
    }


  }
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::chkDesativarGestaoFilaImportacaoClick(TObject *Sender)

{
  if (chkDesativarGestaoFilaImportacao->Checked)
  {
    btnInserirPatioImportacao->Enabled = false;
    btnExcluirPatioImportacao->Enabled = false;
    btnConfirmarPatioImportacao->Enabled = false;
    btnCancelarPatioImportacao->Enabled = false;

    btnInserirSlotImportacao->Enabled = false;
    btnExcluirSlotImportacao->Enabled = false;
    btnConfirmarSlotImportacao->Enabled = false;
    btnCancelarSlotImportacao->Enabled = false;
    m_editModeSlotImportacao = true;

//    try
//    {
//      cdsImportacaoSlots->EmptyDataSet();
//    }
//    catch (Exception &e)
//    {
//      ShowMessage("Erro ao limpar o dataset: " + e.Message);
//    }


  }
  else
  {
    if ((TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista))
    {
      btnInserirPatioImportacao->Enabled = true;
    }
//    btnExcluirSlotImportacao->Enabled = false;
//    btnConfirmarSlotImportacao->Enabled = false;
//    btnCancelarSlotImportacao->Enabled = false;
    m_editModeSlotImportacao = false;

    m_AllowEditingSlotImportacao = false;
    cxgImportacaoSlotsDBTableView1->OptionsData->Editing = false;
    //cxgImportacaoSlotsDBTableView1->OnEditing = cxgImportacaoSlotsDBTableView1Editing;

//    if(CarregarFilaServer())
//    {
//      PreencherGrids();
//    }



  }
}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::cdsExportacaoPatioAfterOpen(TDataSet *DataSet)

{
//    if (cxgExportacaoPatioDBTableView1->DataController->RecordCount > 0)
//    {
//        cxgExportacaoPatioDBTableView1->Controller->FocusedRowIndex = 0;
//    }

//    if (cxgImportacaoPatioDBTableView1->DataController->RecordCount > 0)
//    {
//        cxgImportacaoPatioDBTableView1->Controller->FocusedRowIndex = 0;
//    }
}
int __fastcall TFormParametrosSistema::getMaiorSequencialFilaCriado()
{
  int MaiorSequencia = 0;
  for (std::vector<Fila>::iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt)
  {
     if (filaIt->PID.Length() < 15)
     {
       int valor = filaIt->PID.ToIntDef(-1);
       if ( MaiorSequencia > valor )
        MaiorSequencia++;
       else
        MaiorSequencia =  valor;
     }

  }
  MaiorSequencia++;

  return MaiorSequencia;
}
//---------------------------------------------------------------------------




void __fastcall TFormParametrosSistema::chkAtvOfclzAutoClick(TObject *Sender)
{
  if(!chkAtvOfclzAuto->Checked)
  {
    FieldTPPlnAuto->Enabled = false;
  }
  else
  {
    FieldTPPlnAuto->Enabled = true;
	}


}
//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::chkAtvPlnParcialClick(TObject *Sender)
{
  if(!chkAtvPlnParcial->Checked)
  {
		FieldTPTimeoutPln->Enabled = false;
    FieldTPPlnRslMin->Enabled = false;
  }
  else
	{
    FieldTPTimeoutPln->Enabled = true;
    FieldTPPlnRslMin->Enabled = true;
  }

}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

void __fastcall TFormParametrosSistema::PageControl2Change(TObject *Sender)
{
	TTabSheet *activeTab2 = PageControl2->ActivePage;
		if (activeTab2 != NULL)
		{
			if(PageControl2->ActivePage->TabIndex ==0)
			{
				this->ClientHeight = 430;
			}
			else
			{
				this->ClientHeight = 620;
			}
		}

    int size = 0;
    ResizeComponentByChildSizes((TWinControl*)this,size);
}
bool __fastcall TFormParametrosSistema::VerificaSlotDestinoFila(const std::vector<Fila>& filas, const String& patio, bool isExportacao, const String& slotName,String PIDFila)
{
  for (std::vector<Fila>::const_iterator filaIt = filas.begin(); filaIt != filas.end(); ++filaIt)
  {
    if (filaIt->PID == PIDFila)
    {
      String destinoFila = "";
      if (isExportacao)
      {
        destinoFila = filaIt->patio;
      }
      else
        destinoFila = "ZPG";

      Patio* pp = m_core->getInstance()->getPatioPorSigla(destinoFila);
      if (pp)
      {
        SB* sb = m_core->getInstance()->getSBPorSigla(slotName);
        if ( sb && sb->segmento->patioPertencente == pp)
          return true;
      }
      break;
    }
  }
  return false;
}

//---------------------------------------------------------------------------



void __fastcall TFormParametrosSistema::PageControl1Enter(TObject *Sender)
{

  	// Obter a aba ativa
	TTabSheet *activeTab = PageControl1->ActivePage;

	// Exibir mensagem com o nome da aba ativa
	if (activeTab != NULL)
		{
			if(PageControl1->ActivePage->TabIndex ==0)
			{
				this->ClientWidth = 411;
			}
			else
			{
				this->ClientWidth = 850;
			}
		}
	//this->ClientHeight = 490;

  int size = 0;
    ResizeComponentByChildSizes((TWinControl*)this,size);
}
//---------------------------------------------------------------------------
int TFormParametrosSistema::ResizeComponentByChildSizes(TWinControl *parentControl, int &pMaxWidth)
{
  int maxBottom = 0, addBotton = 0;
  int maxWidth = pMaxWidth;
  TControl* controlMaxBotton;
  //percorre todos os filhos do parent
  for (int i = 0; i < parentControl->ControlCount; i++)
  {
    TControl* Control = parentControl->Controls[i];

    if(!Control->Visible) continue;

    //se o componenete for um checkbox analisa o tamanho dele pelo Caption
    if(dynamic_cast<TCheckBox*>(Control))
    {
      int WidthControl =  Canvas->TextWidth(dynamic_cast<TCheckBox*>(Control)->Caption);
      WidthControl +=Control->ClientToScreen(Point(0,0)).x-this->ClientToScreen(Point(0,0)).x;
      if(maxWidth<WidthControl)
      {
        pMaxWidth = WidthControl;
        maxWidth = pMaxWidth;
      }
    }
    else
    {
      //pega os objetos sem alinhamento "fixo" para ver qual tem a maior righ em tela
      if(Control->Align==alNone || Control->Align==alCustom )
      {
        if(Control->ClientToScreen(Point(Control->Height,0)).x>maxWidth )
        {
          maxWidth =Control->ClientToScreen(Point(Control->Height,0)).x>maxWidth;
        }
      }
    }

    //ignora os componentes com alinhamento ao botton, pegando somente a sua altura, pois a posio deles  ajustada pelo crescimento do componente pai
    if(Control->Align==alBottom)
    {
      addBotton+= Control->Height;
      continue;
    }

    //O tamanho do Page Control tem que ser alterado antes da alterao do tabSheet,
    //mas para saber o tamnho dele  preciso saber qual tamanho tera o tabseheet
    //por isso ele  chamado no recursivo no lugar do page control
    if(dynamic_cast<TPageControl*>(Control))
    {
      TPageControl *PageControl  =  dynamic_cast<TPageControl*>(Control);
      TTabSheet *ActiveTab = PageControl->ActivePage;

      if (dynamic_cast<TWinControl*>(ActiveTab))
      {
        TWinControl* ChildWinControl = dynamic_cast<TWinControl*>(ActiveTab);
        maxWidth = ResizeComponentByChildSizes(ChildWinControl,pMaxWidth);
      }

      int bottom = ActiveTab->Height+ActiveTab->Margins->Top+ActiveTab->Margins->Bottom+50;
      if (bottom > maxBottom)
      {
        maxBottom = bottom;
        controlMaxBotton =  Control;
      }
    }
    else
    {
      //se for qualquer outro compoente basta ser um TWinControl e ser chamamdo no recursivo
      if (dynamic_cast<TWinControl*>(Control))
      {
        TWinControl* ChildWinControl = dynamic_cast<TWinControl*>(Control);

        maxWidth = ResizeComponentByChildSizes(ChildWinControl,pMaxWidth);
      }

      int bottom = Control->Top + Control->Height +Control->Margins->Top/2+Control->Margins->Bottom/2;
      if (bottom > maxBottom)
      {
        maxBottom = bottom;
        controlMaxBotton =  Control;
      }
    }


  }

  if(maxBottom>0)
  {
     //se parent for um TabSheet quem tem que ser alterado  o PageControl
     if(dynamic_cast<TTabSheet*>(parentControl))
     {
       TTabSheet *TabSheetFilho  =  dynamic_cast<TTabSheet*>(parentControl);
       TPageControl *pageControlPai =  TabSheetFilho->PageControl;
       parentControl = dynamic_cast<TWinControl*>(pageControlPai);
       //calcila o quanto tem que ser adicionado no height em funco do cabealho do tabsheet no tabcontrol
       maxBottom += (TabSheetFilho->ClientToScreen(Point(0,0)).y - pageControlPai->ClientToScreen(Point(0,0)).y)*2;
       parentControl->Height = maxBottom +addBotton;
       TabSheetFilho->Height = maxBottom;
     }
     //reajustar apenas se a diferena entre o tamanho atual e o novo for maior que 5 pixel,
     //no consegui resolver o problema das margens no calculo
     if(abs(parentControl->Height - maxBottom +addBotton)>5)
     {
      if(parentControl==this)
       parentControl->ClientHeight = maxBottom +addBotton;
      else
        parentControl->Height = maxBottom +addBotton;
     }


     //verifica se o componente mais ao botton ficou com o botton abaixo do tamanho do parent mais que 5 pixels e realiza o ajuste no tamanho do parent
     int sizeAdd = controlMaxBotton->ClientToParent(Point(0,controlMaxBotton->Top + controlMaxBotton->Height +controlMaxBotton->Margins->Top/2+controlMaxBotton->Margins->Bottom/2)).y;
     sizeAdd -= controlMaxBotton->ClientToParent(Point(0,parentControl->Height)).y;
     if(sizeAdd>5)
     {
       parentControl->Height += sizeAdd;
     }
     sizeAdd = controlMaxBotton->ClientToScreen (Point(0,controlMaxBotton->Top + controlMaxBotton->Height +controlMaxBotton->Margins->Top/2+controlMaxBotton->Margins->Bottom/2)).y;
     sizeAdd -= controlMaxBotton->ClientToScreen(Point(0,this->Height)).y;

      //verifica se o componente mais ao botton ficou com o botton abaixo do tamanho do form mais que 5 pixels  e realiza o ajuste no tamanho do form
     if(sizeAdd>5)
     {
       this->Height += sizeAdd;
     }

     //se for o form o parent ajusta o tamanho da largura com o valor mximo encontrado
     if(parentControl==this && maxWidth > 10)
     {
        this->ClientWidth = maxWidth + 50;
     }
  }
  //retorna o maxWitdh para que possa ser feito o ajuste no form
  return maxWidth;
}
void __fastcall TFormParametrosSistema::FormShow(TObject *Sender)
{
   int size = 0;
   ResizeComponentByChildSizes((TWinControl*)this,size);
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFDetalharPontosFila.h =====
//---------------------------------------------------------------------------

#ifndef UFDetalharPontosFilaH
#define UFDetalharPontosFilaH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include "UDAO.h"
#include "UUteis.h"
#include <Vcl.Mask.hpp>
//---------------------------------------------------------------------------
class TFormDetalharPontosFila : public TForm
{
__published:	// IDE-managed Components
	TPanel *Panel1;
	TPanel *Panel2;
	TPanel *Panel3;
	TPanel *Panel4;
	TPanel *Panel5;
	TPanel *Panel6;
	TButton *btnOk;
	TButton *btnCancelar;
	TPanel *Panel11;
	TLabel *Label1;
	TLabel *Label2;
	TLabel *Label3;
	TLabel *lblTerminalDestino;
	TLabel *lblTipoTrem;
	TLabel *lblPatioAnterior;
	TPanel *Panel7;
	TPanel *Panel8;
	TPanel *Panel9;
	TLabel *Label7;
	TLabel *Label8;
	TLabel *lblCapacidadePatioReg;
	TLabel *lblPatioReg;
	TStringGrid *stgSBsRegulador;
	TPanel *Panel10;
	TPanel *Panel12;
	TLabel *Label4;
	TLabel *Label5;
	TLabel *Label6;
	TLabel *Label9;
	TLabel *lblPatioAux;
	TLabel *lblCapacidadePatioAux;
	TMaskEdit *medTempoFilaFora;
	TMaskEdit *medTempoSeguranca;
	TStringGrid *stgSBsAuxilar;
	TPanel *Panel13;
	TPanel *Panel14;
	TPanel *Panel15;
	TPanel *Panel16;
	void __fastcall edtTempoFilaForaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall edtTempoSegurancaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
	void __fastcall btnOkClick(TObject *Sender);


private:	// User declarations
	String FIdFila_;
	String FIdFilaTerm_;
public:		// User declarations
	__fastcall TFormDetalharPontosFila(TComponent* Owner);
	__fastcall TFormDetalharPontosFila(String idFila,String patioDestino,String patioAnteior);

	void __fastcall CarregaInfosPatios();
	void __fastcall PreecheStgSB(String IdFilaTerm, TStringGrid *stgSBs);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormDetalharPontosFila *FormDetalharPontosFila;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FTP.h =====

// ---------------------------------------------------------------------------

#ifndef FTPH
#define FTPH
// ---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <VCLTee.Chart.hpp>
#include <VCLTee.TeEngine.hpp>
#include <VCLTee.TeeProcs.hpp>
#include "cxClasses.hpp"
#include "cxContainer.hpp"
#include "cxControls.hpp"
#include "cxEdit.hpp"
#include "cxGraphics.hpp"
#include "cxHint.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxTextEdit.hpp"
#include "dxCustomHint.hpp"
#include "dxScreenTip.hpp"
#include "dxUIAClasses.hpp"
#include "VCLTee.TeeTools.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.ComCtrls.hpp>
#include <Vcl.DockTabSet.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Mask.hpp>
#include <Vcl.Menus.hpp>
#include <Vcl.Tabs.hpp>
#include <Vcl.ToolWin.hpp>
#include <VCLTee.TeeGDIPlus.hpp>
#include "cxImageList.hpp"
#include "cxGroupBox.hpp"
#include <map>
//

#include "UTP.h"
//#include <VCLTee.Series.hpp>
#include "UTPSBSeries.h"
#include "UTPMovimentoSeries.h"
#include "UTPRestricaoSeries.h"
#include "UTPLinhaTempoSeries.h"
#include "UTPLinhaDuplaSeries.h"
#include "UTPArrastoSeries.h"
#include "UTPCriarTremSeries.h"
#include "UTPPrefixoSeries.h"

#include "UTPEnums.h"

#include "UDAO.h"
#include <Vcl.Mask.hpp>
#include <VCLTee.TeeGDIPlus.hpp>
//#include "VCLTee.TeeOpenGL.hpp"
#include <Vcl.ActnList.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.ComCtrls.hpp>
#include <Vcl.ToolWin.hpp>
#include <Vcl.Menus.hpp>

#include "UFormsManager.h"
//#include <Vcl.ActnMan.hpp>
//#include <Vcl.PlatformDefaultStyleActnCtrls.hpp>
#include <Vcl.Graphics.hpp>
#include "VCLTee.TeeTools.hpp"
#include <Vcl.Buttons.hpp>
#include <UTPDefs.h>
#include "cxContainer.hpp"
#include "cxControls.hpp"
#include "cxEdit.hpp"
#include "cxGraphics.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxTextEdit.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "VCLTee.TeeAntiAlias.hpp"
#include "cxScrollBox.hpp"
#include "cxClasses.hpp"
#include "cxHint.hpp"
#include "dxCustomHint.hpp"
#include "dxScreenTip.hpp"
#include <Vcl.DockTabSet.hpp>
#include <Vcl.Tabs.hpp>
#include "dxUIAClasses.hpp"
class TTPHintSeries;
class TFormWidgetGanttOcupacao;


// ---------------------------------------------------------------------------
class TFormTP : public TForm
{
__published: // IDE-managed Components

  TPanel *pnlBotton;
  TPanel *pnlGrafico;
  TPanel *pnlLeft;
  TPanel *pnlRight;
  TPanel *pnlTop;
  TImageList *il;
	TActionList *al;
  TAction *acCarregar;
  TAction *acVisao;
  TAction *acRealizarZoom;
  TPopupMenu *pmnTrem;
  TAction *acExcluirMovimento;
	TMenuItem *mniExcluirMovimento;
  TMenuItem *mniPrefixo;
  TMenuItem *N1;
  TAction *acRestringir;
  TAction *acInterditar;
  TAction *acMarcarRestricaoUpdate;
  TAction *acSelecionar;
  TPanel *pnlStatus;
  TLabel *lblStatus;
  TPanel *pnlTitulo;
  TPanel *pnlControles;
  TPopupMenu *pmnRestricoes;
  TMenuItem *EditarRestrio1;
  TMenuItem *ExcluirRestrio1;
  TAction *acEditarRestricao;
  TAction *acExcluirRestricao;
  TAction *acSelecionarRestricao;
  TGroupBox *GroupBox1;
  TLabel *Label4;
  TMaskEdit *medData;
  TComboBox *cboTipoTrem;
  TComboBox *cboEstadoTrem;
  TGroupBox *grpBusca;
  TToolBar *ToolBar2;
	TToolButton *ToolButton8;
  TGroupBox *grpControles;
  TAction *acIncluirParada;
  TMenuItem *IncluirParada1;
  TMenuItem *N2;
  TAction *acEditarMovimento;
  TMenuItem *EditarMovimento1;
  TPanel *Panel2;
  TGroupBox *GroupBox4;
  TLabel *Label2;
  TLabel *lblValorY;
  TLabel *Label1;
  TLabel *lblValorX;
  TAction *acRealizarMovimento;
  TAction *acFixarMovimento;
  TMenuItem *FixarMovimento1;
  TMenuItem *RealizarMovimento1;
  TAction *acCriarTrem;
  TAction *acCancelarTremArrasto;
  TMenuItem *N3;
  TAction *acRealizadoProgramado;
  TMenuItem *RealizadoXProgramado1;
  TAction *acRemoverRealizadoProgramado;
  TMenuItem *RemoverRealizadoXProgramado1;
  TAction *acPesquisarPrefixo;
  TAction *acOficializar;
  TAction *acInicializar;
  TAction *acProgramar;
  TAction *acAjustarPrefixos;
  TAction *acFiltrarTrens;
  TMenuItem *N4;
  TMenuItem *MovimentosTrem1;
  TAction *acMovimentosTrem;
	TAction *acFichaTrem;
  TMenuItem *FichadoTrem1;
  TAction *acCriarAtividade;
  TAction *acEditarAtividade;
  TAction *acExcluirAtividade;
  TMenuItem *N5;
  TMenuItem *acCriarPAT1;
  TAction *acAtividadesTrem;
  TMenuItem *acAtividadesTrem1;
  TAction *acExibirParametros;
  TAction *acVerificarConflitos;
  TPanel *pnlHintPrefixo;
  TShape *Shape1;
  TLabel *lblHintPrefixo;
  TLabel *lblCapHintSB;
  TLabel *lblCapHintChegada;
  TLabel *lblCapHintSaida;
  TLabel *lblHintSB;
  TLabel *lblHintChegada;
  TLabel *lblHintSaida;
  TTimer *tmrMouseMovePrefixo;
  TAction *acZerarParadasTrem;
  TMenuItem *acZerarParadasTrem1;
  TAction *acReexibirMovimentos;
  TAction *acZerarParadasOcultandoMovimentos;
  TLabel *lblCapHintDestinoTabela;
  TLabel *lblHintDestinoTabela;
  TAction *acEditarTrem;
  TAction *acExcluirTrem;
  TAction *acSuprimirTrem;
  TMenuItem *acExcluirTrem1;
  TMenuItem *acSuprimirTrem1;
  TAction *acRestaurarTrem;
  TMenuItem *RestaurarTrem1;
  TAction *acEditarMovimentoOrigem;
  TMenuItem *N6;
  TMenuItem *acEditarMovimentoOrigem1;
  TAction *acPriorizarMovimentos;
  TMenuItem *PriorizarMovimentos1;
  TMenuItem *EditarTrem1;
  TLabel *lblHintAtividade;
  TToolButton *ToolButton16;
  TAction *acRestaurarTremNaoPlanejado;
  TAction *acPublicarEntreMesas;
  TToolButton *ToolButton19;
  TAction *acGradeDeTrens;
  TAction *acZerarParadasTrens;
  TAction *acAtualizarTrem;
  TMenuItem *N7;
  TMenuItem *acAtualizarTrem1;
  TPopupMenu *pmnGeral;
  TMenuItem *IncluirMovimento2;
  TMenuItem *N8;
  TMenuItem *CriarAtividade1;
  TMenuItem *N9;
  TMenuItem *ModoSelecaoTrens;
  TMenuItem *ModoSelecaoRestricoes;
  TMenuItem *Interdio1;
  TMenuItem *Restrio1;
  TMenuItem *acCriarTrem1;
  TMenuItem *N10;
  TMenuItem *PublicarEntreMesas2;
  TMenuItem *acOficializar1;
  TMenuItem *N11;
  TToolBar *ToolBar3;
  TToolButton *ToolButton21;
  TLabel *lblCapHintPai;
  TShape *Shape2;
  TLabel *lblCapHintPrevFimPai;
  TLabel *lblHintPai;
  TLabel *lblPrevFimPai;
  TLabel *lblHintTempoTerminal;
  TAction *acGerarPlanilhaEquipagem;
  TMenuItem *N12;
  TMenuItem *GerarPlanilhaEquipagem1;
  TAction *acCriarTremTabela;
  TPopupMenu *pmnCriarTrem;
  TMenuItem *MenuItem1;
  TMenuItem *CriarTremdeTabela1;
  TAction *acTrazerPraFrente;
  TMenuItem *N13;
  TMenuItem *acTrazerPraFrente1;
  TAction *acIniciarPlanejamento;
  TAction *acFinalizarPlanejamento;
  TGroupBox *GroupBox5;
  TLabel *lblDataOficializacao;
  TLabel *lblUsuarioOficializacao;
  TLabel *lblPorcentagemOficializacao;
  TAction *acConsultarLogOficializacao;
  TToolBar *ToolBar1;
  TToolButton *ToolButton9;
  TLabel *lblCapHintPronto;
  TLabel *lblHintPronto;
  TAction *acLimparMovimentosPriorizados;
  TMenuItem *acLimparMovimentosPriorizados1;
  TAction *acAtivarCalculoFila;
  TAction *acDesativarCalculoFila;
  TToolButton *btnToolTerminais;
  TAction *acFilasTerminais;
  TAction *acTab;
	TAction *acListarAderenciaFila;
  TAction *acEnviarRestricaoParaTras;
  TAction *acEnviarRestricaoParaFrente;
  TAction *acAjustarRestricaoAoTrem;
  TMenuItem *N14;
  TMenuItem *acAjustarRestricaoAoTrem1;
  TAction *acEnviarRestPTras;
  TAction *acTrazerRestPFrente;
  TMenuItem *N15;
  TMenuItem *acEnviarRestPTras1;
  TMenuItem *acTrazerRestPFrente1;
  TPopupMenu *pmnOrdem;
  TAction *acOrdemSaida;
  TMenuItem *ConsultaFilasdeTerminais1;
  TMenuItem *OrdemdeSadaTRem1;
  TcxTextEdit *edtPesquisar;
	TImageList *imglstIcons;
  TPanel *pnlTitulo2;
  TLabel *lblLinhaFerroviaria;
  TCheckBox *chkTravar;
  TAction *acGatilhos;
  TMenuItem *acGatilhos1;
	TAction *acAtivarValidacaoHorGrade;
	TAction *acDesativarValidacaoHorGrade;
  TTeeGDIPlus *TeeGDIPlus1;
  TScrollBar *scbRodape;
  TScrollBox *scbCharts;
	TChart *chrTTP;
  TShape *ShapeSelecao;
  TChart *chrTTPLeft;
  TShape *Shape3;
  TChart *chrTTPRight;
  TShape *Shape4;
  TScrollBox *scbChartRight;
  TScrollBox *scbChartLeft;
  TAction *acRefreshSceen;
  TAction *acOficializarTrem;
  TMenuItem *N17;
  TMenuItem *acOficializarTrem1;
  TPaintBox *PaintBox1;
  TPanel *pnlScrollTop;
  TChart *chrTTPTop;
  TShape *Shape5;
  TPanel *pnlScrollBot;
  TChart *chrTTPBot;
  TShape *Shape6;
  TAction *acEntreMesasOficializado;
  TAction *acEntreMesasAutomatico;
  TComboBox *cboCarregamentoOficializacao;
  TAction *acAjustarRestricaoAoTremDinamico;
  TMenuItem *AjustaraoTremdeCorteFixar1;
  TMenuItem *N18;
  TAction *acLimparTremRestricaoDinamica;
	TMenuItem *acLimparTremRestricaoDinamica1;
  TdxScreenTipRepository *dxScreenTip;
  TdxScreenTip *observacao;
  TdxScreenTip *movimento;
  TdxScreenTip *restricao;
  TcxHintStyleController *cxHintController;
	TMarksTipTool *ChartTool1;
    TClipSeriesTool *ChartTool2;
	TAction *acAcionarAutomatico;
	TDockTabSet *dtsInfos;
	TPanel *pnlInfos;
	TAction *acAlertaEntrePlanos;
  TAction *acAdicionarTempoDataMaxRestricao;
  TAction *acReduzirTempoDataMinRestricao;
  TAction *acSetDuracaoRestricao;
  TAction *acAtivaDesativaDataFimFixa;
  TMenuItem *acAtivaDesativaDataMaxFimRestricao1;
  TMenuItem *acAdicionarTempoDataMaxRestricao1;
  TMenuItem *acSetDuracaoRestricao1;
  TMenuItem *acReduzirTempoDataMinRestricao1;
  TMenuItem *N19;
  TMenuItem *N20;
  TAction *acAtivaDesativaDataMaxFimRestricao;
  TAction *acRestaurarDuracaoOriginal;
  TMenuItem *RestaurarDuraoOriginal1;
  TPopupMenu *pmnListarAlertas;
  TMenuItem *AlertaInconsistnciaentrePlanos1;
  TAction *acAtividadesAlteradas;
  TMenuItem *AtividadesAlteradas1;
  TGroupBox *gbxAlerta;
  TToolBar *ToolBarAlertas;
  TToolButton *tbtAlerta1;
  TToolButton *tbtAlerta2;
  TToolButton *tbtAlerta3;
  TdxScreenTip *FarolVerde;
  TAction *acParametrosAtivos;
  TAction *acParametrosDesativadosTpExp;
  TAction *acParametrosDesativados;
  TAction *acParametrosVazio;
  TPopupMenu *pmnCadastroRestricao;
  TAction *acReter;
  TMenuItem *CriarInterdio1;
  TMenuItem *acReter1;
  TAction *acOcupacaoPatios;
  TPanel *pnlGanttOcupacao;
  TDockTabSet *dtsGanttOcupacao;
  TSplitter *sptGanttOcupacao;
  TAction *acCriarRetencao;
  TToolBar *ToolBarEventos;
  TToolButton *tbtProgram;
  TToolButton *tbtPointer;
  TToolButton *tbtSelectRestriction;
  TToolButton *tbtAddRestriction;
  TToolButton *tbtRestricao;
  TToolButton *tbtScale;
  TToolButton *tbtConfig;
  TToolButton *tbtAddTrain;
  TToolBar *ToolBarMaisEventos;
  TToolButton *tbtSalvar;
  TToolButton *tbtnPlanejamentoOnOff;
  TToolButton *tbtOficializar;
  TToolButton *tbtAutomatico;
  TToolButton *tbtExport;
  TToolButton *tbtAlarm;
  TToolButton *tbtComparison;
  TToolButton *ToolButton1;
  TAction *acRemoverTrensRetencao;
  TAction *acLimparTrensRemovidosRetencao;
  TMenuItem *N21;
  TMenuItem *RemoverTrensReteno1;
  TMenuItem *LimparTrensRemovidosReteno1;
  TAction *acRetencaoDinamica;
  TToolButton *tbtLog;
  TAction *acLogIntegracao;
  TAction *acInfo;
  TMenuItem *mniOptmove;
  TAction *acTelaWidgetDebug;
  TLabel *lblUltimoConflitoResolvido;
  TAction *acAtivarDesativarCalculoVelocidade;
  TMenuItem *acAtivarDesativarCalculoVelocidade1;
  TMenuItem *N22;
  TAction *acPriorizarDestinos;
  TPopupMenu *pmnProgramacao;
  TMenuItem *acProgramar1;
  TMenuItem *PriorizarDestinos1;
	TAction *Action2;
	TcxImageList *cxImageList1;
	


  void __fastcall chrTTPMouseMove(TObject *Sender, TShiftState Shift, int X, int Y);
  void __fastcall chrTTPGetAxisLabel(TChartAxis *Sender, TChartSeries *Series, int ValueIndex, String &LabelText);
	void __fastcall PlotarTrens();
  void __fastcall chrTTPMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y);
  void __fastcall chrTTPMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y);
  void __fastcall chrTTPDblClick(TObject *Sender);
  void __fastcall acCarregarExecute(TObject *Sender);
  void __fastcall acVisaoExecute(TObject *Sender);
  void __fastcall acRealizarZoomExecute(TObject *Sender);
  void __fastcall chrTTPUndoZoom(TObject *Sender);
  void __fastcall chrTTPZoom(TObject *Sender);
  void __fastcall pmnTremPopup(TObject *Sender);
  void __fastcall chrTTPContextPopup(TObject *Sender, TPoint &MousePos, bool &Handled);
  void __fastcall acExcluirMovimentoExecute(TObject *Sender);
  void __fastcall acRestringirExecute(TObject *Sender);
  void __fastcall acInterditarExecute(TObject *Sender);
  void __fastcall acMarcarRestricaoUpdateExecute(TObject *Sender);
  void __fastcall acSelecionarExecute(TObject *Sender);
  void __fastcall EditarRestrio1Click(TObject *Sender);
  void __fastcall acEditarRestricaoExecute(TObject *Sender);
  void __fastcall acExcluirRestricaoExecute(TObject *Sender);
  void __fastcall acSelecionarRestricaoExecute(TObject *Sender);
  void __fastcall acIncluirParadaExecute(TObject *Sender);
  void __fastcall acEditarMovimentoExecute(TObject *Sender);
  void __fastcall acRealizarMovimentoExecute(TObject *Sender);
  void __fastcall acCriarTremExecute(TObject *Sender);
  void __fastcall acCancelarTremArrastoExecute(TObject *Sender);
  void __fastcall acRealizadoProgramadoExecute(TObject *Sender);
  void __fastcall acRemoverRealizadoProgramadoExecute(TObject *Sender);
  void __fastcall acPesquisarPrefixoExecute(TObject *Sender);
  void __fastcall edtPesquisarEnter(TObject *Sender);
  void __fastcall cboTipoTremChange(TObject *Sender);
  void __fastcall cboEstadoTremChange(TObject *Sender);
  void __fastcall pmnRestricoesPopup(TObject *Sender);
  void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
  void __fastcall acInicializarExecute(TObject *Sender);
  void __fastcall acProgramarExecute(TObject *Sender);
  void __fastcall acAjustarPrefixosExecute(TObject *Sender);
  void __fastcall acFiltrarTrensExecute(TObject *Sender);
  void __fastcall edtPesquisarExit(TObject *Sender);
  void __fastcall acMovimentosTremExecute(TObject *Sender);
  void __fastcall acFichaTremExecute(TObject *Sender);
  void __fastcall acCriarAtividadeExecute(TObject *Sender);
  void __fastcall acAtividadesTremExecute(TObject *Sender);
  void __fastcall acExibirParametrosExecute(TObject *Sender);
  void __fastcall acVerificarConflitosExecute(TObject *Sender);
  void __fastcall tmrMouseMovePrefixoTimer(TObject *Sender);
  void __fastcall acOficializarExecute(TObject *Sender);
  void __fastcall acZerarParadasTremExecute(TObject *Sender);
  void __fastcall acReexibirMovimentosExecute(TObject *Sender);
  void __fastcall acZerarParadasOcultandoMovimentosExecute(TObject *Sender);
  void __fastcall acExcluirTremExecute(TObject *Sender);
  void __fastcall acSuprimirTremExecute(TObject *Sender);
  void __fastcall acRestaurarTremExecute(TObject *Sender);
  void __fastcall acEditarMovimentoOrigemExecute(TObject *Sender);
  void __fastcall acPriorizarMovimentosExecute(TObject *Sender);
  void __fastcall acEditarTremExecute(TObject *Sender);
  void __fastcall acRestaurarTremNaoPlanejadoExecute(TObject *Sender);
  void __fastcall acPublicarEntreMesasExecute(TObject *Sender);
  void __fastcall acGradeDeTrensExecute(TObject *Sender);
  void __fastcall acZerarParadasTrensExecute(TObject *Sender);
  void __fastcall acAtualizarTremExecute(TObject *Sender);
  void __fastcall mniPrefixoDrawItem(TObject *Sender, TCanvas *ACanvas, TRect &ARect, bool Selected);
  void __fastcall acGerarPlanilhaEquipagemExecute(TObject *Sender);
  void __fastcall acCriarTremTabelaExecute(TObject *Sender);
  void __fastcall edtPesquisarKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall acTrazerPraFrenteExecute(TObject *Sender);
  void __fastcall acIniciarPlanejamentoExecute(TObject *Sender);
  void __fastcall acFinalizarPlanejamentoExecute(TObject *Sender);
  void __fastcall acConsultarLogOficializacaoExecute(TObject *Sender);
  void __fastcall acLimparMovimentosPriorizadosExecute(TObject *Sender);
  void __fastcall acAtivarCalculoFilaExecute(TObject *Sender);
  void __fastcall acDesativarCalculoFilaExecute(TObject *Sender);
  void __fastcall acFilasTerminaisExecute(TObject *Sender);
  void __fastcall acTabExecute(TObject *Sender);
	void __fastcall acListarAderenciaFilaExecute(TObject *Sender);
  void __fastcall acAjustarRestricaoAoTremExecute(TObject *Sender);
  void __fastcall acEnviarRestPTrasExecute(TObject *Sender);
  void __fastcall acTrazerRestPFrenteExecute(TObject *Sender);
  void __fastcall acOrdemSaidaExecute(TObject *Sender);
  void __fastcall alExecute(TBasicAction *Action, bool &Handled);
  void __fastcall acGatilhosExecute(TObject *Sender);
  void __fastcall acDesativarValidacaoHorGradeExecute(TObject *Sender);
  void __fastcall acAtivarValidacaoHorGradeExecute(TObject *Sender);
  void __fastcall chrTTPResize(TObject *Sender);
  void __fastcall chrTTPAfterDraw(TObject *Sender);
  void __fastcall scbChartsEnter(TObject *Sender);
  void __fastcall pnlGraficoResize(TObject *Sender);
  void __fastcall cboEstadoTremEnter(TObject *Sender);
  void __fastcall cboTipoTremEnter(TObject *Sender);
  void __fastcall chrTTPKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall acRefreshSceenExecute(TObject *Sender);
  void __fastcall chrTTPClickSeries(TCustomChart *Sender, TChartSeries *Series, int ValueIndex,
          TMouseButton Button, TShiftState Shift, int X, int Y);
  void __fastcall chrTTPMouseEnter(TObject *Sender);
  void __fastcall acOficializarTremExecute(TObject *Sender);
  void __fastcall cboCarregamentoOficializacaoChange(TObject *Sender);
  void __fastcall chrTTPBeforeDrawSeries(TObject *Sender);
  void __fastcall chrTTPBeforeDrawChart(TObject *Sender);
  void __fastcall acAjustarRestricaoAoTremDinamicoExecute(TObject *Sender);
  void __fastcall acLimparTremRestricaoDinamicaExecute(TObject *Sender);
	void __fastcall acAcionarAutomaticoExecute(TObject *Sender);
	void __fastcall cxHintControllerShowHint(TObject *Sender, UnicodeString &HintStr,
          bool &CanShow, THintInfo &HintInfo);
  void __fastcall FormCreate(TObject *Sender);
	void __fastcall chrTTPMouseLeave(TObject *Sender);
	void __fastcall pnlInfosResize(TObject *Sender);
	void __fastcall acAlertaEntrePlanosExecute(TObject *Sender);
	void __fastcall pnlInfosDockDrop(TObject *Sender, TDragDockObject *Source, int X,
          int Y);
	void __fastcall pnlInfosDragDrop(TObject *Sender, TObject *Source, int X, int Y);
	void __fastcall pnlInfosStartDock(TObject *Sender, TDragDockObject *&DragObject);
	void __fastcall pnlInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow);
	void __fastcall dtsInfosDockDrop(TObject *Sender, TDragDockObject *Source, int X,
          int Y);
	void __fastcall dtsInfosEndDock(TObject *Sender, TObject *Target, int X, int Y);
	void __fastcall dtsInfosTabRemoved(TObject *Sender);
	void __fastcall dtsInfosUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow);
	void __fastcall dtsInfosMeasureTab(TObject *Sender, int Index, int &TabWidth);
	void __fastcall chrTTPEnter(TObject *Sender);
  void __fastcall acAtivaDesativaDataMaxFimRestricaoExecute(TObject *Sender);
  void __fastcall acAdicionarTempoDataMaxRestricaoExecute(TObject *Sender);
  void __fastcall acAtivaDesativaDataFimFixaExecute(TObject *Sender);
  void __fastcall acAtivaDesativaDataFimFixaUpdate(TObject *Sender);
  void __fastcall acSetDuracaoRestricaoExecute(TObject *Sender);
  void __fastcall acReduzirTempoDataMinRestricaoExecute(TObject *Sender);
  void __fastcall acRestaurarDuracaoOriginalExecute(TObject *Sender);
  void __fastcall acAtividadesAlteradasExecute(TObject *Sender);
  void __fastcall acParametrosDesativadosTpExpExecute(TObject *Sender);
  void __fastcall acReterExecute(TObject *Sender);
  void __fastcall acOcupacaoPatiosExecute(TObject *Sender);
  void __fastcall dtsGanttOcupacaoDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y);
  void __fastcall dtsGanttOcupacaoEndDock(TObject *Sender, TObject *Target, int X,
          int Y);
  void __fastcall dtsGanttOcupacaoUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow);
  void __fastcall chrTTPLeftMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y);
  void __fastcall chrTTPLeftDblClick(TObject *Sender);
  void __fastcall pnlGanttOcupacaoDockDrop(TObject *Sender, TDragDockObject *Source,
          int X, int Y);
  void __fastcall pnlGanttOcupacaoDragDrop(TObject *Sender, TObject *Source, int X,
          int Y);
  void __fastcall pnlGanttOcupacaoEndDock(TObject *Sender, TObject *Target, int X,
          int Y);
  void __fastcall pnlGanttOcupacaoEndDrag(TObject *Sender, TObject *Target, int X,
          int Y);
  void __fastcall pnlGanttOcupacaoResize(TObject *Sender);
  void __fastcall pnlGanttOcupacaoStartDock(TObject *Sender, TDragDockObject *&DragObject);
  void __fastcall pnlGanttOcupacaoUnDock(TObject *Sender, TControl *Client, TWinControl *NewTarget,
          bool &Allow);
  void __fastcall dtsGanttOcupacaoTabRemoved(TObject *Sender);
  void __fastcall acRemoverTrensRetencaoExecute(TObject *Sender);
  void __fastcall acLimparTrensRemovidosRetencaoExecute(TObject *Sender);
  void __fastcall acRetencaoDinamicaExecute(TObject *Sender);
  void __fastcall acLogIntegracaoExecute(TObject *Sender);
  void __fastcall GroupBox5Click(TObject *Sender);
  void __fastcall acInfoExecute(TObject *Sender);
  void __fastcall acTelaWidgetDebugExecute(TObject *Sender);
  void __fastcall acAtivarDesativarCalculoVelocidadeExecute(TObject *Sender);
  void __fastcall acPriorizarDestinosExecute(TObject *Sender);
  void __fastcall FormResize(TObject *Sender);



protected: // User declarations

  TTPHintSeries* t_seriesGlobal;
  TTP* TP_;
  TTPRamalPtr FRamal_;
	TTPTremListPtr FTrens_;

	TTPRestricaoListPtr FRestricoes_;

	//TTPMovimentoSeries* FSerieMovimentoSelecionada_;
	TTPMovimentoSeries* fSerieMovimentoSelecionada_;
	__property TTPMovimentoSeries* FSerieMovimentoSelecionada_ = {read = fSerieMovimentoSelecionada_, write = setMovimentoSelecionado};
	void setMovimentoSelecionado(TTPMovimentoSeries* pSerieMovimentoSelecionada);


	TTPMovimentoSeries* FSerieMovimentoCliked_;
  TTPRestricaoSeries* FSerieRestricaoSelecionada_;
  TXStringList* FSeriesRestSelecionadas_;
  TXStringList* FSeriesObservacao_;
  TTPRestricaoSeries* FSerieRestricaoMouseOver_;

  TTPTipoSelecao FTipoSelecaoAtual_;
  String FPIDObjetoSelecionado_;
	int FSequenciaSBOrigemMovimentoSelecionado_;
  int FSequenciaSBDestinoMovimentoSelecionado_;

  TTPSBSeries* FSerieSBs_;
  TTPSBSeries* FSerieSBsChartTop_;
  TTPSBSeries* FSerieSBsChartBot_;
  TTPSBSeries* FSerieSBsChartLeft_;
  TTPSBSeries* FSerieSBsChartRight_;
	TTPSBListPtr FListSBs_;
	TTPTipoArrasto FTipoArrasto_;
  TTPTipoArrasto FTipoArrastoRealizado_; // Atribudo aps usurio concluir o arrasto
  TTPArrastoSeries* FArrastoSeries_;

  TStringList *seriesTransposicao_;

  // trem selecionado com o duplo cique
	TTPTremPtr FTremSelecionado_;

	TTPMovimento* FMovimentoSelecionado_;
	bool FMoverTremSelecionadoClickAtivo_;

  TPoint FPontoInicioPanning_;
  bool FIsMiminizedChart_, FIsCtrlA_;
  bool FFezPanning_;
	bool fPanning_;
  bool FTemTremSelecionado_;
  int FTotalPanning_;

  bool FArrastou_;
  bool FAjustarScroll_;
  bool FVisaoPlajemanto_;
  TDateTime FDataHoraArrasto_;
  bool FAlteraPrevisaoSaida_;
  bool FEditandoOrigem_;
  bool FMoveuSobreObservacao_;

  TPopupMenu *FPopupContexto_;
  bool FHabilitarPopup;

  // Restries
  bool FMarcarRestricao_;
  TRect FCoordenadasSelecao_;
  bool FSelecionandoRestArrastoShift_;
  int  FPrimeiraRestricao_;

	bool RefreshAfterPlotarTrens_;
	TLineSeries *serieRefreshAfterPlotarTrens_;

  // Criar Trem
  bool FCriandoTremArrasto_;
  TTPCriaTremSeries* FTremSelecionadoSerie_;

  // Congelando programao
  bool FCongelandoProgramacao_;
  TTPLinhaTempoSeries* serieLinhaTempoCongelar_;
  TTPLinhaTempoSeries* serieLinhaTempoAparagarParadas_;

  // Verificao de Conflitos
	typedef std::multimap<double, double>TListaConflitos;
	typedef TListaConflitos::value_type value_type;

  // Tabs
  TPageControl* FPageControl;
 
  //Replotar Trem Filho
  TTPTrem* FTremFilho_;
  TDateTime FDataHoraCriacaoTremFilho_;

  bool FSelecionarTremRemoverRestricao_;
  TStringList* ListaTrensRemoverRestricao_;
  bool FSelecionouSerieRemoverRestricao_;

	virtual void Inicializar(TTPRamalPtr pPainel, int DiasPassado = 0);
  void __fastcall PlotarLinhaTempo();
  void __fastcall PlotarLinhasDuplas();
  TDateTime __fastcall GetDataHoraSistema();
	void __fastcall VoltarScroll();
  void ClickMPSeries(TChartSeries* serie, TShiftState Shift, int X, int Y);
	TTPTipoSerie GetTipoSerieMP(TChartSeries* serie);
  TTPTipoArrasto VerificarSerieParaArrasto(TTPMovimentoSeries* serieTrecho, int posicaoXClick, int posicaoYClick, TShiftState Shift);
	virtual void Arrastar(double X, int Y, double XLimit = 0);
	virtual void ArrastarRestricao(double X, int Y);
  void RealizarZoomRapido(double pX, int pY);
  TTPSBPtr TFormTP::GetSBByY(double pY);
  virtual void __fastcall MontarPopupTrem();
  void GerenciarRestricoes(double pPontoEixoX, double pPontoEixoY);
  void GerenciarCriacaoTremArrasto(double pPontoEixoX, double pPontoEixoY);
  TTPTremPtr __fastcall PlotarTrem(domain::TremMalha* pTrem);

  unsigned short shortCutCarregar;
  unsigned short shortCutProgramar;
  unsigned short shortCutOficializar;
  unsigned short shortCutPublicar;
  bool filtrou_, FISZoomed_, FisRebuffered_;
  double FMouseX_,FMouseXTimer_, FMouseXScroll_;
  double FMouseY_,FMouseYTimer_, FMouseYScroll_,FMouseYSBs_;
  double FMinGlobalLeftRight_, FMaxGlobalLeftRight_;

  double FWhidtChart_, FHeight_;

  double FHorarioCentralAtual_;

	TStringList *formsAbertos_;

  int ultimaPosicaoscbCharts_, ultimaPosicaoscbChartVert_, tickCount_;

  bool FExecutouResetPosicao_, FPerdeuFocus_;
  int FCountSeriesSBsPainel_;
  TTPLinhaTempoSeries* FLinhaTempoSerie_;
  TStringList* menusDinamicos_;

  String DB_SCHEMA_MODL;
  String DB_INSTANCE_MODL;
  String DB_USR_SRV_MODL;
  String DB_PWD_CORE_MODL;


public: // User declarations
  __property TTPMovimentoSeries* SerieMovimentoSelecionada = {read = FSerieMovimentoSelecionada_,write = FSerieMovimentoSelecionada_};
  __fastcall TFormTP(TComponent* Owner, TTPRamalPtr pRamal);
  inline __fastcall ~TFormTP(void);
  void __fastcall CreateParams(TCreateParams& Params);
	virtual void __fastcall PlotarTrem(TTPTrem* pTrem, bool pPlotarPrefixo = true, bool pTremCopia = false,
    bool pAtualizar = false);
  TTPRestricaoSeries* PlotarRestricao(TTPRestricaoPtr &pRestricao);
  void AtualizarRestricao(TTPRestricaoPtr &pRestricao, TTPTipoAtualizacaoRestricao pTipo = tarEdicao);
  void ConfigurarGrafico();
  void ConfigurarBotoes();
  void ConfigurarGraficoAux(TChart *chart);
  void __fastcall LimparGrafico();
  void __fastcall LimparTrens();
  void __fastcall LimparSeriesObservacao(TTPTrem* pTrem);
  void RetirarSelecao(bool pManterMovimento = false);
  void RetirarSelecaoZerarParadas();
  void AtualizarSaidaTremArrastoMouse(bool pParar = false, bool pShift = false);
  void ExcluirTrem(TTPTrem* pTrem, TTPTipoExclusaoTrem pTipoExcluscao = texParcial);
  void RemoverSeriesPrefixoTransposicao(TTPTrem* pTrem, bool pSuprimir = false);

  void AjustarPrefixos(bool inZoomed);
  void DesfazerAjustarPrefixos();
  bool PontoVisivel(double pX, double pY);
  void CorrigirSobreposicaoPrefixo(TTPPrefixoSeries *pnovaSerie);
  void LimparListaConflitos();

	void RemoverSerieMP(TChartSeries *& serie);
	void AntialiasONOFF(bool pOnOff);

  int contPlotagem;

	virtual void AjustarEstadoControles(bool pOnOff);
  void AjustarEstadoControleOficializar(bool pForcarDesabilitar = false);
  void AjustarEstadoControleSinalizadorInconsistenciaFila(bool pHabilitar = true, bool pChecarTodosForms = false);
  void ShowHint(double pX, double pY);
  void ShowHint(String pPrefixo, String pSB, String pAtividade, String pDataFim, String pDuracao, double pX, double pY);
  void HideHint();
  void AjustarLinhaTempo();
  String getNomeRamal();
	bool TrocarSBMovimento(TTPMovimento* pMovimento, String pNovaSB);
  void __fastcall AtualizarLinhaCongelamento();
  bool PesquisarPrefixo(String pPrefixo, bool pLancarExcecao = true);

  __property bool ExecutouResetPosicao =
  {read              = FExecutouResetPosicao_, write = FExecutouResetPosicao_};
    __property bool ISZoomed =
  {read              = FISZoomed_};

  __property TTP* TP =
  {read              = TP_, write = TP_};

	__property bool FPanning_ = {read = fPanning_, write = SetFPanning};

  __property bool FSelecionarTremRemoverRestricao = {read = FSelecionarTremRemoverRestricao_, write = SetSelecionarTremRemoverRestricao};

	void SetFPanning(bool pValue)
	{
		 fPanning_ = pValue;
		 TTPFormsManager::getInstance()->DrawAllSeries = pValue;
  }

  // Controle Programao Mesa
  bool FPlanoInicializado;


  void ThreadGerarPlanilha();
  void ThreadIniciarProgramacao(TTheadResultado *pResult);
  void ThreadFinalizarProgramacao(TTheadResultado *pResult);

  void __fastcall DesativarFilas(bool desativa);
  void __fastcall DesativarGatilhoVazio(bool desativa);
  bool __fastcall CheckGatilhoVazio();
	bool __fastcall CheckFilasAtivas();
  void __fastcall FechaFormsAbertos();
  void __fastcall AddFormAberto(TForm *formAberto);
  void __fastcall WsFormsAbertos(TWindowState t_ws);
  TTPMovimentoSeries* __fastcall SerieProximaPontoY(float Y);

  void LimparSeriesTransposicao(TTPTrem* pTrem);
  void AplicarAjusteRestricaoAoTrem(TTPTrem* pTrem, bool pAjusteTremRetomada = false, bool pFixarTrem = false);
  void AtualizarRestricoesServer(TTPTrem* pTrem = NULL, bool pAvoidRedrawSeries = false);
  void SelecionarRestricoes(double pX, int pY);

  void __fastcall ScrollTo(TTPMovimentoSeries * tSerieSelecionada = NULL, double horario = -1);
  void __fastcall ScrollToOnZoom(double addX, double addY);

  void getTremFilho(TTPTrem* Trem);
  bool PlotarTremFilho(TTPTrem* Trem);
  void ConfigurarTextoSelecionar();
  void EditarMovimentoOrigemTremForaLimiteGrafico(TTPTremPtr pTrem);
  void AjustarEstadoControleMovimentosOficializadosEntreMesas();
  void __fastcall SincyCharts();
  void __fastcall EnableDisableChart(bool val);
  void __fastcall RedimencionaChartToVisao();
  void __fastcall RestaurarChart();
	void __fastcall MinimizarChart();
   void clearSmartPTr();
	__property TTPRamalPtr Ramal =  {read = FRamal_};

	TTPMovimentoSeries* PlotarRotaTrem(TTPTrem* pTrem, bool pPlotarPrefixo, bool pTremCopia, bool pAtualizar, TTPMovimentoListPtr pRota, TTPMovimentoSeries* pMovimentoSerie = NULL);

	void  __fastcall ReordenarSeriesObservacao();

	void ConfigurarChartsLimitesHorizontaisDefault();
	bool FExibirMsgSalvarAltomatico_, FAcionarAutomaticoOk_;

	void AjustarEstadoAcionarAutomatico(bool pOnOff);

	void __fastcall scbChartsResize(TObject *Sender);

	bool FNoSetFocus_;
	bool FRedrawChart_;
	bool FRedrawChartOnMouseMove_;

	void  __fastcall ForceRedrawChart();

	void  __fastcall AtualizarAlertaEntrePlanos();

  bool IsSerieValida(TChartSeries* serie);
  void  __fastcall preencherFilas();
  TStringList* Filas_;
   void __fastcall UpdateStatusProgramando(boost::shared_ptr<boost::thread>  th, bool updateProgress, int timeOutCancelamento, String msgComplementar);


  __property TTPSBListPtr FListSBs = {read = FListSBs_};


  __property TTPLinhaTempoSeries* FLinhaTempoSerie = {read = FLinhaTempoSerie_};

  __property TTPHintSeries* FHintSeries = {read = t_seriesGlobal};
  __property TFormWidgetGanttOcupacao *FormWidgetGanttOcupacao_ = {write = setFormWidgetGanttOcupacao};

  void setFormWidgetGanttOcupacao(TFormWidgetGanttOcupacao *pFormWidgetGanttOcupacao);


  TWndMethod OldScrollBoxWP;
  void __fastcall NewScrollBoxWP(TMessage& AMsg);
  void AlterarIconeLog(bool checkError);
  void SetSelecionarTremRemoverRestricao(bool pSelecionarTrem);
  TTPTremPtr AddTremListaLocal(String pidTrem);
  TTPRestricaoPtr AddRestricaoListaLocal(TTPRestricaoPtr& pRestricao);
  void RedrawAllMovimentoSeries();

  void AdjustGroupBoxSize(TGroupBox *GroupBox);
  void TFormTP::AdjustGroupBoxesPosition();

  #pragma region Metodos_MultiThread
  // durante a compilao em release apresentaram problema de internal compile error, movido para o fim do form parou de dar problema
  void ThreadCarregarIconesAtividades(TTheadResultado *&pResult);
  void ThreadOficializar(TTheadResultado *pResult);
  void ThreadCalcularTrens(TTheadResultado *&pResult);
  void ThreadCarregarTrensMalha(TTheadResultado *&pResult);
  void ThreadSincronizarProgramacao(TTheadResultado *pResult);
  void ThreadProgramarTrens(bool pCongelarLinha, TTheadResultado *&pResult, int pBranchProgramingID  = -1);
  void ThreadPublicarEntreMesas(TTheadResultado *pResult);
  void ThreadGravarModelo(TTheadResultado *pResult);
  #pragma end_region
};

// ---------------------------------------------------------------------------
extern PACKAGE TFormTP *FormTP;
// ---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFFilas.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFFilas.h"
#include "FilaMalha.h"
#include "PontoFila.h"

#include "FTP.h"
#include "UFormsManager.h"
#include "UTPTrem.h"
#include "UTPItinerarioTrem.h"
#include "UTPMovimento.h"
#include "UTPSB.h"
//#include "UDModuleMP.h"

#include "UFPontosFila.h"
#include "cxGridExportLink.hpp"
#include <DateTimeNull.h>
#pragma region Server
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/SegmentoTremRealizado.h"
#pragma end_region
// ---------------------------------------------------------------------------
#pragma link "cxLabel"
#pragma link "cxGridBandedTableView"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"
TFormFilas *FormFilas;

domain::FilaMalha *FFilaMalha_;

// ---------------------------------------------------------------------------
__fastcall TFormFilas::TFormFilas(TComponent* Owner) : TForm(Owner)
{

  FEditandoFilasInconsistentes_ = false;
  FEditouOrdemFila_             = false;
  FRowEditando_                 = 0;

  CarregarFilas();

  acEditarPontosFila->Enabled = false;
  acEditarPontosFila->Visible = false;

  if (TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista)
  {
    acEditarPontosFila->Enabled = true;
    acEditarPontosFila->Visible = true;
  }

  FTrensFilasInconsistentes_ = new TStringList();
  FTrensFilasInconsistentes_->Duplicates    = System::Types::dupIgnore;
  FTrensFilasInconsistentes_->CaseSensitive = true;

  if (cboFilas->Items->Count > 0)
    CarregarTrens();

  FLocate_.Clear();

  ConfigurarGrid();
  cboFilas->Text = "FILAS";

}
inline __fastcall TFormFilas::~TFormFilas(void)
{
  delete FTrensFilasInconsistentes_;
}
// ---------------------------------------------------------------------------
__fastcall TFormFilas::TFormFilas(TComponent* Owner, TStringList* FilasInconsistentes) : TForm(Owner)
{

  FEditandoFilasInconsistentes_             = true;
  FRowEditando_                             = 0;
  FTrensFilasInconsistentes_                = new TStringList();
  FTrensFilasInconsistentes_->Duplicates    = System::Types::dupIgnore;
  FTrensFilasInconsistentes_->CaseSensitive = true;

  FFilas_ = FilasInconsistentes;

  CarregarFilas();

  CarregarTrens();

  FLocate_.Clear();

  acEditarPontosFila->Enabled = false;
  acEditarPontosFila->Visible = false;

  lblTituloDuracaoSeguranca->Visible = false;
  lblDuracaoSeguranca->Visible       = false;
  lblTituloDuracaoUsuario->Visible   = false;
  medDuracaoUsuario->Visible         = false;
  acSalvarDuracaoUsu->Enabled        = false;
  acSalvarDuracaoUsu->Visible        = false;

  ConfigurarGrid();

  cboFilas->Text = "FILAS";

  cxgFilasDBTableView1->Styles->ContentEven = cxDefault;
  cxgFilasDBTableView1->Styles->Content     = cxDefault;
  cxgFilasDBTableView1->Styles->Selection->RestoreDefaults();

}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::ConfigurarGrid()
{

  cxgFilasDBTableView1->OptionsCustomize->ColumnFiltering = false;
  cxgFilasDBTableView1->OptionsCustomize->ColumnGrouping  = false;
  cxgFilasDBTableView1->OptionsCustomize->ColumnHidingOnGrouping = false;
  cxgFilasDBTableView1->OptionsCustomize->ColumnSorting = false;

  cxgFilasDBTableView1->DataController->DataModeController->SyncMode = true;

}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::CarregarFilas()
{
  cboFilas->Clear();

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  if (!FFilas_)
    FFilas_ = core->getFilas();
  for (int i = 0; i < FFilas_->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)FFilas_->Objects[i];
    domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
    if (t_segmento->codZonaControleResponsavel == TTPFormsManager::getInstance()->Mesa)
    {
      cboFilas->Items->Add(t_filaMalha->getPatioDestino()->sigla);
    }
  }

  cboFilas->Text = "FILAS";
}

// ---------------------------------------------------------------------------
int __fastcall SortPorOrdem(TStringList* List, int Index1, int Index2)
{

  String string1 = ((TFormFilas::TTremFila*)List->Objects[Index1])->fila;
  String string2 = ((TFormFilas::TTremFila*)List->Objects[Index2])->fila;

  if (string1 < string2)
    return 1;
  if (string2 < string1)
    return -1;

  bool filaAtivaitem2 = ((TFormFilas::TTremFila*)List->Objects[Index2])->ativaOriginal;
  bool filaAtivaitem1 = ((TFormFilas::TTremFila*)List->Objects[Index1])->ativaOriginal;

  if (filaAtivaitem1 && !filaAtivaitem2)
  {
    return 1;
  }
  else if (!filaAtivaitem1 && filaAtivaitem2)
  {
    return -1;
  }

  TFormFilas::TTremFila* tTremFila1 = ((TFormFilas::TTremFila*)List->Objects[Index1]);
  SegmentoTrem *segmentoTrem1 = tTremFila1->tremMalha->getUltimoMovimento();

  TFormFilas::TTremFila* tTremFila2 = ((TFormFilas::TTremFila*)List->Objects[Index2]);
  SegmentoTrem *segmentoTrem2 = tTremFila2->tremMalha->getUltimoMovimento();

  if(tTremFila1->tremMalha->filaTrem->getTipoAlgoritmoOrdenacaoFila()==FilaMalha::TipoAlgoritmoOrdenacaoFila::FILA_NORMAL)
  return tTremFila1->tremMalha->comparaOrdemFila(segmentoTrem2,segmentoTrem1);
  else
  return tTremFila1->tremMalha->comparaOrdemFila2(segmentoTrem2,segmentoTrem1);
 /* unsigned long long int item2 =  ((TFormFilas::TTremFila*)List->Objects[Index2])->ordemOriginal;
  unsigned long long int item1 = ((TFormFilas::TTremFila*)List->Objects[Index1])->ordemOriginal;
  long long int resultado      = item2 - item1;
  if (resultado == 0 && Index2 != Index1)
  {
    ((TFormFilas::TTremFila*)List->Objects[Index2])->isOrdemErrada = true;
    ((TFormFilas::TTremFila*)List->Objects[Index1])->isOrdemErrada = true;
  }
  if (((TFormFilas::TTremFila*)List->Objects[Index2])->isOrdemErrada || ((TFormFilas::TTremFila*)List->Objects[Index1])
    ->isOrdemErrada || ((!filaAtivaitem1 && !filaAtivaitem2)))
  {
    long double difTempo = (((TFormFilas::TTremFila*)List->Objects[Index2])->dataChegadaTerminal -
      ((TFormFilas::TTremFila*)List->Objects[Index1])->dataChegadaTerminal);
    if (difTempo < 0)
    {
      return 1;
    }
    else if (difTempo > 0.00001)
    {
      return -1;
    }
    else
    {
      return 0;
    }
  }

  if (resultado < 0)
  {
    return 1;
  }
  else if (resultado > 0.00001)
  {
    return -1;
  }
  else
  {
    return 0;
  }
   */
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::CarregarTrens()
{
  try
  {
    TTremFila *t_tremFila;
    TStringList *t_trensFila = new TStringList();

    PreencheHorariosSegUsu("", "");

    int linhaSelecionanda = 1;

    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    TStringList *t_filas           = core->getFilas();
    TStringList *t_trens           = core->getTrensCalculados();

    if (!FEditandoFilasInconsistentes_)
      FFilas_ = t_filas;

    for (int i = 0; i < FFilas_->Count; i++)
    {
      domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)FFilas_->Objects[i];
      domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];

      // if (t_segmento->codZonaControleResponsavel == TTPFormsManager::getInstance()->Mesa)
      {
        for (int x = 0; x < t_filaMalha->trensFila->Count; x++)
        {
          domain::TremMalha* tremMalha = (domain::TremMalha*)t_filaMalha->trensFila->Objects[x];
          FTrensFilasInconsistentes_->AddObject(tremMalha->PID, (TObject*)tremMalha);

          AnsiString t_siglaAux = "", t_duracaoSegurancaAux = "", t_duracaoUsuarioAux = "", t_siglaReg = "",
            t_duracaoSegurancaReg = "", t_duracaoUsuarioReg = "";

          for (int j = 0; j < t_filaMalha->pontosFila->Count; j++)
          {
            domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];

            if (t_pontoFila->getTipoPonto() == domain::TipoPontoFila::AUXILIAR)
            {
              t_siglaAux            = t_pontoFila->patioFila->sigla;
              t_duracaoSegurancaAux =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoSeguranca().hours() * 60 +
                t_pontoFila->getDuracaoSeguranca().minutes());
              t_duracaoUsuarioAux =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoUsuario().hours() * 60 + t_pontoFila->getDuracaoUsuario()
                .minutes());
            }
            else
            {
              t_siglaReg            = t_pontoFila->patioFila->sigla;
              t_duracaoSegurancaReg =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoSeguranca().hours() * 60 +
                t_pontoFila->getDuracaoSeguranca().minutes());
              t_duracaoUsuarioReg =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoUsuario().hours() * 60 + t_pontoFila->getDuracaoUsuario()
                .minutes());
            }

          } // for ponto fila

          timeTP::TimeTP dataChegadaTerm = tremMalha->getUltimoMovimento()->getOrdemSaida();
          tremMalha->getPrimeiroMovimento()->getPeriodoOcupacao();

          String tPatioAtual = "";
          TDateTime tDataRef = NULL;

          if (tremMalha->possuiRealizado())
          {
            using namespace domain;
            tPatioAtual =
              ((SegmentoTremRealizado*)tremMalha->rotaRealizada->Objects[tremMalha->rotaRealizada->Count - 1])->getSB()
              ->segmento->segmento;
            tDataRef = tremMalha->getdataUltimoRealizado()->asDateTime();
          }
          else
          {
            tPatioAtual = (tremMalha->origem->patioPertencente ? tremMalha->origem->patioPertencente->sigla :
              String(""));
            tDataRef = tremMalha->getPrimeiroMovimento()->getDataHoraFimCursoTrem();
          }

          if(t_duracaoSegurancaAux == "00:00")
            t_duracaoSegurancaAux = "";
          if(t_duracaoUsuarioAux == "00:00")
             t_duracaoUsuarioAux = "";
          if(t_duracaoSegurancaReg == "00:00")
             t_duracaoSegurancaReg = "";
          if(t_duracaoUsuarioReg == "00:00")
              t_duracaoUsuarioReg = "";

          TDateTime tDataRegulador = NULL;

          if(tremMalha->getPrimeiroPontoFila())
          {
            tDataRegulador = tremMalha->getPrimeiroPontoFila()->segmentoTremInicioPatio->getDataHoraChegadaCabecaTrem();
          }

          TTPTremPtr tTrem = TTPFormsManager::getInstance()->Trens->get(tremMalha->PID);

          bool tFilaAtivaOriginalmente = tremMalha->getCalculoFilaAtivo();
          if(!tFilaAtivaOriginalmente)
          {
            if(!tTrem.isNull() && tTrem->IsFilaDasativUsu)
            {
              tFilaAtivaOriginalmente = tTrem->IsFilaDasativUsu;
            }
          }
          double ordemFila = 0;
          if(!tremMalha->ordremFila.is_not_a_date_time())
            ordemFila = tremMalha->ordremFila.asDateTime();
          t_tremFila = new TTremFila(tremMalha, t_filaMalha->getPatioDestino()->sigla, 0, tremMalha->prefixoTrem,
            tremMalha->tipoTrem->nome, tremMalha->getCalculoFilaAtivo(), tFilaAtivaOriginalmente
            , (tremMalha->origem->patioPertencente ? tremMalha->origem->patioPertencente->sigla : tremMalha->origem->segmento)
            , (tremMalha->destino->patioPertencente ? tremMalha->destino->patioPertencente->sigla : tremMalha->destino->segmento)
            , tPatioAtual, tDataRef, t_siglaAux, t_duracaoSegurancaAux,
            t_duracaoUsuarioAux, t_siglaReg, t_duracaoSegurancaReg, t_duracaoUsuarioReg, tremMalha->PID,
            tremMalha->IDExterno, ordemFila , tremMalha->codigoTabela, dataChegadaTerm.asDateTime(),
            tremMalha->getPossuiCapacidade(), t_segmento->codZonaControleResponsavel,
            tremMalha->getOrdemFila().asDateTime(), tDataRegulador);

          t_trensFila->AddObject("", (TObject*)t_tremFila);

        } // for trens
      } // if filtro
    }

    t_trensFila->CustomSort(SortPorOrdem);

    cdsFilas->Close();
    cdsFilas->CreateDataSet();
    cdsFilas->Open();

    String tFilaAtual  = "";
    int tContadorGeral = 1;
    int tContadorGrupo = 1;
    for (int i = 0; i < t_trensFila->Count; i++)
    {
      t_tremFila = (TTremFila*)t_trensFila->Objects[i];

      if (FEditandoFilasInconsistentes_ ||
        (!FEditandoFilasInconsistentes_ && t_tremFila->mesaControle == TTPFormsManager::getInstance()->Mesa))
      {
        cdsFilas->Append();
        if (t_tremFila->fila != tFilaAtual)
        {
          if (tFilaAtual != "")
          {
            cdsFilasordemGeral->Value = tContadorGeral;
            tContadorGeral++;
            tContadorGrupo         = 1;
            cdsFilasativa->Visible = false;
            cdsFilasativa->Value   = false;
            cdsFilas->Post();
            cdsFilas->Append();
          }
          tFilaAtual = t_tremFila->fila;
        }

        cdsFilasordemGeral->Value = tContadorGeral;
        cdsFilasfila->Text    = t_tremFila->fila;
        cdsFilasordem->Text   = tContadorGrupo;
        cdsFilasprefixo->Text = t_tremFila->prefixo;
        cdsFilastipo->Text    = t_tremFila->tipo;
        cdsFilasativa->Value  = t_tremFila->ativa;
        cdsFilasorigem->Text  = t_tremFila->origem;
        cdsFilasdestino->Text = t_tremFila->destino;

        cdsFilaspatioAtual->Text     = t_tremFila->patioAtual;
        cdsFilasprevisaoSaida->Value = t_tremFila->previsaoSaida;

        cdsFilaspatioAuxiliar->Text  = t_tremFila->patioAuxiliar;
        cdsFilasduracaoSegAux->Text  = t_tremFila->duracaoSegurancaAuxiliar;
        cdsFilasduracaoUsuaAux->Text = t_tremFila->duracaoUsuarioAuxiliar;

        cdsFilaspatioRegulador->Text = t_tremFila->patioRegulador;
        cdsFilasduracaoSegReg->Text  = t_tremFila->duracaoSegurancaRegulador;
        cdsFilasduracaoUsuaReg->Text = t_tremFila->duracaoUsuarioRegulador;

        cdsFilasid->Text                          = t_tremFila->id;
        cdsFilasidExterno->Text                   = t_tremFila->idExterno;
        cdsFilasordemOriginal->Text               = t_tremFila->ordemOriginal;
        cdsFilastabela->Text                      = t_tremFila->tabela;
        cdsFilasdataPrevisaoChegadaTerminal->Text = t_tremFila->dataChegadaTerminal;
        cdsFilasmesaControle->Text                = t_tremFila->mesaControle;
        cdsFilasordemCalculada->Text              = t_tremFila->ordemCalculada;
        cdsFilasdataChegadaRegulador->Text        = t_tremFila->dataRegulador;

        TTPTremPtr tTrem = TTPFormsManager::getInstance()->Trens->get(t_tremFila->id);
        if(!tTrem.isNull())
          cdsFilasfilaDesativadaUsuario->Value        = tTrem->IsFilaDasativUsu;
        else
        int parar =0;
        cdsFilas->Post();

        tContadorGrupo++;
        tContadorGeral++;
      }
    }

    cdsFilas->IndexName = "cdsFilasIndex1";
    cxgFilasDBTableView1ordemGeral->SortOrder = soAscending;

    SetRegistroEditavel();

//    algorithm::CoreTMPlanner::getInstance()->getListaOrdemFilas();
    while (t_trensFila->Count > 0)
    {
       TTremFila* tf = (TTremFila* )t_trensFila->Objects[0];
       delete  tf;

      t_trensFila->Delete(0);
    }

   delete t_trensFila;
  }
  catch (Exception& e)
  {
    return;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::cboFilasChange(TObject *Sender)
{
  if (cboFilas->ItemIndex <= -1)
  {
    cboFilas->Text     = "FILAS";
    cdsFilas->Filter   = "";
    cdsFilas->Filtered = false;
    PreencheHorariosSegUsu("", "");
  }
  else if (cboFilas->ItemIndex > -1)
  {
    cdsFilas->Filter   = "fila = '" + cboFilas->Text + "'";
    cdsFilas->Filtered = true;
    bool acheiPonto    = false;

    if (!FEditandoFilasInconsistentes_)
    {
      for (int i = 0; i < FFilas_->Count; i++)
      {
        domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)FFilas_->Objects[i];
        if (t_filaMalha->getPatioDestino()->sigla == cboFilas->Text)
        {
          for (int j = 0; j < t_filaMalha->pontosFila->Count; j++)
          {
            domain::PontoFila *t_pontoFila = (domain::PontoFila*)t_filaMalha->pontosFila->Objects[j];

            if (t_pontoFila->getTipoPonto() == domain::TipoPontoFila::AUXILIAR)
            {
              AnsiString t_duracaoSegurancaAux =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoSeguranca().hours() * 60 +
                t_pontoFila->getDuracaoSeguranca().minutes());
              AnsiString t_duracaoUsuarioAux =
                TUteis::FormataDuracao(t_pontoFila->getDuracaoUsuario().hours() * 60 + t_pontoFila->getDuracaoUsuario()
                .minutes());
              PreencheHorariosSegUsu(t_duracaoSegurancaAux, t_duracaoUsuarioAux);
              acheiPonto = true;
            }
          }
          break;
        }
      } // For Filas
      if (!acheiPonto)
        PreencheHorariosSegUsu("", "");
    } // IF FILA Inconsistente
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::edtBuscarPrefixoEnter(TObject *Sender)
{
  if (edtBuscarPrefixo->Text == "PREFIXO TREM")
    edtBuscarPrefixo->Text = "";
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::edtBuscarPrefixoExit(TObject *Sender)
{
  if (edtBuscarPrefixo->Text.Length() == 0)
  {
    edtBuscarPrefixo->Text = "PREFIXO TREM";
    cboFilasChange(this);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::btnBuscarPrefixoClick(TObject *Sender)
{
  bool encontrei = false;
  for (int i = 0; i < cdsFilas->RecordCount; i++)
  {
    String prefixoAux = VarToStr(cxgFilasDBTableView1->DataController->GetValue(i, cxgFilasDBTableView1prefixo->Index));
    if (prefixoAux.Length() > 0 && prefixoAux == edtBuscarPrefixo->Text)
    {
      cxgFilasDBTableView1->DataController->FocusedRowIndex = i;
      encontrei = true;
      break;
    }
  }
  if (!encontrei)
  {
    Informacao("Prefixo no encontrado");
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::edtBuscarPrefixoKeyDown(TObject * Sender, WORD & Key, TShiftState Shift)
{
  if (Key == vkReturn)
  {
    if (edtBuscarPrefixo->Text.Length() == 0)
    {
      edtBuscarPrefixoExit(this);
      btnBuscarPrefixo->SetFocus();
    }
    else
      cboFilasChange(this);
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::PreencheHorariosSegUsu(AnsiString drSeguranca, AnsiString drUsuario)
{
  lblDuracaoSeguranca->Caption = "__:__";
  medDuracaoUsuario->Text      = "__:__";

  if (drSeguranca != "")
    lblDuracaoSeguranca->Caption = drSeguranca;

  if (drUsuario != "")
    medDuracaoUsuario->Text = drUsuario;

}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::medDuracaoUsuarioKeyDown(TObject * Sender, WORD & Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDuracaoUsuario->Text, Key, (TTPTipoFormatacaoCampoDataHora)3);

  if (temp.Length() > 0)
    medDuracaoUsuario->Text = temp;
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::acSalvarDuracaoUsuExecute(TObject * Sender)
{
  try
  {

    for (int i = 0; i < FFilas_->Count; i++)
    {
      domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)FFilas_->Objects[i];
      {
        FFilaMalha_ = t_filaMalha;

        if (cboFilas->ItemIndex == -1 || (cboFilas->ItemIndex != -1 && FFilaMalha_->getPatioDestino()
          ->sigla == cboFilas->Text))
        {
          if (!FFilaMalha_->pontosFila)
            return;
          int hora                       = medDuracaoUsuario->Text.SubString(0, 2).ToInt();
          int minutos                    = medDuracaoUsuario->Text.SubString(4, 2).ToInt();
          double duracaoUsuario          = (hora * 60) + minutos;
          algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

          if (!FFilaMalha_->pontosFila)
            return;

          for (int j = 0; j < FFilaMalha_->pontosFila->Count; j++)
          {
            domain::PontoFila *t_pontoFila = (domain::PontoFila*)FFilaMalha_->pontosFila->Objects[j];

            if (t_pontoFila->getTipoPonto() == domain::TipoPontoFila::AUXILIAR)
            {
              int duracaoSeguranca = t_pontoFila->getDuracaoSeguranca().total_seconds() / 60;
              // t_pontoFila->setDuracaoUsuario(duracao) ;
              core->alterarPontoFila(t_pontoFila->PID, duracaoSeguranca, duracaoUsuario);
            }
          }
        }
      }
    }

    CarregarTrens();

  }
  catch (Exception& e)
  {
    return;
  }
  cboFilasChange(this);
}
// ---------------------------------------------------------------------------

void __fastcall TFormFilas::acEditarPontosFilaExecute(TObject * Sender)
{
  TFormPontosFila *fPontosFila = new TFormPontosFila(this);
  fPontosFila->ShowModal();
  delete fPontosFila;
  fPontosFila = NULL;
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::acCancelarExecute(TObject * Sender)
{
  this->Close();
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::btnOkClick(TObject * Sender)
{
	bool lockMutex = false;
	try
  {

    if(FEditouOrdemFila_)
    {
      ModalResult = mrCancel;
    }

    TTPFormsManager::getInstance()->tryLockMutexProc(60,"Alterar Fila Term :Tente novamente em alguns segundos","Alterar Fila Term");


		lockMutex = true;

    AtualizarPosicaoTrens();
    if (FEditandoFilasInconsistentes_)
    {
      FFilas_->Clear();
    }
    //FFilas_ = TTPFormsManager::getInstance()->ValidarTrensFila();
    if (FFilas_->Count > 0)
    {
      try
      {
        CarregarFilas();
        CarregarTrens();
      }
      catch (Exception& e)
      {
        throw Exception("Erro na ordenao dos trens na(s) fila(s)");
      }
    }

		TTPFormsManager::getInstance()->MutexProc->unlock();

    ModalResult = mrOk;

    if (!FEditandoFilasInconsistentes_)
      this->Close();

  }
  catch (Exception& e)
  {
		Alerta(e.Message);
		if(lockMutex)
			TTPFormsManager::getInstance()->MutexProc->unlock();

		CarregarTrens();
    cboFilas->ItemIndex = 0;
    cboFilasChange(NULL);
    ModalResult = mrNone;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormFilas::SetRegistroEditavel()
{
  try
  {
    // Atualizar as ordens antes de setar novamente
    cdsFilas->First();
    int ordem   = 0;
    String fila = "";

    for (int j = 0; j < cboFilas->Items->Count; j++)
    {
      String fila        = cboFilas->Items->operator[](j);
      cdsFilas->Filter   = "fila = '" + fila + "'";
      cdsFilas->Filtered = true;
      bool start         = false;

      for (int i = 0; i < cdsFilas->RecordCount; i++)
      {
        if (cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemOriginal->Index)->Value == 0)
        {
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1editavel->Index)->Value = true;
          cdsFilas->Post();
          cdsFilas->Next();
          continue;
        }

        if (!start)
        {
          start = true;
          ordem = cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemOriginal->Index)->Value;
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1editavel->Index)->Value = false;
          cdsFilas->Post();
          cdsFilas->Next();
          continue;
        }

        if (ordem == cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemOriginal->Index)->Value)
        {
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1editavel->Index)->Value = true;
          cdsFilas->Post();
          cdsFilas->Prior();
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1editavel->Index)->Value = true;
          cdsFilas->Post();
          cdsFilas->Next();
        }
        else
        {
          ordem = cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemOriginal->Index)->Value;
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1editavel->Index)->Value = false;
          cdsFilas->Post();
        }

        cdsFilas->Next();
      }

      cdsFilas->Filter = "";
      cdsFilas->Filtered = false;
    }

    cdsFilas->Filter = "";
    cdsFilas->Filtered = false;

  }
  catch (Exception& e)
  {
    return;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormFilas::AtualizarPosicaoTrens(bool pIgnorarMesaAtual)
{
  if (!cdsFilas->IsEmpty())
  {
    // Atualizar as ordens antes de setar novamente
    this->Visible = false;
    Application->ProcessMessages();
    domain::TremMalha* tremMalhaFrente = NULL;
    cdsFilas->First();
    for (int i = 0; i < cdsFilas->RecordCount; i++)
    {
      String pidTrem = VarToStr(cxgFilasDBTableView1->DataController->GetValue(i, cxgFilasDBTableView1id->Index));

      if(pidTrem=="")
        tremMalhaFrente = NULL;
      else
      {
        domain::TremMalha* tremMalhaAtual =
              (domain::TremMalha*)FTrensFilasInconsistentes_->Objects[FTrensFilasInconsistentes_->IndexOf(pidTrem)];

        TTPTremPtr tTrem = TTPFormsManager::getInstance()->Trens->get(tremMalhaAtual->PID);

        bool filaAtiva = (cxgFilasDBTableView1->DataController->GetValue(i, cxgFilasDBTableView1ativa->Index));
        if(!tTrem.isNull() && tTrem->IsFilaDasativUsu)
        {
          filaAtiva = true;
        }

        String mesa = VarToStr(cxgFilasDBTableView1->DataController->GetValue(i, cxgFilasDBTableView1mesaControle->Index));
        if (filaAtiva && (!pIgnorarMesaAtual || (pIgnorarMesaAtual && TTPFormsManager::getInstance()
          ->Mesa != mesa)))
        {
          tremMalhaAtual->setTremFilaAnterior(tremMalhaFrente);
          tremMalhaFrente = tremMalhaAtual;
          tremMalhaAtual->ordremFila = DateTimeNullUNIX +(double)(cxgFilasDBTableView1->DataController->GetValue(i, cxgFilasDBTableView1ordem->Index));
        }
       }
    }

    /*for (int i = 0; i < cdsFilas->RecordCount; i++)
    {
      if (!cdsFilas->Fields->operator[](cxgFilasDBTableView1id->Index)->IsNull)
      {
        String pidTrem = cdsFilas->Fields->operator[](cxgFilasDBTableView1id->Index)->Value;
        bool filaAtiva = cdsFilas->Fields->operator[](cxgFilasDBTableView1ativa->Index)->Value.VBoolean;
        if (filaAtiva && (!pIgnorarMesaAtual || (pIgnorarMesaAtual && TTPFormsManager::getInstance()
          ->Mesa != cdsFilas->Fields->operator[](cxgFilasDBTableView1mesaControle->Index)->Text)))
        {
          domain::TremMalha* tremMalha =
            (domain::TremMalha*)FTrensFilasInconsistentes_->Objects[FTrensFilasInconsistentes_->IndexOf(pidTrem)];
          tremMalha->ordremFila = cdsFilas->Fields->operator[](cxgFilasDBTableView1ordem->Index)->Value;
        }
      }

      cdsFilas->Next();

    } */
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::cxgFilasDBTableView1KeyDown(TObject * Sender, WORD & Key, TShiftState Shift)
{
  if (Shift.Contains(ssCtrl)) // && FEditandoFilasInconsistentes_)
  {
    int indexRow     = cxgFilasDBTableView1->Controller->SelectedRecords[0]->Index;
    bool permiteAcao = !((indexRow == 0 && Key == 38) || (indexRow == cdsFilas->RecordCount - 1 && Key == 40) || !cdsFilasativa->Value);

    if (permiteAcao && (Key == 38 || Key == 40))
    {

      String myFila = VarToStr(cxgFilasDBTableView1->DataController->GetValue(indexRow,
      cxgFilasDBTableView1fila->Index));
      String myPrefixo = VarToStr(cxgFilasDBTableView1->DataController->GetValue(indexRow,
        cxgFilasDBTableView1prefixo->Index));

      if(myFila=="")
      return;


      FEditouOrdemFila_ = true;
      int myOrdem = (cxgFilasDBTableView1->DataController->GetValue(indexRow, cxgFilasDBTableView1ordem->Index));
      int myOrdemGeral = (cxgFilasDBTableView1->DataController->GetValue(indexRow,
        cxgFilasDBTableView1ordemGeral->Index));

      int indexAux = indexRow;

      if (Key == 38) // UP
      {
        indexAux--;
      }
      else if (Key == 40) // Down
      {
        indexAux++;
      }

      String filaAux = VarToStr(cxgFilasDBTableView1->DataController->GetValue(indexAux,
        cxgFilasDBTableView1fila->Index));
      String prefixoAux = VarToStr(cxgFilasDBTableView1->DataController->GetValue(indexAux,
        cxgFilasDBTableView1prefixo->Index));

      if(filaAux=="")
       return;

      bool filaAtivaAux = StrToBool(VarToStr(cxgFilasDBTableView1->DataController->GetValue(indexAux,
        cxgFilasDBTableView1ativa->Index)));

      if(!filaAtivaAux)
      {
        return;
      }

      int ordemAux = (cxgFilasDBTableView1->DataController->GetValue(indexAux, cxgFilasDBTableView1ordem->Index));
      int ordemGeralAux = (cxgFilasDBTableView1->DataController->GetValue(indexAux,
        cxgFilasDBTableView1ordemGeral->Index));

      if (myPrefixo.Length() > 0 && prefixoAux.Length() > 0 && myFila == filaAux)
      {
        if (cdsFilas->Locate("prefixo", prefixoAux, FLocate_))
        {
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1ordem->Index)->Value = myOrdem;
          cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemGeral->Index)->Value = myOrdemGeral;
          cdsFilas->Post();
        }
        if (cdsFilas->Locate("prefixo", myPrefixo, FLocate_))
        {
          cdsFilas->Edit();
          cdsFilas->Fields->operator[](cxgFilasDBTableView1ordem->Index)->Value = ordemAux;
          cdsFilas->Fields->operator[](cxgFilasDBTableView1ordemGeral->Index)->Value = ordemGeralAux;
          cdsFilas->Post();
        }
      }
      Key = 0;
    }
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::acExportarExcelExecute(TObject *Sender)
{
  try
  {
    SaveDialog->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
    SaveDialog->Title  = "Exportar para Excel...";

    if (SaveDialog->Execute())
    {
      ExportGridToExcel(SaveDialog->FileName, cxgFilas);
      MessageDlg("A planilha foi salva em " + SaveDialog->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
    }
  }
  catch (Exception& exception)
  {
    throw Exception("No foi possvel exportar para Excel");
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormFilas::cxgFilasDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender,
  TcxCustomGridRecord *ARecord, TcxCustomGridTableItem *AItem, TcxStyle *&AStyle)
{
  if (VarToStr(ARecord->Values[cxgFilasDBTableView1prefixo->Index]).Length() == 0)
  {
		AStyle = cxStyle2;
  }
  else if (VarToStr(ARecord->Values[cxgFilasDBTableView1ativa->Index]).Length() == 0 ||
    !StrToBool(VarToStr(ARecord->Values[cxgFilasDBTableView1ativa->Index])))
  {
    AStyle = cxFilaInativa;
    if(VarToStr(ARecord->Values[cxgFilasDBTableView1filaDesativadaUsuario->Index])!="")
     if(StrToBool(VarToStr(ARecord->Values[cxgFilasDBTableView1filaDesativadaUsuario->Index])))
      AStyle = cxFilaInativaUsu;
  }
  else if (FEditandoFilasInconsistentes_ && ARecord->Values[cxgFilasDBTableView1editavel->Index] != NULL)
  {
    String checked = VarToStr(ARecord->Values[cxgFilasDBTableView1editavel->Index]);
    if (checked.Length() != 0 && StrToBool(checked))
    {
      AStyle = cxErro;
    }
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::cxgFilasDBTableView1ativaCustomDrawCell(TcxCustomGridTableView *Sender, TcxCanvas *ACanvas,
  TcxGridTableDataCellViewInfo *AViewInfo, bool &ADone)
{
  if (VarToStr(AViewInfo->RecordViewInfo->GridRecord->Values[cxgFilasDBTableView1prefixo->Index]).Length() == 0)
  {

    TColor c = (AViewInfo->Selected) ? cxgFilasDBTableView1->Styles->Selection->Color
    :cxDisabled->Color ;
     ACanvas->FillRect(AViewInfo->Bounds, c);
    ADone = true;
  }
  // ---------------------------------------------------------------------------
}

void __fastcall TFormFilas::cxgFilasDBTableView1possuiCapacidadeCustomDrawCell(TcxCustomGridTableView *Sender,
  TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo, bool &ADone)
{
  if (VarToStr(AViewInfo->RecordViewInfo->GridRecord->Values[cxgFilasDBTableView1prefixo->Index]).Length() == 0)
  {
    AViewInfo->LookAndFeelPainter->DrawButton(ACanvas, AViewInfo->Bounds, "", cxbsDisabled, false,
      ACanvas->Brush->Color, ACanvas->Brush->Color, false, false);
    ADone = true;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormFilas::FormCreate(TObject *Sender)
{
  int parar = 0;
}
// ---------------------------------------------------------------------------
void __fastcall TFormFilas::acAtivarCalculoFilaExecute(TObject *Sender)
{
  String pidTrem = cdsFilasid->Value;
  TTPTrem* tTrem = &*TTPFormsManager::getInstance()->Trens->operator[](TTPFormsManager::getInstance()->Trens->IndexOf(pidTrem));
  if(tTrem)
  {
    if (!tTrem->ISCalculoFilaAtivo)
    {
      ((TFormTP *)Owner)->getTremFilho(tTrem);

      tTrem->IsFilaDasativUsu = false;
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      String tPID = "";
      int idx = core->getMalha()->listaTrens->IndexOf(tTrem->PID);
      if (idx >= 0)
        tPID = tTrem->PID;

      core->ativarFilaTrem(tPID);
      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

      TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, false);
      ((TFormTP *)Owner)->PlotarTremFilho(tTrem);

      cdsFilas->Edit();
      cdsFilasativa->Value = tTrem->ISCalculoFilaAtivo;
      cdsFilasfilaDesativadaUsuario->Value = tTrem->IsFilaDasativUsu;
      cdsFilas->Post();
    }
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormFilas::acDesativarCalculoFilaExecute(TObject *Sender)
{
  String pidTrem = cdsFilasid->Value;
  TTPTrem* tTrem = &*TTPFormsManager::getInstance()->Trens->operator[](TTPFormsManager::getInstance()->Trens->IndexOf(pidTrem));
  if(tTrem)
  {
    if (tTrem->ISCalculoFilaAtivo)
    {
      ((TFormTP *)Owner)->getTremFilho(tTrem);

      tTrem->IsFilaDasativUsu = true;

      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      String tPID = "";
      int idx = core->getMalha()->listaTrens->IndexOf(tTrem->PID);
      if (idx >= 0)
        tPID = tTrem->PID;

      core->desativarCalculoFilaTrem(tPID);
      // Sincronizar Trens Client / Server
      TTPFormsManager::getInstance()->SincronizarTremClientServer(tTrem);

      TTPFormsManager::getInstance()->PlotarTrem(tTrem, false, false, true, false);
      ((TFormTP *)Owner)->PlotarTremFilho(tTrem);

      cdsFilas->Edit();
      cdsFilasativa->Value = tTrem->ISCalculoFilaAtivo;
      cdsFilasfilaDesativadaUsuario->Value = tTrem->IsFilaDasativUsu;
      cdsFilas->Post();
    }
	}
}
//---------------------------------------------------------------------------

void __fastcall TFormFilas::cxgFilasContextPopup(TObject *Sender, TPoint &MousePos, bool &Handled)
{
  if(FEditandoFilasInconsistentes_)
  {
    acAtivarCalculoFila->Visible = false;
    acDesativarCalculoFila->Visible = false;

    return;
  }

  String pidTrem = cdsFilasid->Value;
  TTPTrem* tTrem = &*TTPFormsManager::getInstance()->Trens->operator[](TTPFormsManager::getInstance()->Trens->IndexOf(pidTrem));
  if(tTrem)
  {
    if (tTrem->ISCalculoFilaAtivo)
    {
      acAtivarCalculoFila->Visible = false;
      acDesativarCalculoFila->Visible = true;
    }
    else
    {
      acAtivarCalculoFila->Visible = true;
      acDesativarCalculoFila->Visible = false;
    }
  }
}
//---------------------------------------------------------------------------
void __fastcall TFormFilas::cxgFilasDBTableView1CellDblClick(TcxCustomGridTableView *Sender, TcxGridTableDataCellViewInfo *ACellViewInfo,
          TMouseButton AButton, TShiftState AShift, bool &AHandled)
{
  String pidTrem = cdsFilasid->Value;

  if(pidTrem=="")
    return;

  int index = TTPFormsManager::getInstance()->Trens->IndexOf(pidTrem);
  if(index<0)
   return;

  TTPTrem* tTrem = &*TTPFormsManager::getInstance()->Trens->operator[](index);
  if(tTrem)
	{
	 for(int i =0; i<tTrem->ItinerarioTrem->Movimentos->count(); i++ )
   if (tTrem->ItinerarioTrem->Movimentos->operator [](i)->SB->CodigoSegmento == cdsFilasfila->Value)
   {
     TTPFormsManager::getInstance()->setFocus("",&*tTrem->ItinerarioTrem->Movimentos->operator [](i));
   }
  }
}
//---------------------------------------------------------------------------






================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFPriorizarDestino.h =====
#ifndef UFPriorizarDestinosH
#define UFPriorizarDestinosH
#include "UDModuleMP.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Mask.hpp>
#include <Vcl.ActnList.hpp>
#include "cxClasses.hpp"
#include <Data.DB.hpp>
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include "cxLabel.hpp"
#include "cxGridBandedTableView.hpp"
#include <Vcl.Dialogs.hpp>
#include <Vcl.Menus.hpp>
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "cxColorComboBox.hpp"
#include "cxDropDownEdit.hpp"

namespace domain
{
  class TremMalha;
}

using namespace domain;
//---------------------------------------------------------------------------
class TFormPriorizarDestinos : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel4;
  TPanel *Panel3;
  TPanel *Panel2;
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
  TPanel *pnlPrincipal;
	TButton *btnSalvarDuracaoUsuario;
	TActionList *al;
	TAction *acInicializar;
	TAction *acSalvarDuracaoUsu;
	TAction *acEditarPontosFila;
	TAction *acCancelar;
  TDataSource *dsPatio;
  TcxGridDBTableView *cxgPatioDBTableView;
  TcxGridLevel *cxgPatioLevel;
  TcxGrid *cxgPatio;
  TcxStyleRepository *cxStyleRepositoryGrids;
  TcxStyle *cxHeader;
  TcxStyle *cxContentEven;
  TcxStyle *cxStyle21;
  TcxStyle *cxSelection;
  TcxStyle *cxBandHeader;
  TcxStyle *cxContent;
  TcxStyle *cxBandHeaderDesabilitado;
  TcxStyle *cxHeaderDesabilitado;
  TcxStyle *cxSLAExtrapoladoContent;
  TcxStyle *cxInterrompidoContent;
  TcxStyle *cxMapaVerde;
  TcxStyle *cxMapaVermelho;
  TcxStyle *cxEmAndamentoContent;
  TcxStyle *cxStyle22;
  TcxStyle *cxStyle23;
  TcxGridBandedTableViewStyleSheet *ssBandedTable;
  TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
  TcxGridTableViewStyleSheet *ssGridTable;
  TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
  TPopupMenu *mnuPrincipal;
  TImageList *il;
  TSaveDialog *SaveDialog;
  TAction *acExportarExcel;
  TMenuItem *ExportarExcel1;
  TcxStyle *cxErro;
  TcxStyle *cxDisabled;
  TcxStyle *cxDefault;
  TcxStyle *cxFilaInativa;
  TClientDataSet *cdsPatio;
  TcxStyle *cxFilaInativaUsu;
  TIntegerField *cdsPatioNUM_ORDEM;
  TStringField *cdsPatioNM_PATIO;
  TStringField *cdsPatioDC_PATIO;
  TStringField *cdsPatioLOTACAO;
  TStringField *cdsPatioORI_DEST;
  TStringField *cdsPatioPRODUTO;
  TStringField *cdsPatioTERMINAL;
  TcxGridDBColumn *cxgPatioDBTableViewNUM_ORDEM;
  TcxGridDBColumn *cxgPatioDBTableViewDC_PATIO;
  TcxGridDBColumn *cxgPatioDBTableViewLOTACAO;
  TcxGridDBColumn *cxgPatioDBTableViewORI_DEST;
  TcxGridDBColumn *cxgPatioDBTableViewNM_PATIO;
  TcxGridDBColumn *cxgPatioDBTableViewPRODUTO;
  TcxGridDBColumn *cxgPatioDBTableViewTERMINAL;
  TButton *cmdExcluirTodos;
  TCheckBox *chkSwitchItensOrdenados;
  TComboBox *cboOficializacao;
  TLabel *lblOficializacao;

	void __fastcall FormCreate(TObject *Sender);
  void __fastcall acCancelarExecute(TObject *Sender);
	void __fastcall btnOkClick(TObject *Sender);
  void __fastcall cxgPatioDBTableViewKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall acExportarExcelExecute(TObject *Sender);
  void __fastcall cxgPatioDBTableViewNavigatorButtonsButtonClick(TObject *Sender,
          int AButtonIndex, bool &ADone);
  void __fastcall cxgPatioDBTableViewEditValueChanged(TcxCustomGridTableView *Sender, TcxCustomGridTableItem *AItem);
  void __fastcall cmdExcluirTodosClick(TObject *Sender);
  void __fastcall cxgPatioDBTableViewCanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cboOficializacaoChange(TObject *Sender);



public:		// User declarations
  __fastcall TFormPriorizarDestinos(TComponent* Owner);
  __fastcall TFormPriorizarDestinos(TComponent* Owner, TStringList* FilasInconsistentes);
  inline __fastcall ~TFormPriorizarDestinos(void);

#pragma regin Enumeraoes
  enum class NAVIGATEGRIDBUTTONS { AddNewRecord=16, RemoveRecord, ConfirmeRecord, CancelEditRecord, RefreshRecord, RefreshRecordInDatabase };
#pragma end_region // Enumeraes

#pragma region Declaraes de variveis
private:	// User declarations
  bool m_hasData;
  bool m_editMode;
  bool m_newRow;
  bool m_pularevento;
  int  m_editRow;
  PtrQuery m_queryPatio;
  PtrQuery m_queryProduto;
  PtrQuery m_queryTerminal;
  algorithm::CoreTMPlanner * m_core;
  TStringList* m_oficializacoes;
#pragma end_region

#pragma region Mtodos Privados
private:
  void __fastcall IniciarDialog();
  bool __fastcall CarregarPatio();
  bool __fastcall CarregarProduto();
  bool __fastcall CarregarTerminal();

  void __fastcall ConfigurarGrid();

  void __fastcall LimparDataSet();
  void __fastcall PreencherComboPatio();
  void __fastcall PreencherComboProduto();
  void __fastcall PreencherComboTerminal();
  void __fastcall RecarregarGridDoBancoDeDados();
  void __fastcall PreencherGridPatios();

  void __fastcall CancelEdit();
  void __fastcall SalvarNoServer();
  void __fastcall SetNavigatorButtons(bool addnewEnabled, bool removeEnabled, bool confimeEnabled, bool CancelEditEnabled, bool refreshEnabled);
  void __fastcall SetButtons(bool okEnabled, bool cancelEnabled, bool removeItemsEnabled);

  String __fastcall GetRecordPatio(int row);
  String __fastcall GetRecordOrigemDestino(int row);
  String __fastcall GetRecordLotacao(int row);
  String __fastcall GetRecordProduto(int row);
  String __fastcall GetRecordTerminal(int row);

  String __fastcall GetRecordEditPatio();
  String __fastcall GetRecordEditOrigemDestino();
  String __fastcall GetRecordEditLotacao();
  String __fastcall GetRecordEditProduto();
  String __fastcall GetRecordEditTerminal();

  bool __fastcall ValidarDados();

  void __fastcall GridOnEdit();
  void __fastcall GridOnExportarExcel();
  void __fastcall GridOnKeyDownExecute(WORD & Key, TShiftState Shift);
  void __fastcall GridOnButtomClick(int AButtonIndex, bool &ADone);
#pragma end_region
};


//---------------------------------------------------------------------------
extern PACKAGE TFormPriorizarDestinos *FormPriorizarDestinos;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetTrem.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FWidgetTrem.h"

#include "UUteis.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "UFormsManager.h"
#include "UDModuleMP.h"

#include "UTPGrupoVMP.h"
#include "FichaTrem.h"
#include "UTPItinerarioTrem.h"
#include "UTPTipoTrem.h"
#include "UTPMovimento.h"
#include "UTPSB.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "FWidgetBase"
#pragma resource "*.dfm"
TFormWidgetTrem *FormWidgetTrem;
//---------------------------------------------------------------------------
__fastcall TFormWidgetTrem::TFormWidgetTrem(TComponent* Owner, TTPTrem* pTremPtr, TTPMovimento* pMovimentoSelecionado)
	: TFormWidgetBase(Owner)
{
	FTremPtr_ = pTremPtr;
	FMovimentoSelecionado_ = pMovimentoSelecionado;


}
//---------------------------------------------------------------------------
void __fastcall TFormWidgetTrem::FormShow(TObject *Sender)
{
	using namespace domain;

	this->Text = "Editando o Trem " + FTremPtr_->Prefixo;

  edtPrefixo->Enabled   = false;
  cboTipo->Enabled      = false;
  rdbCarregado->Enabled = false;
  rdbVazio->Enabled     = false;
  cboGrupoVMP->Enabled  = false;

  lblSegInicio->Caption = "Seg. Corte: ";

	edtPrefixo->Text               = FTremPtr_->Prefixo;
	cboTipo->Text                  = FTremPtr_->TipoTrem->Nome;

	cboSegmentoInicio->Text        = FTremPtr_->ItinerarioTrem->Movimentos->operator[]
		(0)->SB->CodigoSegmento;
	cboSegmentoFim->Text           = FTremPtr_->ItinerarioTrem->Movimentos->operator[]
		(FTremPtr_->ItinerarioTrem->Movimentos->count() - 1)->SB->CodigoSegmento;

	TTPGrupoVMPListPtr pListaCompletaGruposVMP = TTPFormsManager::getInstance()->GruposVMP;



	if (FMovimentoSelecionado_->ServerSegTremPlanejado)
	{
		FichaTrem* t_fichaTremSrv = FMovimentoSelecionado_->ServerSegTremPlanejado->fichaTrem;
		cboGrupoVMP->Text    = pListaCompletaGruposVMP->get(pListaCompletaGruposVMP->IndexOf(t_fichaTremSrv->PIDGrupoVMP))->Nome;
    rdbCarregado->Checked     = t_fichaTremSrv->lotacao.SubString(0, 1) == "C";
    rdbVazio->Checked         = t_fichaTremSrv->lotacao.SubString(0, 1) == "V";
		medVelocidade->Text       = t_fichaTremSrv->velocidadeTrem;
		medComprimento->Text      = t_fichaTremSrv->comprimentoTrem;
	}
}
//---------------------------------------------------------------------------


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFAlertaTrensTabelaBusca.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFAlertaTrensTabelaBusca.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FGridBase"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma link "dxUIAClasses"
#pragma link "dxGDIPlusClasses"
#pragma resource "*.dfm"
#include "UTPMovimento.h"
#include "UTPTrem.h"
#include "UTPSB.h"

TFormAlertaTrensTabelaBusca *FormAlertaTrensTabelaBusca;
//---------------------------------------------------------------------------
__fastcall TFormAlertaTrensTabelaBusca::TFormAlertaTrensTabelaBusca(TComponent* Owner, TStringList* pMovimentos)
  : TFormGridBase(Owner)
{
  FMovimentos_ = pMovimentos;
//  HICON imagem_icone = LoadIcon(NULL,IDI_QUESTION)  ;
//  TIcon *icon = new TIcon;
//  icon->Handle = imagem_icone;
//  Image1->Picture->Icon = icon;
  AtualizarGrid();
}
//---------------------------------------------------------------------------
void TFormAlertaTrensTabelaBusca::AtualizarGrid()
{
  cdsGrid->CreateDataSet();
  cdsGrid->DisableControls();
  cdsGrid->Open();

  FMovimentos_->Sorted = false;
  FMovimentos_->CustomSort(SortPorDataChegada);
  FMovimentos_->Sorted = true;

  for(int i = 0; i<FMovimentos_->Count; i++)
  {
    cdsGrid->Append();

    TTPMovimento* movimento = (TTPMovimento*)FMovimentos_->Objects[i];
    cdsGridIdTrem->Text  = movimento->Trem->PID;
		cdsGridPrefixo->Text = movimento->Trem->Prefixo;
		cdsGridLocal->Text   = movimento->SB->CodigoSegmento;
    cdsGridDataChegada->Value =  movimento->DataChegada;

    cdsGrid->Post();
  }

  cdsGrid->EnableControls();
  cdsGrid->First();
}
//---------------------------------------------------------------------------
int __fastcall  SortPorDataChegada(TStringList* List, int Index1, int Index2)
{
  TTPMovimento* movimento1 = (TTPMovimento*)List->Objects[Index1];
  TTPMovimento* movimento2 = (TTPMovimento*)List->Objects[Index2];

  if (movimento1->DataChegada < movimento2->DataChegada)
    return -1;
  if (movimento2->DataChegada < movimento1->DataChegada)
    return 1;

    return 0;
}
void __fastcall TFormAlertaTrensTabelaBusca::cxgGridDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
 acOkExecute(this);
}
//---------------------------------------------------------------------------
void __fastcall TFormAlertaTrensTabelaBusca::acCloseExecute(TObject *Sender)
{
 ModalResult = mrCancel;
}
//---------------------------------------------------------------------------
void __fastcall TFormAlertaTrensTabelaBusca::acOkExecute(TObject *Sender)
{
   ModalResult = mrOk;
}
//---------------------------------------------------------------------------




================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFEditarMovimento.cpp =====
// ---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "UFEditarMovimento.h"
#include "UDModuleMP.h"
#include "UTPMovimentoSeries.h"
#include "UFormsManager.h"
#include "UUteis.h"
#include "../domain/TremMalha.h"
#include "../domain/SegmentoTrem.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TFormEditarMovimento *FormEditarMovimento;

// ---------------------------------------------------------------------------
__fastcall TFormEditarMovimento::TFormEditarMovimento(TComponent* Owner) : TForm(Owner)
  {
  }

// ---------------------------------------------------------------------------
__fastcall TFormEditarMovimento::TFormEditarMovimento(TComponent* Owner, TTPTrem* pTrem,
  TTPMovimento* pMovimento, TTPMovimento* pMovimentoAnterior, TTPMovimento* pMovimentoPosterior,
  TTPSBListPtr pListSBs, bool pEditandoOrigem) : TForm(Owner)
  {
    FTrem_               = pTrem;
    FMovimento_          = pMovimento;
    FMovimentoAnterior_  = pMovimentoAnterior;
    FMovimentoPosterior_ = pMovimentoPosterior;
    FListSBs_            = pListSBs;
    FEditandoOrigem_     = pEditandoOrigem;

    // Se o movimento anterior (anteriorReal) for realizado, comporta igual setando origem
    if (FMovimentoAnterior_ != NULL && !FEditandoOrigem_)
    {
			if(FMovimentoAnterior_->Serie != NULL && FMovimentoAnterior_->MovimentoAnterior != NULL
				&& FMovimentoAnterior_->MovimentoAnterior->IsRealizado)
				FEditandoOrigem_ = true;
    }

    if(FEditandoOrigem_ && !FTrem_->PossuiMovimentoRealizado)
    {
      medDataFimParada->Text = FormatDateTime("dd/mm/yyyy", FMovimento_->DataChegada.DateTimeString());
      medHoraFimParada->Text = FormatDateTime("hh:nn", FMovimento_->DataChegada.DateTimeString());
    }
    else
    {
      medDataFimParada->Text = FormatDateTime("dd/mm/yyyy", FMovimento_->DataSaida.DateTimeString());
      medHoraFimParada->Text = FormatDateTime("hh:nn", FMovimento_->DataSaida.DateTimeString());
    }
    FTempoCurso_ = FMovimento_->DataSaida - FMovimento_->DataChegada;

    String tCaption = "Editar Movimento ";

    btnAnterior->Visible = false;
    btnPosterior->Visible = false;

		if(!FEditandoOrigem_ && FMovimentoAnterior_ && FMovimentoAnterior_->Serie != NULL && FMovimentoAnterior_->MovimentoAnterior != NULL
		&& FMovimentoAnterior_->MovimentoAnterior->MovimentoAnterior != NULL)
    {
			lblAnterior->Caption = FMovimentoAnterior_->MovimentoAnterior->MovimentoAnterior->SB->NomeVia;
    }
		else
    {
      lblAnterior->Caption = "Origem";
		}
    if(!FEditandoOrigem_ && FMovimentoPosterior_ != NULL)
      lblPosterior->Caption = FMovimentoPosterior_->SB->NomeVia;
    else
      lblPosterior->Caption = "";


    if (FEditandoOrigem_ && pMovimento!= NULL)
      {
        tCaption += " ORIGEM ";
				cboSBFimParada->Text    = pMovimento->SB->NomeVia;
        cboSBFimParada->Enabled = false;
        chkEmanciparTremFilho->Caption = "Quebrar vnculo trem: " + FTrem_->PrefixoPai;
        chkEmanciparTremFilho->Visible = FTrem_->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado != NULL
                                           && FTrem_->PrimeiroMovimentoPrevisto->ServerSegTremPlanejado->trem->tremPai != NULL;
      }
    else
      {
        chkEmanciparTremFilho->Visible = false;
        for (int z = 0; z < FListSBs_->count(); z++)
          {
            cboSBFimParada->Items->AddObject(FListSBs_->operator[](z)->NomeVia,
              (TObject*)&*FListSBs_->operator[](z));
          }

        cboSBFimParada->ItemIndex = cboSBFimParada->Items->IndexOf(FMovimento_->SB->NomeVia);
      }

    tCaption += FTrem_->Prefixo + " - " + " Movimento: " + FMovimento_->SB->NomeVia;
    this->Caption = tCaption;

  }

// ---------------------------------------------------------------------------
void __fastcall TFormEditarMovimento::btnOkClick(TObject *Sender)
{

  try
  {
  //  if(!FEditandoOrigem_ && !FMovimento_->IsParada)
  //    throw Exception ("Erro ao editar movimento!");

    if(FEditandoOrigem_ && !FTrem_->PossuiMovimentoRealizado)
    {
      if (medDataFimParada->Text + " " + medHoraFimParada->Text == FormatDateTime("dd/mm/yyyy hh:nn",
        FMovimento_->DataChegada.DateTimeString()) && cboSBFimParada->Text == FMovimento_->SB->NomeVia)
      {
				ModalResult = mrCancel;
        return;
      }
    }
    else
    {
      if (medDataFimParada->Text + " " + medHoraFimParada->Text == FormatDateTime("dd/mm/yyyy hh:nn",
        FMovimento_->DataSaida.DateTimeString()) && cboSBFimParada->Text == FMovimento_->SB->NomeVia)
      {
        ModalResult = mrCancel;
        return;
      }
    }

    TDateTime t_dataChegada = FMovimento_->DataChegada;
    TDateTime t_dataSaida   = StrToDateTime(medDataFimParada->Text + " " + medHoraFimParada->Text + ":" +
      "00");



    if (FEditandoOrigem_)
    {
      t_dataChegada = t_dataSaida - FTempoCurso_;
      t_dataSaida   = t_dataSaida ;
    }
    else
    {
			if(FMovimento_->Serie != NULL && FMovimento_->MovimentoAnterior != NULL)
      {
         if(t_dataSaida < t_dataChegada)
         {
           throw Exception ("Data de Partida no pode ser inferior a data de chegada!");
         }
      }
    }

    if (FMovimento_->TemPAT && t_dataSaida < FMovimento_->DataParadaAtividade)
    {
		 if(!FEditandoOrigem_)
		 {
			 throw Exception
				("O movimento possui PAT e a data de partida no pode ser inferior a data de chegada + o tempo do PAT!");
		 }
		}

    FMovimento_->DataChegada  = t_dataChegada;
    FMovimento_->DataSaida    = t_dataSaida;

		if (FEditandoOrigem_)
    {
      FTrem_->IsAlteradoUsuario = true;
			FTrem_->AlterouMovimentoOrigem = true;
    }

    if (!FEditandoOrigem_)
		{
      if (cboSBFimParada->ItemIndex != -1)
			{
        TTPSB* t_SB = (TTPSB*)cboSBFimParada->Items->Objects[cboSBFimParada->ItemIndex];
        // Ajustando a SB da Parada
        if (FMovimento_->SB->NomeVia != t_SB->NomeVia && FMovimento_->ServerSegTremPlanejado != NULL)
        {
          FMovimento_->ServerSegTremPlanejado->setSBUsuario(t_SB->NomeVia);
        }
      }
      else
      {
        throw Exception("A SB no foi selecionada corretamente!");
      }
		}
  }
  catch (Exception& e)
  {
    Alerta(e.Message);
    ModalResult = mrNone;
  }

}
// ---------------------------------------------------------------------------
void __fastcall TFormEditarMovimento::medHoraFimParadaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraFimParada->Text, Key, (TTPTipoFormatacaoCampoDataHora)2);

  if(temp.Length() > 0)
    medHoraFimParada->Text = temp;
}
//---------------------------------------------------------------------------

void __fastcall TFormEditarMovimento::medDataFimParadaKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medDataFimParada->Text, Key, (TTPTipoFormatacaoCampoDataHora)1);

  if(temp.Length() > 0)
    medDataFimParada->Text = temp;
}
//---------------------------------------------------------------------------

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFPontosFila.cpp =====
//---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFPontosFila.h"
#include "UFDetalharPontosFila.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxGraphics"
#pragma link "cxImageList"
#pragma resource "*.dfm"
TFormPontosFila *FormPontosFila;
//---------------------------------------------------------------------------
__fastcall TFormPontosFila::TFormPontosFila(TComponent* Owner)
	: TForm(Owner)
{
  CarregarPontosFila();

}
//---------------------------------------------------------------------------
void __fastcall TFormPontosFila::CarregarPontosFila()
{
  stgPontosFila->ColWidths[0] = 0;
  stgPontosFila->Cols[0]->Text = "#";
  stgPontosFila->ColWidths[1] = 115;
  stgPontosFila->Cols[1]->Text = "Destino";
  stgPontosFila->ColWidths[2] = 150;
  stgPontosFila->Cols[2]->Text = "Anterior";
  stgPontosFila->ColWidths[3] = 115;
  stgPontosFila->Cols[3]->Text = "Ativo";
  PtrQuery qrPontosFila = TDAO::getPontosFila();
  //qrPostosFila->Fields->operator [](0)->Name
  int j=1;
  while (!qrPontosFila->Eof)
  {
	stgPontosFila->Cells[0][j] = qrPontosFila->FieldByName("ID_FILA_TERM")->Text;
	stgPontosFila->Cells[1][j] = qrPontosFila->FieldByName("CD_SGMT_DEST_TREM")->Text;
	stgPontosFila->Cells[2][j] = qrPontosFila->FieldByName("CD_SGMT_ANTR_SNTD")->Text;
	stgPontosFila->Cells[3][j] = qrPontosFila->FieldByName("SGMT_ATVO")->Text;
	qrPontosFila->Next();
	j++;
  }

  stgPontosFila->RowCount = j+1;

  MudaTextoBtnAtivar(stgPontosFila->Row);
}


void __fastcall TFormPontosFila::btnDetalharClick(TObject *Sender)
{
  String idFila = stgPontosFila->Cells[0][stgPontosFila->Row];
  String patioDestino = stgPontosFila->Cells[1][stgPontosFila->Row];
  String patioAnterior = stgPontosFila->Cells[2][stgPontosFila->Row];

  FormDetalharPontosFila = new TFormDetalharPontosFila(idFila,patioDestino,patioAnterior);
  FormDetalharPontosFila->ShowModal();
}
//---------------------------------------------------------------------------


void __fastcall TFormPontosFila::btnAtivarClick(TObject *Sender)
{
  String idFila = stgPontosFila->Cells[0][stgPontosFila->Row];
  bool ativar =  stgPontosFila->Cells[3][stgPontosFila->Row] == "F";

  TDAO::ativarPontoFila(idFila, ativar);
  CarregarPontosFila();
}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::btnBuscarPrefixoClick(TObject *Sender)
{
  edtBuscarPatio->SelectAll();
  for(int i=0; i< stgPontosFila->RowCount; i++)
  {
   if(stgPontosFila->Cells[1][i] == edtBuscarPatio->Text)
   {
	 stgPontosFila->Row = i;
	 return;
   }

  }
  stgPontosFila->Row = 0;

}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::edtBuscarPatioEnter(TObject *Sender)
{
 if(edtBuscarPatio->Text == "SIGLA PATIO")
	 edtBuscarPatio->Text = "";
}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::edtBuscarPatioExit(TObject *Sender)
{
  if (edtBuscarPatio->Text.Length() == 0)
	   edtBuscarPatio->Text = "SIGLA PATIO";
}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::edtBuscarPatioKeyDown(TObject *Sender, WORD &Key,
          TShiftState Shift)
{
  if(Key == vkReturn)
   btnBuscarPrefixoClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::stgPontosFilaSelectCell(TObject *Sender, int ACol,
		  int ARow, bool &CanSelect)
{
 if(ARow==0) return;

  MudaTextoBtnAtivar(ARow);
}
//---------------------------------------------------------------------------

void __fastcall TFormPontosFila::MudaTextoBtnAtivar(int ARow)
{

 btnAtivar->Enabled =  stgPontosFila->Cells[0][ARow] != "";

 if(stgPontosFila->Cells[3][ARow] == "V")
	btnAtivar->Caption = "Desativar";
  else
	btnAtivar->Caption = "Ativar";
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFControleAcesso.cpp =====
            // ---------------------------------------------------------------------------

#include <vcl.h>
#include <windows.h>
#include <assert.h>
#include <lm.h>
#include <stdlib.h>
#include <winldap.h>
#pragma hdrstop
#include "UFControleAcesso.h"
#include "UUteis.h"
#include "UDAO.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"

#pragma comment (lib, "wldap32.lib")
#pragma link "wldap32.lib"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "dxGDIPlusClasses"
#pragma resource "*.dfm"
TFormControleAcesso *FormControleAcesso;

// ---------------------------------------------------------------------------
__fastcall TFormControleAcesso::TFormControleAcesso(TComponent* Owner, String pBD, String pSchema) : TForm(Owner)
{
  this->Caption     = "OptMove - Verso: " + TUteis::getVersaoExe();
  edtBD->Text       = pBD;
  edtAmbiente->Text = pSchema;
  lblModuloVersao->Caption    = "Otimizao de Movimento - v."+TUteis::getVersaoExe();
  lblModuloVersaoSombra->Caption = lblModuloVersao->Caption;
}

// ---------------------------------------------------------------------------
void __fastcall TFormControleAcesso::btnOkClick(TObject *Sender)
{
  try
  {
    if (edtUsuario->Text.Length() < 3)
      throw Exception("Usurio invlido");
    if (edtSenha->Text.Length() < 3)
      throw Exception("Senha invlida");
    if (edtBD->Text.Length() < 8)
      throw Exception("Informe o Banco corretamente");
    String tpLogIn = algorithm::CoreTMPlanner::getInstance()->getParamByName("LOGINTYPE");
    if (tpLogIn == "AD")
    {
      String nome = "";
			int nivel   = -1;
      if (!VerificarAcessoAD(edtUsuario->Text, edtSenha->Text, nome, nivel))
			{
				throw Exception("Usurio ou Senha invlido(s)!");
      }
      if (nome == "" || nivel <= 0)
      {
        throw Exception("usuario no configurado no Active Directory");
			}

			NivelAcessoUsuario = nivel;
			NomeUsuario = nome;
			CodigoUsuario       =edtUsuario->Text;

      AnsiString NameHost;
      AnsiString IPHost;
      NameHost = TUteis::getNameHost();
			IPHost = TUteis::getIPHost(NameHost);
      TDAO::inserirLogAcesso(edtUsuario->Text, IPHost, NameHost);
    }
    else if (tpLogIn == "DB")
    {
      PtrQuery qrDadosUsario = TDAO::getDadosUsuario(edtUsuario->Text);
      if (!qrDadosUsario->Eof)
      {
         //*10 para teste do usurio
				NivelAcessoUsuario = (qrDadosUsario->FieldByName("CD_NIVEL_PERF_INTN")->AsInteger)*10;
				NomeUsuario        = qrDadosUsario->FieldByName("NM_APLD_USUA")->Text;
				CodigoUsuario      = edtUsuario->Text;
        String senhaDB =TUteis::Decrypt(qrDadosUsario->FieldByName("DC_SENHA_INTN")->Text);
        if (edtSenha->Text != senhaDB ||senhaDB =="")
        {
          throw Exception("Usurio ou Senha invlido(s)!")  ;
        }

      }
      else
        throw Exception("Usurio no cadastrado");
    }
    else
    {
      throw Exception("Tipo de login no configurado ");
    }

    ModalResult = mrOk;

  }
  catch (Exception& e)
  {
    Informacao(e.Message);
    ModalResult = mrNone;
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormControleAcesso::btnCancelarClick(TObject *Sender)
{
  ModalResult = mrCancel;
}

// ---------------------------------------------------------------------------
void __fastcall TFormControleAcesso::FormShow(TObject *Sender)
{

  char Usuario[40];
  const unsigned long BUFSIZE = 255;
  unsigned long dwSize        = BUFSIZE;
  wchar_t pbuf[BUFSIZE + 1];
  if (GetUserName(pbuf, &dwSize))
  {
    strcpy(Usuario, AnsiString(pbuf).c_str());
    edtUsuario->Text = Usuario;
    edtSenha->SetFocus();
  }
  else
  {
    edtUsuario->SetFocus();
  }
}
 inline __fastcall  TFormControleAcesso::~TFormControleAcesso(void)
 {
 }
// ---------------------------------------------------------------------------
bool __fastcall TFormControleAcesso::VerificarAcessoAD(String pUsuario, String pSenha, String &pNomeUsuario,
  int &pNivelAcesso)
{
  try
  {
    String hst   = algorithm::CoreTMPlanner::getInstance()->getParamByName("LDAPHOST");
    int ldapPort = algorithm::CoreTMPlanner::getInstance()->getParamByName("LDAPPORT").ToIntDef(389);

    AnsiString Host     = hst; // "mrs.com.br"; // "ldap://mrs.com.br:389";
    AnsiString User     = pUsuario;
    AnsiString Password = pSenha;

    LDAP* pLdapConnection = NULL;
    AnsiString domain     = AnsiString(algorithm::CoreTMPlanner::getInstance()->getParamByName("LDAPDOMAIN"));
    PCHAR pMyDN           = domain.c_str();
    SEC_WINNT_AUTH_IDENTITY secIdent;

    pLdapConnection = ldap_init(String(Host.c_str()).c_str(), ldapPort);

    ULONG lRtn = LDAP_SUCCESS;
    lRtn       = ldap_connect(pLdapConnection, NULL);

    secIdent.User           = (unsigned short*)User.c_str();
    secIdent.UserLength     = strlen(User.c_str());
    secIdent.Password       = (unsigned short*)Password.c_str();
    secIdent.PasswordLength = strlen(Password.c_str());
    secIdent.Domain         = (unsigned short*)Host.c_str();
    secIdent.DomainLength   = strlen(Host.c_str());
    secIdent.Flags          = SEC_WINNT_AUTH_IDENTITY_ANSI;

    lRtn = ldap_bind_sA(pLdapConnection, // Session Handle
      pMyDN, // Domain DN
      (PCHAR) & secIdent, // Credential structure
      LDAP_AUTH_NEGOTIATE); // Auth mode
    if (lRtn != LDAP_SUCCESS)
    { // ERRO DE CONEXAO.
     unsigned long  dasdsa  = ldap_unbind_s(pLdapConnection);
//      ldap_control_free();
      return false;
    }

    ULONG errorCode = LDAP_SUCCESS;
    LDAPMessage* pSearchResult;
    // PCHAR pMyFilter = "(&(objectClass=user))";
    AnsiString filtro = "(&(objectClass=*)(sAMAccountName=";
    filtro += pUsuario;
    filtro += "))";
    PCHAR pMyFilter = filtro.c_str();
    PCHAR pMyAttributes[3];

    pMyAttributes[0] = "memberOf";
    pMyAttributes[1] = "displayName";
    pMyAttributes[2] = NULL;

    errorCode = ldap_search_sA(pLdapConnection, // Session handle
      pMyDN, // DN to start search
      LDAP_SCOPE_SUBTREE, // Scope
      pMyFilter, // Filter
      pMyAttributes, // Retrieve list of attributes
      0, // Get both attributes and values
      &pSearchResult); // [out] Search results

    if (errorCode != LDAP_SUCCESS)
    {
      String msg;
      msg.printf(L"ldap_search_s failed with 0x%0lx \n", errorCode);
      ldap_unbind_s(pLdapConnection);
      if (pSearchResult != NULL)
        ldap_msgfree(pSearchResult);
      return false;
    }
    ULONG numberOfEntries;

    numberOfEntries = ldap_count_entries(pLdapConnection, // Session handle
      pSearchResult); // Search result

    if (numberOfEntries == NULL)
    {

      String msg;
      msg.printf(L"ldap_count_entries failed with 0x%0lx \n", errorCode);
      ldap_unbind_s(pLdapConnection);
      if (pSearchResult != NULL)
        ldap_msgfree(pSearchResult);
      return false;
    }
    LDAPMessage* pEntry = NULL;
    PCHAR pEntryDN = NULL;
    ULONG iCnt     = 0;
    wchar_t* sMsg;
    BerElement* pBer = NULL;
    PCHAR pAttribute = NULL;
    PCHAR* ppValue   = NULL;
    ULONG iValue     = 0;

    for (iCnt = 0; iCnt < numberOfEntries; iCnt++)
    {
      // Get the first/next entry.
      if (!iCnt)
        pEntry = ldap_first_entry(pLdapConnection, pSearchResult);
      else
        pEntry = ldap_next_entry(pLdapConnection, pEntry);
      if (pEntry == NULL)
      {
        String msg;
        msg.printf(L"%s failed with 0x%0lx \n", sMsg, LdapGetLastError());
        ldap_unbind_s(pLdapConnection);
        ldap_msgfree(pSearchResult);
        return false;
      }
      pAttribute = ldap_first_attributeA(pLdapConnection, // Session handle
        pEntry, // Current entry
        &pBer); // [out] Current BerElement
      while (pAttribute != NULL)
      {
				String attName = pAttribute;

					ppValue = ldap_get_valuesA(pLdapConnection, // Session Handle
					pEntry, // Current entry
          pAttribute); // Current attribute

        // Print status if no values are returned (NULL ptr)
				if (ppValue != NULL)
        {
					iValue = ldap_count_valuesA(ppValue);
					if (iValue)
          {

            ULONG z;
            String attValue = "";
            // Output more values if available
            for (z = 0; z < iValue; z++)
            {
							attValue += String(ppValue[z]);
						}
						if (attName == "displayName")
              pNomeUsuario = attValue;
            else if (attName == "memberOf")
            {
							TXStringList* acessProfile = TDAO::getPerfisAcesso();
              for (int i = 1; i < acessProfile->Count; i += 2)
              {
								String profile = acessProfile->operator[](i);
                if (attValue.Pos(profile))
                {
                  pNivelAcesso = acessProfile->operator[](i - 1).ToIntDef(0);
                  break;
                }
							}
						}
          }
        }
        ppValue = NULL;
        // ldap_memfree(pAttribute);

        // Get next attribute name.
        pAttribute = ldap_next_attributeA(pLdapConnection, // Session Handle
          pEntry, // Current entry
          pBer); // Current BerElement
			}
    }
     //ldap_unbind(pLdapConnection);
 		return true;
  }
  catch (Exception& e)
  {
    return false;
  }
}

void __fastcall TFormControleAcesso::Image1Click(TObject *Sender)
{
  ModalResult = mrCancel;
}
//---------------------------------------------------------------------------



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FDebugConflito.cpp =====
// ---------------------------------------------------------------------------


#include <vcl.h>
#include "Winapi.DwmApi.hpp"
#include <cxExport.hpp>
#include <cxGridExportLink.hpp>
#include "cxGrid.hpp"
#pragma hdrstop
#include "FDebugConflito.h"
#pragma region Server
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
//#include "..\domain\ConflitoCandidato.h"
//#include "..\domain\SegmentoTremOficializado.h"
//#include "..\domain\SegmentoTremRealizado.h"
#pragma end_region
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxGrid"
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "cxGrid"
#pragma link "cxGrid"
#pragma link "cxGrid"
#pragma link "cxGrid"
#pragma resource "*.dfm"


TForm1 *Form1;

// ---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner, domain::Conflito* conflito, domain::ConflitoCandidato* confCandidato)
  : TForm(Owner)
{
  /*
   using namespace domain;
   if (confCandidato != NULL)
   {

   String periodoConflito                 = confCandidato->periodoConflito.asString();
   this->edtPeriodoConflito->Text         = periodoConflito;
   this->edtisConflitoComInterdicao->Text = confCandidato->isConlitoComInterdicao ? "True" : "False";
   if (confCandidato->isConlitoComInterdicao)
   {
   this->edtSegmentoConflito->Text = confCandidato->segmentoTremConflitoInterdicao->segmentoOcupado->segmento;

   this->edtTremInterdicao->Text = confCandidato->segmentoTremConflitoInterdicao->trem->prefixoTrem;
   }
   else
   this->edtSegmentoConflito->Text = confCandidato->segmentoConflitado->segmento;

   }
   this->edtIsDescartado->Text = "false";
   if (conflito != NULL)
   {
   this->edtQtdTrensConflito->Text = String(conflito->trensConflitados->Count);
   this->edtSBConflito->Text       = conflito->sbConflito->sb;

   this->edtTremVencedor->Text = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])
   ->segmentoTrem->trem->prefixoTrem;

   this->edt1Perdedor->Text = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])
   ->segmentoTrem->trem->prefixoTrem;

   domain::trainPriority tp          = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])->prioridade;
   this->edtPrioridadevencedor->Text = String(tp.elemento.selecaoUsua) + "-" + String(tp.elemento.cargaPerigosa) +
   "-" + String(tp.elemento.metaTrem) + "-" + String(tp.elemento.pesoTrem) + "-" + String(tp.elemento.tipoTrem);

   tp                                = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])->prioridade;
   this->edtPrioridadePerdedor->Text = String(tp.elemento.selecaoUsua) + "-" + String(tp.elemento.cargaPerigosa) +
   "-" + String(tp.elemento.metaTrem) + "-" + String(tp.elemento.pesoTrem) + "-" + String(tp.elemento.tipoTrem);

   }
   else if (!confCandidato->isConlitoComInterdicao)

   {
   this->edtIsDescartado->Text = "true";
   }
   */
  /*
   stgConflitos->ColWidths[0]  = 30;
   stgConflitos->Cols[0]->Text = "#";
   stgConflitos->ColWidths[1]  = 250;
   stgConflitos->Cols[1]->Text = "PeriodoConflito";

   stgConflitos->ColWidths[2]  = 70;
   stgConflitos->Cols[2]->Text = "ComInterdicao";

   stgConflitos->ColWidths[3]  = 80;
   stgConflitos->Cols[3]->Text = "TremInterdicao";

   stgConflitos->ColWidths[4]  = 60;
   stgConflitos->Cols[4]->Text = "Segmento";

   stgConflitos->ColWidths[5]  = 30;
   stgConflitos->Cols[5]->Text = "Qtd";

   stgConflitos->ColWidths[6]  = 50;
   stgConflitos->Cols[6]->Text = "SB";

   stgConflitos->ColWidths[7]  = 80;
   stgConflitos->Cols[7]->Text = "TremVencedor";

   stgConflitos->ColWidths[8]  = 200;
   stgConflitos->Cols[8]->Text = "Prioridade";

   stgConflitos->ColWidths[9]  = 80;
   stgConflitos->Cols[9]->Text = "TremPerdedor";

   stgConflitos->ColWidths[10]  = 200;
   stgConflitos->Cols[10]->Text = "Prioridade";

   stgConflitos->ColWidths[11]  = 80;
   stgConflitos->Cols[11]->Text = "Tipo";

   stgConflitos->RowCount = 2;
   */
  this->cdsGrid->Close();
  this->cdsGrid->CreateDataSet();
  this->cdsGrid->Open();

  TRect Recto(Left, Top, Left + PanelCandidatos->Width, Top + ClientHeight);

  PanelConflitos->ManualFloat(Recto);
  PanelConflitos->ManualDock(PageControl1, PageControl1, alClient);
  PageControl1->Pages[PageControl1->PageCount - 1]->Caption = PanelConflitos->Caption;
  PanelCandidatos->ManualFloat(Recto);
  PanelCandidatos->ManualDock(PageControl1, PageControl1, alClient);
  PageControl1->Pages[PageControl1->PageCount - 1]->Caption = PanelCandidatos->Caption;
  panelDeslocados->ManualFloat(Recto);
  panelDeslocados->ManualDock(PageControl1, PageControl1, alClient);
  PageControl1->Pages[PageControl1->PageCount - 1]->Caption = panelDeslocados->Caption;
  Application->ProcessMessages();

  delete TabSheet2;
  delete TabSheet1;
  delete TabSheet3;
  PageControl1->ActivePageIndex = 0;
}

void TForm1::adicionarConflito(domain::Conflito* conflito, domain::ConflitoCandidato* confCandidato)
{
  cdsGrid->Append();
  using namespace domain;
  String prioridadePer  = "";
  String prioridadeVenc = "";
  if (confCandidato != NULL)
  {

    String periodoConflito = confCandidato->periodoConflito.asString();
  }
  if (conflito)
  {
    domain::PRIORIDADE tp = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])->prioridade;
    prioridadeVenc        = String(tp.elemento.usuario) + "-" + String(tp.elemento.aguardaInterdicao) + "-" +
      String(tp.elemento.mercadoria) + "-" + String(tp.elemento.saidaterminal) + "-" + String(tp.elemento.aguadaPAT) +
      "-" + String(tp.elemento.aguardaCaminho) + "-" + String(tp.elemento.coeficienteParada) + "-" +
      String(tp.elemento.metaTrem) + "-" + String(tp.elemento.tipoTrem) + "-" + String(tp.elemento.pesoTrem) + "-" +
      String(tp.elemento.chegadaTremAFrente);

    if (conflito->trensPorPrioridade->Count > 1)
    {
      tp            = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])->prioridade;
      prioridadePer = String(tp.elemento.usuario) + "-" + String(tp.elemento.aguardaInterdicao) + "-" +
        String(tp.elemento.mercadoria) + "-" + String(tp.elemento.saidaterminal) + "-" + String(tp.elemento.aguadaPAT) +
        "-" + String(tp.elemento.aguardaCaminho) + "-" + String(tp.elemento.coeficienteParada) + "-" +
        String(tp.elemento.metaTrem) + "-" + String(tp.elemento.tipoTrem) + "-" + String(tp.elemento.pesoTrem) + "-" +
        String(tp.elemento.chegadaTremAFrente);

    }
  }

  if (confCandidato != NULL)
  {
    cdsGridindex->Value           = cdsGrid->RecordCount + 1;
    cdsGridPeriodoConflito->Value = confCandidato->periodoConflito.asString();
    cdsGridComInterdicao->Value   = confCandidato->isConlitoComInterdicao ? "True" : "False";

    cdsGridTipo->Value = String(confCandidato->tipoConflito);
    if (confCandidato->isConlitoComInterdicao)
    {
      cdsGridTremInterdicao->Value = confCandidato->segmentoTremConflitoInterdicao->trem->prefixoTrem;

      cdsGridSegmento->Value = confCandidato->segmentoTremConflitoInterdicao->segmentoOcupado->segmento;

    }
    else
    {
      cdsGridSegmento->Value = confCandidato->segmentoConflitado->segmento;
    }
  }
  if (conflito != NULL)
  {

    cdsGridSB->Value  = conflito->sbConflito->sb;
    cdsGridQtd->Value = (conflito->trensPorPrioridade->Count);
    // stgConflitos->Cells[3][row] = confCandidato->segmentoConflitado->segmento;
    cdsGridTremVencedor->Value = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])
      ->segmentoTrem->trem->prefixoTrem;
    cdsGridPrioridade->Value   = prioridadeVenc;
    if (conflito->trensPorPrioridade->Count >1)
    {
    cdsGridTremPerdedor->Value = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])
      ->segmentoTrem->trem->prefixoTrem;
    }
    cdsGridPrioridadePerdedor->Value = prioridadePer;
    /*
     stgConflitos->Cells[4][row] = String(conflito->trensConflitados->Count);
     stgConflitos->Cells[5][row] = conflito->sbConflito->sb;
     stgConflitos->Cells[6][row] = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])
     ->segmentoTrem->trem->prefixoTrem;

     domain::trainPriority tp    = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[0])->prioridade;
     stgConflitos->Cells[7][row] = String(tp.elemento.usuario) + "-" + String(tp.elemento.saidaterminal) + "-" +
     String(tp.elemento.aguardaInterdicao) + "-" + String(tp.elemento.aguadaPAT) + "-" +
     String(tp.elemento.aguardaInterdicao) + "-" + String(tp.elemento.aguardaCaminho) + "-" +
     String(tp.elemento.mercadoria) + "-" + String(tp.elemento.metaTrem) + "-" + String(tp.elemento.pesoTrem) + "-" +
     String(tp.elemento.tipoTrem);

     stgConflitos->Cells[8][row] = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])
     ->segmentoTrem->trem->prefixoTrem;
     tp                          = ((SegmentoTremImpactado*)conflito->trensPorPrioridade->Objects[1])->prioridade;
     stgConflitos->Cells[9][row] = String(tp.elemento.usuario) + "-" + String(tp.elemento.saidaterminal) + "-" +
     String(tp.elemento.aguardaInterdicao) + "-" + String(tp.elemento.aguadaPAT) + "-" +
     String(tp.elemento.aguardaInterdicao) + "-" + String(tp.elemento.aguardaCaminho) + "-" +
     String(tp.elemento.mercadoria) + "-" + String(tp.elemento.metaTrem) + "-" + String(tp.elemento.pesoTrem) + "-" +
     String(tp.elemento.tipoTrem);
     */
  }
  if (!conflito && !confCandidato)
  {
    // stgConflitos->Cells[0][row] = "-";
    // stgConflitos->Cells[1][row] = "-";
    // stgConflitos->Cells[2][row] = "-";
    // stgConflitos->Cells[3][row] = "-";
    //
    // stgConflitos->Cells[4][row]  = "-";
    // stgConflitos->Cells[6][row]  = "-";
    // stgConflitos->Cells[5][row]  = "-";
    // stgConflitos->Cells[7][row]  = "Sem conflitos";
    // stgConflitos->Cells[8][row]  = "Sem conflitos";
    // stgConflitos->Cells[9][row]  = "Sem conflitos";
    // stgConflitos->Cells[10][row] = "Sem conflitos";

  }
  cdsGrid->Post();
}

// ---------------------------------------------------------------------------
void __fastcall TForm1::FormCreate(TObject *Sender)
{
  /* int pvAttribute;
   pvAttribute = DWMFLIP3D_EXCLUDEABOVE;
   if (DwmCompositionEnabled)
   DwmSetWindowAttribute(Handle, DWMWA_FLIP3D_POLICY, &pvAttribute, sizeof(Integer));
   */
}
// ---------------------------------------------------------------------------

void __fastcall TForm1::acExportarExcelExecute(TObject *Sender)
{
  try
  {
    SaveDialogGrid->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
    SaveDialogGrid->Title  = "Exportar para Excel...";

    if (SaveDialogGrid->Execute())
    {
      TcxGrid* grid = GetActiveGrid(PageControl1->ActivePage);
      ExportGridToExcel(SaveDialogGrid->FileName, grid);
      MessageDlg("A planilha foi salva em " + SaveDialogGrid->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
    }
  }
  catch (Exception& exception)
  {
    throw Exception("No foi possvel exportar para Excel");
  }

}
// ---------------------------------------------------------------------------

void __fastcall TForm1::GridEnableControls()

{

  this->Visible = true;

  cdsGrid->EnableControls();
 cdsGrid2->EnableControls();
  TRect Recto(Left, Top, Left + PanelCandidatos->Width, Top + ClientHeight);

  if (!PanelCandidatos->Visible)

  {
    PanelCandidatos->ManualFloat(Recto);
    PanelCandidatos->ManualDock(PageControl1, PageControl1, alClient);
  }

  if (!PanelConflitos->Visible)

  {

    PanelConflitos->ManualFloat(Recto);
    PanelConflitos->ManualDock(PageControl1, PageControl1, alClient);
  }
  if (!PanelOrdemSegmento->Visible)
  {

    PanelOrdemSegmento->ManualFloat(Recto);
    PanelOrdemSegmento->ManualDock(PageControl1, PageControl1, alClient);
  }


}

void __fastcall TForm1::Action1Execute(TObject *Sender)

{
  try
  {
    SaveDialogGrid->Filter = "Pasta de Trabalho do Microsoft Office Excel (*.xls) | *.xls";
    SaveDialogGrid->Title  = "Exportar para Excel...";

    if (SaveDialogGrid->Execute())
    {
      ExportGridToExcel(SaveDialogGrid->FileName, cxGrid2);
      MessageDlg("A planilha foi salva em " + SaveDialogGrid->FileName, mtInformation, TMsgDlgButtons() << mbOK, 0);
    }
  }
  catch (Exception& exception)
  {
    throw Exception("No foi possvel exportar para Excel");
  }

}

// ---------------------------------------------------------------------------
void __fastcall TForm1::ListarConflitosCandidatos()

{

  using namespace domain;

  this->cdsGrid2->Close();

  this->cdsGrid2->CreateDataSet();
  this->cdsGrid2->Open();

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  TStringList * listaConflitosCandidatos = core->getListaConflitosCandidatos();

  GridDisableControls();
  cdsGrid2->DisableControls();

  for (int i = 0; i < listaConflitosCandidatos->Count - 1; i++)

  {

    ConflitoCandidato* conflitoCandidato = (ConflitoCandidato*)listaConflitosCandidatos->Objects[i];

    cdsGrid2->Append();

    String chave = listaConflitosCandidatos->operator[](i);

    cdsGrid2index->Value = cdsGrid2->RecordCount + 1;

    cdsGrid2Trem1->Value = (!conflitoCandidato->isConlitoComInterdicao) ?
      conflitoCandidato->segmentoTremA->trem->prefixoTrem :
      conflitoCandidato->segmentoTremConflitoInterdicao->trem->prefixoTrem;
    cdsGrid2Trem2->Value = (conflitoCandidato->segmentoTremB) ? conflitoCandidato->segmentoTremB->trem->prefixoTrem :
      String("");
    cdsGrid2Segmento->Value   = conflitoCandidato->segmentoConflitado->segmento;
    cdsGrid2Interdicao->Value = (!conflitoCandidato->isConlitoComInterdicao) ? "Sim" : "No";

    cdsGrid2PeriodoConflito->Value = conflitoCandidato->periodoConflito.asString();

    cdsGrid2chaveConflito->Value = chave;

    cdsGrid2->Post();

  }
  cdsGrid2->First();

  GridEnableControls();

  PanelCandidatos->SetFocus();

}

void __fastcall TForm1::BitBtn1Click(TObject *Sender)

{
  ListarConflitosCandidatos();
}

// ---------------------------------------------------------------------------
void __fastcall TForm1::ListarTrensAdiados()

{
  using namespace domain;
  using namespace timeTP;
  GridDisableControls();
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  domain::MalhaFerroviaria* malha = core->getMalha();
  for (int i = 0; i < malha->listaTrens->Count; i++)
  {
    TimeTP dataOrigInicItnr;
    TremMalha* trem = (TremMalha*)malha->listaTrens->Objects[i];
    if (trem->getRotaOficializada() && trem->getRotaOficializada()->Count > 0)
    {
      SegmentoTremOficializado* segOf =
        (SegmentoTremOficializado*)trem->getRotaOficializada()->Objects[trem->getRotaOficializada()->Count - 1];
      dataOrigInicItnr = segOf->getHoraFimParadaTremCalculado() > segOf->getHoraFimParadaTrem() ?
        segOf->getHoraFimParadaTremCalculado() : segOf->getHoraFimParadaTrem();
    }
    else if (trem->rotaRealizada && trem->rotaRealizada->Count > 0)
    {
      SegmentoTremRealizado* segReal =
        (SegmentoTremRealizado*)trem->rotaRealizada->Objects[trem->rotaRealizada->Count - 1];

      dataOrigInicItnr = segReal->getFimParadaTrem();
    }
    SegmentoTrem* segInic = trem->getPrimeiroMovimento();
    if (!dataOrigInicItnr.is_not_a_date_time() && segInic && dataOrigInicItnr != segInic->getPeriodoOcupacao()->begin())
    {
      cdsGrid3->Append();

      cdsGrid3Index->Value           = cdsGrid3->RecordCount + 1;
      cdsGrid3Trem->Value            = trem->prefixoTrem;
      cdsGrid3Segmento->Value        = segInic->segmentoOcupado->segmento;
      cdsGrid3previsaoChegada->Value = dataOrigInicItnr.asString();
      TimeTP dataInicItnr            = segInic->getPeriodoOcupacao()->begin();
      cdsGrid3inicioMovimento->Value = dataInicItnr.asString();

      cdsGrid3->Post();

    }
  }
  GridEnableControls();

  panelDeslocados->SetFocus();
}

void __fastcall TForm1::BitBtn4Click(TObject *Sender)

{
  this->cdsGrid3->Close();

  this->cdsGrid3->CreateDataSet();
  this->cdsGrid3->Open();

  ListarTrensAdiados();
}
// ---------------------------------------------------------------------------I=

void __fastcall TForm1::Panel3EndDock(TObject *Sender, TObject *Target, int X, int Y)

{
  if (Target && ((TComponent*)Target)->Name != "")
  {

    TTabSheet* tsb = ((TPageControl*)Target)->ActivePage;
    // TTabSheet* tsb2 = ((TPageControl*)Target)->Pages[((TPageControl*)Target)->PageCount - 1];
    tsb->Caption = ((TPanel*)Sender)->Caption;

  }
}
 int __fastcall SortPorChegada(TStringList* List, int Index1, int Index2)
  {
   using namespace domain;
    if (
    ((SegmentoTrem*)List->Objects[Index1])->getPeriodoOcupacao()->begin() <  ((SegmentoTrem*)List->Objects[Index2])->getPeriodoOcupacao()->begin() )
    {
      return -1;
    }
    else  if    (
    ((SegmentoTrem*)List->Objects[Index1])->getPeriodoOcupacao()->begin()> ((SegmentoTrem*)List->Objects[Index2])->getPeriodoOcupacao()->begin())
    {
      return 1;
    }
    else
    return 0;

  }
  int __fastcall SortPorSaida(TStringList* List, int Index1, int Index2)
  {
   using namespace domain;
    if (
    ((SegmentoTrem*)List->Objects[Index1])->getFimParadaTrem()<  ((SegmentoTrem*)List->Objects[Index2])->getFimParadaTrem() )
    {
      return -1;
    }
    else  if    (
    ((SegmentoTrem*)List->Objects[Index1])->getFimParadaTrem()> ((SegmentoTrem*)List->Objects[Index2])->getFimParadaTrem())
    {
      return 1;
    }
    else
    return 0;

  }
    int __fastcall SortPorSaidaCalculada(TStringList* List, int Index1, int Index2)
  {
   using namespace domain;
    if (
    ((SegmentoTrem*)List->Objects[Index1])->getOrdemSaida()<  ((SegmentoTrem*)List->Objects[Index2])->getOrdemSaida() )
    {
      return -1;
    }
    else  if    (
    ((SegmentoTrem*)List->Objects[Index1])->getOrdemSaida()> ((SegmentoTrem*)List->Objects[Index2])->getOrdemSaida())
    {
      return 1;
    }
    else
    return 0;

  }
void __fastcall TForm1::ListarOrdemTrensSegmento(String segmento)
{
   using namespace domain;
  using namespace timeTP;
  GridDisableControls();
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  domain::MalhaFerroviaria* malha = core->getMalha();
  TStringList * listOrdem = new TStringList();
  for (int i = 0; i < malha->listaTrens->Count; i++)
  {
    TimeTP dataOrigInicItnr;
    TremMalha* trem = (TremMalha*)malha->listaTrens->Objects[i];
    for (int a = 0; a < trem->rotaTrem->Count; a++)
    {
        SegmentoTrem * seg =  (SegmentoTrem * )trem->rotaTrem->Objects[a];
     if (seg->segmentoOcupado->segmento != segmento)
      continue;

        listOrdem->AddObject(seg->trem->prefixoTrem,(TObject*)seg);
    }
  }
   listOrdem->CustomSort(SortPorChegada);

    for (int a= 0; a <  listOrdem->Count; a++)
    {
      SegmentoTrem * seg =  (SegmentoTrem * )listOrdem->Objects[a];
      cdsGrid4->Append();
      cdsGrid4PrefixoTrem->Value            = seg->trem->prefixoTrem;
      TimeTP dtChegada= seg->getPeriodoOcupacao()->begin();
      cdsGrid4DTChegada->Value        = dtChegada.asString();
      cdsGrid4OrdemChegada->Value        = a+1;
      TimeTP dtSaida= seg->getFimParadaTrem();
      cdsGrid4DTSaida->Value        = dtSaida.asString();
      cdsGrid4->Post();
    }
    listOrdem->CustomSort(SortPorSaida);
    cdsGrid4->First() ;
    while (!cdsGrid4->Eof)
    {

    int idx =    listOrdem->IndexOf(cdsGrid4PrefixoTrem->Value);
      if (idx > -1)
      {
      cdsGrid4->Edit();
      cdsGrid4OrdemSaida->Value        = idx +1;
      cdsGrid4->Post();
      }
      cdsGrid4->Next();
    }

  listOrdem->CustomSort(SortPorSaidaCalculada);
    cdsGrid4->First() ;
    while (!cdsGrid4->Eof)
    {

    int idx =    listOrdem->IndexOf(cdsGrid4PrefixoTrem->Value);
      if (idx > -1)
      {
      cdsGrid4->Edit();
      cdsGrid4OrdemCalculada->Value        = idx +1;
      cdsGrid4->Post();
      }
      cdsGrid4->Next();
    }
  GridEnableControls();

  PanelOrdemSegmento->SetFocus();
 

}

// ---------------------------------------------------------------------------5


void __fastcall TForm1::BitBtn3Click(TObject *Sender)

{
 if (Edit1->Text == "")
  {
    throw Exception("Informe o segmento");
  }
  this->cdsGrid4->Close();

  this->cdsGrid4->CreateDataSet();
  this->cdsGrid4->Open();
  ListarOrdemTrensSegmento(Edit1->Text);

}
//---------------------------------------------------------------------------


void __fastcall TForm1::ListarTemposExecucao()


{
  using namespace domain;
  using namespace timeTP;
  GridDisableControls();
  serverDB::TDBMP* DB = serverDB::pool::getDatabaseInstance();
  TStringList* listaConsultas =  DB->lstExecTime;

  for (int i = 0; i < listaConsultas->Count; i++)
  {
    TStringList* listaTempos = (TStringList*)listaConsultas->Objects[i];
    float soma = 0.0;
    float max = 0.0;
    float min = StrToFloat(listaTempos->operator[](0));
    float valor;
    float avg;

    for(int j = 0; j < listaTempos->Count; j++)
    {
      valor = StrToFloat(listaTempos->operator[](j));
      //acumulando no total
      soma += valor;
      // verificando maximo
      if(valor > max)
      {
        max = valor;
      }
      // verificando minimo
      if(valor < min)
      {
        min = valor;
      }
      std::cout << valor;
    }
    //media
    avg = soma / listaTempos->Count;

    cdsGrid5->Append();
    cdsGrid5TextoQuery->Value = listaConsultas->operator[](i);
    cdsGrid5TempoTotal->Value = soma;
    cdsGrid5QuantidadeExec->Value = listaTempos->Count;
    cdsGrid5TempoMax->Value = max;
    cdsGrid5TempoMin->Value = min;
    cdsGrid5TempoMedio->Value = avg;
    cdsGrid5->Post();
  }

  GridEnableControls();
}


 //---------------------------------------------------------------------------


void __fastcall TForm1::Button1Click(TObject *Sender)

{
  this->cdsGrid5->Close();

  this->cdsGrid5->CreateDataSet();
  this->cdsGrid5->Open();

  ListarTemposExecucao();
}
//---------------------------------------------------------------------------

TcxGrid* __fastcall TForm1::GetActiveGrid(TWinControl* pComponent)
{
  TcxGrid* grid = dynamic_cast<TcxGrid*>(pComponent);

  if(grid)
  {
    return grid;
  }
  for(int i = 0; i < pComponent->ControlCount; i++)
  {
    TControl* t_comp = pComponent->Controls[i];
    if(dynamic_cast<TWinControl*>(t_comp))
    {
      return GetActiveGrid((TWinControl*)t_comp);
    }
  }
  return NULL;
}



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetDebug.h =====
//---------------------------------------------------------------------------

#ifndef FWidgetDebugH
#define FWidgetDebugH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "FWidgetBase.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "../domain/TremMalha.h"
#include "../domain/Conflito.h"
#include "FTP.h"
#include "UDModuleMP.h"

#include <Vcl.ExtCtrls.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.Buttons.hpp>
#include <Vcl.ComCtrls.hpp>
#include <Vcl.Dialogs.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include <Datasnap.Provider.hpp>

#include "cxGridExportLink.hpp"
#include <Vcl.Mask.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"

   namespace domain
	 {
	  class Conflito;
	  class ConflitoCandidato;
	  }
//---------------------------------------------------------------------------
class TFormWidgetDebug : public TFormWidgetBase
{
__published:	// IDE-managed Components
	TActionList *al;
	TAction *acExportarExcel;
	TClientDataSet *cdsGrid;
	TFloatField *cdsGridindex;
	TStringField *cdsGridPeriodoConflito;
	TStringField *cdsGridComInterdicao;
	TStringField *cdsGridTremInterdicao;
	TStringField *cdsGridSegmento;
	TIntegerField *cdsGridQtd;
	TStringField *cdsGridSB;
	TStringField *cdsGridTremVencedor;
	TStringField *cdsGridPrioridade;
	TStringField *cdsGridTremPerdedor;
	TStringField *cdsGridPrioridadePerdedor;
	TStringField *cdsGridTipo;
	TClientDataSet *cdsGrid2;
	TIntegerField *cdsGrid2index;
	TStringField *cdsGrid2Trem1;
	TStringField *cdsGrid2Trem2;
	TStringField *cdsGrid2Segmento;
	TStringField *cdsGrid2Interdicao;
	TStringField *cdsGrid2PeriodoConflito;
	TStringField *cdsGrid2chaveConflito;
	TClientDataSet *cdsGrid3;
	TIntegerField *cdsGrid3Index;
	TStringField *cdsGrid3Trem;
	TStringField *cdsGrid3Segmento;
	TStringField *cdsGrid3previsaoChegada;
	TStringField *cdsGrid3inicioMovimento;
	TClientDataSet *cdsGrid4;
	TStringField *cdsGrid4PrefixoTrem;
	TStringField *cdsGrid4DTChegada;
	TIntegerField *cdsGrid4OrdemChegada;
	TStringField *cdsGrid4DTSaida;
	TIntegerField *cdsGrid4OrdemSaida;
	TIntegerField *cdsGrid4OrdemCalculada;
	TClientDataSet *cdsGrid5;
	TStringField *cdsGrid5tempoExecucao;
	TIntegerField *cdsGrid5QuantidadeExec;
	TFloatField *cdsGrid5TempoMax;
	TFloatField *cdsGrid5TempoMin;
	TFloatField *cdsGrid5TempoMedio;
	TFloatField *cdsGrid5TempoTotal;
	TStringField *cdsGrid5TextoQuery;
	TcxStyleRepository *cxStyleRepositoryGrids;
	TcxStyle *cxHeader;
	TcxStyle *cxContentEven;
	TcxStyle *cxStyle1;
	TcxStyle *cxSelection;
	TcxStyle *cxBandHeader;
	TcxStyle *cxContent;
	TcxStyle *cxBandHeaderDesabilitado;
	TcxStyle *cxHeaderDesabilitado;
	TcxStyle *cxSLAExtrapoladoContent;
	TcxStyle *cxInterrompidoContent;
	TcxStyle *cxMapaVerde;
	TcxStyle *cxMapaVermelho;
	TcxStyle *cxEmAndamentoContent;
	TcxStyle *cxStyle2;
	TcxStyle *cxStyle3;
	TcxStyle *cxErro;
	TcxStyle *cxDisabled;
	TcxStyle *cxDefault;
	TcxStyle *cxFilaInativa;
	TcxStyle *cxForaOrdemOriginal;
	TcxGridBandedTableViewStyleSheet *ssBandedTable;
	TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
	TcxGridTableViewStyleSheet *ssGridTable;
	TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
	TPanel *Panel9;
	TPageControl *PageControl1;
	TTabSheet *TabSheet1;
	TPanel *PanelTabSheet1;
	TPanel *PanelConflitos;
	TcxGrid *cxgGrid;
	TcxGridDBTableView *cxgGridDBTableView1;
	TcxGridDBColumn *cxgGridDBTableView1index;
	TcxGridDBColumn *cxgGridDBTableView1PeriodoConflito;
	TcxGridDBColumn *cxgGridDBTableView1ComInterdicao;
	TcxGridDBColumn *cxgGridDBTableView1TremInterdicao;
	TcxGridDBColumn *cxgGridDBTableView1Segmento;
	TcxGridDBColumn *cxgGridDBTableView1Qtd;
	TcxGridDBColumn *cxgGridDBTableView1SB;
	TcxGridDBColumn *cxgGridDBTableView1TremVencedor;
	TcxGridDBColumn *cxgGridDBTableView1Prioridade;
	TcxGridDBColumn *cxgGridDBTableView1TremPerdedor;
	TcxGridDBColumn *cxgGridDBTableView1PrioridadePerdedor;
	TcxGridDBColumn *cxgGridDBTableView1Tipo;
	TcxGridLevel *cxgGridLevel1;
	TTabSheet *TabSheet2;
	TPanel *PanelCandidatos;
	TPanel *Panel5;
	TcxGrid *cxGrid2;
	TcxGridDBTableView *cxGrid2DBTableView1;
	TcxGridDBColumn *cxGrid2DBTableView1index;
	TcxGridDBColumn *cxGrid2DBTableView1Trem1;
	TcxGridDBColumn *cxGrid2DBTableView1Trem2;
	TcxGridDBColumn *cxGrid2DBTableView1Segmento;
	TcxGridDBColumn *cxGrid2DBTableView1PeriodoConflito;
	TcxGridDBColumn *cxGrid2DBTableView1Interdicao;
	TcxGridDBColumn *cxGrid2DBTableView1chaveConflito;
	TcxGridLevel *cxGrid2Level1;
	TPanel *Panel1;
	TBitBtn *BitBtn1;
	TTabSheet *TabSheet3;
	TPanel *panelDeslocados;
	TPanel *Panel3;
	TcxGrid *cxGrid1;
	TcxGridDBTableView *cxGridDBTableView1;
	TcxGridDBColumn *cxGridDBTableView1index;
	TcxGridDBColumn *cxGridDBTableView1Trem;
	TcxGridDBColumn *cxGridDBTableView1Segmento;
	TcxGridDBColumn *cxGridDBTableView1previsaoChegada;
	TcxGridDBColumn *cxGridDBTableView1inicioMovimento;
	TcxGridLevel *cxGridLevel1;
	TPanel *Panel4;
	TBitBtn *BitBtn2;
	TTabSheet *TabSheet4;
	TPanel *PanelOrdemSegmento;
	TPanel *Panel6;
	TcxGrid *cxGrid3;
	TcxGridDBTableView *cxGridDBTableView2;
	TcxGridDBColumn *cxGridDBTableView2PrefixoTrem;
	TcxGridDBColumn *cxGridDBTableView2DTChegada;
	TcxGridDBColumn *cxGridDBTableView2OrdemChegada;
	TcxGridDBColumn *cxGridDBTableView2DTSaida;
	TcxGridDBColumn *cxGridDBTableView2OrdemSaida;
	TcxGridDBColumn *cxGridDBTableView2OrdemCalculada;
	TcxGridLevel *cxGridLevel2;
	TPanel *Panel7;
	TLabel *Label1;
	TBitBtn *BitBtn3;
	TEdit *Edit1;
	TTabSheet *TabSheet5;
	TPanel *PanelTemposExec;
	TPanel *Panel2;
	TcxGrid *cxGrid4;
	TcxGridDBTableView *cxGrid4DBTableView1;
	TcxGridDBColumn *cxGrid4DBTableView1TextoQuery;
	TcxGridDBColumn *cxGrid4DBTableView1TempoTotal;
	TcxGridDBColumn *cxGrid4DBTableView1QuantidadeExec;
	TcxGridDBColumn *cxGrid4DBTableView1TempoMedio;
	TcxGridDBColumn *cxGrid4DBTableView1TempoMax;
	TcxGridDBColumn *cxGrid4DBTableView1TempoMin;
	TcxGridLevel *cxGrid4Level1;
	TPanel *Panel8;
	TButton *Button1;
	TButton *Button2;
	TPopupMenu *PopupMenu1;
	TMenuItem *MenuItem1;
	TPopupMenu *PopupMenuGrid;
	TMenuItem *ExportarExcel1;
	TSaveDialog *SaveDialogGrid;
	TPageControl *PageControl2;
	TTabSheet *TabSheet6;
	TPanel *Panel10;
	TPanel *Panel11;
	TcxGrid *cxGrid5;
	TcxGridDBTableView *cxGridDBTableView3;
	TcxGridLevel *cxGridLevel3;
	TTabSheet *TabSheet7;
	TPanel *Panel12;
	TPanel *Panel13;
	TcxGrid *cxGrid6;
	TcxGridDBTableView *cxGridDBTableView4;
	TcxGridLevel *cxGridLevel4;
	TPanel *Panel14;
	TBitBtn *BitBtn4;
	TTabSheet *TabSheet8;
	TPanel *Panel15;
	TPanel *Panel16;
	TcxGrid *cxGrid7;
	TcxGridDBTableView *cxGridDBTableView5;
	TcxGridLevel *cxGridLevel5;
	TPanel *Panel17;
	TBitBtn *BitBtn5;
	TTabSheet *TabSheet9;
	TPanel *Panel18;
	TPanel *Panel19;
	TcxGrid *cxGrid8;
	TcxGridDBTableView *cxGridDBTableView6;
	TcxGridLevel *cxGridLevel6;
	TPanel *Panel20;
	TLabel *Label2;
	TBitBtn *BitBtn6;
	TEdit *Edit2;
	TTabSheet *TabSheet10;
	TPanel *Panel21;
	TPanel *Panel22;
	TcxGrid *cxGrid9;
	TcxGridDBTableView *cxGridDBTableView7;
	TcxGridLevel *cxGridLevel7;
	TPanel *Panel23;
	TButton *Button3;
	TButton *Button4;
	TDataSetProvider *cspGrid2;
	TDataSource *dsGrid2;
	TDataSource *dsGrid;
	TDataSource *csGrid5;
	TDataSetProvider *cspGrid5;
	TDataSource *dsGrid3;
	TDataSetProvider *cspGrid3;
	TDataSource *dsGrid4;
	TDataSetProvider *cspGrid4;
	TDataSetProvider *dtspGrid;
	TClientDataSet *ClientDataSet1;
	TStringField *StringField1;
	TStringField *StringField2;
	TIntegerField *IntegerField1;
	TStringField *StringField3;
	TIntegerField *IntegerField2;
	TIntegerField *IntegerField3;
	TPopupMenu *PopupMenu2;
	TMenuItem *MenuItem2;
	TcxGridDBColumn *cxGridDBTableView7tempoExecucao;
	TcxGridDBColumn *cxGridDBTableView7QuantidadeExec;
	TcxGridDBColumn *cxGridDBTableView7TempoMax;
	TcxGridDBColumn *cxGridDBTableView7TempoMin;
	TcxGridDBColumn *cxGridDBTableView7TempoMedio;
	TcxGridDBColumn *cxGridDBTableView7TempoTotal;
	TcxGridDBColumn *cxGridDBTableView7TextoQuery;
	TcxGridDBColumn *cxGridDBTableView5index;
	TcxGridDBColumn *cxGridDBTableView5Trem;
	TcxGridDBColumn *cxGridDBTableView5Segmento;
	TcxGridDBColumn *cxGridDBTableView5previsaoChegada;
	TcxGridDBColumn *cxGridDBTableView5inicioMovimento;
	TPanel *pnlSuperior;
	TGroupBox *gbDebug;
	TCheckBox *chbxDrawConf;
	TBitBtn *btnDebug;
	TEdit *edtNconfSeg;
	TEdit *edtNconf;
	TcxGridDBColumn *cxGridDBTableView4index;
	TcxGridDBColumn *cxGridDBTableView4Trem1;
	TcxGridDBColumn *cxGridDBTableView4Trem2;
	TcxGridDBColumn *cxGridDBTableView4Segmento;
	TcxGridDBColumn *cxGridDBTableView4Interdicao;
	TcxGridDBColumn *cxGridDBTableView4PeriodoConflito;
	TcxGridDBColumn *cxGridDBTableView4chaveConflito;
	TcxGridDBColumn *cxGridDBTableView6PrefixoTrem;
	TcxGridDBColumn *cxGridDBTableView6DTChegada;
	TcxGridDBColumn *cxGridDBTableView6OrdemChegada;
	TcxGridDBColumn *cxGridDBTableView6DTSaida;
	TcxGridDBColumn *cxGridDBTableView6OrdemSaida;
	TcxGridDBColumn *cxGridDBTableView6OrdemCalculada;
	TcxGridDBColumn *cxGridDBTableView3index;
	TcxGridDBColumn *cxGridDBTableView3PeriodoConflito;
	TcxGridDBColumn *cxGridDBTableView3ComInterdicao;
	TcxGridDBColumn *cxGridDBTableView3TremInterdicao;
	TcxGridDBColumn *cxGridDBTableView3Segmento;
	TcxGridDBColumn *cxGridDBTableView3Qtd;
	TcxGridDBColumn *cxGridDBTableView3SB;
	TcxGridDBColumn *cxGridDBTableView3TremVencedor;
	TcxGridDBColumn *cxGridDBTableView3Prioridade;
	TcxGridDBColumn *cxGridDBTableView3TremPerdedor;
	TcxGridDBColumn *cxGridDBTableView3PrioridadePerdedor;
	TcxGridDBColumn *cxGridDBTableView3Tipo;
  TImageList *il;
  TButton *btCongelarCenario;
  TGroupBox *gpbCongelarCenario;
  TMaskEdit *edtDataHoraCongelamento;
  TRadioGroup *rdgPAT_FiltroPrefixo;
  TTabSheet *TabSheet11;
  TcxGridDBTableView *cxGrid10DBTableView1;
  TcxGridLevel *cxGrid10Level1;
  TcxGrid *cxGrid10;
  TPanel *Panel24;
  TPanel *Panel25;
  TButton *Button5;
  TDataSource *dsGridAderencia;
  TDataSetProvider *cspGridAderencia;
  TClientDataSet *cdsGridAderencia;
  TStringField *cdsGridAderenciapidTrem;
  TStringField *cdsGridAderenciacodLocal;
  TStringField *cdsGridAderenciapidTipo;
  TStringField *cdsGridAderenciatranstTimeReal;
  TStringField *cdsGridAderenciatranstTimeCalc;
  TDateTimeField *cdsGridAderenciadtChegRealOrig;
  TDateTimeField *cdsGridAderenciadtChegadaRealDest;
  TcxGridDBColumn *cxGrid10DBTableView1pidTrem;
  TcxGridDBColumn *cxGrid10DBTableView1codLocal;
  TcxGridDBColumn *cxGrid10DBTableView1pidTipo;
  TcxGridDBColumn *cxGrid10DBTableView1transtTimeReal;
  TcxGridDBColumn *cxGrid10DBTableView1transtTimeCalc;
  TcxGridDBColumn *cxGrid10DBTableView1dtChegRealOrig;
  TcxGridDBColumn *cxGrid10DBTableView1dtChegadaRealDest;
  TStringField *cdsGridAderenciaprefixoTrem;
  TStringField *cdsGridAderencianmTipoTrem;
  TStringField *cdsGridAderenciadiffTT;
  TDateTimeField *cdsGridAderenciadtChegadaOfOrig;
  TDateTimeField *cdsGridAderenciadtChegadaOfDest;
  TcxGridDBColumn *cxGrid10DBTableView1prefixoTrem;
  TcxGridDBColumn *cxGrid10DBTableView1nmTipoTrem;
  TcxGridDBColumn *cxGrid10DBTableView1diffTT;
  TcxGridDBColumn *cxGrid10DBTableView1dtChegadaOfOrig;
  TcxGridDBColumn *cxGrid10DBTableView1dtChegadaOfDest;
  TStringField *cdsGridAderencianmRamal;
  TFloatField *cdsGridAderencianuKmInicio;
  TcxGridDBColumn *cxGrid10DBTableView1nmRamal;
  TcxGridDBColumn *cxGrid10DBTableView1nuKmInicio;
  TButton *Button6;
  TComboBox *cboTrechos;
  TStringField *cdsGridAderenciadiffTTSemParada;
  TcxGridDBColumn *cxGrid10DBTableView1diffTTSemParada;
  TStringField *cdsGridAderenciatransTimeCalcSemParada;
  TcxGridDBColumn *cxGrid10DBTableView1transTimeCalcSemParada;
  TTabSheet *TabSheet12;
  TPanel *Panel26;
  TPanel *Panel27;
  TcxGrid *cxGrid11;
  TcxGridDBTableView *cxGridDBTableView8;
  TcxGridLevel *cxGridLevel8;
  TPanel *Panel28;
  TBitBtn *BitBtn7;
  TDataSource *dsDependencias;
  TClientDataSet *cdsDependencias;
  TStringField *cdsDependenciasTrem;
  TStringField *cdsDependenciasSegmento;
  TStringField *cdsDependenciasTremAfetado;
  TStringField *cdsDependenciasSegmentoAfetado;
  TcxGridDBColumn *cxGridDBTableView8Trem;
  TcxGridDBColumn *cxGridDBTableView8Segmento;
  TcxGridDBColumn *cxGridDBTableView8TremAfetado;
  TcxGridDBColumn *cxGridDBTableView8SegmentoAfetado;
  TStringField *cdsDependenciasRelatorio;
  TcxGridDBColumn *cxGridDBTableView8Relatorio;
  TTabSheet *TabSheet13;
  TPanel *Panel29;
  TPanel *Panel30;
  TcxGrid *cxGrid12;
  TcxGridDBTableView *cxGridDBTableView9;
  TcxGridLevel *cxGridLevel9;
  TPanel *Panel31;
  TBitBtn *BitBtn8;
  TClientDataSet *cdsJustificativa;
  TStringField *cdsJustificativaTrem;
  TDataSource *dsJustificativa;
  TStringField *cdsJustificativaGanhador;
  TStringField *cdsJustificativaPerdedor;
  TStringField *cdsJustificativaParada;
  TStringField *cdsJustificativaConflito;
  TDateTimeField *cdsJustificativaDtConflito;
  TDateTimeField *cdsJustificativaDtParada;
  TStringField *cdsJustificativaJustificativa;
  TcxGridDBColumn *cxGridDBTableView9Trem;
  TcxGridDBColumn *cxGridDBTableView9Ganhador;
  TcxGridDBColumn *cxGridDBTableView9Perdedor;
  TcxGridDBColumn *cxGridDBTableView9Parada;
  TcxGridDBColumn *cxGridDBTableView9DtParada;
  TcxGridDBColumn *cxGridDBTableView9Conflito;
  TcxGridDBColumn *cxGridDBTableView9DtConflito;
  TcxGridDBColumn *cxGridDBTableView9Justificativa;
  TBooleanField *cdsJustificativatemConflitoValido;
  TcxGridDBColumn *cxGridDBTableView9temConflitoValido;
  TStringField *cdsJustificativaprioridadeVencedor;
  TStringField *cdsJustificativaprioridadePerdedor;
  TcxGridDBColumn *cxGridDBTableView9prioridadeVencedor;
  TcxGridDBColumn *cxGridDBTableView9prioridadePerdedor;
  TCheckBox *chkTrace50;
	void __fastcall btnDebugClick(TObject *Sender);
	void __fastcall BitBtn4Click(TObject *Sender);
	void __fastcall BitBtn5Click(TObject *Sender);
	void __fastcall BitBtn6Click(TObject *Sender);
	void __fastcall Button3Click(TObject *Sender);
	void __fastcall acExportarExcelExecute(TObject *Sender);
  void __fastcall btCongelarCenarioClick(TObject *Sender);
  void __fastcall Button5Click(TObject *Sender);
  void __fastcall Button6Click(TObject *Sender);
  void __fastcall BitBtn7Click(TObject *Sender);
  void __fastcall BitBtn8Click(TObject *Sender);



private:	// User declarations
	domain::Conflito* conf;
	domain::ConflitoCandidato* candi;
	TFormTP *FFTP_;

public:		// User declarations
	__fastcall TFormWidgetDebug(TComponent* Owner, TFormTP *pFTP);
	void __fastcall ListarConflitosCandidatos();
	void __fastcall ListarTrensAdiados();
	void __fastcall GridEnableControls();
	void __fastcall ListarOrdemTrensSegmento(String segmento);
	void __fastcall ListarTemposExecucao();
  void __fastcall drawConflitoCallback(domain::SegmentoTrem* segTrem1, domain::SegmentoTrem* segTrem2);
	TcxGrid* __fastcall GetActiveGrid(TWinControl* pComponent);
  bool isNext;
	void adicionarConflito(domain::Conflito* conflito, domain::ConflitoCandidato* confCandidato);
	void __fastcall GridDisableControls()
	{
	 this->Visible = false;
	 cdsGrid->DisableControls();
	};
  void SetFTP(TFormTP *pFTP);

};
//---------------------------------------------------------------------------
extern PACKAGE TFormWidgetDebug *FormWidgetDebug;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFControleLogsIntegracao.h =====
//---------------------------------------------------------------------------

#ifndef UFControleLogsIntegracaoH
#define UFControleLogsIntegracaoH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "FGridBase.h"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.Dialogs.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include "cxMaskEdit.hpp"
#include "cxCalendar.hpp"
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
#include "cxImageList.hpp"

//---------------------------------------------------------------------------
class TFormControleLogs : public TFormGridBase
{
__published:	// IDE-managed Components
  TIntegerField *cdsGridNU_SEQL_EVNT;
  TStringField *cdsGridIC_EVNT;
  TStringField *cdsGridDS_EVNT;
  TStringField *cdsGridDS_XML_INFO;
  TDateTimeField *cdsGridDT_CARGA_GERL;
  TStringField *cdsGridNM_SERV;
  TComboBox *cmbServicos;
  TComboBox *cmbIcEventos;
  TLabel *lblServico;
  TLabel *lblIndicador;
  TStringField *cdsGridDT_EVNT;
  TcxGridDBColumn *cxgGridDBTableView1NU_SEQL_EVNT;
  TcxGridDBColumn *cxgGridDBTableView1NM_SERV;
  TcxGridDBColumn *cxgGridDBTableView1IC_EVNT;
  TcxGridDBColumn *cxgGridDBTableView1DS_EVNT;
  TcxGridDBColumn *cxgGridDBTableView1DS_XML_INFO;
  TcxGridDBColumn *cxgGridDBTableView1DT_CARGA_GERL;
  TcxGridDBColumn *cxgGridDBTableView1DT_EVNT;
  TLabel *lblAutoUmaHora;
  TLabel *lblSeisHoras;
  TLabel *lblAutoDozeHoras;
  TLabel *lblMesaUmaHora;
  TLabel *lblMesaSeisHoras;
  TLabel *lblMesaDozeHoras;
  TLabel *lblCarregando;
  TLabel *lblProgramando;
  TLabel *lblPlotando;
	TLabel *lblTempoParametro;
	TGroupBox *gbTempoMesa;
	TGroupBox *gbTempoAutomatico;
	TGroupBox *gbTemposSistema;
  TLabel *lblUmaHoraParcial;
  TLabel *lblSeisHoraParcial;
  TLabel *lblDozeHoraParcial;
	TPanel *Panel1;
	TPanel *Panel2;
	TPanel *Panel3;
  void __fastcall FormShow(TObject *Sender);
  void __fastcall cmbServicosChange(TObject *Sender);
  void __fastcall cmbIcEventosChange(TObject *Sender);
  void __fastcall cxgGridDBTableView1CustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);
  void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
  void __fastcall btnOkClick(TObject *Sender);
  void __fastcall btnCancelarClick(TObject *Sender);
private:	// User declarations
public:		// User declarations
  __fastcall TFormControleLogs(TComponent* Owner);
  inline __fastcall ~TFormControleLogs(void);
  void __fastcall CarregarLinhas(String pNomeServico,String pICEvnt,int pRangeTempo);
  void  __fastcall CarregarComboServicos();
  void  __fastcall CarregarComboICEventos();
  void  __fastcall ConfigurarGrid();
  void  __fastcall ConfigurarTemposOficializacao();
  void __fastcall  CarregarTemposClient(int pRangeTempo);
  String RetornaICEventos(String pICEvento);
  String IcEventosToString(String pEvento);
  String  _nMesa;
  int _rangeTempo;


};
//---------------------------------------------------------------------------
extern PACKAGE TFormControleLogs *FormControleLogs;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFAtividadesTrem.cpp =====
//---------------------------------------------------------------------------

#include <vcl.h>
#include "Classes\Model\UTPItinerarioTrem.h"
#include "boost\date_time\posix_time\posix_time.hpp"
#pragma hdrstop
#include "UFAtividadesTrem.h"
#include "UTPAtividade.h"
#include "UTPTipoAtividade.h"
#include "UFCriarAtividadeTrem.h"
//#include "UDModuleMP.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "..\domain\SegmentoTremOficializado.h"
#include "UFormsManager.h"
#include "UTPZonaControle.h"
#include "UTPMovimento.h"
#include "UTPSB.h"
//#include "timeTP.h"
#include "UUteis.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FGridBase"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma resource "*.dfm"
TFormAtividadesTrem *FormAtividadesTrem;
// ---------------------------------------------------------------------------
__fastcall TFormAtividadesTrem::TFormAtividadesTrem(TComponent* Owner, TTPSBListPtr pListaSBs) : TFormGridBase(Owner)
{
	FListaSBs_ = pListaSBs;
	FAtualiazarTrem = false;

}
// ---------------------------------------------------------------------------

__fastcall TFormAtividadesTrem::TFormAtividadesTrem(TComponent* Owner, TTPTrem* pTrem, TTPMovimento* pMovimento,
  TTPSBListPtr pListaSBs) : TFormGridBase(Owner)
{
  TUteis::gravarLog("Atividades do Trem: " + pTrem->PID);
  this->Caption = "Atividades do Trem: " + pTrem->Prefixo;
  FTrem_        = pTrem;
	FMovimento_   = pMovimento;
  FListaSBs_    = pListaSBs;

  CarregarLinhas();

  AJustarDisplayTextDateTime(cxgGridDBTableView1FimPAT,cdsGridFimPAT);
  AJustarDisplayTextDateTime(cxgGridDBTableView1FimFila,cdsGridFimFila);

  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMinimaChegada,cdsGridDataMinimaChegada);
  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMinimaSaida,cdsGridDataMinimaSaida);
  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMaximaSaida,cdsGridDataMaximaSaida);

  FAtualiazarTrem = false;
}

// ---------------------------------------------------------------------------
void __fastcall TFormAtividadesTrem::btnCriarClick(TObject *Sender)
{
  TTPTrem* tTrem                          = FTrem_;
  TTPMovimento* tMovimento                = FMovimento_;
  TFormCriarAtividadeTrem *criarAtividade = new TFormCriarAtividadeTrem(this, tTrem, tMovimento, this->FListaSBs_);

  if (criarAtividade->ShowModal() == mrOk)
  {
    CarregarLinhas();
		FAtualiazarTrem = true;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TFormAtividadesTrem::CarregarLinhas()
{
  cxgGridDBTableView1->OnFocusedRecordChanged = NULL;
  cdsGrid->Close();
  cdsGrid->CreateDataSet();
  cdsGrid->Open();


  int linhaSelecionanda = 1;
  bool achouMovimentoAtividade = false;
	if(!TTPFormsManager::getInstance()->ShowVisualizador)
	{
		for (int i = 0; i < FTrem_->Atividades->count(); i++)
		{
			cdsGrid->Append();
			for(int j = 0; j< FTrem_->ItinerarioTrem->Movimentos->count(); j++)
			{
				if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->SB->NomeVia  == FTrem_->Atividades->operator[](i)->SBAtual->NomeVia)
				{
         if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->IsRealizado)
          continue;

				 if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->ServerSegTremPlanejado)
					{
						cdsGridIndexRota->Value = FTrem_->ItinerarioTrem->Movimentos->operator [](j)->ServerSegTremPlanejado->indexRotaTrem;
						cdsGridIsEditavel->Value = true;
					}
					else
						cdsGridIsEditavel->Value = false;

				 break;
				}
			}

			for (int j = 0; j < FTrem_->Atividades->count() && !achouMovimentoAtividade; j++)
			{
				if (FMovimento_->SB->NomeVia == FTrem_->Atividades->operator[](j)
						->SBAtual->NomeVia)
				{
					linhaSelecionanda = j + 1;
					achouMovimentoAtividade = true;
					break;
				}
			}
			double tDataFimD  = FTrem_->Atividades->operator[](i)->DataFim;
			double tDataFilaD = FTrem_->Atividades->operator[](i)->DataFimFila;
      #ifdef BAIXADA_SANTISTA
      if (tDataFilaD <= 0)
      {
        tDataFilaD = FTrem_->Atividades->operator[](i)->DataHoraFimNecessidadeTerminal;
      }

      #endif

			double tDataMinimaChegada   = FTrem_->Atividades->operator[](i)->DataHoraMinimaChegada;
			double tDataHoraMinimaSaida = FTrem_->Atividades->operator[](i)->DataHoraMinimaSaida;
			double tDataHoraMaximaSaida = FTrem_->Atividades->operator[](i)->DataHoraMaximaSaida;

			cdsGridLinha->Value=(i);
			if(!FTrem_->Atividades->operator[](i)->SBAtual.isNull())
				cdsGridSB->Value=(FTrem_->Atividades->operator[](i)->SBAtual->NomeVia);
			else
				cdsGridSB->Value=("");

			cdsGridTipo->Value=(FTrem_->Atividades->operator[](i)->Tipo->Nome);

			if (tDataFilaD > 0)
				cdsGridFimFila->Value=(tDataFilaD);
			if (tDataFimD > 0)
				cdsGridFimPAT->Value=(tDataFimD);

			if (tDataMinimaChegada > 0)
				cdsGridDataMinimaChegada->Value=(tDataMinimaChegada);
			if (tDataHoraMinimaSaida > 0)
				cdsGridDataMinimaSaida->Value=(tDataHoraMinimaSaida);
			if (tDataHoraMaximaSaida > 0)
				cdsGridDataMaximaSaida->Value=(tDataHoraMaximaSaida);

			cdsGridDuracao->Value= FTrem_->Atividades->operator[](i)->DuracaoFormatada;
			cdsGridDescricao->Value=(FTrem_->Atividades->operator[](i)->Descricao);

			cdsGrid->Post();
		 }
	}
	else
	{
		 bool isOficializacao =  false;
		 for (int i = 0; i < FTrem_->Atividades->count(); i++)
		{
			isOficializacao =  false;

			for(int j = 0; j< FTrem_->ItinerarioTrem->Movimentos->count(); j++)
			{
        if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->IsRealizado)
					continue;

				if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->SB->NomeVia  == FTrem_->Atividades->operator[](i)->SBAtual->NomeVia
					 && (FTrem_->ItinerarioTrem->Movimentos->operator[](j)->PIDRotaOficializada == FMovimento_->PIDRotaOficializada || FMovimento_->IsRealizado)
					 && FTrem_->ItinerarioTrem->Movimentos->operator[](j)->ServerSegTremOficializado
           && FTrem_->Atividades->operator[](i)->AtividadeServer == FTrem_->ItinerarioTrem->Movimentos->operator[](j)->ServerSegTremOficializado->getAtividade() )
				{
         cdsGrid->Append();
				 if(FTrem_->ItinerarioTrem->Movimentos->operator [](j)->ServerSegTremOficializado)
					{
						cdsGridIndexRota->Value = j;
						cdsGridIsEditavel->Value = true;
					}
					else
						cdsGridIsEditavel->Value = false;

				 isOficializacao = true;

				 break;
				}
			}

			if(!isOficializacao)
			continue;

			for (int j = 0; j < FTrem_->Atividades->count() && !achouMovimentoAtividade; j++)
			{
				if (FMovimento_->SB->NomeVia == FTrem_->Atividades->operator[](j)
						->SBAtual->NomeVia)
				{
					linhaSelecionanda = j + 1;
					achouMovimentoAtividade = true;
					break;
				}
			}
			double tDataFimD  = FTrem_->Atividades->operator[](i)->DataFim;
			double tDataFilaD = FTrem_->Atividades->operator[](i)->DataFimFila;

			double tDataMinimaChegada   = FTrem_->Atividades->operator[](i)->DataHoraMinimaChegada;
			double tDataHoraMinimaSaida = FTrem_->Atividades->operator[](i)->DataHoraMinimaSaida;
			double tDataHoraMaximaSaida = FTrem_->Atividades->operator[](i)->DataHoraMaximaSaida;

			cdsGridLinha->Value=(i);
			if(!FTrem_->Atividades->operator[](i)->SBAtual.isNull())
				cdsGridSB->Value=(FTrem_->Atividades->operator[](i)->SBAtual->NomeVia);
			else
				cdsGridSB->Value=("");

			cdsGridTipo->Value=(FTrem_->Atividades->operator[](i)->Tipo->Nome);

			if (tDataFilaD > 0)
				cdsGridFimFila->Value=(tDataFilaD);
			if (tDataFimD > 0)
				cdsGridFimPAT->Value=(tDataFimD);

			if (tDataMinimaChegada > 0)
				cdsGridDataMinimaChegada->Value=(tDataMinimaChegada);
			if (tDataHoraMinimaSaida > 0)
				cdsGridDataMinimaSaida->Value=(tDataHoraMinimaSaida);
			if (tDataHoraMaximaSaida > 0)
				cdsGridDataMaximaSaida->Value=(tDataHoraMaximaSaida);

			cdsGridDuracao->Value= FTrem_->Atividades->operator[](i)->DuracaoFormatada;
			cdsGridDescricao->Value=(FTrem_->Atividades->operator[](i)->Descricao);

			cdsGrid->Post();

		}
	}
  cxgGridDBTableView1->OnFocusedRecordChanged = cxgGridDBTableView1FocusedRecordChanged;

  if(cdsGrid->RecordCount>=linhaSelecionanda)
		cdsGrid->RecNo = linhaSelecionanda;

  bool CanSelect = true;

  stgAtividadesTremSelectCell(this, 0, cdsGridLinha->Value, CanSelect);

	cdsGrid->IndexName = "cdsFilasIndex1";

  if(!achouMovimentoAtividade && cdsGrid->RecordCount>0)
    cdsGrid->RecNo = 1;
}

// ---------------------------------------------------------------------------
void __fastcall TFormAtividadesTrem::btnEditarClick(TObject *Sender)
{
  if(!cdsGridLinha->IsNull)
  {
    TFormCriarAtividadeTrem *criarAtividade = new TFormCriarAtividadeTrem(this, FTrem_->Atividades->operator[](cdsGridLinha->Value),
      this->FListaSBs_);

    if (criarAtividade->ShowModal() == mrOk)
    {
      CarregarLinhas();
      FAtualiazarTrem = true;
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormAtividadesTrem::btnExcluirClick(TObject *Sender)
{
  if(!cdsGridLinha->IsNull)
  {
    TTPAtividadePtr atividade = FTrem_->Atividades->operator[](cdsGridLinha->Value);
    TUteis::gravarLog("Excluir Atividade - " + atividade->PID);
    if (!atividade->Tipo->ISPermitidoExclusao)
    {
      throw Exception("No  permitido excluir este tipo de atividade");
    }

    if (Confirme("Deseja realmente remover a atividade: " + atividade->PID + " - " + atividade->Tipo->Nome + "?"))
    {
      algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

      core->ExcluirAtividade(atividade->PID);

      FTrem_->Atividades->remove(cdsGridLinha->Value);
      FTrem_->AtividadesDel->add(atividade->PID, atividade);

      //Remoo da atividade das listas de Insert e Update
      if(FTrem_->AtividadesInsert->IndexOf(atividade->PID)>-1)
      {
        FTrem_->AtividadesInsert->remove(atividade->PID);
      }

      if(FTrem_->AtividadesUpdate->IndexOf(atividade->PID)>-1)
      {
        FTrem_->AtividadesUpdate->remove(atividade->PID);
      }

      if (TTPFormsManager::getInstance()->TrensAlteracaoAtividade->IndexOf(FTrem_->PID) > -1)
      {
        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->get(FTrem_->PID)->AtividadesDel->add(atividade->PID, atividade);
      }
      else
      {
        String tPID = "";
        int idx = core->getMalha()->listaTrens->IndexOf(FTrem_->PID);
        if (idx >= 0)
          tPID = FTrem_->PID;

        TTPFormsManager::getInstance()->TrensAlteracaoAtividade->add(FTrem_->PID,
        TTPFormsManager::getInstance()->Trens->get(tPID));
      }
      CarregarLinhas();
      FAtualiazarTrem = true;
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormAtividadesTrem::stgAtividadesTremSelectCell(TObject *Sender, int ACol, int ARow, bool &CanSelect)
{
	using namespace domain;
	{
		if (ARow > -1 && FTrem_->Atividades->count() > 0)
    {
      TTPAtividadePtr atividade            = FTrem_->Atividades->operator[](ARow);
      TTPZonaControlePtr tZonaControleTemp = TTPFormsManager::getInstance()->ZonasControle->get
        (atividade->SBAtual->ZonaControle);

      if (tZonaControleTemp)
      {
				if (tZonaControleTemp->Mesa == TTPFormsManager::getInstance()->Mesa && cdsGridIsEditavel->Value )
				{
          EnableButtons(true);
          return;
        }
      }

      EnableButtons(false);
    }
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormAtividadesTrem::EnableButtons(bool enabled)
{
	btnEditar->Enabled  = enabled;
	btnExcluir->Enabled = enabled;

	if(TTPFormsManager::getInstance()->ShowVisualizador)
	{
		btnEditar->Caption = "Exibir";
		btnEditar->Enabled  = true;
		btnEditar->Left =  btnCriar->Left;
		btnExcluir->Visible = false;
		btnCriar->Visible = false;
		btnCancelar->Visible = false;
		btnOk->ModalResult = mrCancel;
	}
}

void __fastcall TFormAtividadesTrem::cxgGridDBTableView1FocusedRecordChanged(TcxCustomGridTableView *Sender, TcxCustomGridRecord *APrevFocusedRecord,
          TcxCustomGridRecord *AFocusedRecord, bool ANewItemRecordFocusingChanged)
{
  bool CanSelect = true;
  stgAtividadesTremSelectCell(this, 0, cdsGridLinha->Value, CanSelect);
}
//---------------------------------------------------------------------------

void __fastcall TFormAtividadesTrem::cxgGridDBTableView1CellDblClick(TcxCustomGridTableView *Sender, TcxGridTableDataCellViewInfo *ACellViewInfo,
          TMouseButton AButton, TShiftState AShift, bool &AHandled)
{
  if(btnEditar->Enabled)
    btnEditarClick(this);
}
//---------------------------------------------------------------------------


void __fastcall TFormAtividadesTrem::cxgGridDBTableView1ColumnSizeChanged(TcxGridTableView *Sender, TcxGridColumn *AColumn)
{

  AJustarDisplayTextDateTime(cxgGridDBTableView1FimPAT,cdsGridFimPAT);
  AJustarDisplayTextDateTime(cxgGridDBTableView1FimFila,cdsGridFimFila);

  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMinimaChegada,cdsGridDataMinimaChegada);
  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMinimaSaida,cdsGridDataMinimaSaida);
  AJustarDisplayTextDateTime(cxgGridDBTableView1DataMaximaSaida,cdsGridDataMaximaSaida);


  /*cdsGridFimFila->DisplayFormat = "dd/mm/yyyy hh:mm";
  int width
    = cxgGridDBTableView1FimPAT->GridView->ViewInfo->Canvas->TextWidth("99/99/9999 99:99 ");

  if (cxgGridDBTableView1FimFila->Width < width && cdsGridFimFila->DisplayFormat != "hh:mm")
  cdsGridFimFila->DisplayFormat = "hh:mm";

  cdsGridFimPAT->DisplayFormat = "dd/mm/yyyy hh:mm";

  if (cxgGridDBTableView1FimPAT->Width < width && cdsGridFimPAT->DisplayFormat != "hh:mm")
  cdsGridFimPAT->DisplayFormat = "hh:mm";  */
}
//---------------------------------------------------------------------------


void __fastcall TFormAtividadesTrem::acInfoAtividadeExecute(TObject *Sender)
{
  TTPAtividadePtr atividade = FTrem_->Atividades->operator[](cdsGridLinha->Value);

  if(atividade != NULL)
  {
    String tPID = atividade->PID;
    String tPrefixo = atividade->Trem->Prefixo;
    String tTipo = atividade->Tipo->Nome + "\n";
    String mensagemAlerta = "ATIVIDADE:\n";
    mensagemAlerta += "Prefixo Trem: " +tPrefixo + "\n";
    mensagemAlerta += "PID Atividade: " +tPID + "\n";
    mensagemAlerta += "Tipo: " +tTipo + "\n";
    Alerta(mensagemAlerta);
  }
}
//---------------------------------------------------------------------------



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFGradeTrens.h =====
//---------------------------------------------------------------------------

#ifndef UFGradeTrensH
#define UFGradeTrensH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Grids.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.ActnList.hpp>
#include "UTPSBSeries.h"

#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include <System.Actions.hpp>
#include <System.ImageList.hpp>

#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxContainer.hpp"
#include "cxTextEdit.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"

#include <Vcl.Dialogs.hpp>
#include <Vcl.Menus.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include <Vcl.Buttons.hpp>
#include "dxUIAClasses.hpp"
//---------------------------------------------------------------------------
class TFormGradeTrens : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
	TActionList *al;
	TAction *acCancelar;
  TcxGridDBTableView *cxgGradeTremDBTableView1;
  TcxGridLevel *cxgGradeTremLevel1;
  TcxGrid *cxgGradeTrem;
  TDataSource *dsGradeTrem;
  TClientDataSet *cdsGradeTrem;
  TStringField *cdsGradeTremprefixo;
  TStringField *cdsGradeTremtipo;
  TStringField *cdsGradeTremdestino;
  TStringField *cdsGradeTremsegmento;
  TStringField *cdsGradeTremprevisaoPartida;
  TStringField *cdsGradeTremramal;
  TStringField *cdsGradeTremzonaControle;
  TStringField *cdsGradeTremid;
  TStringField *cdsGradeTremidExterno;
  TcxGridDBColumn *cxgGradeTremDBTableView1prefixo;
  TcxGridDBColumn *cxgGradeTremDBTableView1tipo;
  TcxGridDBColumn *cxgGradeTremDBTableView1destino;
  TcxGridDBColumn *cxgGradeTremDBTableView1segmento;
  TcxGridDBColumn *cxgGradeTremDBTableView1previsaoPartida;
  TcxGridDBColumn *cxgGradeTremDBTableView1ramal;
  TcxGridDBColumn *cxgGradeTremDBTableView1zonaControle;
  TcxGridDBColumn *cxgGradeTremDBTableView1id;
  TcxGridDBColumn *cxgGradeTremDBTableView1idExterno;
  TAction *acExportarExcel;
  TSaveDialog *SaveDialog;
  TImageList *il;
  TPopupMenu *PopupMenu1;
  TMenuItem *acExportarExcel1;
  TcxStyleRepository *cxStyleRepositoryGrids;
  TcxStyle *cxHeader;
  TcxStyle *cxContentEven;
  TcxStyle *cxStyle21;
  TcxStyle *cxSelection;
  TcxStyle *cxBandHeader;
  TcxStyle *cxContent;
  TcxStyle *cxBandHeaderDesabilitado;
  TcxStyle *cxHeaderDesabilitado;
  TcxStyle *cxSLAExtrapoladoContent;
  TcxStyle *cxInterrompidoContent;
  TcxStyle *cxMapaVerde;
  TcxStyle *cxMapaVermelho;
  TcxStyle *cxEmAndamentoContent;
  TcxStyle *cxStyle22;
  TcxStyle *cxStyle23;
  TcxStyle *cxErro;
  TcxStyle *cxDisabled;
  TcxStyle *cxDefault;
  TcxGridBandedTableViewStyleSheet *ssBandedTable;
  TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
  TcxGridTableViewStyleSheet *ssGridTable;
  TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
	TMenuItem *N1;
	TAction *acEditarMovimentoOrigem;
	TMenuItem *acEditarMovimentoOrigem1;
  TPanel *Panel7;
  TAction *acPesquisarPrefixo;
  TGroupBox *GroupBox2;
  TcxTextEdit *edtDestino;
  TcxTextEdit *edtPrefixo;
  TBitBtn *btnBuscarPrefixo;
	void __fastcall acCancelarExecute(TObject *Sender);
	void __fastcall btnOkClick(TObject *Sender);
  void __fastcall acExportarExcelExecute(TObject *Sender);
	void __fastcall acEditarMovimentoOrigemExecute(TObject *Sender);
  void __fastcall acPesquisarPrefixoExecute(TObject *Sender);
  void __fastcall edtDestinoExit(TObject *Sender);
  void __fastcall PopupMenu1Popup(TObject *Sender);

private:	// User declarations
  int idxEncontrado_;
  int idxPrimeiroEncontrado_;
public:		// User declarations
  __fastcall TFormGradeTrens(TComponent* Owner);
  void __fastcall CarregarTrens();
   __property int IdxEncontrado         = {read=idxEncontrado_, write=idxEncontrado_};
   __property int IdxPrimeiroEncontrado         = {read=idxPrimeiroEncontrado_, write=idxPrimeiroEncontrado_};
   void __fastcall ZerarParadasTrem(TTPTremPtr pTrem);
};
//---------------------------------------------------------------------------
extern PACKAGE TFormGradeTrens *FormGradeTrens;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFGatilhos.h =====
//---------------------------------------------------------------------------

#ifndef UFGatilhosH
#define UFGatilhosH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "FGridBase.h"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.Dialogs.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"
//---------------------------------------------------------------------------
class TformGatilhos2 : public TFormGridBase
{
__published:	// IDE-managed Components
  TStringField *cdsGridtipoGatilho;
  TStringField *cdsGridsegmento;
  TBooleanField *cdsGridgatilhoOrdenacao;
  TBooleanField *cdsGridvalidarMesmoSentido;
  TBooleanField *cdsGridgatilhoDinamico;
  TBooleanField *cdsGridaplicarDestino;
  TBooleanField *cdsGridmanterOrdenacao;
  TStringField *cdsGridcodigoGatilho;
  TAction *acDesabilitarGatilho;
  TAction *acHabilitarGatilho;
  TMenuItem *acDesabilitarGatilho1;
  TMenuItem *acHabilitarGatilho1;
  TcxGridDBColumn *cxgGridDBTableView1tipoGatilho;
  TcxGridDBColumn *cxgGridDBTableView1segmento;
  TcxGridDBColumn *cxgGridDBTableView1gatilhoOrdenacao;
  TcxGridDBColumn *cxgGridDBTableView1validarMesmoSentido;
  TcxGridDBColumn *cxgGridDBTableView1gatilhoDinamico;
  TcxGridDBColumn *cxgGridDBTableView1aplicarDestino;
  TcxGridDBColumn *cxgGridDBTableView1manterOrdenacao;
  TcxGridDBColumn *cxgGridDBTableView1codigoGatilho;
  TcxGridDBColumn *cxgGridDBTableView1codigoTipoGatilho;
  TBooleanField *cdsGridativoUsuario;
  TcxGridDBColumn *cxgGridDBTableView1ativoUsuario;
  TIntegerField *cdsGridqtdadeFixOrdem;
  TcxGridDBColumn *cxgGridDBTableView1qtdadeFixOrdem;
  void __fastcall acDesabilitarGatilhoExecute(TObject *Sender);
  void __fastcall acHabilitarGatilhoExecute(TObject *Sender);
  void __fastcall PopupMenuGridPopup(TObject *Sender);
private:	// User declarations
  void __fastcall CarregarGatilhos();
public:		// User declarations
  __fastcall TformGatilhos2(TComponent* Owner);
};
//---------------------------------------------------------------------------
extern PACKAGE TformGatilhos2 *formGatilhos2;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFormsManager.cpp =====
// ---------------------------------------------------------------------------
#include <stdio.h>    //incluso da biblioteca necessria para imprimir
#include <typeinfo.h>
#include <fstream>
#include <sstream>
#include <dos.h>
#include <windows.h>
#include <time.h>
#include <dirent.h>
#include <sys/stat.h>
#include <direct.h>
#pragma hdrstop
#include "UFormsManager.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
// ---------------------------------------------------------------------------
#include "UTPSBSeries.h"
#include "UTPSBCBTC.h"


#include "UFPrincipal.h"
#include "UTPZonaControle.h"
#include "UTPAtividade.h"
#include "UTPTipoAtividade.h"
#include "UTPTipoTrem.h"
#include "UTPItinerarioTrem.h"
#include "UTPGrupoVMP.h"
#include "UTPSB.h"
#include "UTPTipoRestricao.h"
#include "UTPMovimento.h"
#include <boost/thread.hpp>
//#include <boost/asio.hpp>
#pragma warn -8012
#include <boost/asio/io_service.hpp>
#include <boost/bind.hpp>
#pragma warn .8012
#include <boost/thread/mutex.hpp>


#include "UUteis.h"
#include "UFFilas.h"

#include "UFormTabSheet.h"
#include "UTPMovimentoSeries.h"

#include "UGerenteComunicacaoAQ.h"
#include "UGerenteProgramacao.h"
#include "UFResultadoProcessos.h"

#include <../domain/Comparacao.h>
#include "UTPComparacao.h"
#include "UFTestes.h"

#pragma region Server
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "../domain/InterdicaoSB.h"
#include "../domain/SegmentoTremRealizado.h"
#include "../domain/SegmentoTremOficializado.h"
#include "../domain/RetencaoSB.h"
#include "../domain/AtividadePlanejamento.h"
#pragma end_region

// ---------------------------------------------------------------------------
TTPFormsManager *TTPFormsManager::instancia = 0;

// ---------------------------------------------------------------------------
/*
 void workerThread(boost::asio::io_service* service)
 {
 service->run();
 }
 */
// ---------------------------------------------------------------------------
TTPFormsManager::~TTPFormsManager()
{
  FecharFormsAbertos();
  trens_ = NULL;

  copiaTrens_ = NULL;

   trensSuprimidos_= NULL;
   restricoes_= NULL;
   restricoesDel_= NULL;
   restricoesDinamicas_= NULL;
   trensAlteracaoAtividade_ = NULL;

  gruposVMP_ = NULL;

  for  (int i = 0; i <fomrsZonas_->Count ;i++)
  {
    TFormPrincipal* fp =(TFormPrincipal*)fomrsZonas_->Objects[i];
    fp->clearSmartPtr();
    delete  fp;
//    fomrsZonas_->Delete(0);
  }
  sbcbtcs_= NULL;
  delete fomrsZonas_;
  tiposAtividade_= NULL;
  tiposRestricao_ = NULL;
  tRamaisNaoCarregados_ = NULL;
  tiposTrem_= NULL;
  sbs_= NULL;
  zonasControle_ = NULL;

  delete trensAderenciaFila_;
  delete trensForaOrdemFila_;
  delete FParametros.listaFilasAtivas;
  delete FParametros.listaFilasInativas;
  delete listaAlertaComparacoesTTP_;
  delete listaAlertaComparacoes_;
  delete siglaPatios_;

  delete hint_;
  delete mesasPlanejamento_;
  delete filasTerminais_;
  delete filtroTrensViewer_;
  if(listaOficializacoesViewer_)
    delete listaOficializacoesViewer_;
  if (formsAbertos_ )
    delete formsAbertos_;

   TTPGerenteProgramacao::freeInstance();
  if (IconesAtividades)
  {
    while (IconesAtividades->Count > 0)
    {
      TBitmap* btm =(TBitmap*)IconesAtividades->Objects[0];

     IconesAtividades->Delete(0);

     int objRep = IconesAtividades->IndexOfObject((TObject*)btm);
     while (objRep > -1 )
     {
        IconesAtividades->Delete(objRep);
        objRep = IconesAtividades->IndexOfObject((TObject*)btm);
     }

      delete  btm;
    }
    delete IconesAtividades;
  }
  if (menusDinamicos_)
  {
   while (menusDinamicos_->Count > 0)
    {
      TTPMenuDinamico* mnd =(TTPMenuDinamico*)menusDinamicos_->Objects[0];
      delete  mnd;
     menusDinamicos_->Delete(0);
    }
  delete menusDinamicos_;
  }
 instancia = NULL;

}

// ---------------------------------------------------------------------------
void TTPFormsManager::gravarLog(String mensagem, TTPTipoLog tipoLog)
{
  using namespace std;
  try
  {
    TUteis::gravarLog(mensagem, tipoLog);
    /*
     AnsiString nomePath = "C:\\LOG\\";
     String     nomeArq  = "ClienTTP2.log";

     // Primeiro vamos verificar se o arquivo j exs
     wfstream logFile;
     time_t now = time(0);
     struct tm tstruct;
     char buf[80];
     tstruct = *localtime(&now);
     // Visit http://en.cppreference.com/w/cpp/chrono/c/strftime
     // for more information about date/time format
     strftime(buf, sizeof(buf), "%d/%m/%Y %X", &tstruct);
     string data = buf;

     std::string strLogPathDir = nomePath.c_str();
     DWORD       ftyp          = GetFileAttributesA(strLogPathDir.c_str());
     if (!(ftyp & FILE_ATTRIBUTE_DIRECTORY))
     {
     mkdir(strLogPathDir.c_str());
     }

     String nomeLogFile = nomePath + nomeArq;

     logFile.open(nomeLogFile.c_str(), std::fstream::out | std::fstream::app);
     logFile << data.c_str() << " - " << mensagem.c_str() << std::endl;

     logFile.close();
     */
  }
  catch (...)
  {
  }

}

// ---------------------------------------------------------------------------
TTPFormsManager::TTPFormsManager(TForm* pOwner)
{
  MutexProc = new boost::mutex();
  isPrimeiroCarregamento = true;
   InitializeCriticalSection(&CriticalSectionSeries);
  formPrincipal_                    = pOwner;
  tmrAtualizarOcializacao           = new TTimer(pOwner);
  tmrAtualizarOcializacao->Interval = 60000;
  tmrAtualizarOcializacao->OnTimer  = this->tmrAtualizarOcializacaoTimer;
  tmrAtualizarOcializacao->Enabled  = true;
  formsAbertos_                     = NULL;
  clockTimeOut_                     = std::clock();

  trensAderenciaFila_             = new TStringList();
  trensAderenciaFila_->Sorted     = true;
  trensAderenciaFila_->Duplicates = System::Types::dupIgnore;

  trensForaOrdemFila_             = new TStringList();
  trensForaOrdemFila_->Sorted     = true;
  trensForaOrdemFila_->Duplicates = System::Types::dupIgnore;

  tmrOcioso           = new TTimer(pOwner);
  tmrOcioso->Interval = 0;
  tmrOcioso->OnTimer  = this->tmrOciosoTimer;
  tmrOcioso->Enabled  = true;
  this->IconesAtividades = NULL;

	IconesAtividades = NULL;
  MovimentosSerieMouseOver = NULL;
  this->menusDinamicos_ = NULL;

	FParametros.ExibirRealizadoReal =  false;
	FParametros.ExibirRealizadosViewer = true;
	FParametros.ExibirRealizadosViewerLinhaDoTempo = true;
  FParametros.DesativarGatilhoCadenciamentoVazio = false;
  FParametros.listaFilasAtivas = new TStringList();
  FParametros.listaFilasInativas = new TStringList();
  FParametros.dtExpiracao = NULL;
  FParametros.CarregarOrdemGatilho = algorithm::CoreTMPlanner::getInstance()->getIsCarregarOrdemGatilho();
  contM = 0;
  contMD = 0;
  saldoM = 0;
  contP = 0;
  contPD = 0;
	saldoP = 0;

	isEscutarFilaAutomatico_ = false;
	chamouRefreshCharts_     = false;

	stringDataUltimaOflzAutomatico_ = "";
	listaDatasComparacao_ = NULL;
	listaAlertaComparacoes_ =  new TStringList();
	listaAlertaComparacoesTTP_ = new TStringList();
	refreshComparacoes_ = false;

	linhaTempoComparador_ = "";
  isAcionamentoComparador_ = false;

  siglaPatios_ =  new TStringList();
  siglaPatios_->Duplicates = System::Types::dupIgnore;

  exbirPATsGantt_ = true;
  exibirInterdicoesGantt_ = true;

  ordemVisualizaoSBsPatio_ = ordNormal;

  isAguardeComparadorPlanos_ = false;

  String tempTamanhoTremLongo = algorithm::CoreTMPlanner::getInstance()->getParamByName("CP_TREM_LONGO");
  if(tempTamanhoTremLongo.Length()> 0)
  {
    try
    {
      tamanhoTremLongo_ = tempTamanhoTremLongo.ToDouble();
    }
    catch(...)
    {
      tamanhoTremLongo_ = 0;
    }
  }

  if(tamanhoTremLongo_ < 1.5)
    tamanhoTremLongo_ = 1.5;

  descricaoTremLongo_ = algorithm::CoreTMPlanner::getInstance()->getParamByName("DC_TREM_LONGO");
  if(descricaoTremLongo_.Length() == 0)
    descricaoTremLongo_ = "(VL)";

  listaOficializacoesViewer_ = NULL;
  dataAtualParametrosOficializadosViewer_ = NULL;
  TrensOrdemAlterada = new TStringList();
  // getDataModule();
  //FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

  isComparacaoPlanosLigado_ = true;
  String parametroGlobalCompPlanos = algorithm::CoreTMPlanner::getInstance()->getParamByName("IS_COMP_PLANOS_ATIVO");
  if(parametroGlobalCompPlanos.SubString(1,1) == "F")
    isComparacaoPlanosLigado_ = false;

}
 // ---------------------------------------------------------------------------
void __fastcall TTPFormsManager::AtualizarStatusOficializacao(String strDataUltimaOficializacao,String mesaOfizializacao,
String porcentagemUltimaOficializacao,bool existeErro, String cadeadoTravaEntreMesas,TTPProgramacaoEmCurso result)
{

  struct TLocalArgs
  {// processo para poder chamar via multhread
      String strDataUltimaOficializacao;
      String mesaOfizializacao;
      String porcentagemUltimaOficializacao;
      bool existeErro;
      String cadeadoTravaEntreMesas;
      TTPProgramacaoEmCurso result;
      void __fastcall AtualizarStatusOficializacao()
      {
          for (int i = 0; i < TTPFormsManager::getInstance()->FomrsZonas->Count; i++)
        {
          TFormPrincipal *t_formPrincipal = (TFormPrincipal*)TTPFormsManager::getInstance()->FomrsZonas->Objects[i];
          for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
          {
            // Application->ProcessMessages();
            TFormTP *t_FormTP                              = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
            t_FormTP->lblDataOficializacao->Caption        = strDataUltimaOficializacao; // .SubString(0, 16);
            t_FormTP->lblUsuarioOficializacao->Caption     = mesaOfizializacao;
            t_FormTP->lblPorcentagemOficializacao->Caption = porcentagemUltimaOficializacao;
            t_FormTP->lblPorcentagemOficializacao->Font->Color = !existeErro ? clWindowText : clRed;
            if ( cadeadoTravaEntreMesas.UpperCase()!="TRUE")
            {
              if (!result.isPlanoInicado && t_FormTP->FPlanoInicializado)
              {
                t_FormTP->FPlanoInicializado    = false;
                t_FormTP->acPublicarEntreMesas->Enabled = false;
                t_FormTP->acOficializar->Enabled = false;
                t_FormTP->AjustarEstadoControleOficializar(false);
                if (TTPFormsManager::getInstance()->getAmbienteDebug())
                {
                  t_FormTP->acPublicarEntreMesas->Enabled = true;
                }
                t_FormTP->acCarregar->Enabled   = true;
              }
              else if (result.isPlanoInicado && !t_FormTP->FPlanoInicializado)
              {
                t_FormTP->FPlanoInicializado = true;
                t_FormTP->AjustarEstadoControles(false);
                t_FormTP->acCarregar->Enabled  = true;
              }
            }
          }
        }
      }
  };

  TLocalArgs Args;
  Args.strDataUltimaOficializacao= strDataUltimaOficializacao;
  Args.mesaOfizializacao=mesaOfizializacao;
  Args.porcentagemUltimaOficializacao=porcentagemUltimaOficializacao;
  Args.existeErro=existeErro;
  Args.cadeadoTravaEntreMesas=cadeadoTravaEntreMesas;
  Args.result=result;
  TThread::Synchronize(NULL, &Args.AtualizarStatusOficializacao);

}
// ---------------------------------------------------------------------------
void __fastcall TTPFormsManager::tmrAtualizarOcializacaoTimer(TObject *Sender)
{

  if (! isAtualizarOcializacaoRunning_)
  {
    boost:: thread threadProcessamentoCalc(&this->threadAtualizarOcializacaoTimer);
  }
}
void  TTPFormsManager::threadAtualizarOcializacaoTimer()
{
	bool lockMutex = false;
  bool viewerIntrajornada = algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada;
  try
  {
		if(ShowVisualizador && !viewerIntrajornada)
		{
			tmrAtualizarOcializacao->Enabled = false;
			return;
    }

    if (this->tryLockMutexProc(-1,"","Monitor Oficializacao"))
    {
       isAtualizarOcializacaoRunning_ = true;
       lockMutex = true;
      //gravarLog("tryLockMutexProc Monitor Oficializacao");
      PtrQuery ultimaOflz = viewerIntrajornada
                            ?TDAO::getDadosUltimaOficializacaoIntrajornada()
                            :TDAO::getDadosUltimaOficializacao();

      AtualizarStatusFarolParametros();

      String mesaOfizializacao          = "-";
      String strDataUltimaOficializacao = "-";

      bool existeErro = false;
      TDateTime teste = ultimaOflz->FieldByName("DT_OFLZ")->AsDateTime;

      bool existeOflzAuto = false;
      if(!viewerIntrajornada)
      {
        PtrQuery ultimaOflzAutomatico =  TDAO::getTotalizadorOficializacaoAutomatico();
        if (ultimaOflzAutomatico != NULL && !ultimaOflzAutomatico->Eof)
        {
          if(lasDataOficializadaAutomatico!= ultimaOflzAutomatico->FieldByName("DT_OFLZ")->AsString
             || porcentagemUltimaOficializacaoAutomatico != "100%"  )
          {
            existeOflzAuto = true;

            clockTimeOut_ = std::clock();

            lasDataOficializadaAutomatico = ultimaOflzAutomatico->FieldByName("DT_OFLZ")->AsString;
            mesaOfizializacao          = "AUTO";

           // PtrQuery totalizador = //TDAO::getTotalizadorOficializacao(ultimaOflzAutomatico->FieldByName("DT_OFLZ")->AsDateTime);
            int totalRegistros   = 0;
            int processados      = 0;
            while (!ultimaOflzAutomatico->Eof)
            {
              int aux = ultimaOflzAutomatico->FieldByName("COUNT")->AsInteger;

              totalRegistros += aux;
              if (ultimaOflzAutomatico->FieldByName("ESTD")->AsString != "T")
              {
                if (ultimaOflzAutomatico->FieldByName("ESTD")->AsString != "E")
                {
                  existeErro = true;
                }
                processados += aux;
              }
              ultimaOflzAutomatico->Next();
            }
            if (totalRegistros > 0)
            {
              porcentagemUltimaOficializacaoAutomatico = FormatFloat("##0", (processados / (double)totalRegistros) * 100) + "%";
            }
            else
            {
              porcentagemUltimaOficializacaoAutomatico = "100%";
            }

            if (porcentagemUltimaOficializacaoAutomatico == "100%")
            {
              tmrAtualizarOcializacao->Interval = 20000;
            }
            else
            {
              tmrAtualizarOcializacao->Interval = 3000;
            }

            if(processados==0)
            {
              existeOflzAuto = false;
            }

            lasDataOficializada = "";
            porcentagemUltimaOficializacao = "";
          }
        }
      }


      if (!existeOflzAuto && ultimaOflz != NULL && !ultimaOflz->Eof && (lasDataOficializada != ultimaOflz->FieldByName("DT_OFLZ")
        ->AsString || porcentagemUltimaOficializacao != "100%") && ultimaOflz->FieldByName("DT_OFLZ")->AsDateTime >
        TDateTime(0))
      { // horario valido no optmove

        clockTimeOut_ = std::clock();

        strDataUltimaOficializacao = ultimaOflz->FieldByName("DT_OFLZ")->AsString;
        mesaOfizializacao          = ultimaOflz->FieldByName("CD_MESA_OFLZ")->AsString;

        PtrQuery totalizador = TDAO::getTotalizadorOficializacao(ultimaOflz->FieldByName("DT_OFLZ")->AsDateTime);
        int totalRegistros   = 0;
        int processados      = 0;
        while (!totalizador->Eof)
        {
          int aux = totalizador->FieldByName("COUNT")->AsInteger;

          totalRegistros += aux;
          if (totalizador->FieldByName("ESTD")->AsString != "T")
          {
            if (totalizador->FieldByName("ESTD")->AsString != "E")
            {
              existeErro = true;
            }
            processados += aux;
          }
          totalizador->Next();
        }
        if (totalRegistros > 0)
        {
          porcentagemUltimaOficializacao = FormatFloat("##0", (processados / (double)totalRegistros) * 100) + "%";
        }
        else
        {
          porcentagemUltimaOficializacao = "100%";
        }

        if (porcentagemUltimaOficializacao == "100%")
        {
          tmrAtualizarOcializacao->Interval = 60000;
        }
        else
        {
          tmrAtualizarOcializacao->Interval = 3000;
        }
      }

      String mesaPlano="";
      int numeroMesa=0;
      TTPProgramacaoEmCurso result;
      String cadeadoTravaEntreMesas = algorithm::CoreTMPlanner::getInstance()->getParamByName("CPTO_TRAVA_ENTRE_MESAS");
      if ( cadeadoTravaEntreMesas.UpperCase()!="TRUE")
      {
        mesaPlano= algorithm::CoreTMPlanner::getInstance()->getMesaControle();
        numeroMesa = TDAO::getNumeroMesa(mesaPlano);
        result = TDAO::checkProgramacaoEmCurso(numeroMesa,Usuario.Codigo);
      }

      if (strDataUltimaOficializacao != "-" && !existeOflzAuto)
      {
        lasDataOficializada = strDataUltimaOficializacao != "-" && fomrsZonas_->Count>0? strDataUltimaOficializacao : String("");

        AtualizarStatusOficializacao(strDataUltimaOficializacao,mesaOfizializacao,porcentagemUltimaOficializacao,existeErro,cadeadoTravaEntreMesas,result);
      }
      else if (existeOflzAuto)
      {
        // lasDataOficializada = strDataUltimaOficializacao != "-" && fomrsZonas_->Count>0? strDataUltimaOficializacao : String("");

         AtualizarStatusOficializacao(lasDataOficializadaAutomatico,"AUTOMATICO",porcentagemUltimaOficializacaoAutomatico,existeErro,cadeadoTravaEntreMesas,result);
      }

      if(!viewerIntrajornada)
      {
        /* if (((std::clock() - clockTimeOut_)/(double)CLOCKS_PER_SEC) > 60 && tmrAtualizarOcializacao->Interval < 60000)
         {
         tmrAtualizarOcializacao->Interval = 60000;
         } */

         if(strDataUltimaOficializacao == "-" && IsEscutarFilaAutomatico)
         {
            tmrAtualizarOcializacao->Interval = !isAguardandoFimAutomatico_? 1000:20000;

            String tResult = TTPGerenteComunicacaoAQ::getInstance()->escutarMensagemFilaAutomatico(Mesa, 2);
            pugi::xml_document XMLRet;

            pugi::xml_parse_result result = XMLRet.load_string(AnsiString(tResult).c_str());
            String mensagem = "";

            bool isError = false;

            while (tResult!="")
            {

              pugi::xpath_node node = XMLRet.select_single_node("//status");
              String status = node.node().first_child().value();// child_value("status");

              node = XMLRet.select_single_node("//datetime");
              String dateTimeMsg = node.node().first_child().value();// child_value("status");



              if(status == "STARTED")
              {
                mensagem = "Optmove Automtico Acionado!";
                isAguardandoFimAutomatico_ = true;
                isError = false;
              }
              else if(status == "WAIT")
              {
                AjustarEstadoAcionarAutomatico(true);
                IsEscutarFilaAutomatico = false;
                isAguardandoFimAutomatico_ = false;
                isError = false;
                pugi::xpath_node node = XMLRet.select_single_node("//waittime");
                String waittime = node.node().first_child().value();

                String segundos = IntToStr(StrToInt(waittime)%60);
                segundos = segundos.Length()<2 ? "0"+segundos : segundos;

                String minutos = IntToStr(StrToInt(waittime)/60);
                String tempo = minutos==0?"segundos":"minuto(s)";
                mensagem = "Optmove Automtico j est em execuo, aguarde "+minutos+":"+segundos+
                            " "+tempo+" para um novo acionamento";

                TDAO::atualizarControleLogPlanejamento(IdUltimaChamadaAutomatico, Mesa, "ACMT_AUTO",
                NULL,TDAO::getCurrentDate(), 0, 0, "E", Usuario.Codigo, TDAO::getNumeroMesa(Mesa));


              }
              else if(status == "FINISHED")
              {
                AjustarEstadoAcionarAutomatico(true);
                mensagem = "Optmove Automtico terminou e axecuo.\nEm alguns instantes a informao ser exibida no GHT!";
                IsEscutarFilaAutomatico = false;
                isAguardandoFimAutomatico_ = false;
                isError = false;
                TDAO::atualizarControleLogPlanejamento(IdUltimaChamadaAutomatico, Mesa, "ACMT_AUTO",
                NULL, StrToDateTime(dateTimeMsg) , 0, 0, "S", Usuario.Codigo, TDAO::getNumeroMesa(Mesa));

              }
              else if(status == "ERROR")
              {
                AjustarEstadoAcionarAutomatico(true);
                mensagem = "Erro ocorrido durante a execuo do Optmove Automtico, o mesmo no foi atualizado!";
                TDAO::atualizarControleLogPlanejamento(IdUltimaChamadaAutomatico, Mesa, "ACMT_AUTO",
                NULL, TDAO::getCurrentDate(), 0, 0, "X", Usuario.Codigo, TDAO::getNumeroMesa(Mesa));

                isError = true;
                Alerta(mensagem);

                mensagem = "";
                IsEscutarFilaAutomatico = false;
                isAguardandoFimAutomatico_ = false;
              }

              tResult = TTPGerenteComunicacaoAQ::getInstance()->escutarMensagemFilaAutomatico(Mesa,2);
              result = XMLRet.load_string(AnsiString(tResult).c_str());
            }
            if(mensagem!="")
             if(isError)
                Alerta(mensagem);
             else
                Informacao(mensagem);
         }

      }
      //colocar aqui Diego
      TTPFormsManager::AlterarIconeLog();
      MutexProc->unlock();
      isAtualizarOcializacaoRunning_ = false;
      //gravarLog("unlock Monitor Oficializacao");

    }
  }
  catch (Exception &e)
	{
		gravarLog("Alerta Monitor Oficializacao Exception: "+e.Message);
		Alerta(e.Message.c_str());
		if(lockMutex)
		{
			MutexProc->unlock();
			isAtualizarOcializacaoRunning_ = false;
		}
		tmrAtualizarOcializacao->Interval = 60000;
		gravarLog("unlock Monitor Oficializacao Exception " + lockMutex?"T":"F" );
	}
	catch (...)
	{
		if(lockMutex)
		{
			MutexProc->unlock();
			isAtualizarOcializacaoRunning_ = false;
		}
		tmrAtualizarOcializacao->Interval = 60000;
		gravarLog("unlock Monitor Oficializacao Exception Desconhecida "+ lockMutex?"T":"F" );
	}
}

// ---------------------------------------------------------------------------
void __fastcall TTPFormsManager::StartTimeOut(int TimeOut)
{
  if (TimeOut > 60)
  {
    timeOutSeconds     = TimeOut; // 100 segundos
    tempoAlertaSeconds = 60;

    Application->OnIdle    = onIdleForm;
    Application->OnMessage = onMessageForm;

    this->tmrOcioso->Tag      = 0;
    this->tmrOcioso->Interval = (timeOutSeconds - tempoAlertaSeconds) * 1000;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TTPFormsManager::onIdleForm(System::TObject* Sender, bool &Done)
{
  if (!this->tmrOcioso->Enabled)
  {
    this->tmrOcioso->Interval = (timeOutSeconds - tempoAlertaSeconds) * 1000;
    this->tmrOcioso->Enabled  = true;
    this->tmrOcioso->Tag      = 0;
  }
}

// ---------------------------------------------------------------------------
void __fastcall TTPFormsManager::onMessageForm(tagMSG &Msg, bool &Handled)
{

  if (this->tmrOcioso->Enabled && ((Msg.message >= WM_MOUSEFIRST && Msg.message <= WM_MOUSELAST) || // mensagem do mouse
    (Msg.message >= WM_KEYFIRST && Msg.message <= WM_KEYLAST)) && // mensagem teclado
    Application->Active)
  {
    this->tmrOcioso->Enabled = false;
    // this->statusBar->SimpleText = "";
    this->tmrOcioso->Tag = 0;
  }
}
// ---------------------------------------------------------------------------

void __fastcall TTPFormsManager::tmrOciosoTimer(TObject *Sender)
{
  if (this->tmrOcioso->Interval != 1000)
  {
    this->tmrOcioso->Enabled  = false;
    this->tmrOcioso->Interval = 1000; // coloca o timer de 1 em 1 segundos.
    this->tmrOcioso->Enabled  = true;
  }

  this->tmrOcioso->Tag = this->tmrOcioso->Tag + 1;
  int tempoRestante = (tempoAlertaSeconds)-this->tmrOcioso->Tag;
  // this->statusBar->SimpleText = "Sesso ser encerrada em: " + IntToStr(tempoRestante) + " seg.";

  if (tempoRestante <= 0)
  {
     gravarLog("tmrOciosoTimer timeout");
    this->tmrOcioso->Enabled = false;
    this->tmrAtualizarOcializacao->Enabled = false;
    Application->MessageBox(L"Sesso encerrada devido  expirao do tempo limite de inatividade.", L"OptMove",
      MB_OK | MB_SYSTEMMODAL);
    gravarLog("tmrOciosoTimer Fim Sessao");
    Application->Terminate();
  }

}
// ---------------------------------------------------------------------------

TTPFormsManager* TTPFormsManager::getInstance(TForm* pOwner)
{
  if (instancia == NULL)
  {
    instancia                           = new TTPFormsManager(pOwner);
    instancia->zonasControle_           = TTPZonaControleListPtr(new TTPZonaControleList());
    instancia->sbs_                     = TTPSBListPtr(new TTPSBList());
    instancia->sbs_->setSorted(true);
		instancia->sbcbtcs_                 = TTPSBCBTCListPtr(new TTPSBCBTCList());
		instancia->trens_                   = TTPTremListPtr(new TTPTremList());
		instancia->copiaTrens_              = TTPTremListPtr(new TTPTremList());
		instancia->tiposTrem_               = TTPTipoTremListPtr(new TTPTipoTremList());
    instancia->tiposAtividade_          = TTPTipoAtividadeListPtr(new TTPTipoAtividadeList());
    instancia->fomrsZonas_              = new TStringList();
		instancia->restricoes_              = TTPRestricaoListPtr(new TTPRestricaoList());
		instancia->restricoesDel_           = TTPRestricaoListPtr(new TTPRestricaoList());
		instancia->restricoesDinamicas_     = TTPRestricaoListPtr(new TTPRestricaoList());
		instancia->trensSuprimidos_         = TTPTremListPtr(new TTPTremList());
		instancia->trensAlteracaoAtividade_ = TTPTremListPtr(new TTPTremList());
    instancia->hint_                    = new THint();
		instancia->filasTerminais_          = new TXStringList();
		instancia->filtroTrensViewer_       = new TXStringList();
    instancia->tiposRestricao_          = TTPTipoRestricaoListPtr(new TTPTipoRestricaoList());
    instancia->gruposVMP_               = TTPGrupoVMPListPtr(new TTPGrupoVMPList());
    instancia->mesasPlanejamento_       = NULL;
    }

  return instancia;
}

// ---------------------------------------------------------------------------
TTPFormsManager* TTPFormsManager::getInstance()
{
  if (instancia != NULL)
    return instancia;
  else
    throw Exception("Falta gerar instancia passando o form principal");
}
 void TTPFormsManager::freeInstance()
{
   if (instancia != NULL)
   {
     delete  instancia;
     instancia = NULL;
   }
}
// ---------------------------------------------------------------------------
void TTPFormsManager::CarregarZonas()
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* tmalha       = core->getMalha();

  // Montando a condio para recuperar os paineis
  String tCondicao    = "";
  bool carregarBrisao = false;

  for (int i = 0; i < zonasControle_->count(); i++)
  {
    tCondicao += "'" + zonasControle_->operator[](i)->Nome + "',";
  }

  tCondicao = tCondicao.SubString(1, tCondicao.Length() - 1);

  // Em um nico SQL, vamos buscar os dados de ZONA, RAMAIS e SBs
  getDataModule()->ActivateUserDB();

  PtrQuery qrDadosBD = TDAO::getSBsPorZonasControle(tCondicao);

  TTPZonaControlePtr t_zona;
  TTPRamalPtr t_ramal;
  TTPRamalPtr t_ramalAtual;
  String t_nomeRamal = "";

  int totalSBs             = 0;
  int contSegmentos        = 0;
  double t_minY            = 0;
  double comprimentoTotal  = 0L;
  double comprimentoSegAnt = 0L;
  String segmentoAtual     = "";
  double countLinhaSeg     = 1;
  bool achouSBs_           = false;

  // Carregando os dados do Modelo

  // lista para caregar somente os ramais que estiverem no filtro do debug
  TStringList *tFiltroDebug            = new TStringList();
  TStringList *tFiltroZonasRamaisDebug = new TStringList();
  bool isFiltroValido                  = false;
#ifdef _DEBUG
  if (TTPFormsManager::getInstance()->getAmbienteDebug())
  {
    tFiltroZonasRamaisDebug->Duplicates = System::Types::dupIgnore;

    qrDadosBD->First();
    AnsiString filtro = algorithm::CoreTMPlanner::getInstance()->FILTRO_RAMAIS_SNC;
    if (filtro != "")
    {
      filtro                  = "\"" + filtro + "\"";
      filtro                  = ReplaceStr(filtro, ",", "\",\"");
      tFiltroDebug->CommaText = filtro;
    }

    while (!qrDadosBD->Eof)
    {
      if (tFiltroDebug->IndexOf(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text) >
        -1 || tFiltroDebug->IndexOf(qrDadosBD->FieldByName("NM_RAMAL")->Text) > -1)
      {
        isFiltroValido = true;
        break;
      }
      qrDadosBD->Next();
    }
  }
#endif
  qrDadosBD->First();

  while (!qrDadosBD->Eof)
  {
    // if(qrDadosBD->FieldByName("NM_RAMAL")->Text != "FOS-FGI BRISAMAR (BRISO)")
    {
			t_zona      = zonasControle_->get(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text);
			t_nomeRamal = qrDadosBD->FieldByName("NM_RAMAL")->Text;

      if (t_zona->Ramais->IndexOf(t_nomeRamal) == -1)
      {
				t_ramal                              = TTPRamalPtr(new TTPRamal(&*t_zona));
        t_ramal->Numero                      = qrDadosBD->FieldByName("NU_RAMAL")->Text.ToInt();
        t_ramal->Nome                        = t_nomeRamal;

				String tIndicadorPermiteOficializacao = qrDadosBD->FieldByName("IC_PRMS_OFLZ")->Text;
				bool tIsOficializacaoPermitida = tIndicadorPermiteOficializacao == "T"
																			|| tIndicadorPermiteOficializacao == "U";

				t_ramal->PermiteOficializarPainel    = tIsOficializacaoPermitida;
				t_ramal->OficializaSomenteSubMesa    = qrDadosBD->FieldByName("IC_OFLZ_SUB_MESA")->Text == "T";
        t_ramal->CodigoOficializacaoZonaMesa = qrDadosBD->FieldByName("CD_OFLZ_ZONA_MESA")->Text;
				t_ramal->PermiteStandAloneProg       = qrDadosBD->FieldByName("IC_PLJM_EXCS_RAMAL")->Text == "T";
        t_ramal->IndicadorSistemaOrigemIntraJornada = qrDadosBD->FieldByName("IC_SIS_ORIG_ITJD")->Text;

        t_zona->Ramais->add(t_nomeRamal, t_ramal);
      }
      else
      {
        t_ramal = t_zona->Ramais->get(t_nomeRamal);
      }

#ifdef _DEBUG
      if (TTPFormsManager::getInstance()->getAmbienteDebug() && isFiltroValido)
      {
        if (tFiltroDebug->Count != 0)
        {
          if (tFiltroDebug->IndexOf(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text) >
            -1 && tFiltroZonasRamaisDebug->IndexOf(t_nomeRamal) == -1)
          {
            tFiltroZonasRamaisDebug->Add(t_nomeRamal);
            tFiltroZonasRamaisDebug->Add(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text);
          }
          else if (tFiltroDebug->IndexOf(t_nomeRamal) > -1 && tFiltroZonasRamaisDebug->IndexOf(t_nomeRamal) == -1)
          {
            tFiltroZonasRamaisDebug->Add(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text);
            tFiltroZonasRamaisDebug->Add(t_nomeRamal);
          }
        }
        else
        {
          tFiltroZonasRamaisDebug->Add(t_nomeRamal);
          tFiltroZonasRamaisDebug->Add(qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text);
        }

        if (tFiltroZonasRamaisDebug->IndexOf(t_nomeRamal) == -1)
        {
          t_zona->Ramais->remove(t_zona->Ramais->IndexOf(t_nomeRamal));
        }
      }
#endif

      // Verifica se mudou de ZONA E/OU RAMAL
      if (t_ramalAtual == NULL)
      {
        t_ramalAtual = t_ramal;
      }

      else if (t_ramalAtual != t_ramal) // Se mudou de zona
      {
        t_ramalAtual->MinY             = contSegmentos > 1 ? t_minY : 0;
        t_ramalAtual->ComprimentoTotal = comprimentoTotal;

        totalSBs          = 0;
        t_minY            = 0;
        comprimentoTotal  = 0L;
        comprimentoSegAnt = 0L;
        segmentoAtual     = "";
        countLinhaSeg     = 1;
        achouSBs_         = false;
        t_ramalAtual      = t_ramal;
        contSegmentos     = 0;
      }

      if (segmentoAtual != qrDadosBD->FieldByName("CD_SGMT")->Text)
      {
        countLinhaSeg     = 1;
        comprimentoSegAnt = comprimentoTotal;
        segmentoAtual     = qrDadosBD->FieldByName("CD_SGMT")->Text;
        comprimentoTotal += (qrDadosBD->FieldByName("CP_SEG")->Text.ToDouble()) + ((countLinhaSeg - 1) * 0.100);
        // comprimentoTotal    += (qrDadosBD->FieldByName("CP_SEG")->Text.ToDouble());
        contSegmentos++;
      }

      TTPSBPtr sb = new TTPSB();
      sb->PID             = qrDadosBD->FieldByName("ID_SBL")->Text;
      sb->NomeVia         = qrDadosBD->FieldByName("NM_SBL")->Text;
      sb->NumeroLinha     = qrDadosBD->FieldByName("seqSB")->Text.ToInt();
      sb->Linhas          = qrDadosBD->FieldByName("LINHAS")->Text.ToInt();
      sb->CodigoSegmento  = qrDadosBD->FieldByName("CD_SGMT")->Text;
      sb->ApelidoSegmento = qrDadosBD->FieldByName("NM_APLD")->Text;
      sb->Ramal           = qrDadosBD->FieldByName("NM_RAMAL")->Text;
      sb->ZonaControle    = qrDadosBD->FieldByName("NM_ZONA_CTRL")->Text;
      sb->SeqSB           = qrDadosBD->FieldByName("seqSB")->Text.ToInt();
      sb->Seqsegmento     = qrDadosBD->FieldByName("seqSegment")->Text.ToInt();
      sb->CodigoSubMesa   = qrDadosBD->FieldByName("CD_OFLZ_SUB_MESA")->Text;
      sb->RamalPtr        = &*t_ramal;
      sb->TipoProjecaoOflz = qrDadosBD->FieldByName("IC_TIPO_PRJC_OFLZ")->Text;
      sb->IndexGraficoI   = comprimentoSegAnt + (countLinhaSeg > 1 ? ((countLinhaSeg - 1) * 0.100) : 0);
      sb->KMInicial       = qrDadosBD->FieldByName("NU_KM_INIC")->Text.ToDouble();
      sb->KMFinal         = qrDadosBD->FieldByName("NU_KM_FIM")->Text.ToDouble();
      sb->CodCancelamentoOcupacaoSeg = qrDadosBD->FieldByName("CD_CANC_OCUP")->Text;
      // t_difIndex;
    #ifdef BAIXADA_SANTISTA
    // medotod modificado, removendo 0 -0.5 por erro do desenho
      sb->IndexGraficoS = (comprimentoSegAnt + (qrDadosBD->FieldByName("CP_KM")->Text.ToDouble())) +
        (countLinhaSeg > 1 ? ((countLinhaSeg - 1) * 0.100) : 0); // t_difIndex;
    #else
      sb->IndexGraficoS = (comprimentoSegAnt + (qrDadosBD->FieldByName("CP_KM")->Text.ToDouble() - 0.5)) +
        (countLinhaSeg > 1 ? ((countLinhaSeg - 1) * 0.100) : 0); // t_difIndex;
    #endif
      sb->TipoVisao = qrDadosBD->FieldByName("IC_VISAO_LINHA_DUPLA")->Text;
      countLinhaSeg++;

      // Vamos guardar as SBs dos ramais carregados
      // TTPSBPtr copiaSB = new TTPSB(sb);
      // sbs_->add(copiaSB->NomeVia, copiaSB);
      sbs_->add(sb->NomeVia, sb);

      if (t_minY == 0)
      {
        t_minY = comprimentoTotal; // qrSBs->FieldByName("comprimentokm")->Text.ToDouble();
      }

      String nomeSBL = qrDadosBD->FieldByName("NM_SBL")->Text;
      int idxSB = tmalha->listaSBMalha->IndexOf(nomeSBL);
      if (idxSB > -1)
      {
        sb->SBServer = (SB*)tmalha->listaSBMalha->Objects[idxSB];
      }
     
      t_ramal->SBs->add(nomeSBL, sb);

      totalSBs++;
    } qrDadosBD->Next();
  } // while qrDados
  delete tFiltroDebug;
  t_ramalAtual->MinY = t_minY;
  t_ramalAtual->ComprimentoTotal = comprimentoTotal;

  // Instanciar os forms
  for (int i = 0; i < zonasControle_->count(); i++)
  {

#ifdef _DEBUG
    if (TTPFormsManager::getInstance()->getAmbienteDebug() && isFiltroValido)
    {
      if (tFiltroZonasRamaisDebug->Count != 0)
      {
        if (tFiltroZonasRamaisDebug->IndexOf(zonasControle_->operator[](i)->Nome) == -1)
        {
          continue;
        }
      }
    }
#endif

    TFormPrincipal *formPrincipal = new TFormPrincipal(formPrincipal_, zonasControle_->get(i), tipoLegenda_);
    formPrincipal->Caption = "OptMove - " + zonasControle_->operator[](i)->Nome + " - Verso: " +
      TUteis::getVersaoExe() + " - Usurio: " + TTPFormsManager::getInstance()->Usuario.Nome + " (" +
      TTPFormsManager::getInstance()->Usuario.Codigo + ") - Ambiente: " + algorithm::CoreTMPlanner::getInstance()
      ->DB_INSTANCE + " (" + algorithm::CoreTMPlanner::getInstance()->DB_SCHEMA + ")";

    formPrincipal->Show();
    fomrsZonas_->AddObject(zonasControle_->operator[](i)->Nome, formPrincipal);
  }
  delete tFiltroZonasRamaisDebug;
  TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[0];
  t_formPrincipal->BringToFront();
  // Carregar SBs que no esto nos paineis carregados
  PtrQuery qrSBs = TDAO::getSBs();
  tRamaisNaoCarregados_ =TTPRamalListPtr( new TTPRamalList());

  while (!qrSBs->Eof)
  {
    if (sbs_->IndexOf(qrSBs->FieldByName("NM_SBL")->Text) == -1)
    {
      TTPSBPtr sb         = new TTPSB();
      sb->PID             = qrSBs->FieldByName("ID_SBL")->Text;
      sb->NomeVia         = qrSBs->FieldByName("NM_SBL")->Text;
      sb->SeqSB           = qrSBs->FieldByName("NU_SEQL_SBL_SGMT")->Text.ToInt();
      sb->CodigoSegmento  = qrSBs->FieldByName("CD_SGMT")->Text;
      sb->ApelidoSegmento = qrSBs->FieldByName("NM_APLD")->Text;
      sb->Ramal           = qrSBs->FieldByName("NM_RAMAL")->Text;
      sb->ZonaControle    = qrSBs->FieldByName("NM_ZONA_CTRL")->Text;
      sb->Seqsegmento     = qrSBs->FieldByName("seqSegment")->Text.ToInt();
      sb->TipoProjecaoOflz = qrSBs->FieldByName("IC_TIPO_PRJC_OFLZ")->Text;
      sb->IndexGraficoI   = -1;
      sb->IndexGraficoS   = -1;
      sb->CodCancelamentoOcupacaoSeg = qrSBs->FieldByName("CD_CANC_OCUP")->Text;

	  String nomeSBL = qrSBs->FieldByName("NM_SBL")->Text;
	  int idxSB = tmalha->listaSBMalha->IndexOf(nomeSBL);
	  if (idxSB > -1)
	  {
		sb->SBServer = (SB*)tmalha->listaSBMalha->Objects[idxSB];
	  }

      if (tRamaisNaoCarregados_->IndexOf(sb->Ramal) > -1)
      {
        sb->RamalPtr = &*tRamaisNaoCarregados_->get(sb->Ramal);
      }
      else
      {
        TTPRamalPtr t_ramal                  = new TTPRamal(NULL);
        t_ramal->Numero                      = qrSBs->FieldByName("NU_RAMAL")->Text.ToInt();
        t_ramal->Nome                        = sb->Ramal;
        t_ramal->PermiteOficializarPainel    = qrSBs->FieldByName("IC_PRMS_OFLZ")->Text == "T";
        t_ramal->OficializaSomenteSubMesa    = qrSBs->FieldByName("IC_OFLZ_SUB_MESA")->Text == "T";
        t_ramal->CodigoOficializacaoZonaMesa = qrSBs->FieldByName("CD_OFLZ_ZONA_MESA")->Text;
        t_ramal->PermiteStandAloneProg       = qrSBs->FieldByName("IC_PLJM_EXCS_RAMAL")->Text == "T";
		tRamaisNaoCarregados_->add(sb->Ramal, t_ramal);
        sb->RamalPtr = &*t_ramal;
      }

      sbs_->add(sb->NomeVia, sb);
    }
    qrSBs->Next();
  }

  int timeOut = algorithm::CoreTMPlanner::getInstance()->getParamByName("TIMEOUT").ToIntDef(1);
  StartTimeOut(timeOut*60);

  if(!VerificaShowVisualizador())
    AtualizarStatusFarolParametros();

  if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspTeste)
  {
    TformTestes* teste = new  TformTestes(NULL);
    teste->Show();
  }

}
// ---------------------------------------------------------------------------
TXStringList* TTPFormsManager::CarregarMesasPlanejamento()
{
  if(!mesasPlanejamento_)
  {
	mesasPlanejamento_ = TDAO::getMesasPlanejamento();
  }
  return mesasPlanejamento_;
}
// ---------------------------------------------------------------------------
void TTPFormsManager::CarregarDadosCBTC()
{
  // carregar as SBs CBTC
  PtrQuery qrDadosBDSBCBTC = TDAO::getSBCBTCs();
  while (!qrDadosBDSBCBTC->Eof)
  {
    TTPSBCBTCPtr sbcbtc           = new TTPSBCBTC();
    sbcbtc->CodigoSBCBTC          = qrDadosBDSBCBTC->FieldByName("CD_SBL_CBTC")->Text;
    sbcbtc->NomeSBCBTC            = qrDadosBDSBCBTC->FieldByName("NM_SBL_CBTC")->Text;
    sbcbtc->PatioReferenciaSBCBTC = qrDadosBDSBCBTC->FieldByName("SG_PATIO_REFR_CBTC")->Text;
    sbcbtc->CodigoExibicaoPainel  = qrDadosBDSBCBTC->FieldByName("CD_BLOCO_EXIB_PAIN_CBTC")->Text;

    sbcbtcs_->add(sbcbtc->CodigoSBCBTC, sbcbtc);
    qrDadosBDSBCBTC->Next();
  }

}

// ---------------------------------------------------------------------------
void TTPFormsManager::CarregarTiposTrem()
{

  PtrQuery qrTiposTrem = TDAO::getTiposTrem();

  while (!qrTiposTrem->Eof)
  {
    TTPTipoTremPtr tipoTrem     = new TTPTipoTrem();
    tipoTrem->PID               = qrTiposTrem->FieldByName("ID_TIPO_TREM")->Text;
    tipoTrem->Prefixos          = qrTiposTrem->FieldByName("DC_EXPR_PRFX")->Text;
    tipoTrem->RGBCores          = qrTiposTrem->FieldByName("CD_COR_EXIB")->Text;
    tipoTrem->Nome              = qrTiposTrem->FieldByName("NM_TIPO_TREM")->Text;
    tipoTrem->Codigo            = qrTiposTrem->FieldByName("CD_TIPO_TREM")->Text;
    tipoTrem->Comprimento       = qrTiposTrem->FieldByName("CP_TREM_KM")->AsFloat;
    tipoTrem->Peso              = qrTiposTrem->FieldByName("PS_TT_TREM")->AsFloat;
    tipoTrem->PesoVazio         = qrTiposTrem->FieldByName("PS_TT_TREM_VAZIO")->AsFloat;
    tipoTrem->VMA               = qrTiposTrem->FieldByName("VE_VMA_MAXM")->AsFloat;
    tipoTrem->LotacaoPadrao     = qrTiposTrem->FieldByName("IC_PADR_LOTC")->Text;
    tipoTrem->PIDGrupoVMP       = qrTiposTrem->FieldByName("ID_GRUPO_VMP")->Text;
    tipoTrem->PermissaoExclusao = qrTiposTrem->FieldByName("IC_PRMS_EXCL")->Text == "T" ? true : false;

    tiposTrem_->add(tipoTrem->Nome, tipoTrem);

    qrTiposTrem->Next();
  }

  // Tipo VIRTUAL de Trem Cpia
  TTPTipoTremPtr tv = new TTPTipoTrem();
  tv->PID      = 1;
  tv->Nome     = "C";
  tv->Prefixos = "";
  tv->RGBCores = "255,96,96";

  tiposTrem_->add(tv->Nome, tv);

}

// ---------------------------------------------------------------------------
void TTPFormsManager::CarregarTiposRestricao()
{

  if(tiposRestricao_->count() > 0)
    return;

  using namespace domain;
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* tmalha       = core->getMalha();
  TStringList *tiposRest        ;// = new TStringList();

  tiposRest = tmalha->tiposRestricaoMalha;

  // PtrQuery qrTipos = TDAO::getTiposRestricao();

  // while (!qrTipos->Eof)
  for (int i = 0; i < tiposRest->Count; i++)
  {
    TTPTipoRestricaoPtr tipo  = new TTPTipoRestricao();
    TipoRestricao* tipoServer = (TipoRestricao*)tiposRest->Objects[i];
    // tipo->Codigo            = qrTipos->FieldByName("CD_TIPO_RTRC")->Text;
    tipo->Codigo              = tipoServer->getCodigo();
    tipo->Nome                = tipoServer->getNome();
    tipo->ISPararTrem         = tipoServer->getRealizaParada();
    tipo->ISReducaoVelocidade = tipoServer->getReduzVelocidade();
    tipo->CorPlanejado        = tipoServer->getCorPlanejado();
    tipo->CorIniciado         = tipoServer->getCorIniciado();
    tipo->CorFinalizado       = tipoServer->getCorFinalizado();
    tipo->ISPermiteOcupacao   = tipoServer->getPermiteOcupacao();
    tiposRestricao_->add(tipo->Codigo, tipo);

    // qrTipos->Next();
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::CarregarTiposAtividade()
{
  PtrQuery qrTiposAtividade = TDAO::getTiposAtividade();

  // TTPTipoAtividadeListPtr tListaTiposAtividade = new TTPTipoAtividadeList();
  while (!qrTiposAtividade->Eof)
  {
    TTPTipoAtividadePtr temp           = new TTPTipoAtividade();
    temp->PID                          = qrTiposAtividade->FieldByName("ID_TIPO_ATVD_PLJM")->Text;
    temp->Nome                         = qrTiposAtividade->FieldByName("NM_TIPO_ATVD_PLJM")->Text;
    temp->Duracao                      = qrTiposAtividade->FieldByName("DU_PADR")->AsFloat;
    temp->ISAtividadeHoraria           = qrTiposAtividade->FieldByName("IC_ATVD_HRAR")->Text.UpperCase() == "T";
    temp->ISAtividadeCaudaLogica       = qrTiposAtividade->FieldByName("IC_CAUDA_LOGI")->Text.UpperCase() == "T";
    temp->ISAtividadeCalculaVelocidade = qrTiposAtividade->FieldByName("IC_CALC_VE_DU_PCRS")->Text.UpperCase() == "T";
    temp->ISPermitidoExclusao          = qrTiposAtividade->FieldByName("IC_PRMS_EXCL_ATVD")->Text.UpperCase() == "T";
    temp->ISPermitidoAlterarDuracao    = qrTiposAtividade->FieldByName("IC_PRMS_ALTR_DU_PRDA")->Text.UpperCase() == "T";
    temp->CodigoAtividadeExterna       = qrTiposAtividade->FieldByName("CD_ATVD_EXTN")->Text;
    temp->CodigoJustificativaExterna       = qrTiposAtividade->FieldByName("CD_JTFC_EXTN")->Text;
    tiposAtividade_->add(temp->PID, temp);

    qrTiposAtividade->Next();
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::CarregarGruposVMP()
{
  PtrQuery qrGruposVMP = TDAO::getGruposVMP();
  // TTPTipoAtividadeListPtr tListaTiposAtividade = new TTPTipoAtividadeList();
  while (!qrGruposVMP->Eof)
  {
    TTPGrupoVMPPtr temp = new TTPGrupoVMP();
    temp->PID           = qrGruposVMP->FieldByName("ID_GRUPO_VMP")->Text;
    temp->Nome          = qrGruposVMP->FieldByName("NM_GRUPO_VMP")->Text;

    gruposVMP_->add(temp->PID, temp);

    qrGruposVMP->Next();
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerInicializar()
{
	// Inicializa modelo do Server
	try
	{
		algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
		core->setMesaControle("MESA", false);
		core->Inicializar("U");
	}
	catch (Exception &e)
	{
		throw;
	}
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerSetMesaPlan(String pMesa)
{
  // Inicializa modelo do Server
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  Mesa                           = pMesa;
  core->setMesaControle(pMesa);
}

// ---------------------------------------------------------------------------
int TTPFormsManager::ServerGetOrdemPartida(String pid, String pidExterno, TDateTime& dataHoraSaidaOriginal,
  TDateTime& dataHoraSaidaAtual, String &SiglaPatioOrigemExtn, String &CodigoPrefixo)
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  return core->getOrdemSaidaTremPorTipoMesa(pid, pidExterno, dataHoraSaidaOriginal, dataHoraSaidaAtual,
    SiglaPatioOrigemExtn, CodigoPrefixo);
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerCarregarTrensMalha(TComponent* Owner)
{
	try
  {
    this->tmrAtualizarOcializacao->Enabled = false;
    algorithm::CoreTMPlanner *core         = algorithm::CoreTMPlanner::getInstance();
    gravarLog("--> calcularTrensMalha <--");
		if(algorithm::CoreTMPlanner::getInstance()->getSystemProfile() != TSystemProfile::tspVisualizador)
			SetDataGrafico(true);
    core->carregarTrensMalha();
  }
  catch (Exception &e)
  {
    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {

    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
    throw Exception("Erro ao ServerCalcularTrens()");
	}

}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerCarregarTrensMalha(TComponent* Owner,TDateTime dataHoraLinhaTempo, TStringList * datasOficializacao)
{
  try
  {
    this->tmrAtualizarOcializacao->Enabled = false;
    algorithm::CoreTMPlanner *core         = algorithm::CoreTMPlanner::getInstance();
    gravarLog("--> calcularTrensMalha <--");
    core->carregarTrensMalha(dataHoraLinhaTempo,datasOficializacao);
    this->filtroTrensViewer_->Clear();
  }
  catch (Exception &e)
  {
    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {

    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
		throw Exception("Erro ao ServerCalcularTrens()");
	}
}
// ---------------------------------------------------------------------------
TDateTime TTPFormsManager::ServerCalcularTrens(int branchProgramingID)
{
	try
  {
    this->tmrAtualizarOcializacao->Enabled = false;
	  algorithm::CoreTMPlanner *core         = algorithm::CoreTMPlanner::getInstance();

    // Ateno, para que este mtodo NO DEVER SER CHAMADO SEM A PREVIA EXECUCAO DO
    // ->ServerCarregarTrensMalha (core->carregarTrensMalha();)
    // O mtodo mencionado est sendo chamado de fora da Thread secundria
    #ifdef BAIXADA_SANTISTA
      int tentativas = 1;
      for(int i=1; i < tentativas+1; i++)
      {
        if(!VerificaShowVisualizador())
          SetDataGrafico();

        core->calcularTrensMalha(branchProgramingID);
        int conflitosRestantes = core->getTotalConflitosAbandonados();
        if( conflitosRestantes <=1 || i + 1 > tentativas)
        {
          break;
        }
        else
        {
          String msg = "Recarregando: " + String(i) + " T:" + String(conflitosRestantes);
          AguardeSetMensagem(msg);
          SetDataGrafico(true);
          ServerCarregarTrensMalha(NULL);
        }
      }

      if(VerificaShowVisualizador())
        SetDataGrafico();
    #else
      if(!VerificaShowVisualizador())
        SetDataGrafico();

      gravarLog("--> Inicia calcularTrensMalha() <--");
		  core->calcularTrensMalha();
	    gravarLog("--> Fim calcularTrensMalha() <--");

		  if(VerificaShowVisualizador())
        SetDataGrafico();
    #endif

	  gravarLog("--> ServerCarregarTrensCalculados <--");
	  AguardeSetMensagem("Plotando Grfico");

    ServerCarregarTrensCalculados();
    gravarLog("--> ServerCarregarRestricoes <--");

    ServerCarregarRestricoes();
    gravarLog("--> ServerCarregarRestricoes <--");

    SetDataGrafico();

    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Interval = 1000;
      this->tmrAtualizarOcializacao->Enabled  = true;
    }
  }
  catch (Exception &e)
  {
		if (!this->tmrAtualizarOcializacao->Enabled)
      {
        this->tmrAtualizarOcializacao->Enabled = true;
      }

      Screen->Cursor = crDefault;
      throw;
    }
    catch (...)
    {
		if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    String szMessage;
    szMessage = TUteis::ErrorMessage(GetLastError());
    TTPFormsManager::getInstance()->gravarLog("--> GetLastError: "+ szMessage);

    Screen->Cursor = crDefault;

		throw;
	}
  return dataGrafico_;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerProgramarTrens(bool pRealizadoReal, bool pDataPlanejamento, int branchProgramingID)
{
	try
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    /* Mtodo no pode ser chamado pela Thread Secundria */
    // RetirarSelecaoZerarParadas();

    // core->testeCalculo();
	if (pDataPlanejamento)
    {

      timeTP::TimeTP dataAux;
      dataAux = dataProgramacaoCongelada_;
      TTPFormsManager::getInstance()->gravarLog("--> Incio: setDataInicioPlanejamento <--");
      core->setDataInicioPlanejamento(dataAux);
    }

    if (isZerarParadas_)
    {
      TTPFormsManager::getInstance()->gravarLog("--> Incio: ZerarTemposMovimentosTrens <--");
      core->ZerarTemposMovimentosTrens(dataZerarParadasTrem_);
      isZerarParadas_ = false;
		}

		TTPFormsManager::getInstance()->gravarLog("--> Incio: Atualizar Trens <--");
		core->AtualizarTrens(branchProgramingID);
		Aguarde("Plotando Grfico", false);
		TTPFormsManager::getInstance()->gravarLog("--> Fim: Atualizar Trens <--");
		TTPFormsManager::getInstance()->gravarLog("--> Incio: Carregar trens Calculados <--");
		ServerCarregarTrensCalculados();
		TTPFormsManager::getInstance()->gravarLog("--> Fim: Carregar trens Calculados <--");
	}
  catch (Exception &e)
	{
		Screen->Cursor = crDefault;
		TObject *excecao = &e;
		throw;
	}
	catch (...)
	{
		Screen->Cursor = crDefault;
		String szMessage;
		szMessage = TUteis::ErrorMessage(GetLastError());
		TTPFormsManager::getInstance()->gravarLog("--> GetLastError: "+ szMessage);

		throw;
	}
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerCarregarTrensCalculados()
{
  try
  {
    using namespace domain;
    // carrengando a intancia da classe.
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    // core->AtualizarTrens();
    TStringList *t_trens = core->getTrensCalculados();
		TimeTP dataLimiteJanela;
		dataLimiteJanela = dataGrafico_;
    dataLimiteJanela += addMinutes(-360);
    dataInicioLimiteGrafico_ = dataLimiteJanela.asDateTime();

    dataLimiteJanela = StrToDateTime(dataGrafico_.DateString() + " 23:59:59");
    dataLimiteJanela += addMinutes(1440);
    dataFimLimiteGrafico_ = dataLimiteJanela.asDateTime();

    /*
     boost::thread_group poolCarregamento;
     boost::asio::io_service service;
     boost::asio::io_service::work working(service);

     for (int i = 0; i < 4; i++)
     {
     poolCarregamento.create_thread(boost::bind(workerThread, &service));
     }
     */

    for (int i = 0; i < t_trens->Count; i++)
    {
      try
      {
        TremMalha* tremCalc = (TremMalha*)t_trens->Objects[i];
        //if (tremCalc->getPrimeiroMovimento())
        {
          if (trens_->IndexOf(tremCalc->PID) > -1)
          {
            TTPTrem* tTrem = &*trens_->get(tremCalc->PID);
            CriarTremCliente(tremCalc, tTrem, false);
          }
          else
          {
            // service.post(boost::bind(&CriarTremThread, tremCalc));
            CriarTremCliente(tremCalc, NULL, false);
          }
        }
      }
      catch(...)
      {
        int i = 0;
      }
    }

    // Setando trens pai
    TStringList *t_trensNaoPlanejados = core->getTrensNaoPlanejados();
    for (int i = 0; i < t_trens->Count; i++)
    {
      TremMalha* tremCalc = (TremMalha*)t_trens->Objects[i];
      if (trens_->IndexOf(tremCalc->PID) > -1 && tremCalc->tremPai == NULL)
      {

        int indexOf        = t_trens->IndexOf(tremCalc->pidTremPai);
        int indexOfNaoPlan = t_trensNaoPlanejados->IndexOf(tremCalc->pidTremPai);

        TTPTremPtr tTrem = trens_->get(tremCalc->PID);

        if (indexOf > -1)
        {
          TremMalha* tremPai = (TremMalha*)t_trens->Objects[indexOf];
          tTrem->PrefixoPai  = "(" + tremPai->prefixoTrem + ")";
        }
        else if (indexOfNaoPlan > -1)
        {
          TremMalha* tremPai = (TremMalha*)t_trensNaoPlanejados->Objects[indexOfNaoPlan];
          tTrem->PrefixoPai  = "(" + tremPai->prefixoTrem + ")";
        }
        else
        {
          TTPTremPtr tTremPai = trens_->get(tremCalc->pidTremPai);
          if (!tTremPai.isNull())
          {
						tTrem->PrefixoPai = "(" + tTremPai->Prefixo + ")";
          }
        }
      }
    }

    /*
     service.stop();
     poolCarregamento.join_all();
     */

    // Incluindo os trens suprimidos!
    for (int i = 0; i < t_trensNaoPlanejados->Count; i++)
    {
      TremMalha* tremCalc = (TremMalha*)t_trensNaoPlanejados->Objects[i];

      bool plotarRealizado = !tremCalc->getdataUltimoRealizado()->is_not_a_date_time();

      if (trensSuprimidos_->IndexOf(tremCalc->PID) > -1)
      {
        TTPTremPtr tTrem = trensSuprimidos_->operator[](trensSuprimidos_->IndexOf(tremCalc->PID));
				//CriarTremCliente(tremCalc, &*tTrem);
        // Verificar a possibilidade usar o ISSuprimido para flegar no PesquisarPrefixo
      }
      else if (plotarRealizado)
      {
        if (trens_->IndexOf(tremCalc->PID) > -1)
        {
          TTPTremPtr tTrem = trens_->get(tremCalc->PID);
          CriarTremCliente(tremCalc, &*tTrem, false);
        }
        else
        {
          CriarTremCliente(tremCalc, NULL, false);
        }
      }
    }
    if (FParametros.ExibirTrensAderenciaFila)
    {
      ManterIndicadoresAderenciaFila();
    }
     isPrimeiroCarregamento = false;
  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao ServerCarregarTrensCalculados()");
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerCarregarFilas()
{
	try
  {
    using namespace domain;
    // carrengando a intancia da classe.
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
    TStringList *t_filas           = core->getFilas();

		filasTerminais_->Clear();

    for (int i = 0; i < t_filas->Count; i++)
    {
      FilaMalha* fila = (FilaMalha*) t_filas->Objects[i];
      filasTerminais_->Add(fila->getPatioDestino()->sigla);
    }

    t_filas = NULL;
  }
	catch (Exception &e)
	{
		throw;
	}
	catch (...)
	{
		Screen->Cursor = crDefault;
		throw Exception("Erro ao ServerCarregarFilas()");
	}
}
// ---------------------------------------------------------------------------

TTPTremPtr TTPFormsManager::CriarTremCliente(domain::TremMalha* pTremCalc, TTPTrem* pTremExistente, bool pIsTransiente)
{
	try
  {

    boost::mutex mtx_;
    using namespace domain;

    // carrengando a intancia da classe.
		algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TTPTremPtr tremClient;
    if (pTremExistente == NULL)
    {
      tremClient = TTPTremPtr(new TTPTrem());
      tremClient->Internalize(pTremCalc->prefixoTrem, pTremCalc->PID, true, pTremCalc->prefixoTremAnotherRailway);
      TTPTipoTremPtr t_TipoTrem = tiposTrem_->get(pTremCalc->tipoTrem->nome);
      tremClient->TipoTrem      = new TTPTipoTrem(t_TipoTrem);
      tremClient->EstadoTrem    = (EnumEstadoTrem)_wtoi(&(pTremCalc->estadoTrem));
      tremClient->Tabela        = pTremCalc->codigoTabela;
      tremClient->IsTransiente  = pIsTransiente;
      tremClient->DataNecessidadePorto = pTremCalc->dtNCSDPorto.asDateTime();

      if (!pTremCalc->dataTremPronto.is_not_a_date_time())
        tremClient->DataTremPronto = pTremCalc->dataTremPronto.asDateTime();
      tremClient->TempoPermanenciaTerminal = pTremCalc->tempoPermanenciaTerminal;
      if (!pTremCalc->previsaoSaida.is_not_a_date_time())
        tremClient->PrevisaoSaidaOriginal = pTremCalc->previsaoSaida.asDateTime();

			//data de carremento
			tremClient->DataCarregamento = this->Data;

      // verificaes de fila
      #ifdef BAIXADA_SANTISTA
      tremClient->ISTremFila         = pTremCalc->getFilaDemandaTerminal()!=NULL;
      tremClient->ISFilaAtiva        = pTremCalc->getIsCalcularFilaDemandaTerminalAtivo();
      tremClient->ISCalculoFilaAtivo = pTremCalc->getIsCalcularFilaDemandaTerminalAtivoUsuario();
      #else
      tremClient->ISTremFila         = pTremCalc->filaTrem != NULL;
      tremClient->ISFilaAtiva        = pTremCalc->isFilaAtiva();
      tremClient->ISCalculoFilaAtivo = pTremCalc->getCalculoFilaAtivo();
      #endif
      tremClient->ISCalculoVelocidadeAtivo = pTremCalc->getCalculoVelocidadeAtivo();

      tremClient->IDExterno = pTremCalc->IDExterno;
      tremClient->Origem    = pTremCalc->origemExtn;
      tremClient->Destino   = pTremCalc->destinoExtn;
      tremClient->PIDPai    = pTremCalc->pidTremPai;
      if(pTremCalc->getUltimaOficializacaoPlanejamento()!= NULL)
        tremClient->PIDRotaOfzl = pTremCalc->getUltimaOficializacaoPlanejamento()->PID;

      if (pTremCalc->filaTrem != NULL)
        tremClient->FilaTerminal = pTremCalc->filaTrem->getPatioDestino()->sigla;
      if (pTremCalc->ordremFila.is_not_a_date_time())
      tremClient->OrdemFila =0;
      else
      tremClient->OrdemFila = pTremCalc->ordremFila.asDateTime();

      // tremClient->ChaveTremTabela       = pTremCalc->chaveTremTabela;
      if (pTremCalc->origem != NULL)
        tremClient->MesaOrigem = pTremCalc->origem->codZonaControleResponsavel;

      if (pTremCalc->tremPai != NULL && pTremCalc->tremPai->getUltimoMovimento() != NULL)
      {
        pTremCalc->tremPai->getUltimoMovimento()->getPeriodoOcupacao();
        tremClient->PrefixoPai = pTremCalc->tremPai->prefixoTrem;

        try
        {
          tremClient->PrevisaoFimPai = pTremCalc->tremPai->getUltimoMovimento()->getDataHoraFimParadaTrem();
        }
        catch (...)
        {
          int parar = 0;
        }
      }
      else
      {
        tremClient->PrefixoPai     = "";
        tremClient->PrevisaoFimPai = 0;
      }

      tremClient->DeltaPermanenciaTerminalPai = pTremCalc->tempoMinimoAposPai;
      tremClient->IndicadorPlanejamento = pTremCalc->indicadorPlanejamento;
      tremClient->IsAlteradoUsuario     = true;

      // mtx_.lock();
      trens_->add(tremClient->PID, tremClient);
      // mtx_.unlock();

    }
    else
    {
      tremClient = trens_->get(pTremExistente->PID);

      if (tremClient.isNull())
        throw Exception("Trem no encontrado!");

      if (!tremClient->ItinerarioTrem.isNull() && !tremClient->ItinerarioTrem->Movimentos.isNull())
      {
          tremClient->LimparItinerarioTrem();
      }
      else
        int parar = 0;

      if (!tremClient->Atividades.isNull())
        tremClient->Atividades->clear();
      else
        int parar        = 0;
      tremClient->Tabela = pTremCalc->codigoTabela;
      tremClient->PIDPai = pTremCalc->pidTremPai;
      tremClient->DataNecessidadePorto = pTremCalc->dtNCSDPorto.asDateTime();

      if (!pTremCalc->dataTremPronto.is_not_a_date_time())
        tremClient->DataTremPronto = pTremCalc->dataTremPronto.asDateTime();

      tremClient->TempoPermanenciaTerminal = pTremCalc->tempoPermanenciaTerminal;
      tremClient->Internalize(pTremCalc->prefixoTrem, pTremCalc->PID, true, pTremCalc->prefixoTremAnotherRailway);
      tremClient->IsAlteradoUsuario = true;

			//data de Carregamento do trem existente
			tremClient->DataCarregamento = pTremExistente->DataCarregamento;
		}

    // Teremos que gerar os movimentos antes de plotar...
    // caso contrrio a cpia ficar incorreta
		CriarMovimentos(pTremCalc, &*tremClient);

    TTPAtividadeListPtr atividadesTemp = new TTPAtividadeList();

		if (!tremClient->IsSuprimido)
    {
      // --- Criar Atividades Trem -----//
			SincronizarAtividadesTremClienteServer(&*tremClient, pTremCalc);
      // CriarCopiaTrem(tremClient);
    }

    return tremClient;

  }
	catch (Exception& e)
	{
		gravarLog("Erro ao Criar Trem" + e.Message);
		Alerta(e.Message.c_str());
	}
	catch (...)
	{
		Alerta("Erro fatal!");
	}
	return NULL;
}

// ---------------------------------------------------------------------------
TTPTremPtr TTPFormsManager::RecriarTremCliente(TTPTrem* pTremExistente)
{
  using namespace domain;
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList * t_trens          = core->getTrensCalculados();

  int index = t_trens->IndexOf(pTremExistente->PID);

  TremMalha* tremCalc            = (TremMalha*)t_trens->Objects[index];

	TTPTremPtr tremClient = CriarTremCliente(tremCalc, pTremExistente);
	tremClient->DataCarregamento = TDAO::getCurrentDate();
	return tremClient;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::EnableDisableTeechart(bool val)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP                      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->chrTTP->Enabled              = val;
      t_FormTP->chrTTP->Visible              = val;

      t_FormTP->chrTTPRight->Visible              = val;
      t_FormTP->chrTTPRight->Visible              = val;

      t_FormTP->chrTTPLeft->Visible              = val;
      t_FormTP->chrTTPLeft->Visible              = val;

     // t_FormTP->tmrMouseMovePrefixo->Enabled = val;
     
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::LimparListasConflitos()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->LimparListaConflitos();

    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ServerCarregarRestricoes()
{
  using namespace domain;

  // carrengando a intancia da classe.
	algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  // core->AtualizarTrens();
  TStringList *t_restricoes = core->getMalha()->restricoesMalha;

  restricoes_->clear();

  TimeTP dataLimiteRealizado;
  dataLimiteRealizado = StrToDateTime(dataGrafico_.DateTimeString());
  dataLimiteRealizado += addMinutes(-360);
  TDateTime tDataLimiteRealizado = dataLimiteRealizado.asDateTime();

  for (int i = 0; i < t_restricoes->Count; i++)
  {
    RestricaoSB* restricaoServer = (RestricaoSB*)t_restricoes->Objects[i];
    TDateTime tDataFim           = restricaoServer->getFimRestricao().asDateTime();

    if (tDataFim > tDataLimiteRealizado)
    {
      TTPRestricaoPtr restricaoClient     = new TTPRestricao();
      restricaoClient->IDExterno          = restricaoServer->idExterno;
      restricaoClient->PID                = restricaoServer->PID;
      restricaoClient->IDPersistente      = restricaoClient->PID;
      TDateTime tDataInicio               = restricaoServer->getInicioRestricao().asDateTime();
      restricaoClient->DataInicioOriginal = tDataInicio;
      restricaoClient->Tipo               = tiposRestricao_->get(restricaoServer->tipoRestricao->getCodigo());
      restricaoClient->icComportamentoOperacional = restricaoServer->icComportamentoOperacional;

      for (int j = 0; j < restricaoServer->listaTiposTrensDesconsiderar->Count; j++)
      {
        restricaoClient->ListaTiposTremDesconsiderar->Add(restricaoServer->listaTiposTrensDesconsiderar->Strings[j]);
      }
      if (restricaoServer->getClassType() == RestricaoSB::INTERDICAO ||restricaoServer->getClassType() == RestricaoSB::RETENCAOSB)
      {
        restricaoClient->fechaMovimento  = ((InterdicaoSB*)restricaoServer)->isFechaMovimento();
        restricaoClient->interdicaoTunel = ((InterdicaoSB*)restricaoServer)->isTunel();
        restricaoClient->exibirBordas    = TTPFormsManager::getInstance()->Usuario.Nivel == nivManutencao;
        if(((InterdicaoSB*)restricaoServer)->getSegmentoTremInicio() != NULL)
        {
          String tPIDTrem = ((InterdicaoSB*)restricaoServer)->getSegmentoTremInicio()->trem->PID;
          if (trens_->IndexOf(tPIDTrem) > -1)
          {
            restricaoClient->Trem = &*trens_->get(tPIDTrem);
            restricaoClient->ICComportamentoTremRef = restricaoServer->getCodigoComportamentoTrem();
            int indexOfRest = restricoesDinamicas_->IndexOf(restricaoClient->PID);
            if(indexOfRest == -1)
              restricoesDinamicas_->add(restricaoClient->PID, restricaoClient);
          }
        }
      }
      if (tDataInicio > dataInicioLimiteGrafico_)
        restricaoClient->DataInicio = restricaoServer->getInicioRestricao().asDateTime();
      else
        restricaoClient->DataInicio = dataInicioLimiteGrafico_;

      restricaoClient->DataFimOriginal = tDataFim;
      if (tDataFim < dataFimLimiteGrafico_)
        restricaoClient->DataFim = tDataFim;
      else
        restricaoClient->DataFim = dataFimLimiteGrafico_;

      if (restricaoClient->Tipo->ISReducaoVelocidade)
        restricaoClient->VMA = ((RestricaoVelocidadeSB*)restricaoServer)->velocidadeMaxima;

      TStringList *t_SBs = restricaoServer->listSBInterditada;

      for (int x = 0; x < t_SBs->Count; x++)
      {
        TTPSBPtr t_SB = sbs_->get(t_SBs->operator[](x));
        // restricaoClient->SBsRestricao->add(t_SB->NomeVia, new TTPSB(t_SB));
        if (t_SB)
          restricaoClient->SBsRestricao->add(t_SB->NomeVia, t_SB);
      }
      restricaoClient->DataInicioReal = restricaoServer->getDataHoraRealInicio();
      restricaoClient->DataFimReal              = restricaoServer->getDataHoraRealFim();
      restricaoClient->ISRestricaoInconsistente = restricaoServer->getIndicadorRestricaoInconsistente();
      restricaoClient->Observacao               = restricaoServer->descricao;

      if(!restricaoServer->getDataMinimaInicio().is_not_a_date_time())
        restricaoClient->DataMinInicio = restricaoServer->getDataMinimaInicio().asDateTime();
      else
        restricaoClient->DataMinInicio = TDateTime(0);
      if(!restricaoServer->getDataMaximaFim().is_not_a_date_time())
        restricaoClient->DataMaxFim = restricaoServer->getDataMaximaFim().asDateTime();
      else
        restricaoClient->DataMaxFim = TDateTime(0);

      if(!restricaoServer->getDataMinimaInicioOriginal().is_not_a_date_time())
        restricaoClient->DataMinInicioOriginal = restricaoServer->getDataMinimaInicioOriginal().asDateTime();
      else
        restricaoClient->DataMinInicioOriginal = TDateTime(0);
      if(!restricaoServer->getDataMaximaFimOriginal().is_not_a_date_time())
        restricaoClient->DataMaxFimOriginal = restricaoServer->getDataMaximaFimOriginal().asDateTime();
      else
        restricaoClient->DataMaxFimOriginal = TDateTime(0);

      restricaoClient->RetencaoServer = (RetencaoSB*)restricaoServer;
      if(restricaoServer->getClassType() == domain::RestricaoSB::RestricaoClassType::RETENCAOSB)
      {

        if(restricaoClient->RetencaoServer->listaConexaoSB)
        for (int j = 0; j < restricaoClient->RetencaoServer->listaConexaoSB->Count; j++)
        {
          domain::ConexaoSB* con = (domain::ConexaoSB*) restricaoClient->RetencaoServer->listaConexaoSB->Objects[j];
          restricaoClient->ListaConexoes->Add(con->PIDConexao);
        }

        for (int l = 0; l < restricaoClient->RetencaoServer->listaTrensDesconsiderar->Count; l++)
        {
          String PIDTrem = restricaoClient->RetencaoServer->listaTrensDesconsiderar->Strings[l];
          restricaoClient->ListaTrensDesconsiderar->Add(PIDTrem);
        }

      }

      restricoes_->add(restricaoClient->PID, restricaoClient);
    }
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::ServerSetSelecionar(bool pValor)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {

      TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      TActionListState state = t_FormTP->al->State;
      t_FormTP->al->State    = asNormal;

      t_FormTP->acSelecionar->Checked             = false;
      t_FormTP->acAjustarRestricaoAoTrem->Checked = false;

      t_FormTP->ConfigurarTextoSelecionar();

      t_FormTP->al->State = state;
    }
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::CriarCopiaTrem(TTPTrem* pTrem)
{
  if (copiaTrens_->IndexOf(pTrem->PID) == -1)
  {
    TTPTremPtr tremCopia = new TTPTrem(pTrem);
    tremCopia->TipoTrem  = new TTPTipoTrem(tiposTrem_->get("C"));
    copiaTrens_->add(tremCopia->PID, tremCopia);
  }
}
// ---------------------------------------------------------------------------

bool TTPFormsManager::VerificarTremSubindo(int pIndexInicial, domain::TremMalha* pTrem, bool pRealizado)
{

	using namespace domain;

  try
  {
    if (pRealizado)
		{

      SegmentoTremRealizado * itemRota;
      SegmentoTremRealizado * itemRota2;

      if (pTrem->rotaRealizada != NULL)
        for (int i = pIndexInicial; i < pTrem->rotaRealizada->Count - 1; i++)
				{
					itemRota = (SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[i];
					if (i < pTrem->rotaRealizada->Count - 1)
						itemRota2 = (SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[i + 1];
          else
            itemRota2 = (SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[i];

          TTPSBPtr index1 = sbs_->get(itemRota->getSB()->sb);
          TTPSBPtr index2 = sbs_->get(itemRota2->getSB()->sb);

          if (index1.isNull() || index2.isNull())
						return false; //int parar = 0;

					// temos que garantir que a srio foi plotada e que
          // existam ao menos dois movimentos no mesmo painel
					if (index1->IndexGraficoI > 0 && index2->Ramal == index1->Ramal)
          {
						for (int x = i + 1; x < pTrem->rotaRealizada->Count - 1; x++)
            {
              itemRota2       = (SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[x];
              TTPSBPtr index2 = sbs_->get(itemRota2->getSB()->sb);
              if (index2.isNull() || index2->IndexGraficoI < 0 || index2->Ramal != index1->Ramal ||
                index2->NomeVia == index1->NomeVia)
                continue;

              if (index1->IndexGraficoI > index2->IndexGraficoI)
              {
								return false;
              }
              else if (index1->IndexGraficoI < index2->IndexGraficoI)
              {
								return true;
              }
            } // for x
          } // if valido
        } // for i
    }
    else
    {
      SegmentoTrem * itemRota;
      SegmentoTrem * itemRota2;

			if (pTrem->rotaTrem != NULL)
        for (int i = pIndexInicial; i < pTrem->rotaTrem->Count - 1; i++)
        {
          itemRota = (SegmentoTrem*)pTrem->rotaTrem->Objects[i];
          if (i < pTrem->rotaTrem->Count - 1)
            itemRota2 = (SegmentoTrem*)pTrem->rotaTrem->Objects[i + 1];
          else
            itemRota2 = (SegmentoTrem*)pTrem->rotaTrem->Objects[i];

          TTPSBPtr index1 = sbs_->get(itemRota->getSB()->sb);
          TTPSBPtr index2 = sbs_->get(itemRota2->getSB()->sb);

          // temos que garantir que a srio foi plotada e que
          // existam ao menos dois movimentos no mesmo painel
          if (index1.isNull() || index2.isNull())
            return false; //int parar = 0;

          if (index1->IndexGraficoI > 0 && index2->Ramal == index1->Ramal)
          {
            for (int x = i + 1; x < pTrem->rotaTrem->Count - 1; x++)
            {
              itemRota2       = (SegmentoTrem*)pTrem->rotaTrem->Objects[x];
              TTPSBPtr index2 = sbs_->get(itemRota2->getSB()->sb);
              if (index2.isNull() || index2->IndexGraficoI < 0 || index2->Ramal != index1->Ramal ||
                index2->NomeVia == index1->NomeVia)
                continue;

              if (index1->IndexGraficoI > index2->IndexGraficoI)
              {
                return false;
              }
              else if (index1->IndexGraficoI < index2->IndexGraficoI)
              {
                return true;
              }
            } // for x
          } // if valido
        } // for i
    } // if realizado
  }
  catch (Exception& e)
  {
    int parar = 0;
  }

  return false;

}

// ---------------------------------------------------------------------------
void TTPFormsManager::CriarMovimentos(domain::TremMalha* pTrem, TTPTrem* pTremCliente)
{
  try
  {
    using namespace domain;

    SegmentoTrem * itemRota                         = NULL;
    SegmentoTremRealizado * itemRotaRealizado       = NULL;
    SegmentoTremOficializado * itemRotaOficializado = NULL;

    TDateTime dataInicio, dataFim;
    String nomeIni, nomeFim;
    double indexIni, indexFim;
    TTPMovimentoSeries* movimentoAnterior  = NULL;
    TTPMovimento* movimentoAnteriorNegocio = NULL;

    TremMalha* tremCalc = pTrem;

    TTPTrem* trem = pTremCliente;

    int tPidMovimento = 0;

    movimentoAnterior        = NULL;
		movimentoAnteriorNegocio = NULL;
    // TODO -cFICHA : acertar para ler a ficha do segmento.;
    // trem->Peso        = tremCalc->pesoTB;
    // trem->Comprimento = tremCalc->getComprimentoReal();
    // trem->VMA         = tremCalc->velocidade;
    // trem->Lotacao     = (tremCalc->isCarregado ? "Carregado" : "Vazio");

    // Descobrindo o sentido do trem
    bool tremSubindo;
    bool mudouSentido = false;

    // Controles para gerar primeiro ID Oficializacao
    int parametroIntervaloMesa   = 10000;
    int pidMovimentoOficializado = 0;
    String mesaPID               = trem->MesaOrigem;
	bool temMovimento            = false;
    // Controles para gerar primeiro ID Oficializacao

    #pragma region Realizado
    // -------------------------- Realizado ----------------------------------
    {


      TTPMovimentoSeries *ultimaSerie = NULL;

      String tRamal = "";

      // Plotando pontos...
      if (tremCalc->rotaRealizada != NULL)
      {
        TimeTP dataLimiteRealizado;
        dataLimiteRealizado = StrToDateTime(dataGrafico_.DateTimeString());
        dataLimiteRealizado += addMinutes(-360);
        TDateTime tDataLimiteRealizado = dataLimiteRealizado.asDateTime();

        if(tremCalc->rotaRealizada->Count>2)
        {
           SegmentoTremRealizado *itemRotaRealizado0 = (SegmentoTremRealizado*)tremCalc->rotaRealizada->Objects[0];
           SegmentoTremRealizado *itemRotaRealizado1 = (SegmentoTremRealizado*)tremCalc->rotaRealizada->Objects[1];

           String nomeIni = itemRotaRealizado0->getSB()->sb;
           TTPSBPtr tSB0  = sbs_->get(nomeIni);

           nomeIni        = itemRotaRealizado1->getSB()->sb;
           TTPSBPtr tSB1  = sbs_->get(nomeIni);

           if(tSB0->IndexGraficoI < tSB1->IndexGraficoI)
           {
             tremSubindo = true;
           }
           else
           {
             tremSubindo = false;
           }
        }
        else
        {
          tremSubindo = true;
        }

        for (int i = 0; i < tremCalc->rotaRealizada->Count; i++)
        {
          itemRotaRealizado = (SegmentoTremRealizado*)tremCalc->rotaRealizada->Objects[i];
          nomeIni           = itemRotaRealizado->getSB()->sb;
          dataInicio        = itemRotaRealizado->getDataHoraChegadaCabecaTrem();
          TTPSBPtr tSB      = sbs_->get(nomeIni);

          // Controles para gerar primeiro ID Oficializacao
          temMovimento         = true;
          String tMesaItemRota = itemRotaRealizado->segmentoOcupado->codZonaControleResponsavel;

          if (mesaPID != tMesaItemRota)
          {
            mesaPID = tMesaItemRota;
            pidMovimentoOficializado += parametroIntervaloMesa;
          }
          else
          {
            pidMovimentoOficializado++;
          }
          // Controles para gerar primeiro ID Oficializacao

          if (tSB.isNull()) // || itemRotaRealizado->getDataHoraChegadaCabecaTrem() < tDataLimiteRealizado)
          {
            continue;
          }

          if (tRamal.Length() == 0)
          {
            tRamal = tSB->Ramal;
          }
          mudouSentido = VerificarMudancaSentido(i, tremCalc, itemRotaRealizado, tremSubindo);
          if(mudouSentido)
          tremSubindo  = !tremSubindo;

//          // Verifica se vai mudar o sentido...
//          if (i > 2)
//            if (i < tremCalc->rotaRealizada->Count - 2 && ((SegmentoTremRealizado*)tremCalc->rotaRealizada->Objects[i -
//              2]) != NULL)
//              if (itemRotaRealizado->segmentoOcupado == ((SegmentoTremRealizado*)tremCalc->rotaRealizada->Objects[i -
//                2])->segmentoOcupado)
//                // if( tremSubindo != VerificarTremSubindo(i,tremCalc, true))
//              {
//                tremSubindo  = !tremSubindo;
//                mudouSentido = true;
//              }
          TTPMovimentoPtr movimentoTrem = new TTPMovimento(trem, tSB, false);
          itemRotaRealizado->setDelegateOnDestroy(&movimentoTrem->LimpaSerieServer);

          tPidMovimento++;
          movimentoTrem->PID          = tremCalc->PID + String(tPidMovimento);
          movimentoTrem->Sequencial   = tPidMovimento;
          movimentoTrem->DataChegada  = dataInicio;
          movimentoTrem->DataFimCurso =
            (FParametros.ExibirRealizadoReal ? itemRotaRealizado->getDataHoraFimCursoTrem() :
            itemRotaRealizado->getDataHoraFimCursoTremCalculado());
          movimentoTrem->DataSaida              = itemRotaRealizado->getDataHoraFimParadaTrem();
          movimentoTrem->SentidoGrafico         = (tremSubindo ? strSubindo : strDescendo);
					movimentoTrem->IsRealizado            = true;
          movimentoTrem->ServerSegTremRealizado = itemRotaRealizado;
          movimentoTrem->IsOficializado         = false;
		  movimentoTrem->Mesa                   = itemRotaRealizado->segmentoOcupado->codZonaControleResponsavel;

					String PidverificadorMesa = String(pidMovimentoOficializado) + "0" + mesasPlanejamento_->ValueFromIndex[mesasPlanejamento_->IndexOfName(tMesaItemRota)];
          movimentoTrem->IDOficializacao        = PidverificadorMesa.ToInt();

					trem->ItinerarioTrem->AdicionarMovimento(movimentoTrem);

          mudouSentido                   = false;
					trem->PossuiMovimentoRealizado = true;

					if (movimentoAnteriorNegocio != NULL)
					{
						movimentoAnteriorNegocio->MovimentoPosterior = &*movimentoTrem;
						movimentoTrem->MovimentoAnterior             = movimentoAnteriorNegocio;
					}
					movimentoAnteriorNegocio = &*movimentoTrem;
				} // For ROTA REALIZADA
				// SegmentoTremRealizado * itemRota;
				if (tremCalc->rotaRealizada != NULL)
					tremSubindo = VerificarTremSubindo(0, tremCalc, true);
				if (tremSubindo)
					trem->SetSentidoGrafico(strSubindo);
				else
					trem->SetSentidoGrafico(strDescendo);
			}
		}
		// ----------------------------------------------------------------------
		#pragma end_region

		#pragma region Oficializado
		// -------------------------- Oficializado ----------------------------------

		if(!VerificaShowVisualizador())
		{
			if (!trem->IsSuprimido)
			{
				TTPMovimentoSeries *ultimaSerie = NULL;

				String tRamal = "";

				// Plotando pontos...
				if (tremCalc->getUltimaOficializacaoPlanejamento() != NULL)
				{
					for (int i = 0; i < tremCalc->getUltimaOficializacaoPlanejamento()->rotaOficializada->Count; i++)
					{
						itemRotaOficializado = (SegmentoTremOficializado*)tremCalc->getUltimaOficializacaoPlanejamento()->rotaOficializada->Objects[i];
						nomeIni              = itemRotaOficializado->getSB()->sb;
						dataInicio           = itemRotaOficializado->getDataHoraChegadaCabecaTrem();
						TTPSBPtr tSB         = sbs_->get(nomeIni);

						if (tSB.isNull())
						{
							continue;
						}

						// Controles para gerar primeiro ID Oficializacao
						String tMesaItemRota = itemRotaOficializado->getSegmentoOcupado()->codZonaControleResponsavel;
						if (mesaPID != tMesaItemRota)
						{
							mesaPID = tMesaItemRota;
							pidMovimentoOficializado += parametroIntervaloMesa;
						}
						else
						{
							pidMovimentoOficializado++;
						}
						// Controles para gerar primeiro ID Oficializacao

						if (tRamal.Length() == 0)
						{
							tRamal = tSB->Ramal;
						}

						// Verifica se vai mudar o sentido...
          mudouSentido = VerificarMudancaSentido(i, tremCalc, (SegmentoTrem*)itemRotaOficializado, tremSubindo);
          if(mudouSentido)
          tremSubindo  = !tremSubindo;
//						if (i > 2)
//							if (tremCalc->getUltimaOficializacaoPlanejamento()!=NULL && i < tremCalc->getUltimaOficializacaoPlanejamento()->rotaOficializada->Count -
//								2 && ((SegmentoTremOficializado*)tremCalc->getUltimaOficializacaoPlanejamento()->rotaOficializada->Objects[i - 2]) != NULL)
//								if (itemRotaOficializado->getSegmentoOcupado() ==
//									((SegmentoTremOficializado*)tremCalc->getUltimaOficializacaoPlanejamento()->rotaOficializada->Objects[i - 2])->getSegmentoOcupado())
//									// if( tremSubindo != VerificarTremSubindo(i,tremCalc, true))
//								{
//									tremSubindo  = !tremSubindo;
//									mudouSentido = true;
//								}

						TTPMovimentoPtr movimentoTrem = new TTPMovimento(trem, tSB, false);
            itemRotaOficializado->setDelegateOnDestroy(movimentoTrem->LimpaSerieServer);

						tPidMovimento++;
						movimentoTrem->PID                       = tremCalc->PID + String(tPidMovimento);
						movimentoTrem->Sequencial                = tPidMovimento;
						movimentoTrem->ServerSegTremOficializado = itemRotaOficializado;
						movimentoTrem->DataChegada               = dataInicio;
						movimentoTrem->DataFimCurso              = itemRotaOficializado->getDataHoraFimCursoTrem();
						movimentoTrem->DataSaida                 = itemRotaOficializado->getDataHoraFimParadaTrem();
						movimentoTrem->SentidoGrafico            = (tremSubindo ? strSubindo : strDescendo);
						movimentoTrem->IsRealizado               = false;
						movimentoTrem->IsOficializado            = true;
            movimentoTrem->IsCancelarOcupacao        = itemRotaOficializado->isCancelarOcupacaoViaCadastroSegmento();
						movimentoTrem->Mesa = itemRotaOficializado->getSegmentoOcupado()->codZonaControleResponsavel;
						String PidverificadorMesa = String(pidMovimentoOficializado) + "0" + mesasPlanejamento_->ValueFromIndex[mesasPlanejamento_->IndexOfName(tMesaItemRota)];
						movimentoTrem->IDOficializacao        = PidverificadorMesa.ToInt();

						trem->ItinerarioTrem->AdicionarMovimento(movimentoTrem);

						if (movimentoAnteriorNegocio != NULL)
						{
							movimentoAnteriorNegocio->MovimentoPosterior = &*movimentoTrem;
							movimentoTrem->MovimentoAnterior             = movimentoAnteriorNegocio;
						}
						movimentoAnteriorNegocio = &*movimentoTrem;

						mudouSentido                   = false;
						trem->PossuiMovimentoRealizado = true;
					}
				}

        // SegmentoTremRealizado * itemRota;
				if (tremCalc->getUltimaOficializacaoPlanejamento() != NULL)
					tremSubindo = VerificarTremSubindo(0, tremCalc, true);
				if (tremSubindo)
					trem->SetSentidoGrafico(strSubindo);
				else
					trem->SetSentidoGrafico(strDescendo);
			}
		}
		else
		{


				String tRamal = "";

				// Plotando pontos...
				for (int j = 0; j < tremCalc->listaOficializacoes->Count; j++)
				{

					Oficializacao* tOficializacao = (Oficializacao*) tremCalc->listaOficializacoes->Objects[j];
					if(trem->PrefixosOficializados->IndexOfName(tOficializacao->prefixoTremOficializado) == -1)
					{
						trem->PrefixosOficializados->AddPair(tOficializacao->prefixoTremOficializado, tOficializacao->dataHoraBaseCarregamento.asDateTime());
					}
					String chaveOficializacao =   tremCalc->listaOficializacoes->operator [](j);
					for (int i = 0; i < tOficializacao->rotaOficializada->Count; i++)
					{
						itemRotaOficializado = (SegmentoTremOficializado*)tOficializacao->rotaOficializada->Objects[i];
						nomeIni              = itemRotaOficializado->getSB()->sb;
						dataInicio           = itemRotaOficializado->getDataHoraChegadaCabecaTrem();
						TTPSBPtr tSB         = sbs_->get(nomeIni);

						if (tSB.isNull())
						{
							continue;
						}

						// Controles para gerar primeiro ID Oficializacao
						String tMesaItemRota = itemRotaOficializado->getSegmentoOcupado()->codZonaControleResponsavel;
						if (mesaPID != tMesaItemRota)
						{
							mesaPID = tMesaItemRota;
							pidMovimentoOficializado += parametroIntervaloMesa;
						}
						else
						{
							pidMovimentoOficializado++;
						}
						// Controles para gerar primeiro ID Oficializacao

						if (tRamal.Length() == 0)
						{
							tRamal = tSB->Ramal;
						}

						// Verifica se vai mudar o sentido...
            mudouSentido = VerificarMudancaSentido(i, tremCalc, (SegmentoTrem*)itemRotaOficializado, tremSubindo, tOficializacao);
            if(mudouSentido)
              tremSubindo  = !tremSubindo;
            /*
						if (i > 2)
							if (tOficializacao->rotaOficializada!=NULL && i < tOficializacao->rotaOficializada->Count -
								2 && ((SegmentoTremOficializado*)tOficializacao->rotaOficializada->Objects[i - 2]) != NULL)
								if (itemRotaOficializado->getSegmentoOcupado() ==
									((SegmentoTremOficializado*)tOficializacao->rotaOficializada->Objects[i - 2])->getSegmentoOcupado())
									// if( tremSubindo != VerificarTremSubindo(i,tOficializacao, true))
								{
									tremSubindo  = !tremSubindo;
									mudouSentido = true;
								}
            */

						TTPMovimentoPtr movimentoTrem = new TTPMovimento(trem, tSB, false);
            itemRotaOficializado->setDelegateOnDestroy(&movimentoTrem->LimpaSerieServer);

						tPidMovimento++;
						movimentoTrem->PID                       = tOficializacao->PID + String(tPidMovimento);
						movimentoTrem->Sequencial                = tPidMovimento;
						movimentoTrem->ServerSegTremOficializado = itemRotaOficializado;
						movimentoTrem->DataChegada               = dataInicio;
						movimentoTrem->DataFimCurso              = itemRotaOficializado->getDataHoraFimCursoTrem();
						movimentoTrem->DataSaida                 = itemRotaOficializado->getDataHoraFimParadaTrem();
						movimentoTrem->SentidoGrafico            = (tremSubindo ? strSubindo : strDescendo);
						movimentoTrem->IsRealizado               = false;
						movimentoTrem->IsOficializado            = true;
            movimentoTrem->IsCancelarOcupacao        = itemRotaOficializado->isCancelarOcupacaoViaCadastroSegmento();
						movimentoTrem->Mesa = itemRotaOficializado->getSegmentoOcupado()->codZonaControleResponsavel;
						movimentoTrem->CodigoUsuarioOficializacao =  tOficializacao->codigoUsuarioOficializacao;
						movimentoTrem->ZonaResponsavelOficializacao =  tOficializacao->zonaResponsavelOficializacao;
						movimentoTrem->DataHoraBaseCarregamento =   tOficializacao->dataHoraBaseCarregamento.asDateTime();
						String PidverificadorMesa = String(pidMovimentoOficializado) + "0" + mesasPlanejamento_->ValueFromIndex[mesasPlanejamento_->IndexOfName(tMesaItemRota)];
						movimentoTrem->IDOficializacao        = PidverificadorMesa.ToInt();

						trem->ItinerarioTrem->AdicionarMovimento(movimentoTrem,chaveOficializacao);

						if (movimentoAnteriorNegocio != NULL)
						{
							movimentoAnteriorNegocio->MovimentoPosterior = &*movimentoTrem;
							movimentoTrem->MovimentoAnterior             = movimentoAnteriorNegocio;
						}
						movimentoAnteriorNegocio = &*movimentoTrem;

						mudouSentido                   = false;
						trem->PossuiMovimentoRealizado = true;
					}
				}

				if (tremCalc->getUltimaOficializacaoPlanejamento() != NULL)
					tremSubindo = VerificarTremSubindo(0, tremCalc, true);
				if (tremSubindo)
					trem->SetSentidoGrafico(strSubindo);
				else
					trem->SetSentidoGrafico(strDescendo);

				TTPMovimentoSeries *ultimaSerie = NULL;
			}

		//trem->listaOficializacoes
    // ----------------------------------------------------------------------
    #pragma end_region

    TTPMovimentoSeries *ultimaSerie = NULL;
    String tRamal                = "";
    bool tPrimeiroMovimentoRamal = false;

    // FIM Cria movimento para trem SUPRIMIDO

    // Plotando pontos...
		bool pararCriarMovimentosDescarga = false;
		#pragma region Planejado
		if (tremCalc->rotaTrem != NULL)
		{
			for (int i = 0; i < tremCalc->rotaTrem->Count; i++)
      {
				itemRota     = (SegmentoTrem*)tremCalc->rotaTrem->Objects[i];
        nomeIni      = itemRota->getSB()->sb;
        dataInicio   = itemRota->getDataHoraChegadaCabecaTrem();
        TTPSBPtr tSB = sbs_->get(nomeIni);

        // Controles para gerar primeiro ID Oficializacao
        String tMesaItemRota = itemRota->segmentoOcupado->codZonaControleResponsavel;
        if (mesaPID != tMesaItemRota)
        {
          mesaPID = tMesaItemRota;
          pidMovimentoOficializado += parametroIntervaloMesa;
        }
        else
        {
          pidMovimentoOficializado++;
        }
        // Controles para gerar primeiro ID Oficializacao

        if (tSB.isNull())
        {
          continue;
        }

        if (tRamal != tSB->Ramal)
        {
					if (tRamal.Length() > 0 && movimentoAnterior != NULL && movimentoAnterior->Movimento)
          {
            movimentoAnterior->Movimento->IsUltimoPainel = true;
            movimentoAnterior->SetUltimoMovimentoPainel();
          }
          tPrimeiroMovimentoRamal = true;
          tRamal      = tSB->Ramal;
					tremSubindo = VerificarTremSubindo(i, tremCalc);
				}
        else
        {
          tPrimeiroMovimentoRamal = false;
     //Verifica se vai mudar o sentido...
          mudouSentido = VerificarMudancaSentido(i, tremCalc, itemRota, tremSubindo);
          if(mudouSentido)
            tremSubindo  = !tremSubindo;

/*          tPrimeiroMovimentoRamal = false;
          // Verifica se vai mudar o sentido...
					if (i > 2)
            if (i < tremCalc->rotaTrem->Count - 2 && ((SegmentoTrem*)tremCalc->rotaTrem->Objects[i - 2]) != NULL)
            {
              String nomeIniAux = ((SegmentoTrem*)tremCalc->rotaTrem->Objects[i - 2])->getSB()->sb;
              TTPSBPtr tSBAux = sbs_->get(nomeIniAux);
              if (itemRota->segmentoOcupado == ((SegmentoTrem*)tremCalc->rotaTrem->Objects[i - 2])->segmentoOcupado
                || (tremSubindo && tSBAux->IndexGraficoI > tSB->IndexGraficoI && tSBAux->Ramal == tSB->Ramal)
                || (!tremSubindo && tSBAux->IndexGraficoI < tSB->IndexGraficoI&& tSBAux->Ramal == tSB->Ramal))
              {
                tremSubindo  = !tremSubindo;
                mudouSentido = true;
              }
             } */

        }
        // Criando movimento de negcio
        // TTPSBPtr t_NewSB = new TTPSB(sbs_->get(nomeIni));
				// TTPMovimentoPtr movimentoTeste = new TTPMovimento(t_NewSB, false);

				TTPMovimentoPtr movimentoTrem = new TTPMovimento(trem, sbs_->get(nomeIni), false);
        itemRota->setDelegateOnDestroy(&movimentoTrem->LimpaSerieServer);

        tPidMovimento++;
				movimentoTrem->PID                    = tremCalc->PID + String(tPidMovimento);
        movimentoTrem->Sequencial             = tPidMovimento;
				movimentoTrem->ServerSegTremPlanejado = itemRota;
        movimentoTrem->DataChegada            = dataInicio;
        movimentoTrem->DataFimCurso           = itemRota->getDataHoraFimCursoTrem();
        movimentoTrem->DataSaida              = itemRota->getDataHoraFimParadaTrem();
        movimentoTrem->SentidoGrafico         = (tremSubindo ? strSubindo : strDescendo);
        movimentoTrem->IsPrimeiroPainel       = tPrimeiroMovimentoRamal;
        movimentoTrem->IsOficializado         = false;
        movimentoTrem->IsCancelarOcupacao   = itemRota->isCancelarOcupacaoViaCadastroSegmento();
        movimentoTrem->Mesa                   = itemRota->segmentoOcupado->codZonaControleResponsavel;
        String PidverificadorMesa = String(pidMovimentoOficializado) + "0" + mesasPlanejamento_->ValueFromIndex[mesasPlanejamento_->IndexOfName(tMesaItemRota)];
        movimentoTrem->IDOficializacao        = PidverificadorMesa.ToInt();

        int tempoParadaAtivdade = itemRota->getTempoParadaAtividade();

        if (itemRota->atividade != NULL)
          movimentoTrem->TemEquipagem = itemRota->atividade->isAtividadeEquipagem;

        if (i + 1 == tremCalc->rotaTrem->Count)
          movimentoTrem->IsUltimoTrem = true;

        if (tempoParadaAtivdade > 0)
        {
          TimeTP dataLimiteParada = boost::posix_time::time_from_string
            (TUteis::narrow(movimentoTrem->DataFimCurso.FormatString("yyyy-mm-dd hh:nn:ss").c_str()));
          dataLimiteParada += addSeconds(tempoParadaAtivdade);

          movimentoTrem->DataParadaAtividade = dataLimiteParada.asDateTime();
          if (!itemRota->atividade->dataHoraFim.is_not_a_date_time())
            movimentoTrem->DataFimPAT = itemRota->atividade->dataHoraFim.asDateTime();
        }

        timeTP::PeriodTP *periodo = itemRota->getPeriodoOcupacao();
        TimeTP fimCauda = periodo->end();
        TimeTP fimCabeca;
        fimCabeca                 = movimentoTrem->DataSaida;
        movimentoTrem->TempoCauda = (fimCauda - fimCabeca).seconds();
        if (i == 0)
          trem->PrimeiroMovimentoPrevisto = &*movimentoTrem;

        /*
         gravarLog(";"+itemRota->trem->prefixoTrem + ";IT="+i +
         ";"+itemRota->segmentoOcupado->segmento +
         ";"+itemRota->getDataHoraChegadaCabecaTrem().DateTimeString() +
         ";"+itemRota->getDataHoraFimCursoTrem().DateTimeString());
         */

				trem->ItinerarioTrem->AdicionarMovimento(movimentoTrem);
        if (itemRota->getPrioridadeUsuario())
        {
          trem->ItinerarioTrem->MovimentosPriorizados->add(movimentoTrem->PID, movimentoTrem);
        }

        // Verifica se deve parar de exibir movimentos de carga/descarga nos terminais
        if (!FParametros.ExibirCargaDescarga && movimentoTrem->ISMovimentoTerminal() && movimentoTrem->TemPAT)
          pararCriarMovimentosDescarga = true;

        // Criando a srie
				if (!(movimentoTrem->DataChegada <= dataFimLimiteGrafico_ && !pararCriarMovimentosDescarga))
        {
          movimentoTrem->Serie = NULL;
          movimentoAnterior    = NULL;


				}

        if (movimentoAnteriorNegocio != NULL)
				{
					movimentoAnteriorNegocio->MovimentoPosterior = &*movimentoTrem;
					movimentoTrem->MovimentoAnterior             = movimentoAnteriorNegocio;
				}
				movimentoAnteriorNegocio = &*movimentoTrem;
        mudouSentido = false;
			} // FOR ROTA CALCULADA
		 }
     #pragma end_region



	}
  catch (Exception &e)
  {
    int parar = 0;
  }
  catch (...)
  {
    int parar = 0;
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::PlotarTrem(TTPTrem* pTrem, bool pPlotarPrefixo, bool pTremCopia, bool pAtualizar, bool pAtualizarRestricoesDinamicas)
{
	TTPFormsManager::getInstance()->MovimentosSerieMouseOver = NULL;

	for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
			t_FormTP->chrTTP->AutoRepaint = true;
			t_FormTP->PlotarTrem(pTrem, pPlotarPrefixo, pTremCopia, pAtualizar);
    }
  }

  if(pAtualizar && pAtualizarRestricoesDinamicas)
  {
    AtualizarRestricoesDinamicas();
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AtualizarLinhaCongelamento()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      TActionListState state = t_FormTP->al->State;
      t_FormTP->al->State    = asNormal;
      t_FormTP->AtualizarLinhaCongelamento();

      t_FormTP->al->State = state;
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AtualizarTrem(TTPTrem* pTrem, bool pPlotarPrefixo, String pRamal)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      if (pRamal.Length() == 0 || (pRamal.Length() > 0 && pRamal == t_FormTP->getNomeRamal()))
      {
				t_FormTP->PlotarTrem(pTrem, pPlotarPrefixo, false, true);
      }
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::Selecionar()
{
  chamouSelecionar_          = true;
  chamouSelecionarRestricao_ = false;
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      TActionListState state = t_FormTP->al->State;
      t_FormTP->al->State    = asNormal;

      t_FormTP->acSelecionar->Execute();
      t_FormTP->acAjustarRestricaoAoTrem->Checked = false;

      t_FormTP->al->State = state;
    }
  }
  chamouSelecionar_ = false;
  chamouSelecionarRestricao_ = false;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::SelecionarRestricao()
{
  chamouSelecionar_          = false;
  chamouSelecionarRestricao_ = true;
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      TActionListState state = t_FormTP->al->State;
      t_FormTP->al->State    = asNormal;

      t_FormTP->acSelecionarRestricao->Execute();

      t_FormTP->al->State = state;
    }
  }
  chamouSelecionar_ = false;
  chamouSelecionarRestricao_ = false;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::SelecionarDefault()
{
  chamouSelecionar_          = true;
  chamouSelecionarRestricao_ = true;
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      TActionListState state = t_FormTP->al->State;
      t_FormTP->al->State    = asNormal;

      t_FormTP->acSelecionarRestricao->Checked = true;
      t_FormTP->acSelecionarRestricao->Execute();

      t_FormTP->acSelecionar->Checked = true;
      t_FormTP->acSelecionar->Execute();

      t_FormTP->al->State = state;
    }
  }
  chamouSelecionar_ = false;
  chamouSelecionarRestricao_ = false;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::LimparGraficos()
{
  try
  {
    for (int i = 0; i < fomrsZonas_->Count; i++)
    {
      TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
        TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
        t_FormTP->LimparGrafico();
      }
    }

    LimparTrens();
    restricoes_->clear();
    restricoesDel_->clear();
    restricoesDinamicas_->clear();

  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao LimparGraficos()");
  }

}
// ---------------------------------------------------------------------------

void TTPFormsManager::LimparTrens(bool pProgramar)
{
  try
  {
    for (int i = 0; i < fomrsZonas_->Count; i++)
    {
      TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
        TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
        t_FormTP->LimparTrens();
      }
    }

    if (!pProgramar)
    {
      while(trens_->count()>0)
      {
        //TTPTrem* tTrem = &*trens_->get(0);
        trens_->remove(0);

        //delete tTrem;
      }

      trens_->clear();
      trensSuprimidos_->clear();
      trensAlteracaoAtividade_->clear();
      copiaTrens_->clear();
    }
  }
  catch (Exception &e)
  {
    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {
    Screen->Cursor = crDefault;
    throw Exception("Erro ao Limpar Trens");
  }

}
// ---------------------------------------------------------------------------

void TTPFormsManager::PlotarRestricao(TTPRestricaoPtr pRestricao)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->PlotarRestricao(pRestricao);
    }
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::AtualizarRestricao(TTPRestricaoPtr &pRestricao, TTPTipoAtualizacaoRestricao pTipo)
{
  SincronizarRestricaoClientServer(pRestricao);
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->AtualizarRestricao(pRestricao, pTipo);
    }
  }
}
// ---------------------------------------------------------------------------
void TTPFormsManager::RetirarSelecao(bool pManterMovimento)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTP->RetirarSelecao(pManterMovimento);
    }
  }
}
// ---------------------------------------------------------------------------
void TTPFormsManager::RetirarSelecaoZerarParadas()
{
  dataZerarParadasTrem_ = dataGrafico_;
  isZerarParadas_       = false;

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
			TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->RetirarSelecaoZerarParadas();
		}
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::RemoverSerieMP(TChartSeries*& serie)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->RemoverSerieMP(serie);
    }
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::AntialiasONOFF(bool pOnOff)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTP->AntialiasONOFF(pOnOff);
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::VerificarConflitos(String pRamal)
{

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      if (pRamal.Length() == 0 || (pRamal.Length() > 0 && pRamal == t_FormTP->getNomeRamal()))
      {
        TActionListState state = t_FormTP->al->State;
        t_FormTP->al->State    = asNormal;

        t_FormTP->acVerificarConflitos->Execute();

        t_FormTP->al->State = state;
      }
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarPrefixos(String pRamal)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      if (pRamal.Length() == 0 || (pRamal.Length() > 0 && pRamal == t_FormTP->getNomeRamal()))
      {
        TActionListState state = t_FormTP->al->State;
        t_FormTP->al->State    = asNormal;

        t_FormTP->acAjustarPrefixos->Execute();

        t_FormTP->al->State = state;
      }
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarEstadoControles(bool pOnOff)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->AjustarEstadoControles(pOnOff);
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarEstadoControleMovimentosOficializadosEntreMesas()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->AjustarEstadoControleMovimentosOficializadosEntreMesas();
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::PesquisarPrefixo(String Prefixo)
{

    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[0];
    TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[0];
    t_FormTP->PesquisarPrefixo(Prefixo);
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarLinhaTempo()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTP->AjustarLinhaTempo();
    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::RemoverSeriesPrefixoTransposicao(TTPTrem* pTrem)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
			t_FormTP->RemoverSeriesPrefixoTransposicao(pTrem);

    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::LimparSeriesObservacao(TTPTrem* pTrem)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->LimparSeriesObservacao(pTrem);
    }
  }
}

// ---------------------------------------------------------------------------
// ================ MTODO COPIADO DA BAIXADA ================================
void TTPFormsManager::ExcluirTrem(TTPTrem* pTrem, TTPTipoExclusaoTrem pTipoExcluscao)
{
	if (pTipoExcluscao != texSuprimir && pTipoExcluscao != texRePlotar)
  {
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
	core->ExcluirTrem(pTrem->PID);
	gravarLog("Trem excludo " + pTrem->PID);
  }

	LimparSeriesObservacao(pTrem);

	for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
			t_FormTP->ExcluirTrem(pTrem, pTipoExcluscao);
    }
  }

	if (pTrem && pTrem->ItinerarioTrem && !pTrem->ItinerarioTrem.isNull()
      && pTrem->ItinerarioTrem->Movimentos && !pTrem->ItinerarioTrem->Movimentos.isNull())
	{
      if (pTrem->ItinerarioTrem->MovimentosPriorizados && !pTrem->ItinerarioTrem->MovimentosPriorizados.isNull())
        pTrem->ItinerarioTrem->MovimentosPriorizados->clear();

      if (pTipoExcluscao != texSuprimir && pTipoExcluscao != texRePlotar)
      {
        pTrem->LimparItinerarioTrem();
      }
      else
      /*
      Se vai suprimir o trem, mantm os movimentos realizados e o primeiro movimento previsto
      */
      {
        for(int i = pTrem->ItinerarioTrem->MovimentosPrevistos->count()-1; i >= 1; i--)
        {
          pTrem->ItinerarioTrem->MovimentosPrevistos->remove(i);
        }

        if(pTrem->PrimeiroMovimentoPrevisto)
        {
          for(int i = pTrem->ItinerarioTrem->Movimentos->count()-1; i >= 1; i--)
          {
            if(pTrem->ItinerarioTrem->Movimentos->operator [](i)->IsRealizado ||
               pTrem->ItinerarioTrem->Movimentos->operator [](i)->PID ==
                pTrem->PrimeiroMovimentoPrevisto->PID)
            {
              break;
            }
            pTrem->ItinerarioTrem->Movimentos->remove(i);
          }
        }
      }

      // limpar listas
      int index = getInstance()->TrensAlteracaoAtividade->IndexOf(pTrem->PID);
      if(index > 0)
      {
        getInstance()->TrensAlteracaoAtividade->remove(index);
      }
      pTrem->Atividades->clear();
      pTrem->AtividadesDel->clear();
      pTrem->AtividadesInsert->clear();
      pTrem->AtividadesUpdate->clear();

	}

	if (pTipoExcluscao != texRePlotar)
  {
    TTPFormsManager::getInstance()->RemoverSeriesPrefixoTransposicao(pTrem);

    if (pTrem->IsTransiente)
    {
      if (trens_->IndexOf(pTrem->PID) > -1)
        trens_->remove(pTrem->PID);
    }
  }
  }
// ---------------------------------------------------------------------------

void TTPFormsManager::SetDataGrafico(bool forcarAtualizarTPReal)
{
	dataGrafico_              = algorithm::CoreTMPlanner::getInstance()->getDataHoraBaseCalculo(forcarAtualizarTPReal).asDateTime();
	dataProgramacaoCongelada_ = dataGrafico_;

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTP->TP->Data      = dataGrafico_.DateString();
			t_FormTP->medData->Text = dataGrafico_.DateTimeString();

    }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::SetInicializarFinalizarPlanejamento(bool pInicializar, TForm* pOwner)
{
    bool lockMutex = false;
    bool isGraficoVisivel = false;
    try
    {
      String mensagem ;
      String acao = pInicializar ? "Incializar Planejamento": "Finalizar Planejamento";
      mensagem = acao +  " Tente novamente em alguns segundos ";
      this->tryLockMutexProc(60,mensagem,acao);

      lockMutex = true;
      gravarLog("acIniciarPlanejamentoExecute Mutex: lock");



      for (int i = 0; i < fomrsZonas_->Count; i++)
      {
        TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
        for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
        {
          TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
                isGraficoVisivel = t_FormTP->chrTTP->Visible;
                break;
              }
              if(isGraficoVisivel)
              {
                break;
              }
      }

        EnableDisableTeechart(false);
        Application->ProcessMessages();
        AjustarEstadoControles(false);

        if(!pInicializar)
        {

            if(!TTPFormsManager::getInstance()->VerificaShowIntrajornada())
            {
              FecharFormsAbertos();
            }
            Application->ProcessMessages();

            TTheadResultado *tResult = new TTheadResultado();

            boost:: thread threadProc(&this->ThreadFinalizarProgramacao, tResult);
            FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

            Aguarde("Finalizando planejamento");
            threadProc.join();

            FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;

            delete tResult;
            tResult = NULL;

        }
        else // Inicializar Planejamento
        {
            TTheadResultado *tResult = new TTheadResultado();

            boost:: thread threadProc(&this->ThreadIniciarProgramacao, tResult);

            Aguarde("Iniciando planejamento");
            threadProc.join();

            if (tResult->Status > 1)
            {
              TFormResultadoProcessos *fResultado = new TFormResultadoProcessos(pOwner, tResult->ListaResultados);
              fResultado->ShowModal();
            }
            FPlanoInicializado = TTPGerenteProgramacao::getInstance()->ProgramacaoEmCurso.isPlanoInicado;


            delete tResult;
            tResult = NULL;
        }

        for (int i = 0; i < fomrsZonas_->Count; i++)
        {
          TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
          for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
          {
            TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

          t_FormTP->FPlanoInicializado = pInicializar;
          t_FormTP->AjustarEstadoControleOficializar();
        }
      }
    }
    __finally
    {
      if(lockMutex)
      {
				gravarLog("acFinalizarPlanejamentoExecute Mutex: UNlock");
        MutexProc->unlock();
      }
      if (isGraficoVisivel)
      {
        EnableDisableTeechart(true);
      }
      AjustarEstadoControles(true);
    }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::FecharFormsAbertos()
{

  TTPFormsManager::getInstance()->gravarLog("Incio: FechaFormsAbertos()");

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTP->FechaFormsAbertos();

    }
  }

  if (formsAbertos_ == NULL)
  {
    formsAbertos_ = new TStringList();
    for (int i = 0; i < Screen->FormCount; i++)
    {
      TForm *t_form;
      formsAbertos_->AddObject("", (TObject *)Screen->Forms[i]);
    }
  }
  else
  {
    for (int i = 0; i < Screen->FormCount; i++)
    {
      if (formsAbertos_->IndexOfObject((TObject*)Screen->Forms[i]) < 0)
      {
				TForm *t_form       = Screen->Forms[i];

				t_form->ModalResult = mrCancel;
				if(t_form->Visible)
				{
					t_form->Close();
					t_form->Visible = false;
				}
        // delete t_form;
        // t_form = NULL;
      }
    }
  }

  TTPFormsManager::getInstance()->gravarLog("Fim: FechaFormsAbertos()");
}

// ---------------------------------------------------------------------------
void TTPFormsManager::WsFormsAbertos(TWindowState t_ws, TObject *formPrincipal)
{
  t_ws = (t_ws == wsMinimized) ? wsMinimized : wsNormal;

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    if (formPrincipal == fomrsZonas_->Objects[i])
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
        TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

        t_FormTP->WsFormsAbertos(t_ws);
      }
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::SincronizarTremClientServer(TTPTrem* pTremCliente)
{
  using namespace domain;
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_trens           = core->getTrensCalculados();

  String tPID = "";
  int idx = core->getMalha()->listaTrens->IndexOf(pTremCliente->PID);
  if (idx >= 0)
  tPID = pTremCliente->PID;

  TremMalha* pTremServer           = (TremMalha*)t_trens->Objects[t_trens->IndexOf(tPID)];
  #ifdef BAIXADA_SANTISTA
  pTremCliente->ISTremFila         = pTremServer->getFilaDemandaTerminal()!=NULL;
  pTremCliente->ISFilaAtiva        = pTremServer->getIsCalcularFilaDemandaTerminalAtivo();
  pTremCliente->ISCalculoFilaAtivo = pTremServer->getIsCalcularFilaDemandaTerminalAtivoUsuario();
  #else
  pTremCliente->ISFilaAtiva        = pTremServer->isFilaAtiva();
  pTremCliente->ISCalculoFilaAtivo = pTremServer->getCalculoFilaAtivo();
  pTremCliente->ISCalculoVelocidadeAtivo = pTremServer->getCalculoVelocidadeAtivo();
  #endif
  pTremCliente->DataNecessidadePorto = pTremServer->dtNCSDPorto.asDateTime();
	int i                            = 0;

	if(pTremServer->getUltimaOficializacaoPlanejamento()!=NULL)
		pTremCliente->PIDRotaOfzl        = pTremServer->getUltimaOficializacaoPlanejamento()->PID;

  if (!pTremCliente->ItinerarioTrem.isNull() && !pTremCliente->ItinerarioTrem->Movimentos.isNull() && pTremCliente->ItinerarioTrem->Movimentos->count() > 0)
  {
		TTPMovimento* tMovimentoNegocio = &*pTremCliente->ItinerarioTrem->Movimentos->operator[](0);

		// Seta nos cliente os valores dos movimento do Server
    String tNovaSB = "";
		while (tMovimentoNegocio)
    {
      // bug
      // um movimento esta apontado pra si mesmo como posterior e anterior
      // gerando um loop infinito
      // pra passar estou forando pegar o proximo movimento nesses casos
			i++;
			if (tMovimentoNegocio->ServerSegTremPlanejado != NULL)
      {
				tNovaSB = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
        if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
        {
          tMovimentoNegocio->SB->RemoverOcupacaoSB(tMovimentoNegocio->Trem->PID + tMovimentoNegocio->PID);
          tMovimentoNegocio->SB = sbs_->get(tNovaSB);
        }

        tMovimentoNegocio->IsCancelarOcupacao = tMovimentoNegocio->ServerSegTremPlanejado->isCancelarOcupacaoViaCadastroSegmento();

				if (tMovimentoNegocio->MovimentoPosterior != NULL)
        {
          tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
          tNovaSB           = tMovimentoNegocio->ServerSegTremPlanejado->getSB()->sb;
          if (tMovimentoNegocio->SB->NomeVia != tNovaSB)
          {
            tMovimentoNegocio->SB->RemoverOcupacaoSB(tMovimentoNegocio->Trem->PID + tMovimentoNegocio->PID);
            tMovimentoNegocio->SB = sbs_->get(tNovaSB);
          }
          tMovimentoNegocio = tMovimentoNegocio->MovimentoAnterior;
        }
      }

      // bug
      // um movimento esta apontado pra si mesmo como posterior e anterior
      // gerando um loop infinito
      // pra passar estou forando pegar o proximo movimento nesses casos
      if (tMovimentoNegocio != tMovimentoNegocio->MovimentoPosterior)
      {
				tMovimentoNegocio = tMovimentoNegocio->MovimentoPosterior;
      }
      else
      {
        if (i < pTremCliente->ItinerarioTrem->Movimentos->count())
          tMovimentoNegocio = &*pTremCliente->ItinerarioTrem->Movimentos->operator[](i);
        else
          break;
      }
    }

  }

	SincronizarAtividadesTremClienteServer(pTremCliente);
}
// ---------------------------------------------------------------------------
void TTPFormsManager::SincronizarTodosTrensClientServer()
{

  using namespace domain;
  for(int i = 0; i< algorithm::CoreTMPlanner::getInstance()->getMalha()->listaTrens->Count; i++)
  {
    String pidTrem = ((TremMalha*)algorithm::CoreTMPlanner::getInstance()->getMalha()->listaTrens->Objects[i])->PID;

    TTPTrem* tTrem = &*trens_->get(pidTrem);
    SincronizarTremClientServer(tTrem);
  }
}
// ---------------------------------------------------------------------------
void TTPFormsManager::SincronizarAtividadesTremClienteServer(TTPTrem* pTremCliente, domain::TremMalha* pTremServer)
{
  using namespace domain;

  TremMalha* pTremCalc = NULL;
  TTPTrem* tremClient  = pTremCliente;
  TTPAtividadeListPtr atividadesTemp = new TTPAtividadeList();

  if(pTremServer != NULL)
  {
    pTremCalc = pTremServer;
  }
  else
  {
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_trens           = core->getTrensCalculados();

  MalhaFerroviaria* tmalha = core->getMalha();

  String tPID = "";
  int idx = core->getMalha()->listaTrens->IndexOf(pTremCliente->PID);
  if (idx >= 0)
    tPID = pTremCliente->PID;

    pTremCalc = (TremMalha*)t_trens->Objects[t_trens->IndexOf(tPID)]; ;
  }

  if (pTremCalc != NULL && !tremClient->IsSuprimido)
  {
    // --- Criar Atividades Trem -----//
    if (pTremCalc->listaAtividades->Count > 0)
    {
      if (tiposAtividade_->count() == 0)
        CarregarTiposAtividade();

      for (int i = 0; i < pTremCalc->listaAtividades->Count; i++)
      {

        AtividadePlanejamento* atvd = (AtividadePlanejamento*)pTremCalc->listaAtividades->Objects[i];

        if (atvd->isAtividadeAtiva() && atvd->segmentoTremPlanejado != NULL)
        {
          TTPAtividadePtr atividade = new TTPAtividade();
          atividade->PID            = atvd->PID;
					atividade->AtividadeServer = atvd;

					int indexAtvdClient = -1;

					if(!VerificaShowVisualizador())
						tremClient->Atividades->IndexOf(atividade->PID);

          if(indexAtvdClient!=-1)
          {
            TTPAtividadePtr atividadeClientOld = tremClient->Atividades->operator [](indexAtvdClient);
            atividade->PIDPersistente = atividadeClientOld->PIDPersistente;
          }

          String dataFimAtividade   = "";
          String dataFimFila        = "";
		  if(!atvd->tipoAtividade)
		  {
			gravarLog("Tipo Atividade Nulo: " + atvd->PID);
			continue;
		  }
		  TTPTipoAtividadePtr tipo = tiposAtividade_->get(atvd->tipoAtividade->PID);
		  atividade->Tipo          = new TTPTipoAtividade(tipo);
          atividade->Descricao     = atvd->descricao;
          atividade->DataInicio    = (atvd->dataHoraMinimaChegada.is_not_a_date_time() ? NULL :
            atvd->dataHoraMinimaChegada.asDateTime());
          atividade->ISFiltaAtiva          = atvd->isFilaAtiva();
          atividade->FilaModificadaUsuario = atvd->getFilaModificadaUsuario();
          atividade->ISMeta                = atvd->isMeta;

					atividade->CodigoAlertaGrafico   = atvd->codigoAlertaGrafico;
          atividade->Origem   = atvd->origem;

					atividade->ISEquipagem   = atvd->isAtividadeEquipagem;
					atividade->CaudaLogica   = atvd->cpCaudaLogicaTrem;

          if(!tremClient->PossuiAtividadeMetaGrade && atividade->ISMeta)
              tremClient->PossuiAtividadeMetaGrade = true;

          atividade->ISValidarDataMinimaChegadaAtivo = atvd->getIsDataMinimaChegadaAtivo();
          atividade->ISValidarDataMaximaSaidaAtivo   = atvd->getIsDataMaximaSaidaAtivo();

          // atividade->DataFim    = (atvd->dataHoraFim.is_not_a_date_time() ? NULL : atvd->dataHoraFim.asDateTime());
          if (!atvd->dataHoraFim.is_not_a_date_time())
          {
            dataFimAtividade   = atvd->dataHoraFim.asDateTime().DateTimeString();
            atividade->DataFim = StrToDateTime(dataFimAtividade);
          }

          if (!atvd->dataHoraFimFila.is_not_a_date_time() && atividade->ISFiltaAtiva)
          {
            dataFimFila            = atvd->dataHoraFimFila.asDateTime().DateTimeString();
            atividade->DataFimFila = StrToDateTime(dataFimFila);
          }
           if (!atvd->getDataHoraFimNecessidadeTerminal().is_not_a_date_time() )
          {
            String dataFimNecessidade            = atvd->getDataHoraFimNecessidadeTerminal() .asDateTime().DateTimeString();
            atividade->DataHoraFimNecessidadeTerminal = StrToDateTime(dataFimNecessidade);
          }



          if (!atvd->dataHoraMinimaChegada.is_not_a_date_time())
          {
            String dataHoraMinimaChegada            = atvd->dataHoraMinimaChegada.asDateTime().DateTimeString();
            atividade->DataHoraMinimaChegada = StrToDateTime(dataHoraMinimaChegada);
          }

          if (!atvd->dataHoraMinimaSaida.is_not_a_date_time())
          {
            String dataHoraMinimaSaida            = atvd->dataHoraMinimaSaida.asDateTime().DateTimeString();
            atividade->DataHoraMinimaSaida = StrToDateTime(dataHoraMinimaSaida);
          }

					if (!atvd->dataHoraMaximaSaida.is_not_a_date_time())
          {
            String dataHoraMaximaSaida            = atvd->dataHoraMaximaSaida.asDateTime().DateTimeString();
            atividade->DataHoraMaximaSaida = StrToDateTime(dataHoraMaximaSaida);
					}

					if (!atvd->dataHoraSaidaGrade.is_not_a_date_time())
					{
						String dataHoraSaidaGrade            = atvd->dataHoraSaidaGrade.asDateTime().DateTimeString();
						atividade->DataHoraSaidaGrade = StrToDateTime(dataHoraSaidaGrade);
					}

					if(tremClient->Atividades->IndexOf(atividade->PID)>-1)
          {
            TTPAtividadePtr pAtvidadeBkpIndGrade = pTremCliente->Atividades->operator[](tremClient->Atividades->IndexOf(atividade->PID));

            atividade->ISReativarValidarDataMaximaSaidaAtivo = pAtvidadeBkpIndGrade->ISReativarValidarDataMaximaSaidaAtivo;
            atividade->ISAlterandoDatasAtividades = pAtvidadeBkpIndGrade->ISAlterandoDatasAtividades ;
          }

          for(int j = 0; j < atvd->listaSegmentosExecucao->Count; j++)
          {
            atividade->SegmentosAtividade->Add(((domain::Segmento*)atvd->listaSegmentosExecucao->Objects[j])->segmento);
          }

          if (atvd->patioPreferencial != NULL)
          {
            atividade->TipoAtividadeAlgoritmo = etaPatio;
          }
					else if(atvd->isAtividadeSB())
          {
						atividade->TipoAtividadeAlgoritmo = etaSB;
          }
          else
          {
            atividade->TipoAtividadeAlgoritmo = etaSegmento;
          }

					atividade->Duracao = (atvd->duracao.total_seconds() / 60);
					if(!atvd->duracaoPercursoTrem.is_not_a_date_time())
						atividade->DuracaoPercurso = (atvd->duracaoPercursoTrem.total_seconds() /60);
					else
						atividade->DuracaoPercurso = 0;

          if (atvd->recursoCompatilhado && !atvd->duracaoUtilizacaoRecursoCompartilhado.is_special())
            atividade->DuracaoUtilizacaoRecurso = (atvd->duracaoUtilizacaoRecursoCompartilhado.total_seconds() /60);
          else
            atividade->DuracaoUtilizacaoRecurso = 0;


          atividade->Trem     = &*tremClient;
					atividade->ListaPID = atvd->pidList;

						if (atvd->segmentoTremPlanejado && atvd->segmentoTremPlanejado->getSB() != NULL)
            {
              String segmento = "";
              if (atvd->segmentoTremPlanejado->getSB()->segmento != NULL)
              {
                segmento = atvd->segmentoTremPlanejado->getSB()->segmento->segmento;
              }
						if (atvd->isAtividadeSB())
            {
							TStringList* listaSbsServer = atvd->listaSBExecucao;
              for (int i = 0; i < listaSbsServer->Count; i++)
              {
                SB* sb = (SB*) listaSbsServer->Objects[i];
								TTPSBPtr sbCliente =  sbs_->get(sb->sb) ;
								atividade->SBs->add(sbCliente);
              }
							atividade->CodigoSegmento = segmento;
						}

            String nomeSB = atvd->segmentoTremPlanejado->getSB()->sb;
						atividade->SBAtual = sbs_->get(nomeSB);
          }


          //Verificar o operator da lista SB
          //if (atividade->SBs->count() > 0)
          {
						if (atvd->patioPreferencial != NULL)
							atividade->IDPatio = atvd->patioPreferencial->PID;
            else
            {
              atividade->IDPatio = algorithm::CoreTMPlanner::getInstance()->getPIDPatioBySigla(atividade->SBAtual->CodigoSegmento.SubString(1, 3));

              if (atividade->IDPatio == "" && atividade->SBAtual->SBServer && atividade->SBAtual->SBServer->segmento
                && atividade->SBAtual->SBServer->segmento->patioPertencente)
              {
                 atividade->IDPatio = atividade->SBAtual->SBServer->segmento->patioPertencente->PID;
              }
              if (atividade->IDPatio == "")
                atividade->IDPatio = TDAO::getPIDPatioByCodigoSegmento(atividade->SBAtual->CodigoSegmento);
              if (atividade->IDPatio == "")
              atividade->IDPatio = GetPIDPAtioMaisProximo(atividade);
            }
            atividade->ICAgrupExSimultanea  = "2";
            atividade->ICModificaComposicao = "F";

            atividadesTemp->add(atvd->indexRotaTrem, atividade);
          }
        }
      }
    }
    tremClient->Atividades->clear();
    if (atividadesTemp->count() > 0)
    {
      atividadesTemp->setSorted(true);
      for (int i = 0; i < atividadesTemp->count(); i++)
      {
        TTPAtividadePtr tAtividade = atividadesTemp->get(i);
        if (tremClient->Atividades->IndexOf(tAtividade->PID) == -1  || VerificaShowVisualizador() )
          tremClient->Atividades->add(tAtividade->PID, tAtividade);
      }
    }
  }

  // --- Criar Atividades Trem -----//
  // CriarCopiaTrem(tremClient);

}

String TTPFormsManager::GetPIDPAtioMaisProximo(TTPAtividadePtr atvd)
{
  using namespace domain;
  String PIDPatioProximo="PATIO0000000000";
  if (!atvd.isNull())
  {
    if (atvd->AtividadeServer && atvd->AtividadeServer->segmentoTremPlanejado )
    {
      SegmentoTrem* segAtual = atvd->AtividadeServer->segmentoTremPlanejado;
      SegmentoTrem* segBusca = segAtual;
      // verificar o patio anterior
      while (segBusca)
      {
        if (segBusca->segmentoOcupado->patioPertencente)
        {
         PIDPatioProximo =   segBusca->segmentoOcupado->patioPertencente->PID;
         break;
        }
        segBusca =segBusca->segmentoTremAnterior;
      }
      if (!segBusca)
      {
        segBusca = segAtual;
        while (segBusca)
        {
          if (segBusca->segmentoOcupado->patioPertencente)
          {
           PIDPatioProximo =   segBusca->segmentoOcupado->patioPertencente->PID;
           break;
          }
          segBusca =segBusca->segmentoTremPosterior;
        }
      }

    }
  }
  return PIDPatioProximo;
}
// ---------------------------------------------------------------------------
void TTPFormsManager::ManterIndicadoresAderenciaFila()
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();
  if (!FParametros.DesativarCalculoFilas)
  {
    for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
    {
      TTPTremPtr trem          = TTPFormsManager::getInstance()->Trens->operator[](i);
      int indexUltimoMovimento = trem->ItinerarioTrem->Movimentos->count() - 1;
      if (indexUltimoMovimento > 0)
      {
        TTPMovimentoPtr ultimoMovimento = trem->ItinerarioTrem->Movimentos->operator[](indexUltimoMovimento);
        TDateTime dataAderencia         = ultimoMovimento->CalcularDataAderenciaFila();
      }
    }
  }
}
// ---------------------------------------------------------------------------

void TTPFormsManager::LimparIndicadoresAderenciaFila()
{
  trensAderenciaFila_->Clear();
}

// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarEstadoControleSinalizadorInconsistenciaFila(bool pHabilitar)
{
  if (trensAderenciaFila_->Count)
  {
    for (int i = 0; i < fomrsZonas_->Count; i++)
    {
      TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
        TFormTP *t_FormTP      = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
        TActionListState state = t_FormTP->al->State;
        t_FormTP->al->State    = asNormal;

        t_FormTP->AjustarEstadoControleSinalizadorInconsistenciaFila(pHabilitar);

        t_FormTP->al->State = state;
      }
    }
  }
}

// ---------------------------------------------------------------------------
TStringList* TTPFormsManager::ValidarTrensFila()
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();
  TStringList *t_OrdemTrens      = new TStringList();
  TStringList *t_filasErro       = new TStringList();

  for (int i = 0; i < t_filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    // domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];

    // if (t_segmento->codZonaControleResponsavel == Mesa)
    {
      if (t_filaMalha->isAtiva() && t_filaMalha->getTipoOrdenacao() == domain::FilaMalha::TipoOrdenacaoFila::ORDEM_EXTN)
      {
        for (int j = 0; j < t_filaMalha->trensFila->Count; j++)
        {
          domain::TremMalha* tremMalha = (domain::TremMalha*)t_filaMalha->trensFila->Objects[j];
          double tOrdem                = tremMalha->getOrdemFila().asDateTime();
          if (tOrdem < 1 && tremMalha->isFilaAtiva())
          {
            t_filasErro->AddObject(t_filaMalha->PID, (TObject*)t_filaMalha);
            break;
          }
          else
          {
            if (t_OrdemTrens->IndexOf(tOrdem) > -1 && tremMalha->isFilaAtiva())
            {
              t_filasErro->AddObject(t_filaMalha->PID, (TObject*)t_filaMalha);
              break;
            }
            else if (tremMalha->isFilaAtiva())
            {
              t_OrdemTrens->Add(tOrdem);
            }
          }
        } // for trens

        t_OrdemTrens->Clear();
      } // isAtiva
    } // ifMesa
  } // for filas

  return t_filasErro;
}

// ---------------------------------------------------------------------------
int __fastcall SortPorOrdemFila(TStringList* List, int Index1, int Index2)
{

  SegmentoTrem *segmentoTrem1 = ((domain::TremMalha*)List->Objects[Index1])->getUltimoMovimento();
  SegmentoTrem *segmentoTrem2 = ((domain::TremMalha*)List->Objects[Index2])->getUltimoMovimento();

  return ((domain::TremMalha*)List->Objects[Index1])->comparaOrdemFila(segmentoTrem2, segmentoTrem1);
}

// ---------------------------------------------------------------------------
int __fastcall SortPorDataChegadaUltimoPatio(TStringList* List, int Index1, int Index2)
{

  long double difTempo = (((domain::TremMalha*)List->Objects[Index2])->getUltimoMovimento()->getDataChegadaNoUltimoPatio
    ().asDateTime() - ((domain::TremMalha*)List->Objects[Index1])->getUltimoMovimento()->getDataChegadaNoUltimoPatio()
    .asDateTime());
  if (difTempo < 0)
  {
    return 1;
  }
	else if (difTempo > 0.00001)
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::ValidarOrdemEntregaTrensFila(String pFila)
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_filas           = core->getFilas();

  TStringList *t_trensOrdem       = new TStringList();
  TStringList *t_trensDataChegada = new TStringList();

  for (int i = 0; i < t_filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)t_filas->Objects[i];
    domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
    t_trensOrdem->Clear();
    t_trensDataChegada->Clear();

    if (t_filaMalha->isAtiva() && (pFila.Length() == 0 || pFila == t_filaMalha->getPatioDestino()->sigla)
      && t_segmento->codZonaControleResponsavel == Mesa)
    {
      // if (t_filaMalha->getTipoOrdenacao() == domain::FilaMalha::TipoOrdenacaoFila::ORDEM_EXTN)
      {
        for (int j = 0; j < t_filaMalha->trensFila->Count; j++)
        {
          domain::TremMalha* tremMalha = (domain::TremMalha*)t_filaMalha->trensFila->Objects[j];
          if (!tremMalha->isFilaAtiva())
            continue;
          t_trensOrdem->AddObject("", (TObject*)tremMalha);
          t_trensDataChegada->AddObject("", (TObject*)tremMalha);
        } // for trens

        t_trensOrdem->CustomSort(SortPorOrdemFila);
        t_trensDataChegada->CustomSort(SortPorDataChegadaUltimoPatio);

        for (int j = 0; j < t_trensOrdem->Count; j++)
        {
          domain::TremMalha* tremMalhaOrdem = (domain::TremMalha*)t_trensOrdem->Objects[j];
          domain::TremMalha* tremMalhaData  = (domain::TremMalha*)t_trensDataChegada->Objects[j];
          if (tremMalhaOrdem->PID != tremMalhaData->PID)
          {
            // Marcar trens como fora de ordem
            if (trens_->IndexOf(tremMalhaOrdem->PID) > -1)
            {
							// if (tremMalhaOrdem->getUltimoMovimento()->getDataHoraFimParadaTrem() < DataLimiteGrafico)
              {
                trens_->get(tremMalhaOrdem->PID)->IsForaOrdemFila = true;
                trensForaOrdemFila_->Add(tremMalhaOrdem->filaTrem->getPatioDestino()->sigla + " | " +
                  tremMalhaOrdem->prefixoTrem);
              }
            }
            if (trens_->IndexOf(tremMalhaData->PID) > -1)
            {
							// if (tremMalhaData->getUltimoMovimento()->getDataHoraFimParadaTrem() < DataLimiteGrafico)
              {
                trens_->get(tremMalhaData->PID)->IsForaOrdemFila = true;
                trensForaOrdemFila_->Add(tremMalhaData->filaTrem->getPatioDestino()->sigla + " | " +
                  tremMalhaData->prefixoTrem);
              }
            }
          }
          else
          {
            if (trens_->IndexOf(tremMalhaOrdem->PID) > -1)
            {
              trens_->get(tremMalhaOrdem->PID)->IsForaOrdemFila = false;
							int indexOf = trensForaOrdemFila_->IndexOf(tremMalhaOrdem->filaTrem->getPatioDestino()->sigla + " | " +
                tremMalhaOrdem->prefixoTrem);
              if (indexOf > -1)
                trensForaOrdemFila_->Delete(indexOf);
            }
          }
        }
      } // isAtiva
    } // ifMesa
  }
  delete t_trensOrdem;
  delete t_trensDataChegada;
}

// ---------------------------------------------------------------------------
bool TTPFormsManager::getAmbienteDebug()
{

  String debug = std::getenv("GURU");

  if (debug == "DESENVOLVIMENTO")
   return true;
  else
    return false;

}

// ---------------------------------------------------------------------------
bool TTPFormsManager::setFocus(String pStrBusca, TTPMovimento* pMovimento, bool pShowComparadorPlanos, bool pShowAtividadesAlteradas, bool ScroolTo)
{
  if (!pMovimento)
    return false;

  if (!pMovimento->Serie)
    return false;

  if (!pMovimento->Serie->ParentChart)
    return false;

	if (!pMovimento->Serie->ParentChart->Parent)
    return false;

  TWinControl* p = pMovimento->Serie->ParentChart->Parent;
  ClearEdtPesquisar();
  while (p->Parent)
  {
    p = p->Parent;

    p->SetFocus();

  }
  TFormTP *t_FormTP = (TFormTP*)p;
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      // Application->ProcessMessages();
      TFormTP *t_FormTPAux = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      if (t_FormTP == t_FormTPAux)
      {
//          for (int k = 0; k < fomrsZonas_->Count; k++)
//          {
//            TFormPrincipal *t_formPrincipalAux = (TFormPrincipal*)fomrsZonas_->Objects[k];
//            t_formPrincipalAux->pcChange(0);
//          }
        if(ScroolTo)
        {
        t_FormTP->al->State = asNormal;


        t_FormTP->edtPesquisar->Text = pStrBusca=="" ? pMovimento->Trem->Prefixo : pStrBusca;

        t_formPrincipal->pc->ActivePage = (TFormTabSheet*)t_FormTP;
        t_FormTP->Show();
        t_formPrincipal->pc->TabIndex = x;
        t_formPrincipal->pcChange(0);

        if(pShowComparadorPlanos)
        {
        t_FormTP->acAlertaEntrePlanosExecute(t_FormTP);
        }
        if(pShowAtividadesAlteradas)
        {
          t_FormTP->acAtividadesAlteradasExecute(t_FormTP);
        }

        if (t_FormTP->ISZoomed)
         pMovimento->Serie->ParentChart->UndoZoom();

        pMovimento->Serie->Movimento = pMovimento;
        t_FormTP->ExecutouResetPosicao = false;

        bool disableEnableChart = t_FormTP->chrTTP->Enabled;

        if(disableEnableChart)
          t_FormTP->EnableDisableChart(false);


        t_FormTP->ScrollTo(pMovimento->Serie);

        if(disableEnableChart)
          t_FormTP->EnableDisableChart(true);
        }
        else
        {
          pMovimento->Serie->Movimento = pMovimento;
          pMovimento->Serie->SetMovimentoSelecionado(true);
          t_FormTP->SerieMovimentoSelecionada = pMovimento->Serie;
        }


        return true;

      }
    }
  }

  return true;
}

bool TTPFormsManager::setFocus(TTPRestricaoPtr pRestricao)
{
  if (pRestricao.isNull())
    return false;

  if (!pRestricao->Serie)
    return false;

  if (!pRestricao->Serie->ParentChart)
    return false;

	if (!pRestricao->Serie->ParentChart->Parent)
    return false;

  TWinControl* p = pRestricao->Serie->ParentChart->Parent;
  while (p->Parent)
  {
    p = p->Parent;
    p->SetFocus();
  }

  TFormTP *t_FormTP = (TFormTP*)p;
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      // Application->ProcessMessages();
      TFormTP *t_FormTPAux = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

      if (t_FormTP == t_FormTPAux)
      {
        t_FormTP->al->State = asNormal;

        t_formPrincipal->pc->ActivePage = (TFormTabSheet*)t_FormTP;
        t_FormTP->Show();
        t_formPrincipal->pc->TabIndex = x;
        t_formPrincipal->pcChange(0);

        if (t_FormTP->ISZoomed)
         pRestricao->Serie->ParentChart->UndoZoom();

        t_FormTP->ExecutouResetPosicao = false;

        bool disableEnableChart = t_FormTP->chrTTP->Enabled;

        if(disableEnableChart)
          t_FormTP->EnableDisableChart(false);

        if(disableEnableChart)
          t_FormTP->EnableDisableChart(true);


        return true;

      }
    }
  }

  return true;
}

TTPTrem* TTPFormsManager::getTremFilho(TTPTrem* pTrem)
{
  try
  {
    using namespace domain;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TStringList *t_trens = core->getTrensCalculados();
    int indexOf          = t_trens->IndexOf(pTrem->PID);
    if (indexOf > -1)
    {
      TremMalha* tremMalha = (TremMalha*)t_trens->Objects[indexOf];

      if (tremMalha->tremFilho)
      {
        if (trens_->IndexOf(tremMalha->tremFilho->PID) > -1)
        {
          TTPTrem* tTrem = &*trens_->get(tremMalha->tremFilho->PID);
          return tTrem;
        }
      }
    }
    return NULL;
  }
  catch (Exception &e)
  {
    throw;
  }
  catch (...)
  {
    throw Exception("Erro ao getTremFilho");
  }
}

TDateTime TTPFormsManager::getDataHoraPrimeiroMovimentoTremFilhoSrv(TTPTrem* pTrem)
{
  try
  {
    using namespace domain;
    algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

    TStringList *t_trens = core->getTrensCalculados();
    int indexOf          = t_trens->IndexOf(pTrem->PID);
    TremMalha* tremMalha = (TremMalha*)t_trens->Objects[indexOf];
    if (tremMalha->tremFilho)
    {
      if (trens_->IndexOf(tremMalha->tremFilho->PID) > -1)
      {
        return tremMalha->tremFilho->getPrimeiroMovimento()->getDataHoraChegadaCabecaTrem();
      }
		}
    return TDateTime(0);
  }
  catch (Exception &e)
  {
    throw;
  }
  catch (...)
  {
    throw Exception("Erro ao getTremFilho");
  }
}

// ---------------------------------------------------------------------------
void TTPFormsManager::SetMovimentoTremSelecionado(TTPTrem* pTrem)
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP                   = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTP->SerieMovimentoSelecionada = NULL;
      if (pTrem)
      {
        for (int z = 0; z < pTrem->ItinerarioTrem->Movimentos->count(); z++)
        {
          TTPMovimentoSeries* tMovimento = pTrem->ItinerarioTrem->Movimentos->operator[](z)->Serie;
					if (tMovimento != NULL && tMovimento->ParentChart == t_FormTP->chrTTP &&
							tMovimento->Movimento && !tMovimento->Movimento->IsRealizado)
          {
            t_FormTP->SerieMovimentoSelecionada = tMovimento;
            break;
          }
        }
      }
    }
  }
}

void TTPFormsManager::TesteQuantidadeDeSeries()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
      // t_FormTP->chrTTP->Canvas = new TGDIPlusCanvas();
      String err = "QUANTIDADE DE SERIES NO CHART: " + IntToStr(t_FormTP->chrTTP->SeriesCount()) + " " +
        t_FormTP->Caption;
      OutputDebugString(err.c_str());
    }
  }
}

TXStringList * TTPFormsManager::getZonasDebugMode()
{
  AnsiString tfiltro    = algorithm::CoreTMPlanner::getInstance()->FILTRO_RAMAIS_SNC;
  TXStringList * tZonas = new TXStringList();
  if (tfiltro != "")
  {
    tfiltro = "'" + tfiltro + "'";
    tfiltro = ReplaceStr(tfiltro, ",", "','");
    tZonas  = TDAO::getZonasByNomesRamais(tfiltro);
  }

  return tZonas;
}

String TTPFormsManager::getMesaByNomesRamais()
{
  AnsiString tfiltro = algorithm::CoreTMPlanner::getInstance()->FILTRO_RAMAIS_SNC;
  String tMesa       = "";
  if (tfiltro != "")
  {
    tfiltro = "'" + tfiltro + "'";
    tfiltro = ReplaceStr(tfiltro, ",", "','");
    tMesa   = TDAO::getMesaByNomesRamais(tfiltro);
  }

  return tMesa;
}

void TTPFormsManager::CarregarIconesAtividades(TComponent* Owner)
{
  try
  {
    this->tmrAtualizarOcializacao->Enabled = false;
    if (!IconesAtividades || IconesAtividades->Count <1)
    {
      TBitmap* bDef       = new TBitmap();

      TImageList *imgList = ((TFormPrincipal*)fomrsZonas_->Objects[0])->imglstIconesDef;

      bDef->Width         = imgList->Width;
      bDef->Height        = imgList->Height;

      imgList->GetBitmap(0, bDef);

      TDAO::carregarIconesAtividades(this->IconesAtividades, bDef);
      gravarLog("--> CarregarIconesAtividades <--");
    }
  }
  catch (Exception &e)
  {
    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
    throw;
  }
  catch (...)
  {

    if (!this->tmrAtualizarOcializacao->Enabled)
    {
      this->tmrAtualizarOcializacao->Enabled = true;
    }

    Screen->Cursor = crDefault;
    throw Exception("Erro ao CarregarIconesAtividades()");
  }

}

TPngImage* __fastcall TTPFormsManager::getIconeAtividade(String pPIDAtividade, String pStatusGrade)
{
  try
  {
	TPngImage* result = new TPngImage();

    if(IconesAtividades)
    {
      int index = IconesAtividades->IndexOf(pPIDAtividade + pStatusGrade);
      if (index > -1)
       {
		 result->Assign((TBitmap*) IconesAtividades->Objects[index]);
         return result;
       }
	}
	//se no achou icone usa o icone default pro status da atividade
    String n = NOME_ICONE_DEF;
    int index = IconesAtividades->IndexOf(n + pStatusGrade);
	  if (index > -1)
      {
		 result->Assign((TBitmap*) IconesAtividades->Objects[index]);
         return result;
	  }
    //se no achou usa o icone default geral
    index = IconesAtividades->IndexOf(n);
	  if (index > -1)
	  {
		 result->Assign((TBitmap*) IconesAtividades->Objects[index]);
		 return result;
      }

    return result;

  }
  catch (Exception& e)
  {

    try
    {
      std::wcout << "Erro carregarIconesAtividades - " << e.Message.c_str() << std::endl;
#ifdef MODO_DEBUG
      system("pause");
#endif
    }
    catch (...)
    {
    }
    return NULL;
  }
}

void __fastcall TTPFormsManager::MinimizeOtherCharts(TObject *Sender)
{
 for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    if(Sender != (TObject *)fomrsZonas_->Objects[i])
    {
     TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
     t_formPrincipal->MinimizeCharts();
    }
  }
}

void TTPFormsManager::AtualizarRestricoesDinamicas()
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_restricoes = core->getMalha()->restricoesMalha;

  int para1 = 0;

  for(int y = 0; y < restricoesDinamicas_->count(); y++)
  {
    TTPRestricaoPtr tRestricao = restricoesDinamicas_->get(y);
    int idxRestricao = t_restricoes->IndexOf(tRestricao->PID);
    if(idxRestricao > -1)
    {
      RestricaoSB* restricaoServer = (RestricaoSB*)t_restricoes->Objects[idxRestricao];

      TDateTime tDataInicio = restricaoServer->getInicioRestricao().asDateTime();
      tRestricao->DataInicioOriginal = tDataInicio;
      if (tDataInicio > dataInicioLimiteGrafico_)
        tRestricao->DataInicio = restricaoServer->getInicioRestricao().asDateTime();
      else
        tRestricao->DataInicio = dataInicioLimiteGrafico_;

      TDateTime tDataFim          = restricaoServer->getFimRestricao().asDateTime();
      tRestricao->DataFimOriginal = tDataFim;
			if (tDataFim < dataFimLimiteGrafico_)
        tRestricao->DataFim = tDataFim;
      else
				tRestricao->DataFim = dataFimLimiteGrafico_;
    }
  }

  int para2 = 0;

  for(int y = 0; y < restricoesDinamicas_->count(); y++)
  {
    bool atualizouRestricao = false;
    TTPRestricaoPtr tRestricao = restricoesDinamicas_->get(y);
    for (int i = 0; i < fomrsZonas_->Count; i++)
    {
      TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
				TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
        if(!tRestricao->GetSBFim(t_FormTP->Ramal->Nome).isNull()
            ||!tRestricao->GetSBFim(t_FormTP->Ramal->Nome).isNull())
        {
          t_FormTP->AtualizarRestricao(tRestricao);
          atualizouRestricao = true;
          break;
        }
      }
      if(atualizouRestricao)
        break;
    }
  }

	int para3 = 0;
}

void TTPFormsManager::SincronizarRestricaoClientServer(TTPRestricaoPtr &pRestricao)
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  TStringList *t_restricoes = core->getMalha()->restricoesMalha;
  int idxRestricao = t_restricoes->IndexOf(pRestricao->PID);
  if(idxRestricao > -1)
  {
    RestricaoSB* restricaoServer = (RestricaoSB*)t_restricoes->Objects[idxRestricao];

    pRestricao->RetencaoServer = restricaoServer;

    TDateTime tDataInicio = restricaoServer->getInicioRestricao().asDateTime();
    pRestricao->DataInicioOriginal = tDataInicio;
    if (tDataInicio > dataInicioLimiteGrafico_)
      pRestricao->DataInicio = restricaoServer->getInicioRestricao().asDateTime();
    else
      pRestricao->DataInicio = dataInicioLimiteGrafico_;

    TDateTime tDataFim          = restricaoServer->getFimRestricao().asDateTime();
    pRestricao->DataFimOriginal = tDataFim;
    if (tDataFim < dataFimLimiteGrafico_)
      pRestricao->DataFim = tDataFim;
    else
      pRestricao->DataFim = dataFimLimiteGrafico_;
  }
}

void TTPFormsManager::CarregarViewer()
{
	for (int i = 0; i < fomrsZonas_->Count; i++)
	{
		TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
		for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
		{
			TFormTV *t_FormTV  = (TFormTV*)t_formPrincipal->FormsRamais->Objects[x];
			t_FormTV->acCarregarExecute(0);
			return;
		}
	}
}


void TTPFormsManager::AddPrefixoTremFiltroViewer(String pPIDTrem)
{
	int indexOfTrem = trens_->IndexOf(pPIDTrem);
	if(indexOfTrem > -1)
	{
		TTPTrem* tTrem = &*trens_->get(pPIDTrem);
		for(int i = 0; i< tTrem->PrefixosOficializados->Count; i++ )
		{
		  filtroTrensViewer_->Add(tTrem->PrefixosOficializados->Names[i]);
		}
	}


	RefreshCharts();
}
// ---------------------------------------------------------------------------
void TTPFormsManager::RemovePrefixoTremFiltroViewer(String pPIDTrem)
{

	int indexOfTrem = trens_->IndexOf(pPIDTrem);
	if(indexOfTrem > -1)
	{
		TTPTrem* tTrem = &*trens_->get(pPIDTrem);
		for(int i = 0; i< tTrem->PrefixosOficializados->Count; i++ )
		{
			 int index = filtroTrensViewer_->IndexOf(tTrem->PrefixosOficializados->Names[i]);
			 if(index>-1)
					filtroTrensViewer_->Delete(index);
		}
	}


	RefreshCharts();
}
// ---------------------------------------------------------------------------
bool TTPFormsManager::ExibeTremFiltroViewer(String pPIDTrem)
{
	 if(filtroTrensViewer_->Count==0)
		return true;
	 else
		return  filtroTrensViewer_->IndexOf(pPIDTrem)>-1;


}
// ---------------------------------------------------------------------------
void TTPFormsManager::LimparFiltroViewer()
{
	filtroTrensViewer_->Clear();

	RefreshCharts();
}
// ---------------------------------------------------------------------------
int TTPFormsManager::CountTremFiltroViewer()
{
	return filtroTrensViewer_->Count;
}
// ---------------------------------------------------------------------------

void TTPFormsManager::RefreshCharts()
{
	if(chamouRefreshCharts_)
	 return;

	chamouRefreshCharts_ = true;

	for (int i = 0; i < fomrsZonas_->Count; i++)
	{
		TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
		for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
		{
			// Application->ProcessMessages();
			TFormTP *t_FormTP  = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

			t_FormTP->chrTTP->AutoRepaint = false;
      t_FormTP->RedrawAllMovimentoSeries();
			t_FormTP->chrTTP->AutoRepaint = true;
			if(VerificaShowVisualizador())
			{
				((TFormTV *)t_FormTP)->cbExibirRealizados->Checked = FParametros.ExibirRealizadosViewer;
				((TFormTV *)t_FormTP)->cbExibirRealizadosLinhaDoTempo->Enabled = FParametros.ExibirRealizadosViewer;
				((TFormTV *)t_FormTP)->cbExibirRealizadosLinhaDoTempo->Checked = FParametros.ExibirRealizadosViewerLinhaDoTempo;

				((TFormTV *)t_FormTP)->scbChartsResize(0);
				((TFormTV *)t_FormTP)->ScrollTo(NULL, 0);
			}
			else
				t_FormTP->pnlGraficoResize(0);

		}
	}
	chamouRefreshCharts_ = false;
}

void TTPFormsManager::ReordenarSeriesObservacao()
{
  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
			t_FormTP->ReordenarSeriesObservacao();
    }
  }
}

TDateTime TTPFormsManager::getDataLimiteGrafico()
{
	if(dataFimLimiteGrafico_ == TDateTime(0))
	{
		TimeTP dataLimiteJanela;
		dataLimiteJanela = dataGrafico_;
		dataLimiteJanela += addMinutes(-360);

		dataLimiteJanela = StrToDateTime(dataGrafico_.DateString() + " 23:59:59");
		dataLimiteJanela += addMinutes(1440);
		dataFimLimiteGrafico_ = dataLimiteJanela.asDateTime();
	}


	return  dataFimLimiteGrafico_;
}
// ---------------------------------------------------------------------------
TTPMovimentoSeries* TTPFormsManager::getMovimentosSerieMouseOver()
{
 EnterCriticalSection(&CriticalSectionSeries);
	if(movimentosSerieMouseOver_)
	{
		if (!movimentosSerieMouseOver_->Movimentos)
			movimentosSerieMouseOver_ = NULL;
			else if (!movimentosSerieMouseOver_->Movimento)
				movimentosSerieMouseOver_ = NULL;
				else if (!movimentosSerieMouseOver_->Movimento->SB)
					movimentosSerieMouseOver_ = NULL;
	}
   LeaveCriticalSection(&CriticalSectionSeries);
	return movimentosSerieMouseOver_;
}
// ---------------------------------------------------------------------------
void TTPFormsManager::setMovimentosSerieMouseOver(TTPMovimentoSeries* movimento)
{
  EnterCriticalSection(&CriticalSectionSeries);
    this->movimentosSerieMouseOver_ =        movimento;
  LeaveCriticalSection(&CriticalSectionSeries);
}
// ---------------------------------------------------------------------------
void TTPFormsManager::AjustarEstadoAcionarAutomatico(bool pOnOff)
{


  struct TLocalArgs
  {// processo para poder chamar via multhread

      bool pOnOff;
      void __fastcall AjustarEstadoAcionarAutomatico()
      {
        for (int i = 0; i < TTPFormsManager::getInstance()->FomrsZonas->Count; i++)
        {
          TFormPrincipal *t_formPrincipal = (TFormPrincipal*)TTPFormsManager::getInstance()->FomrsZonas->Objects[i];
          for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
          {
            TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
            t_FormTP->AjustarEstadoAcionarAutomatico(pOnOff);
          }
        }

      }
  };

  TLocalArgs Args;
  Args.pOnOff= pOnOff;
  TThread::Synchronize(NULL, &Args.AjustarEstadoAcionarAutomatico);

}

void TTPFormsManager::ThreadCarregarTrensMalhaComparacaoPlanos(TTheadResultado *&pResult)
{
  bool lockMutex = false;
  try
  {
    if (!this->tryLockMutexProc(60,"","Comparador de planos"))
      return;

    gravarLog("tryLockMutexProc Comaprador de Planos InicioProcessamento");
    isAguardeComparadorPlanos_ = true;
    lockMutex = true;

    AjustarEstadoAlertaEntrePlanos(false);
    gravarLog("AjustarEstadoAlertaEntrePlanos Comaprador de Planos OK");

    CarregarTrensMalhaComparacaoPlanos();
    gravarLog("CarregarTrensMalhaComparacaoPlanos Comaprador de Planos OK");

    CarregarListaComparacoes();
    gravarLog("CarregarListaComparacoes Comaprador de Planos OK");

    refreshComparacoes_ = true;
    isAguardeComparadorPlanos_ = false;
    MutexProc->unlock();
    gravarLog("unlock Comaprador de Planos Fim Processamento");
  }
  catch (Exception &e)
  {
		if(lockMutex)
			MutexProc->unlock();
		try
		{
			e.BaseException->Message = e.Message;
			pResult->Status = terErro;
		}
		catch (...)
		{
		}
    pResult->ListaResultados->Add(e.Message);

		gravarLog("unlock Comaprador de Planos Fim Processamento Exception " + e.Message);
  }
  catch (...)
  {
		if(lockMutex)
			MutexProc->unlock();
		pResult->Status = terErro;
    pResult->ListaResultados->Add("Erro no identificado");
		gravarLog("unlock Comaprador de Planos Fim Processamento Exception  Desconhecida");
  }
}

void TTPFormsManager::CarregarTrensMalhaComparacaoPlanos()
{
  gravarLog("getListaDatasOficializacoesComparacao");
	listaDatasComparacao_ = TDAO::getListaDatasOficializacoesComparacao();
		String datasComparacao = "";
		if(listaDatasComparacao_)
		{
			for(int i=0; i<listaDatasComparacao_->Count; i++)
			{
				datasComparacao+=DateTimeToStr(*((TDateTime *)listaDatasComparacao_->Objects[i]));
			}
		}
		 gravarLog("Limpeza da lista de alerta de comparacoes");
		stringDataUltimaOflzAutomatico_ = datasComparacao;

		algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

		while(listaAlertaComparacoes_->Count>0)
		{
			Comparacao *objeto = (Comparacao *)listaAlertaComparacoes_->Objects[0];
			listaAlertaComparacoes_->Delete(0);
			delete objeto; 
		}
    gravarLog("carregarTrensMalhaComparacao");
  listaAlertaComparacoes_ = core->carregarTrensMalhaComparacao(Now(), listaDatasComparacao_);

}
void TTPFormsManager::AjustarEstadoAlertaEntrePlanos(bool pOnOff)
{

 struct TLocalArgs
    {
        bool pOnOff;
        void __fastcall AjustarEstadoAlertaEntrePlanos()
        {
          if(! TTPFormsManager::getInstance()->VerificaShowVisualizador())
          {
            bool atualizouAlerta = false;
            for (int i = 0; i <  TTPFormsManager::getInstance()->FomrsZonas->Count; i++)
            {
              TFormPrincipal *t_formPrincipal = (TFormPrincipal*) TTPFormsManager::getInstance()->FomrsZonas->Objects[i];
              for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
              {
                TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];

                if(!atualizouAlerta && pOnOff)
                {
                  atualizouAlerta = true;
                  t_FormTP->AtualizarAlertaEntrePlanos();
                }

                t_FormTP->acAlertaEntrePlanos->ImageIndex = TTPFormsManager::getInstance()->IsAguardeComparadorPlanos?29: pOnOff? 24:25;
              }
            }
          }
        }
    };

    TLocalArgs Args;
    Args.pOnOff = pOnOff;
    TThread::Synchronize(NULL, &Args.AjustarEstadoAlertaEntrePlanos);

}

void TTPFormsManager::CarregarListaComparacoes()
{
	if(!listaAlertaComparacoesTTP_)
		listaAlertaComparacoesTTP_ = new TStringList();

	while(listaAlertaComparacoesTTP_->Count>0)
	{
		TTPComparacao *objeto = (TTPComparacao *)listaAlertaComparacoesTTP_->Objects[0];
		listaAlertaComparacoesTTP_->Delete(0);
		delete objeto;
	}

	if(listaAlertaComparacoes_)
	{
		for(int i=0; i<listaAlertaComparacoes_->Count;i++ )
		{
			if (((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->getSegmentoOcupado()->codZonaControleResponsavel == TTPFormsManager::getInstance()->Mesa)
			{
				TTPComparacao *comparacao = new TTPComparacao();
				//cdsGrid->Append();

				comparacao->DataOficializacao1 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->oficializacao->dataHoraBaseCarregamento.asDateTime();
				comparacao->DataOficializacao2 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao2->oficializacao->dataHoraBaseCarregamento.asDateTime();

				comparacao->PrefixoTrem =   ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->getTrem()->prefixoTrem;
				comparacao->PidTrem     =   ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->getTrem()->PID;
				comparacao->Local       =  listaAlertaComparacoes_->operator [](i);

				comparacao->DataChegada1 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->getDataHoraChegadaCabecaTrem();
				comparacao->DataChegada2 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao2->getDataHoraChegadaCabecaTrem();

				comparacao->DataSaida1 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao1->getDataHoraFimParadaTrem();
				comparacao->DataSaida2 = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->segmentoOficializacao2->getDataHoraFimParadaTrem();

				double tDuracao1 = (((double) comparacao->DataSaida1) - ((double) comparacao->DataChegada1))*24*60;
				double tDuracao2 = (((double) comparacao->DataSaida2) - ((double) comparacao->DataChegada2))*24*60;

				double duracaot =	abs(tDuracao2 - tDuracao1) ;
				comparacao->Duracao = 0;
				if(duracaot>1)
					comparacao->Duracao =  duracaot/24/60;


				comparacao->TipoComparacao = ((Comparacao*)listaAlertaComparacoes_->Objects[i])->indicadorTipoComparacao;

				if(comparacao->TipoComparacao == "C")
					comparacao->Desvio =  comparacao->DataChegada1 - comparacao->DataChegada2;
				else if(comparacao->TipoComparacao == "S")
					comparacao->Desvio = comparacao->DataSaida1 - comparacao->DataSaida2;

				listaAlertaComparacoesTTP_->AddObject("",(TObject *)comparacao);
			}
		}
	}
}

TDModuleMP* TTPFormsManager::getDataModule()
{
  if(!DModuleMP)
  {
//    DModuleMP = new TDModuleMP(formPrincipal_);
DModuleMP = TDModuleMP::getInstance(formPrincipal_);
  }
  return DModuleMP;
}

void TTPFormsManager::SetFocusTremSegmento(String pPIDtrem, String pSegmento, bool pShowComparadorPlanos, bool pShowAtividadesAlteradas)
{
  try
  {
   if (this->Trens != NULL)
    {
      TTPTremPtr tTrem = NULL;
      for (int x = 0; x < this->Trens->count() ; x++)
      {
        tTrem = this->Trens->get(x);
        if (tTrem->PID == pPIDtrem)
        {
          for (int i = 0; i < tTrem->ItinerarioTrem->Movimentos->count(); i++)
          {
            if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie)
            {
              if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->ParentChart)
              {
                 if(tTrem->ItinerarioTrem->Movimentos->operator[](i)->SB->CodigoSegmento == pSegmento)
                 {
                    if (this->Trens != NULL)
                    {
                      for (int j = 0; j < this->Trens->count(); j++)
                      {
                        TTPTremPtr t_TremRetirarSelecao = this->Trens->operator[](j);
                        if (t_TremRetirarSelecao->IsSelecionado)
                        {
                          for(int k = 0; k< t_TremRetirarSelecao->ItinerarioTrem->Movimentos->count(); k++)
                          if(t_TremRetirarSelecao->ItinerarioTrem->Movimentos->operator[](k)->Serie)
                          {
                           t_TremRetirarSelecao->ItinerarioTrem->Movimentos->operator[](k)->Serie->SetTremSelecionado(false);

                           break;
                          }
                        }
                      }
                    }


                    this->setFocus("",&*tTrem->ItinerarioTrem->Movimentos->operator[](i), pShowComparadorPlanos,pShowAtividadesAlteradas);
                    tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->SetTremSelecionado(true);
                    SetSerieMovimentoSelecionada(tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie);
                    ClearEdtPesquisar();
                    return;
                 }
              }
            }
          }
        }
      }
    }
  }
  catch (Exception &e)
  {
    throw Exception("Erro ao SetFocus()");
  }
}

void TTPFormsManager::SetSerieMovimentoSelecionada(TTPMovimentoSeries *Serie)
{
try
{
	for (int i = 0; i < fomrsZonas_->Count; i++)
	{
		TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
		for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
		{
			TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
			if(t_FormTP->chrTTP == Serie->ParentChart)
			{
				t_FormTP->SerieMovimentoSelecionada = Serie;
				t_formPrincipal->BringToFront();
				return;
			}
		}
	}
}
catch (Exception &e)
{
	throw Exception("Erro ao SetSerieMovimentoSelecionada()");
}
}


bool TTPFormsManager::getIsPrimeiroCarregamento()
{
  return isPrimeiroCarregamento;
}

void TTPFormsManager::ClearEdtPesquisar()
{
  try
  {
    for (int i = 0; i < fomrsZonas_->Count; i++)
    {
      TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
      for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
      {
        TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
        t_FormTP->edtPesquisar->Clear();
      }
    }
  }
  catch (Exception &e)
  {
    throw Exception("Erro ao ClearEdtPesquisar()");
  }
}


bool __fastcall TTPFormsManager::CheckGatilhoVazio()
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  if(!VerificaShowVisualizador())
  {
    using namespace domain;
    MalhaFerroviaria* t_malha      = core->getMalha();

    for (int i = 0; i < t_malha->listaGatilhosMalha->Count; i++)
    {
      GatilhoMalha *t_gatilhoMalha = (GatilhoMalha*)t_malha->listaGatilhosMalha->Objects[i];
      Segmento* segParada = t_gatilhoMalha->getSegmentoParada();

      if (segParada && !t_gatilhoMalha->getIsDesativadoUsuario() && segParada->patioPertencente &&
       (segParada->patioPertencente->sigla == "FBA" ||
       segParada->patioPertencente->sigla == "FOS" ||
       segParada->patioPertencente->sigla == "FBP"))
      {
        return false;
      }
    }
    return true;
  }
  else
  {
   return !core->getCadenciamentoVazioIsAtivoViewer();
  }
}

void __fastcall TTPFormsManager::PreencherResumoFilas()
{
  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  TStringList *filas = core->getFilas();

  resumoFilasAtivas_ ="";
  resumoFilasInativas_="";
  resumoFilasInativasExpiracao_ = "";

  String dataExpiracao = "", filasAtivaLocalAutomatico = "",  filasDesativadasLocalAutomatico = "",
  filasAtivasLocaisDesativadasAutomatico = "", filasDesativadasLocaisAtivasAutomatico = "";



  TDateTime dataComparacaoFilas = TDAO::getCurrentDate();

  if(ShowVisualizador && !VerificaShowIntrajornada())
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[0];
    TFormTV *t_FormTV = (TFormTV*)t_formPrincipal->FormsRamais->Objects[0];
    dataComparacaoFilas = StrToDateTime(t_FormTV->cbxDataOficializacaoFarolParametros->Text);
  }

  for (int i = 0; i < filas->Count; i++)
  {
    domain::FilaMalha *t_filaMalha = (domain::FilaMalha*)filas->Objects[i];
    domain::Segmento *t_segmento   = (domain::Segmento*)t_filaMalha->getPatioDestino()->segmentos->Objects[0];
    if (t_segmento->codZonaControleResponsavel == this->Mesa)
    {
      if(t_filaMalha->isAtiva()==true)
      {
        //this->FParametros.listaFilasAtivas->Add(t_filaMalha->getPatioDestino()->sigla);
        //resumoFilasAtivas_ +=t_filaMalha->getPatioDestino()->sigla", ";

        if (!t_filaMalha->dataExpiracao.is_not_a_date_time() &&  (t_filaMalha->dataExpiracao.asDateTime() > dataComparacaoFilas))
        {
           filasAtivasLocaisDesativadasAutomatico+= t_filaMalha->getPatioDestino()->sigla+", ";
           dataExpiracao = t_filaMalha->dataExpiracao.asDateTime().FormatString("dd/mm/yy hh:nn");
        }
        else
        {
           filasAtivaLocalAutomatico+= t_filaMalha->getPatioDestino()->sigla+", ";
        }
      }
      else
      {

        if (!t_filaMalha->dataExpiracao.is_not_a_date_time() &&  (t_filaMalha->dataExpiracao.asDateTime() > dataComparacaoFilas))
        {
          filasDesativadasLocalAutomatico+= t_filaMalha->getPatioDestino()->sigla+", ";
          dataExpiracao = t_filaMalha->dataExpiracao.asDateTime().FormatString("dd/mm/yy hh:nn");
        }
        else
        {
          filasDesativadasLocaisAtivasAutomatico+= t_filaMalha->getPatioDestino()->sigla+", ";
        }
      }
     }
    }
    int fim =2;
    String espacos = "     ";
    String txtInativacao = "\\b0\\b0 \n \\par "+espacos+"  e \\b Inativas no Automtico at \\b0\\b0\\cf2 "+dataExpiracao+" \\b0\\cf1\\par  ";

    if(filasDesativadasLocalAutomatico+filasAtivasLocaisDesativadasAutomatico+filasDesativadasLocaisAtivasAutomatico+filasAtivasLocaisDesativadasAutomatico=="")
    {
       resumoFilasAtivas_ += "Gesto de Filas";
    }
    else
    {
      if(filasAtivaLocalAutomatico!="")
        resumoFilasAtivas_ += "Filas Ativas em: \n \\par \\pard "+espacos+"- \\b "+filasAtivaLocalAutomatico.SubString(0,filasAtivaLocalAutomatico.Length()-fim)
                           + "\\b0\\b0 \n \\par "+espacos+" e no \\b Automtico \\b0 \\par ";
    }


    if(filasDesativadasLocaisAtivasAutomatico!="")
      resumoFilasInativas_ += "Filas Inativas em: \n \\par \\pard "+espacos+"- \\b "+filasDesativadasLocaisAtivasAutomatico.SubString(0,filasDesativadasLocaisAtivasAutomatico.Length()-fim)
                           + "\\b0\\b0 \n \\par "+espacos+" e \\b Ativas no Automtico \\b0 \\par ";

    if(filasDesativadasLocalAutomatico!="")
      resumoFilasInativasExpiracao_ += "@Filas Inativas em: \n \\par \\pard "+espacos+"- \\b "+filasDesativadasLocalAutomatico.SubString(0,filasDesativadasLocalAutomatico.Length()-fim)
                                    +txtInativacao;
      if(filasAtivasLocaisDesativadasAutomatico!="")
        resumoFilasInativasExpiracao_ += "@Filas Ativas em: \n \\par \\pard "+espacos+"- \\b "+filasAtivasLocaisDesativadasAutomatico.SubString(0,filasAtivasLocaisDesativadasAutomatico.Length()-fim)
                           +txtInativacao;
                                    //+ "\\b0\\b0 \n \\par "+espacos+"  e \\b Inativas no Automtico at \\b0\\b0 \n \\par\\cf2 "+espacos+""+dataExpiracao+" \\b0 \\cf1 \\par ";


}

void __fastcall TTPFormsManager::AtualizarStatusFarolParametros()
{


  struct TLocalArgs
    {// processo para poder chamar via multhread

        void __fastcall AtualizarStatusFarolParametros()
        {
          TTPFormsManager::getInstance()->PreencherResumoFilas();
          TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio = TTPFormsManager::getInstance()->CheckGatilhoVazio();
          algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

          bool parametrosAtivos =
              TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais ||
             !TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio || core->getIsCarregarOrdemGatilho() || TTPFormsManager::getInstance()->ResumoFilasAtivas!="";

          bool parametrosInativos =
             !TTPFormsManager::getInstance()->FParametros.UtilizarParametroOperacionalCapacidadeTerminais ||
              TTPFormsManager::getInstance()->FParametros.DesativarGatilhoCadenciamentoVazio || !core->getIsCarregarOrdemGatilho() ||  TTPFormsManager::getInstance()->ResumoFilasInativas!="";

          bool parametrosInativosTempo = TTPFormsManager::getInstance()->ResumoFilasInativasExpiracao!="";

          for (int i = 0; i < TTPFormsManager::getInstance()->FomrsZonas->Count; i++)
          {
            TFormPrincipal *t_formPrincipal = (TFormPrincipal*)TTPFormsManager::getInstance()->FomrsZonas->Objects[i];
            for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
            {
              TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
              t_FormTP->tbtAlerta1->Action = parametrosAtivos ?t_FormTP->acParametrosAtivos : t_FormTP->acParametrosVazio;
              t_FormTP->tbtAlerta2->Action = parametrosInativosTempo ?t_FormTP->acParametrosDesativadosTpExp : t_FormTP->acParametrosVazio;
              t_FormTP->tbtAlerta3->Action = parametrosInativos ?t_FormTP->acParametrosDesativados : t_FormTP->acParametrosVazio;
            }
          }
        }
    };

    TLocalArgs Args;

    TThread::Synchronize(NULL, &Args.AtualizarStatusFarolParametros);



}

void TTPFormsManager::CarregarConfiguracaoOficializacao(TDateTime pDataOficializacao)
{
  if(!ShowVisualizador)
    return;

  dataAtualParametrosOficializadosViewer_ =  pDataOficializacao;

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTV *t_FormTV = (TFormTV*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = NULL;

      t_FormTV->tbtAlerta1->Action = t_FormTV->acParametrosVazio;
      t_FormTV->tbtAlerta2->Action = t_FormTV->acParametrosVazio;
      t_FormTV->tbtAlerta3->Action = t_FormTV->acParametrosVazio;

      int index = t_FormTV->cbxDataOficializacaoFarolParametros->Properties->Items->IndexOf(pDataOficializacao.DateTimeString());
      t_FormTV->cbxDataOficializacaoFarolParametros->ItemIndex = index;
      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = t_FormTV->cbxDataOficializacaoFarolParametrosPropertiesChange;

    }
  }

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();

  core->carregarConfiguracoesOficializadasViewer(pDataOficializacao);

  this->FParametros.UtilizarParametroOperacionalCapacidadeTerminais = core->getUtilizarParamentroOperacionalCapacidadeTerminal();
  this->FParametros.DesativarGatilhoCadenciamentoVazio = !core->getCadenciamentoVazioIsAtivoViewer();

  this->Mesa = algorithm::CoreTMPlanner::getInstance()->getMesaControleViewer();

  if(this->Mesa!="")
    AtualizarStatusFarolParametros();


}

void TTPFormsManager::ClearDataOficializacaoFarolParametros ()
{
  if(!ShowVisualizador)
    return;

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTV *t_FormTV = (TFormTV*)t_formPrincipal->FormsRamais->Objects[x];

      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = NULL;
      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->Items->Clear();
      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = t_FormTV->cbxDataOficializacaoFarolParametrosPropertiesChange;
    }
  }
}

void TTPFormsManager::AddDataOficializacaoFarolParametros(String StringDataOficializacao, String IndicadorOrigemOflz)
{
   if(!ShowVisualizador)
    return;
  if(!listaOficializacoesViewer_)
  {
    listaOficializacoesViewer_ = new TStringList();
    listaOficializacoesViewer_->Duplicates = System::Types::dupIgnore;
  }
  listaOficializacoesViewer_->Add(StringDataOficializacao);

  for (int i = 0; i < fomrsZonas_->Count; i++)
  {
    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)fomrsZonas_->Objects[i];
    for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
    {
      TFormTV *t_FormTV = (TFormTV*)t_formPrincipal->FormsRamais->Objects[x];
      t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = NULL;

      if(VerificaShowIntrajornada())
      {
        if(t_FormTV->Ramal->IndicadorSistemaOrigemIntraJornada == IndicadorOrigemOflz)
        {
          t_FormTV->cbxDataOficializacaoFarolParametros->Properties->Items->Clear();
          t_FormTV->cbxDataOficializacaoFarolParametros->Properties->Items->Add(StringDataOficializacao);
        }
        t_FormTV->cbxDataOficializacaoFarolParametros->ItemIndex = 0;
      }
      else
      {
        t_FormTV->cbxDataOficializacaoFarolParametros->Properties->Items->Add(StringDataOficializacao);
        t_FormTV->cbxDataOficializacaoFarolParametros->ItemIndex = 0;
        t_FormTV->cbxDataOficializacaoFarolParametros->Properties->OnChange = t_FormTV->cbxDataOficializacaoFarolParametrosPropertiesChange;
      }
    }
  }
}

// ---------------------------------------------------------------------------
TStringList* TTPFormsManager::getListaOficializacoesViewer()
{
  return  listaOficializacoesViewer_;
}

// ---------------------------------------------------------------------------
void TTPFormsManager::RetirarSelecaoTrens()
{
  TTPTremPtr tTrem = NULL;
  if(!ShowVisualizador)
  {
    for (int x = 0; x < this->Trens->count() ; x++)
    {
      tTrem = this->Trens->get(x);
      for (int i = 0; i < tTrem->ItinerarioTrem->Movimentos->count(); i++)
      {
        if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->MovimentoSelecionado == true || tTrem->IsSelecionado == true)
        {
          if (tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie != NULL && tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->ParentChart)
          {
            tTrem->ItinerarioTrem->Movimentos->operator[](i)->Serie->SetTremSelecionado(false);
            break;
          }
        }
      }
    }
  }
  else
  {
    for (int x = 0; x < this->Trens->count(); x++)
    {
      tTrem = this->Trens->get(x);
      if (!tTrem->ItinerarioTrem.isNull())
      {
        for (int i = 1; i < tTrem->ItinerarioTrem->GetTotalRotas(); i++)
        {
          TTPMovimentoListPtr pRota = tTrem->ItinerarioTrem->getRota(i);
          if (!pRota.isNull() && pRota->count()>0 && pRota->operator[](0) && pRota->operator[](0)->ServerSegTremOficializado)
          {
            domain::SegmentoTremOficializado *segmentoTremOficializado = pRota->operator[](0)->ServerSegTremOficializado;
            if (segmentoTremOficializado)
            {
              for (int j = 0; j < pRota->count(); j++)
              {
                TTPMovimento* movimento = &*pRota->operator[](j);
                if (movimento->Serie && movimento->Serie->ParentChart && movimento->MovimentoSelecionado)
                {
                  movimento->Serie->SetTremSelecionado(false);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
}

void TTPFormsManager::SelecionarMovimento(TTPMovimento* pMovimento)
{
 if(!pMovimento || !pMovimento->Serie || !pMovimento->Serie->ParentChart)
 {
   int teste = 1;
   return;
 }

 TWinControl* p = pMovimento->Serie->ParentChart->Parent;
  //ClearEdtPesquisar();
  while (p->Parent)
  {
    p = p->Parent;

   // p->SetFocus();
  }
  TFormTP *t_FormTP = (TFormTP*)p;

  pMovimento->Serie->Movimento = pMovimento;
  pMovimento->Serie->SetMovimentoSelecionado(true);
  t_FormTP->SerieMovimentoSelecionada = pMovimento->Serie;
}

TStringList* TTPFormsManager::CarregarMenusDinamicos()
{

  if(!menusDinamicos_)
  {
    menusDinamicos_ = new TStringList();

    PtrQuery qrResult = TDAO::getConfAux("MN");
    if (!qrResult->Eof)
    {
      //TO-DO Fazer o loop pegando todos os menus configurados no BD
      String XMLConfig  = qrResult->FieldByName("DS_XML_CONF_AUXL")->AsString;

      pugi::xml_document doc;
      pugi::xml_parse_result result = doc.load_string(AnsiString(XMLConfig).c_str());

      pugi::xpath_node confAux  = doc.select_node("//confAux");
      pugi::xpath_node node;
      pugi::xpath_node_set menusDin = confAux.node().select_nodes("//menu");

      for (pugi::xpath_node_set::const_iterator it = menusDin.begin(); it != menusDin.end(); ++it)
      {
        node = *it;
        pugi::xml_node menu = node.node();

        String filtro = menu.child_value("filtroMesa");
        String mesaLogada = algorithm::CoreTMPlanner::getInstance()->getMesaControle();
        if(filtro.Length() == 0 ||
          (filtro.Length() != 0 && mesaLogada == filtro))
        {
          pugi::xml_node objeto = menu.child("objeto");
          String Classe         = objeto.child_value("classe");

          TTPMenuDinamico* menuDin = new TTPMenuDinamico();

          if(Classe == "TTPRestricao")
          {
            pugi::xml_node parametros = objeto.child("parametros");

            TTPMenuDinamico* menuDin = new TTPMenuDinamico();

            menuDin->Caption      = menu.child_value("caption");
            menuDin->FiltroMesa   = menu.child_value("filtroMesa");
            menuDin->SBInicio     = parametros.child_value("sbInicio");
            menuDin->SBFim        = parametros.child_value("sbFim");
            String tipoRestricao  = parametros.child_value("tipo");
            String ListaSB        = parametros.child_value("listaSB");
            String ListaConx      = parametros.child_value("listaConx");


            TTPRestricaoPtr rest = new TTPRestricao();
            TStringList* lstSB = new TStringList();
            TStringList* lstConx = new TStringList();
            lstConx->CommaText = ListaConx;

            if(tiposRestricao_->count() == 0)
              CarregarTiposRestricao();

            for (int i = 0; i < tiposRestricao_->count(); i++)
            {
              if (tiposRestricao_->get(i)->Codigo == tipoRestricao)
              {
                rest->Tipo = tiposRestricao_->get(i);
                break;
              }
            }

            lstSB->CommaText = ListaSB;
            for (int i=0; i< lstSB->Count; i++)
            {
              TTPSBPtr sb = sbs_->get(lstSB->Strings[i]);
              rest->SBsRestricao->add(sb->NomeVia, sb);

              for (int j=0; j < sb->SBServer->listaConexaoSB->Count; j++)
              {
                domain::ConexaoSB* con = (domain::ConexaoSB*) sb->SBServer->listaConexaoSB->Objects[j];
                String descCon = con->sbOrigem->sb + "=>" + con->sb->sb;

                if(lstConx->IndexOf(descCon) > -1)
                  rest->ListaConexoes->AddObject(descCon, (TObject*)con);
              }
            }

            menuDin->RestricaoModelo = rest;
            delete lstConx;
            delete lstSB;
            menusDinamicos_->AddObject(menuDin->Caption, (TObject*) menuDin);
          }
        }
      } //ForMenus
    } //IFConsulta
  } // Controle que j carregou

  return menusDinamicos_;
}

void TTPFormsManager::AlterarIconeLog()
{



  PtrQuery query = TDAO::getAlertaAutomaticoTimeOut();
  bool check = !query->Eof;

 struct TLocalArgs
  {// processo para poder chamar via multhread


    bool check;
    void __fastcall AjustarEstadoAcionarAutomatico()
    {


      for (int i = 0; i < TTPFormsManager::getInstance()->FomrsZonas->Count; i++)
      {
        TFormPrincipal *t_formPrincipal = (TFormPrincipal*)TTPFormsManager::getInstance()->FomrsZonas->Objects[i];
        for (int x = 0; x < t_formPrincipal->FormsRamais->Count; x++)
        {
          TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[x];
          t_FormTP->AlterarIconeLog(check);

        }
      }

    }
  };

  TLocalArgs Args;
  Args.check =check;
  TThread::Synchronize(NULL, &Args.AjustarEstadoAcionarAutomatico);


}
bool TTPFormsManager::VerificaShowIntrajornada()
{
  return algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada; //netto
}

bool  TTPFormsManager::VerificaShowVisualizador()
{
  return algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspVisualizador
      || algorithm::CoreTMPlanner::getInstance()->getSystemProfile() == TSystemProfile::tspIntrajornada;
}

void TTPFormsManager::AtualizarObjetosSBClientByServer()
{

  algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  MalhaFerroviaria* tmalha       = core->getMalha();

  for(int i = 0; i< sbs_->count(); i++)
  {
    TTPSBPtr sb = sbs_->get(i);
    int idxSB = tmalha->listaSBMalha->IndexOf(sb->NomeVia);
    if (idxSB > 0)
    {
      sb->SBServer = (SB*)tmalha->listaSBMalha->Objects[idxSB];
    }
  }

}

void TTPFormsManager::ThreadFinalizarProgramacao(TTheadResultado *pResult)
{
	try
	{
#ifdef _DEBUG
		this->gravarLog("Incio: Finalizar Programao");
#endif

		TTPGerenteProgramacao::getInstance()->FinalizarPlanejamento();
		StopAguarde();

#ifdef _DEBUG
		this->gravarLog("Fim: Finalizar Programao");
#endif
	}
	catch (Exception &e)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = e.Message;
		gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = "Erro no identificado.";
		gravarLog("Erro no identificado.");
	}
}
// ---------------------------------------------------------------------------

void TTPFormsManager::ThreadIniciarProgramacao(TTheadResultado *pResult)
{
	try
	{
#ifdef _DEBUG
		gravarLog("Incio: Iniciar Programao");
#endif

		TTPGerenteProgramacao::getInstance()->InicializarPlanejamento(pResult);

		StopAguarde();

#ifdef _DEBUG
		gravarLog("Fim: Iniciar Programao");
#endif
	}
	catch (Exception &e)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = e.Message;
		pResult->ListaResultados->Add(e.Message);
		gravarLog(e.Message);
	}
	catch (...)
	{
		StopAguarde();
		pResult->Status    = terErro;
		pResult->Resultado = "Erro no identificado.";
		pResult->ListaResultados->Add("Erro no identificado.");
		gravarLog("Erro no identificado.");
	}
}
bool TTPFormsManager::tryLockMutexProc(int timeOut, String MensagemErro, String nomeProcessoLock)
{
  bool ret = false;
  void* windowList = NULL;

  try
  {
    std::clock_t start = std::clock();

    while (!this->MutexProc->try_lock())
    {
      if (((std::clock() - start) / (double)CLOCKS_PER_SEC) > timeOut)
      {
        if (MensagemErro != "")
        {
          MensagemErro = "["+ Now().DateTimeString() +"] " + MensagemErro;
          MensagemErro += " est aguardando o processo: " + this->LastProcessoLock +" iniciado a " + String((std::clock() - clckIniLock) / (double)CLOCKS_PER_SEC)+ " seg";
          gravarLog("tryLockMutexProc ERRO MSG: "+MensagemErro + " PROCESSO: "+nomeProcessoLock );
          throw Exception(MensagemErro);
        }

        gravarLog("tryLockMutexProc FALSE PROCESSO: "+nomeProcessoLock + " Ultimo Lock:" +this->LastProcessoLock);

        return false;
      }

      if (System::MainThreadID == GetCurrentThreadId() )
      {// processo para evitar que fique preso uma thread secundaria que tenta atualizar o form no thread syncronize
        if (!windowList )
         windowList = DisableTaskWindows(NULL);

        Application->ProcessMessages();
      }
    }

    clckIniLock = start;

    this->LastProcessoLock = nomeProcessoLock;
    //gravarLog("tryLockMutexProc SUCESSO MSG: "+MensagemErro + " PROCESSO: "+nomeProcessoLock );

    ret = true;
  }
  __finally
  {
   if (windowList)
   {
     EnableTaskWindows(windowList);
   }
  }

  return ret;
}

void TTPFormsManager::LimparXmlPublicacaoTrens()
{
  for (int i = 0; i < TTPFormsManager::getInstance()->Trens->count(); i++)
  {
    TTPTremPtr trem = TTPFormsManager::getInstance()->Trens->operator[](i);

    trem->XMLPublicacao = "";
    trem->XMLOficializacao = "";
    trem->XMLComplementarPublicacao = "";
    trem->XMLComplementarOficializacao = "";
  }
}

  bool TTPFormsManager::VerificarMudancaSentido(int iAtual, domain::TremMalha* pTrem, domain::SegmentoTremBase* pSegmentoTrem, bool pTremSubindo, Oficializacao* pOficializacao)
{

  SegmentoTrem* itemRota                         = NULL;
  SegmentoTremRealizado* itemRotaRealizado       = NULL;
  SegmentoTremOficializado* itemRotaOficializado = NULL;


  if(pSegmentoTrem->getClassType() == SegmentoTremBase::TipoOcupacao::SEGMENTO_TREM)
    itemRota = (SegmentoTrem*)pSegmentoTrem;
  else if (pSegmentoTrem->getClassType() == SegmentoTremBase::TipoOcupacao::SEGMENTO_TREM_REALIZADO)
    itemRotaRealizado = (SegmentoTremRealizado*)pSegmentoTrem;
  else if (pSegmentoTrem->getClassType() == SegmentoTremBase::TipoOcupacao::SEGMENTO_TREM_OFICIALIZADO)
    itemRotaOficializado = (SegmentoTremOficializado*)pSegmentoTrem;

  //Como descobrir qual o tipo do movimento que vamos testar?
  if(itemRota && !itemRotaRealizado && !itemRotaOficializado)
  {
    //Planejado - i, tremCalc, itemRota, tremSubindo
    String nomeIni      = itemRota->getSB()->sb;
    TTPSBPtr tSB = sbs_->get(nomeIni);

    if (iAtual > 2)
    if (iAtual < pTrem->rotaTrem->Count - 2 && ((SegmentoTrem*)pTrem->rotaTrem->Objects[iAtual - 2]) != NULL)
    {
     String nomeIniAux = ((SegmentoTrem*)pTrem->rotaTrem->Objects[iAtual - 2])->getSB()->sb;
      TTPSBPtr tSBAux = sbs_->get(nomeIniAux);
      if (itemRota->segmentoOcupado == ((SegmentoTrem*)pTrem->rotaTrem->Objects[iAtual - 2])->segmentoOcupado
        || (pTremSubindo && tSBAux->IndexGraficoI > tSB->IndexGraficoI && tSBAux->Ramal == tSB->Ramal)
        || (!pTremSubindo && tSBAux->IndexGraficoI < tSB->IndexGraficoI&& tSBAux->Ramal == tSB->Ramal))
      {
      return true;
      }
    }
  }
  else if(itemRotaRealizado && !itemRota && !itemRotaOficializado)
  {
    //Realizado - i, tremCalc, itemRota, tremSubindo
    if (iAtual > 2)
      if (iAtual < pTrem->rotaRealizada->Count - 2 && ((SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[iAtual -
        2]) != NULL)
        if (itemRotaRealizado->segmentoOcupado == ((SegmentoTremRealizado*)pTrem->rotaRealizada->Objects[iAtual -
          2])->segmentoOcupado)
          // if( tremSubindo != VerificarTremSubindo(i,tremCalc, true))
    {
     return true;
    }
  }
  else if( itemRotaOficializado && !itemRotaRealizado && !itemRota)
  {
    if(pOficializacao == NULL)
    {
      //Oficializado - i, tremCalc, itemRota, tremSubindo
      if (iAtual > 2)
        if (pTrem->getUltimaOficializacaoPlanejamento()!=NULL && iAtual < pTrem->getUltimaOficializacaoPlanejamento()->rotaOficializada->Count -
          2 && ((SegmentoTremOficializado*)pTrem->getUltimaOficializacaoPlanejamento()->rotaOficializada->Objects[iAtual - 2]) != NULL)
          if (itemRotaOficializado->getSegmentoOcupado() ==
            ((SegmentoTremOficializado*)pTrem->getUltimaOficializacaoPlanejamento()->rotaOficializada->Objects[iAtual - 2])->getSegmentoOcupado())
         //  if( tremSubindo != VerificarTremSubindo(i,tremCalc, true))
      {
        return true;
      }
    }
    else
    {
      if (iAtual > 2)
      if (pOficializacao->rotaOficializada!=NULL && iAtual < pOficializacao->rotaOficializada->Count -
        2 && ((SegmentoTremOficializado*)pOficializacao->rotaOficializada->Objects[iAtual - 2]) != NULL)
        if (itemRotaOficializado->getSegmentoOcupado() ==
          ((SegmentoTremOficializado*)pOficializacao->rotaOficializada->Objects[iAtual - 2])->getSegmentoOcupado())
        {
          return true;
        }
    }
  }
  {
    return false;
  }
}

void TTPFormsManager::LimparListasPersistenciaAtividadesTrem(TTPTrem* pTrem)
{
   pTrem->AtividadesInsert->clear();
   pTrem->AtividadesUpdate->clear();
   pTrem->AtividadesDel->clear();
}

void  TTPFormsManager::CompararPlanos()
{
   AjustarEstadoAlertaEntrePlanos(false);
  if( trens_ && trens_->count()>0 /* && TTPFormsManager::getInstance()->Usuario.Nivel >= nivEspecialista*/)
  {
    if(listaDatasComparacao_)
    {
      while(listaDatasComparacao_->Count>0)
      {
        TDateTime *data = (TDateTime *)listaDatasComparacao_->Objects[0];
        listaDatasComparacao_->Delete(0);
        delete data;
      }
    }

    listaDatasComparacao_ = TDAO::getListaDatasOficializacoesComparacao();

    if(listaDatasComparacao_)
    {
      String datasComparacao = "";
      for(int i=0; i<listaDatasComparacao_->Count; i++)
      {
        datasComparacao+=DateTimeToStr(*((TDateTime *)listaDatasComparacao_->Objects[i]));
      }

      if(stringDataUltimaOflzAutomatico_ != datasComparacao && datasComparacao!="")
      {
        gravarLog("Iniciando Comaprador de Planos");
        refreshComparacoes_ = true;
        TTheadResultado *tResult = new TTheadResultado();
        ThreadCarregarTrensMalhaComparacaoPlanos(tResult);

        delete tResult;
        tResult = NULL;
        gravarLog("Comaprador de Planos Thread Disparada");
      }
    }

    if(refreshComparacoes_)
    {
      if(listaAlertaComparacoes_ && listaAlertaComparacoes_->Count>0)
      {
        AjustarEstadoAlertaEntrePlanos(true);
        refreshComparacoes_ = false;
      }
    }
  }
}

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGridMonitoramentoEntrePlanos.cpp =====
//---------------------------------------------------------------------------
#pragma warn -8111

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "FWidgetGridMonitoramentoEntrePlanos.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "FWidgetGridBase"
#pragma link "cxContainer"
#pragma link "cxTextEdit"
#pragma link "cxTimeEdit"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"
#pragma link "dxUIAClasses"
#pragma link "cxImageList"
#pragma resource "*.dfm"

#include "../domain/SegmentoTremOficializado.h"
#include "../domain/Oficializacao.h"
#include <../domain/Segmento.h>
#include <../domain/Comparacao.h>
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
#include "UTPMovimentoSeries.h"

#include "UFormsManager.h"
#include "UTPZonaControle.h"
#include "UTPComparacao.h"


#define DIFERENCA_LIMIMTE 40
TFormWidgetGridDiferencasEntrePlanos *FormWidgetGridDiferencasEntrePlanos;
//---------------------------------------------------------------------------
__fastcall TFormWidgetGridDiferencasEntrePlanos::TFormWidgetGridDiferencasEntrePlanos(TComponent* Owner)
  : TFormWidgetGridBase(Owner)
{
  cdsGrid2->CreateDataSet();
  FisExecutarViewer_ =  true;
  FTickCountUltimoExecutaViewer_ = std::clock();
}
//---------------------------------------------------------------------------
TStringList* TFormWidgetGridDiferencasEntrePlanos::ComparaOficializacoes(domain::Oficializacao *pOficializacao1, domain::Oficializacao *pOficializacao2, bool pCompararTempoPermanencia)
{
//	using namespace domain;
//	TStringList* tReturn = NULL;
//	TDateTime dataGrafico  = algorithm::CoreTMPlanner::getInstance()->getDataHoraBaseCalculo(false).asDateTime();
//	for (int i = 0; i < pOficializacao1->rotaOficializada->Count; i++)
//	{
//		SegmentoTremOficializado* itemRotaOficializado1 = (SegmentoTremOficializado*)pOficializacao1->rotaOficializada->Objects[i];
//
//	 // TDateTime tDataChegada1 = itemRotaOficializado1->getDataHoraChegadaCabecaTrem();
//	//	TDateTime tDataSaida1 = itemRotaOficializado1->getDataHoraFimParadaTrem();
//
//		if(itemRotaOficializado1->getSegmentoOcupado()->inicioHorizonteComparacao>0 ||
//			 itemRotaOficializado1->getSegmentoOcupado()->fimHorizonteComparacao >0 )
//		{
//
//			TDateTime DataInicioHorComp = IncMinute(dataGrafico, itemRotaOficializado1->getSegmentoOcupado()->inicioHorizonteComparacao);
//			TDateTime DataFimHorComp = IncMinute(dataGrafico, itemRotaOficializado1->getSegmentoOcupado()->fimHorizonteComparacao);
//
//			for (int i = 0; i < pOficializacao2->rotaOficializada->Count; i++)
//			{
//				SegmentoTremOficializado* itemRotaOficializado2 = (SegmentoTremOficializado*)pOficializacao2->rotaOficializada->Objects[i];
//
//				if(itemRotaOficializado1->getSegmentoOcupado() == itemRotaOficializado2->getSegmentoOcupado())
//				{
//					TDateTime tDataChegada1 = itemRotaOficializado1->getDataHoraChegadaCabecaTrem();
//					TDateTime tDataSaida1 = itemRotaOficializado1->getDataHoraFimParadaTrem();
//
//					double tDuracao1 = (((double) tDataSaida1) - ((double) tDataChegada1))*24*60;
//
//
//					TDateTime tDataChegada2 = itemRotaOficializado2->getDataHoraChegadaCabecaTrem();
//					TDateTime tDataSaida2 = itemRotaOficializado2->getDataHoraFimParadaTrem();
//
//					double tDuracao2 = (((double) tDataSaida2) - ((double) tDataChegada2))*24*60;
//
//					double duracaot =	abs(tDuracao2 - tDuracao1) ;
//
//					int minutosEntreChegada = MinutesBetween(tDataChegada1,tDataChegada2);
//
//					if(((tDataChegada1 >= DataInicioHorComp && tDataChegada1 <= DataFimHorComp) ||
//							(tDataChegada2 >= DataInicioHorComp && tDataChegada2 <= DataFimHorComp))&&
//						 ((pCompararTempoPermanencia && duracaot > DIFERENCA_LIMIMTE) ||
//							minutosEntreChegada > DIFERENCA_LIMIMTE))
//					{
//						double *duracaoTotal = new double;
//						*duracaoTotal =	(tDuracao2 - tDuracao1) ;
//
//						if(!tReturn)
//						 tReturn = new TStringList();
//
//
//						domain::Comparacao* comparacao = new domain::Comparacao(itemRotaOficializado1,itemRotaOficializado2);
//
//
//						tReturn->AddObject(itemRotaOficializado1->getSegmentoOcupado()->segmento, (TObject *)comparacao);
//					}
//
//					break;
//				}
//			}
//		}
//
//	}
//
//	return tReturn;
  return NULL; //netto
}

void TFormWidgetGridDiferencasEntrePlanos::CompararOficializacoes(bool pCompararTempoPermanencia)
{
  if(!TTPFormsManager::getInstance()->RefreshComparacoes)
  {
      if(medOflz1->Text == TTPFormsManager::getInstance()->DatasComparacao.SubString(0,19))
      {
        return;
      }

      if(TTPFormsManager::getInstance()->ListaAlertaComparacoesClient && TTPFormsManager::getInstance()->ListaAlertaComparacoesClient->Count==0)
      {
        medOflz1->Text =TTPFormsManager::getInstance()->DatasComparacao.SubString(0,19);
        medOflz2->Text = TTPFormsManager::getInstance()->DatasComparacao.SubString(20,34);
      }
  }

  TTPFormsManager::getInstance()->RefreshComparacoes = false;

  medOflz1->Text =TTPFormsManager::getInstance()->DatasComparacao.SubString(0,19);
  medOflz2->Text = TTPFormsManager::getInstance()->DatasComparacao.SubString(20,34);

  using namespace domain;
  //algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
  cdsGrid2->First();
  //Application->ProcessMessages();

  cdsGrid2->Close();
  cdsGrid2->CreateDataSet();
  cdsGrid2->Open();
  cdsGrid2->DisableControls();

  //chbxCompTempoPerm->Checked = pCompararTempoPermanencia;

  //TStringList *t_trens = core->getTrensCalculados();
  //cdsGridCHECK->OnChange = NULL;

  TStringList* Comparacoes = TTPFormsManager::getInstance()->ListaAlertaComparacoesClient;

 //	medOflz1->Text = "";
 //	medOflz2->Text = "";

  TFormatSettings   formatSeetings;
  GetLocaleFormatSettings(NULL,formatSeetings);
  formatSeetings.DateSeparator   = '/';
  formatSeetings.ShortDateFormat = "dd/mm/yy";
  formatSeetings.LongTimeFormat  = "hh:nn";
  formatSeetings.TimeSeparator   = ':';

  if(Comparacoes)
  {
    for(int i=0; i<Comparacoes->Count;i++ )
    {
      cdsGrid2->Append();

      medOflz1->Text = ((TTPComparacao*)Comparacoes->Objects[i])->DataOficializacao1;
      medOflz2->Text = ((TTPComparacao*)Comparacoes->Objects[i])->DataOficializacao2;

      cdsGridPrefixo->Text =   ((TTPComparacao*)Comparacoes->Objects[i])->PrefixoTrem;
      cdsGridPIDTrem->Text =   ((TTPComparacao*)Comparacoes->Objects[i])->PidTrem;
      cdsGridLocal->Text =    ((TTPComparacao*)Comparacoes->Objects[i])->Local;
      cdsGridDtChegPlan1->AsDateTime = ((TTPComparacao*)Comparacoes->Objects[i])->DataChegada1;
      cdsGridDtChegPlan2->AsDateTime = ((TTPComparacao*)Comparacoes->Objects[i])->DataChegada2;

      cdsGridDtSaidaPlan1->AsDateTime = ((TTPComparacao*)Comparacoes->Objects[i])->DataSaida1;
      cdsGridDtSaidaPlan2->AsDateTime = ((TTPComparacao*)Comparacoes->Objects[i])->DataSaida2;

      if(((TTPComparacao*)Comparacoes->Objects[i])->Duracao>0)
        cdsGridPermanencia->AsFloat =  ((TTPComparacao*)Comparacoes->Objects[i])->Duracao;

      cdsGridDesvioTotal->AsFloat =  ((TTPComparacao*)Comparacoes->Objects[i])->Desvio;
      cdsGridDesvioTela->Value = FloatToHHMM(fabs(cdsGridDesvioTotal->AsFloat));

      cdsGridTipoComparacao->Text = ((TTPComparacao*)Comparacoes->Objects[i])->TipoComparacao;
      if(cdsGridTipoComparacao->Text == "C")
      {
        cdsGridDataComparacao1->Text = FormatDateTime("dd/mm/yy hh:mm", ((TTPComparacao*)Comparacoes->Objects[i])->DataChegada1.DateTimeString());
        cdsGridDataComparacao2->Text = FormatDateTime("dd/mm/yy hh:mm", ((TTPComparacao*)Comparacoes->Objects[i])->DataChegada2.DateTimeString());
      }
      else if(cdsGridTipoComparacao->Text == "S")
      {
       cdsGridDataComparacao1->Text = FormatDateTime("dd/mm/yy hh:mm", ((TTPComparacao*)Comparacoes->Objects[i])->DataSaida1.DateTimeString());
       cdsGridDataComparacao2->Text = FormatDateTime("dd/mm/yy hh:mm", ((TTPComparacao*)Comparacoes->Objects[i])->DataSaida2.DateTimeString());
      }

      cdsGrid2->Post();
    }
  }
  /*
  for (int i = 0; i < t_trens->Count; i++)
  {
     domain::TremMalha* tremCalc = (domain::TremMalha*)t_trens->Objects[i];

     if(tremCalc->listaOficializacoes->Count >1)
     {
        Oficializacao *of0 = (Oficializacao*) tremCalc->listaOficializacoes->Objects[0];
        Oficializacao *of1 = (Oficializacao*) tremCalc->listaOficializacoes->Objects[1];

        TStringList* Comparacoes;
        TStringList* ComparacoesCore;

        if(of0->dataHoraBaseCarregamento>of1->dataHoraBaseCarregamento)
        {
        // ComparacoesCore = ComparaOficializacoes( of1, of0, pCompararTempoPermanencia);
         Comparacoes  = core->getListaDivergenciasOficializacoes(of1, of0, pCompararTempoPermanencia);
        }
        else
        {
        // ComparacoesCore  = ComparaOficializacoes( of0, of1, pCompararTempoPermanencia);
         Comparacoes = core->getListaDivergenciasOficializacoes( of0, of1, pCompararTempoPermanencia);
        }

        if(Comparacoes)
        {
          for(int i=0; i<Comparacoes->Count;i++ )
          {
            cdsGrid2->Append();
            cdsGridPrefixo->Text =  tremCalc->prefixoTrem;
            cdsGridLocal->Text =  Comparacoes->operator [](i);
            cdsGridDtChegPlan1->AsDateTime = ((Comparacao*)Comparacoes->Objects[i])->segmentoOficializacao1->getDataHoraChegadaCabecaTrem();
            cdsGridDtChegPlan2->AsDateTime = ((Comparacao*)Comparacoes->Objects[i])->segmentoOficializacao2->getDataHoraChegadaCabecaTrem();

            cdsGridDtSaidaPlan1->AsDateTime = ((Comparacao*)Comparacoes->Objects[i])->segmentoOficializacao1->getDataHoraFimParadaTrem();
            cdsGridDtSaidaPlan2->AsDateTime = ((Comparacao*)Comparacoes->Objects[i])->segmentoOficializacao2->getDataHoraFimParadaTrem();

            double tDuracao1 = (((double) cdsGridDtSaidaPlan1->AsDateTime) - ((double) cdsGridDtChegPlan1->AsDateTime))*24*60;
            double tDuracao2 = (((double) cdsGridDtSaidaPlan2->AsDateTime) - ((double) cdsGridDtChegPlan2->AsDateTime))*24*60;

            double duracaot =	abs(tDuracao2 - tDuracao1) ;

            if(duracaot>1)
            cdsGridPermanencia->AsFloat =  duracaot/24/60;

            cdsGridDesvio->AsFloat =  cdsGridDtChegPlan1->AsDateTime - cdsGridDtChegPlan2->AsDateTime;

            cdsGrid2->Post();
          }
        }
     }
  }
   */
  cdsGrid2->First();
  cdsGrid2->EnableControls();
}

void __fastcall TFormWidgetGridDiferencasEntrePlanos::cxgGridDBTableView1CellDblClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  if(chkExibirTremViewer->Checked)
    acAbrirViewerExecute(this);
  else
    TTPFormsManager::getInstance()->SetFocusTremSegmento(cdsGridPIDTrem->Text,cdsGridLocal->Text, true);
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetGridDiferencasEntrePlanos::acPesquisarPrefixoExecute(TObject *Sender)

{
  bool encontrei = false;
  cdsGrid2->Close();
  cdsGrid2->Filtered  = false;

  Application->ProcessMessages();

  edtPrefixo->Text = (edtPrefixo->Text==edtPrefixo->Properties->Nullstring)?(String)"": (String)edtPrefixo->Text.Trim();
  edtDestino->Text = (edtDestino->Text==edtDestino->Properties->Nullstring)?(String)"": (String)edtDestino->Text.Trim();

  cdsGrid2->Filter = " Prefixo LIKE ('"+edtPrefixo->Text.Trim()+"%') and Local LIKE ('"+edtDestino->Text.Trim()+"%')";
  cdsGrid2->Filtered  = True;
  cdsGrid2->Open();

  edtPrefixoExit(edtPrefixo);
  edtPrefixoExit(edtDestino);
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridDiferencasEntrePlanos::edtPrefixoExit(TObject *Sender)

{
if (((TcxTextEdit *)Sender)->Text == "")
    ((TcxTextEdit *)Sender)->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TFormWidgetGridDiferencasEntrePlanos::edtPrefixoKeyDown(TObject *Sender,
          WORD &Key, TShiftState Shift)
{
  acPesquisarPrefixoExecute(this);
}
//---------------------------------------------------------------------------


void __fastcall TFormWidgetGridDiferencasEntrePlanos::chbxCompTempoPermClick(TObject *Sender)

{
CompararOficializacoes(chbxCompTempoPerm->Checked);
}
//---------------------------------------------------------------------------




void __fastcall TFormWidgetGridDiferencasEntrePlanos::acAbrirViewerExecute(TObject *Sender)

{
  HWND  hwnd = FindWindow(NULL, L"OPTMOVE VISUALIZADOR");

  if(!hwnd)
  {
   if(!FisExecutarViewer_ && ((std::clock() - FTickCountUltimoExecutaViewer_) / (double)CLOCKS_PER_SEC) > 30 )
    FisExecutarViewer_= true;

   if(FisExecutarViewer_)
   {
     String parametros = TTPFormsManager::getInstance(this)->Usuario.Codigo+" "+
                        ReplaceStr(TTPFormsManager::getInstance(this)->Usuario.Nome," ","_")+" "+
                        IntToStr(TTPFormsManager::getInstance(this)->Usuario.Nivel)+" "+
                        TTPFormsManager::getInstance(this)->Usuario.Password+" "+
                        ReplaceStr(TTPFormsManager::getInstance(this)->Mesa," ","_")+" "+
                        ReplaceStr(medOflz1->Text," ","_")+" "+
                        ReplaceStr(medOflz2->Text," ","_")+" "+
                        cdsGridPIDTrem->Text+" "+
                        cdsGridLocal->Text;

     HINSTANCE resp = ShellExecute(hwnd, L"open", Application->ExeName.c_str(),parametros.w_str(), NULL, SW_SHOWNORMAL);

     bool erro = (int)resp<=(int)SE_ERR_DLLNOTFOUND;
     if(erro)
     {
       Alerta("Erro ao Chamar o Optmove Visualizador, tente novamente mais tarde!");
       FisExecutarViewer_ = true;
     }
     else
     {
       FisExecutarViewer_ = false;
       FTickCountUltimoExecutaViewer_ = std::clock();
     }

   }
  }
  else
  {
    FisExecutarViewer_ = true;

    AnsiString s_mensagem = ReplaceStr(medOflz1->Text," ","_")+","+
                      ReplaceStr(medOflz2->Text," ","_")+","+
                      cdsGridPIDTrem->Text+","+
                      cdsGridLocal->Text;

    char * c_mensagem = s_mensagem.c_str();

    COPYDATASTRUCT CopyData;
    CopyData.dwData = 0;
    CopyData.cbData = strlen(c_mensagem)+1;
    CopyData.lpData = c_mensagem;


    Screen->Cursor = crHourGlass;


    SetForegroundWindow(hwnd);

    SendMessage(hwnd, WM_COPYDATA,(WPARAM)hwnd, (LPARAM)&CopyData) ;


    Screen->Cursor = crDefault;
  }
}
//---------------------------------------------------------------------------





String FloatToHHMM(float tempo)
{
  float total = ((tempo))*24.0*60;
  int h = total/60;
  int m = ((int)total)%60;

  String retorno = (h<10)?"0":"" ;
  retorno+= (String) h + ":" ;

  retorno+= (m<10)?"0":"" ;
  retorno+= (String) m;

  return retorno;
}



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFAguarde.h =====
//---------------------------------------------------------------------------
#ifndef UFAguardeH
#define UFAguardeH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Imaging.GIFImg.hpp>
#include "cxContainer.hpp"
#include "cxControls.hpp"
#include <cxEdit.hpp>
#include "cxGraphics.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxProgressBar.hpp"
#include "dxUIAClasses.hpp"
//---------------------------------------------------------------------------
class TFormAguarde : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel2;
  TPanel *Panel3;
  TPanel *Panel4;
  TPanel *Panel5;
  TLabel *Label2;
  TPanel *Panel6;
  TImage *Image1;
  TLabel *lblMensagem;
  TLabel *lblAllowCancel;
  TTimer *tmrEnableCancelUserRequest;
  TcxProgressBar *prgBarStatus;
  void __fastcall FormKeyPress(TObject *Sender, System::WideChar &Key);
  void __fastcall FormActivate(TObject *Sender);
  void __fastcall tmrEnableCancelUserRequestTimer(TObject *Sender);
  void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
private:	// User declarations
  bool allowCancelUserRequest_;
  bool cancelUserRequest_;
  int enableCancelUserRequestByTime_;
  CRITICAL_SECTION CriticalSection;
  std::clock_t clockInicio;
  void* windowList;
  HWND FormAguardeWnd;
public:		// User declarations
  __fastcall TFormAguarde(TComponent* Owner, String pMensagem);
  __fastcall ~TFormAguarde();
  void __fastcall FormAguardeWndProc(TMessage &Message);
  void __fastcall Cancelar();
  void __fastcall SetMensagem(String pMensagem);
  void __fastcall SetAllowCancelUserRequest(bool pValor);
  void __fastcall SetEnableCancelUserRequestByTime(int pValor);
  void __fastcall SetProgressUpdate(double val);
  void __fastcall ShowLikeModal();
  __property bool AllowCancelUserRequest = {read=allowCancelUserRequest_, write=SetAllowCancelUserRequest};
  __property int EnableCancelUserRequestByTime = {read=enableCancelUserRequestByTime_};
  __property bool CancelUserRequest = {read=cancelUserRequest_, write=cancelUserRequest_};
  bool isShow;
};
//---------------------------------------------------------------------------
extern PACKAGE TFormAguarde *FormAguarde;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFOrdemTrem.h =====
// ---------------------------------------------------------------------------

#ifndef UFOrdemTremH
#define UFOrdemTremH
// ---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "cxClasses.hpp"
#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridBandedTableView.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include "FGridBase.h"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include <Vcl.Dialogs.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ImgList.hpp>
#include <Vcl.Menus.hpp>
#include <Vcl.ActnList.hpp>
#include <Vcl.Buttons.hpp>

#include "UFormsManager.h"
#include "cxLabel.hpp"
#include <System.Actions.hpp>
#include <System.ImageList.hpp>
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include "dxUIAClasses.hpp"

// ---------------------------------------------------------------------------
class TformOrdemTrem : public TFormGridBase
{
__published: // IDE-managed Components

  TIntegerField *cdsGridordemGeral;
  TStringField *cdsGridprefixo;
  TStringField *cdsGridid;
  TComboBox *cboLocal;
  TLabel *lblLocal;
  TIntegerField *cdsGridindexRota;
  TcxGridDBColumn *cxgGridDBTableView1prefixo;
  TcxGridDBColumn *cxgGridDBTableView1id;
  TcxGridDBColumn *cxgGridDBTableView1indexRota;
  TStringField *cdsGriddestino;
  TStringField *cdsGridtabela;
  TStringField *cdsGridorigem;
  TStringField *cdsGridpatioAtual;
  TcxGridDBColumn *cxgGridDBTableView1destino;
  TcxGridDBColumn *cxgGridDBTableView1tabela;
  TcxGridDBColumn *cxgGridDBTableView1origem;
  TcxGridDBColumn *cxgGridDBTableView1patioAtual;
  TDateTimeField *cdsGridprevisaoSaida;
  TcxGridDBColumn *cxgGridDBTableView1previsaoSaida;
  TBitBtn *btnDesfazerOrdenacao;
  TIntegerField *cdsGridordemGeralInicial;
  TStringField *cdsGridlocal;
  TcxGridDBColumn *cxgGridDBTableView1local;
  TIntegerField *cdsGridordemTela;
  TcxGridDBColumn *cxgGridDBTableView1ordemTela;
  TAction *acDesfazer;
  TIntegerField *cdsGridordemOriginal;
  TcxGridDBColumn *cxgGridDBTableView1ordemOriginal;
  TBooleanField *cdsGridordemFixa;
  TcxGridDBColumn *cxgGridDBTableView1ordemFixa;
  TLabel *lblParametroSalvarOrdem;
  TBooleanField *cdsGridativa;
  TcxGridDBColumn *cxgGridDBTableView1ativa;
  TStringField *cdsGridTremFrente;
  TcxGridDBColumn *cxgGridDBTableView1TremFrente;

  void __fastcall cboLocalChange(TObject *Sender);
  void __fastcall cxgGridDBTableView1KeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall acDesfazerExecute(TObject *Sender);
  void __fastcall cxgGridDBTableView1StylesGetContentStyle(TcxCustomGridTableView *Sender, TcxCustomGridRecord *ARecord,
    TcxCustomGridTableItem *AItem, TcxStyle *&AStyle);
  void __fastcall cxgGridDBTableView1FocusedRecordChanged(TcxCustomGridTableView *Sender, TcxCustomGridRecord *APrevFocusedRecord,
    TcxCustomGridRecord *AFocusedRecord, bool ANewItemRecordFocusingChanged);
  void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
  void __fastcall cxgGridDBTableView1CustomDrawCell(TcxCustomGridTableView *Sender,
          TcxCanvas *ACanvas, TcxGridTableDataCellViewInfo *AViewInfo,
          bool &ADone);



private: // User declarations

  TStringList * FLocaisGatilho_,*FLocaisGatilhoAux_, *FListaTrocasOrdem_;
  int FindexLocalAnterior_, FIndexAnterior_;
  bool FisFixarOrdemOn;
  TStringList * FTrensAlterados_;

public: // User declarations
  TTPTremListPtr FListaTremsRefresh_;

  __fastcall TformOrdemTrem(TComponent* Owner);
  void __fastcall CarregarGatilhos();
  void __fastcall CarregarTrens();
  void __fastcall SalvarOrdem();
  bool __fastcall ValidarTrocasOrdemPendente();
  void __fastcall AddAllListaTremsRefresh();
  void __fastcall EnableControls();

  String FLocalCellAnt_, FUltLocalTroca_;

};

int __fastcall SortPorOrdemSaida(TStringList* List, int Index1, int Index2);
int __fastcall SortPorOrdemChegada(TStringList* List, int Index1, int Index2);

// ---------------------------------------------------------------------------
extern PACKAGE TformOrdemTrem *formOrdemTrem;
// ---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/FWidgetGanttOcupacao.h =====
//---------------------------------------------------------------------------

#ifndef FWidgetGanttOcupacaoH
#define FWidgetGanttOcupacaoH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include "FWidgetBase.h"
#include <Vcl.ExtCtrls.hpp>
#include <VCLTee.Chart.hpp>
#include <VclTee.TeeGDIPlus.hpp>
#include <VCLTee.TeEngine.hpp>
#include <VCLTee.TeeProcs.hpp>
#include "VCLTee.TeeTools.hpp"
#include "cxContainer.hpp"
#include "cxControls.hpp"
#include "cxDropDownEdit.hpp"
#include "cxEdit.hpp"
#include "cxGraphics.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxMaskEdit.hpp"
#include "cxTextEdit.hpp"
#include "cxClasses.hpp"
#include "cxHint.hpp"
#include "dxCustomHint.hpp"
#include "dxScreenTip.hpp"
#include "dxUIAClasses.hpp"

class TFormTP ;
class TTPSBSeries;
class TTPHintSeries;
//---------------------------------------------------------------------------
class TFormWidgetGanttOcupacao : public TFormWidgetBase
{
__published:	// IDE-managed Components
  TPanel *pnlGrafico;
  TPaintBox *PaintBox1;
  TScrollBar *scbRodape;
  TScrollBox *scbCharts;
  TChart *chrTTP;
  TShape *ShapeSelecao;
  TMarksTipTool *ChartTool1;
  TClipSeriesTool *ChartTool2;
  TPanel *pnlScrollTop;
  TChart *chrTTPTop;
  TShape *Shape5;
  TPanel *pnlScrollBot;
  TChart *chrTTPBot;
  TShape *Shape6;
  TScrollBox *scbChartRight;
  TChart *chrTTPRight;
  TShape *Shape4;
  TScrollBox *scbChartLeft;
  TChart *chrTTPLeft;
  TShape *Shape3;
  TComboBox *cbLocal;
  TTeeGDIPlus *TeeGDIPlus1;
  TCheckBox *CheckBox1;
  TPanel *pnlOflz;
  TcxComboBox *cbxDataOficializacaoFarolParametros;
  TLabel *lblOficializacao;
  TLabel *lblLocal;
  TdxScreenTipRepository *dxScreenTip;
  TdxScreenTip *observacao;
  TdxScreenTip *movimento;
  TdxScreenTip *restricao;
  TdxScreenTip *FarolVerde;
  TcxHintStyleController *cxHintController;
  TCheckBox *cbxInterdicoes;
  TCheckBox *cbxPATs;
  TLabel *Label1;
  TCheckBox *cbxOrdenarSBs;
  void __fastcall FlowPanel1Resize(TObject *Sender);
  void __fastcall CheckBox1Click(TObject *Sender);
  void __fastcall chrTTPZoom(TObject *Sender);
  void __fastcall cbLocalChange(TObject *Sender);
  void __fastcall chrTTPMouseMove(TObject *Sender, TShiftState Shift, int X, int Y);
  void __fastcall chrTTPMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
          int X, int Y);
  void __fastcall cbxDataOficializacaoFarolParametrosPropertiesChange(TObject *Sender);
  void __fastcall chrTTPUndoZoom(TObject *Sender);
  void __fastcall cxHintControllerShowHint(TObject *Sender, UnicodeString &HintStr,
          bool &CanShow, THintInfo &HintInfo);
  void __fastcall FormShow(TObject *Sender);
  void __fastcall chrTTPDblClick(TObject *Sender);
  void __fastcall cbxInterdicoesClick(TObject *Sender);
  void __fastcall cbxPATsClick(TObject *Sender);
  void __fastcall cbxOrdenarSBsClick(TObject *Sender);
  void __fastcall FormResize(TObject *Sender);


private:	// User declarations

TFormTP * FTP_;
TTPSBListPtr ListaSbs_;
TTPSBSeries* FSerieSBs_,*FSerieSBsChartTop_,*FSerieSBsChartBot_,*FSerieSBsChartLeft_,*FSerieSBsChartRight_;

double FMouseX_, FMouseY_;
TStringList *FTrensSeries_;
int FScrollBoxPos_;

void __fastcall ConfigurarChart();
public:		// User declarations
  __fastcall TFormWidgetGanttOcupacao(TComponent* Owner, TFormTP *tFTP, double UMAHORA, double UMDIA, double  TP_MAXX_PLAN);
  void __fastcall PlotarGantt(TTPSBListPtr pListaSBs, TFormTP *tFTP);
  void __fastcall PlotarTrens(TTPSBListPtr pListaSBs);
  void __fastcall PlotarInterdicoes(TTPSBListPtr pListaSBs);
  void __fastcall LimparChart(TChart *pChart);

  void __fastcall PlotarLinhaTempo();
  void __fastcall SyncCharts();

  TTPHintSeries* t_seriesGlobal;

  void __fastcall SelecionarPatio(String pSiglaPatio, TFormTP *tFTP);

  __fastcall ~TFormWidgetGanttOcupacao();

  void __fastcall PlotarConflitos(TTPSBListPtr pListaSBs);
  void __fastcall RedrawChart();
  void __fastcall LimparGannt();

  TWndMethod OldScrollBoxWP;
  void __fastcall NewScrollBoxWP(TMessage& AMsg);

  __property int  FScrollBoxPos = {read = FScrollBoxPos_, write = FScrollBoxPos_};

  void SetFTP(TFormTP *pFTP);


  void __fastcall RefreshSeries();
};
//---------------------------------------------------------------------------
extern PACKAGE TFormWidgetGanttOcupacao *FormWidgetGanttOcupacao;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFRestricao.h =====
//---------------------------------------------------------------------------

#ifndef UFRestricaoH
#define UFRestricaoH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ComCtrls.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Mask.hpp>

#include "UTPRestricao.h"

#include "cxClasses.hpp"

#include "cxHint.hpp"

#include "dxCustomHint.hpp"
#include "dxCalloutPopup.hpp"/
#include "dxScreenTip.hpp"
#include "dxScreenTip.hpp"
//---------------------------------------------------------------------------
class TFormRestricao : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel1;
  TPanel *Panel2;
  TPanel *Panel3;
  TPanel *Panel4;
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
  TGroupBox *GroupBox1;
  TLabel *Label1;
  TComboBox *cbosegmentoInicio;
  TLabel *Label9;
  TComboBox *cboPatioInicio;
  TGroupBox *GroupBox2;
  TLabel *Label10;
  TLabel *Label11;
  TComboBox *cboPatioFim;
  TComboBox *cbosegmentoFim;
  TGroupBox *gbxDatas;
  TLabel *lblDataInicio;
  TMaskEdit *medDataInicio;
  TMaskEdit *medHoraInicio;
  TLabel *lblDataFim;
  TMaskEdit *medDataFim;
  TMaskEdit *medHoraFim;
  TPageControl *pgcDetalhes;
  TTabSheet *TabSBs;
  TLabel *Label7;
  TLabel *Label8;
  TButton *btnAdd;
  TButton *btnAddAll;
  TButton *btnRemoveAll;
  TButton *brnRemove;
  TListView *lswViasSelecionadas;
  TListView *lswViasDisponiveis;
  TTabSheet *TabConexoes;
  TLabel *Label5;
  TLabel *Label6;
  TButton *btnAddCon;
  TButton *btnAddAllCon;
  TButton *brnRemoveCon;
  TButton *btnRemoveAllCon;
  TGroupBox *GroupBox4;
  TRichEdit *redObservacao;
  TGroupBox *GroupBox5;
  TLabel *Label2;
  TComboBox *cboTipoRestricao;
  TLabel *lblFimReal;
  TMaskEdit *medDataFimReal;
  TMaskEdit *medHoraFimReal;
  TLabel *Label15;
  TComboBox *cboFiltroLocalAfetado;
  TLabel *Label16;
  TMaskEdit *medFiltroVia;
  TLabel *lblInicioReal;
  TMaskEdit *medDataInicioReal;
  TMaskEdit *medHoraInicioReal;
  TLabel *Label18;
  TMaskEdit *medVelocidade;
  TLabel *lblMinInicio;
  TMaskEdit *medDataMinInicio;
  TMaskEdit *medHoraMinInicio;
  TLabel *lblMaxFim;
  TMaskEdit *medDataMaxFim;
  TMaskEdit *medHoraMaxFim;
  TButton *btnRestauraMinIniOriginal;
  TButton *btnRestauraMaxFimOriginal;
  TMaskEdit *medDataInicioOrig;
  TLabel *Label3;
  TMaskEdit *medHoraInicioOrig;
  TLabel *Label4;
  TMaskEdit *medDataFimOrig;
  TMaskEdit *medHoraFimOrig;
  TLabel *Label12;
  TComboBox *cboSentidoConexoes;
  TListView *lswConxDisponiveis;
  TListView *lswConxSelecionadas;
  TTabSheet *TabTrensRemovidos;
  TLabel *Label13;
  TListView *lswTrensDinsponiveis;
  TListView *lswTrensRemovidos;
  TLabel *Label14;
  TButton *btnAddTremRemovido;
  TButton *btnAddAllTrensRemovido;
  TButton *btnAddAllTrensDisponiveis;
  TButton *btnAddTremDisponivel;
  TTabSheet *TabSheet1;
  TLabel *Label17;
  TLabel *lblSugerida;
  TButton *btnAtualizarOportunidades;
  TListView *lswOportunidades;
  TLabel *lblSugerida2;
  TTabSheet *TabTiposTremRemovidos;
  TLabel *Label19;
  TListView *lswTiposRemovidos;
  TLabel *Label20;
  TListView *lswTiposDisponiveis;
  TButton *btnAddTipoTremRemovido;
  TButton *btnAddAllTipoTrensRemovido;
  TButton *btnAddAllTipoTrensDisponiveis;
  TButton *btnAddTipoTremDisponivel;
  void __fastcall btnOkClick(TObject *Sender);
  void __fastcall btnAddClick(TObject *Sender);
  void __fastcall btnAddAllClick(TObject *Sender);
  void __fastcall btnRemoveAllClick(TObject *Sender);
  void __fastcall brnRemoveClick(TObject *Sender);
  void __fastcall cbosegmentoInicioChange(TObject *Sender);
  void __fastcall cbosegmentoFimChange(TObject *Sender);
  void __fastcall cboPatioInicioChange(TObject *Sender);
  void __fastcall cboPatioFimChange(TObject *Sender);
  void __fastcall cboFiltroLocalAfetadoChange(TObject *Sender);
  void __fastcall medFiltroViaChange(TObject *Sender);
  void __fastcall lswViasDisponiveisDblClick(TObject *Sender);
  void __fastcall lswViasSelecionadasDblClick(TObject *Sender);
  void __fastcall medDataInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall medDataFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall medHoraInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall medHoraFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift);
  void __fastcall medDataInicioChange(TObject *Sender);
  void __fastcall medHoraInicioChange(TObject *Sender);
  void __fastcall medDataFimChange(TObject *Sender);
  void __fastcall medHoraFimChange(TObject *Sender);
  void __fastcall btnRestauraMinIniOriginalClick(TObject *Sender);
  void __fastcall btnRestauraMaxFimOriginalClick(TObject *Sender);
  void __fastcall btnAddConClick(TObject *Sender);
  void __fastcall btnAddAllConClick(TObject *Sender);
  void __fastcall btnRemoveAllConClick(TObject *Sender);
  void __fastcall brnRemoveConClick(TObject *Sender);
  void __fastcall cboSentidoConexoesChange(TObject *Sender);
  void __fastcall lswConxDisponiveisDblClick(TObject *Sender);
  void __fastcall lswConxSelecionadasDblClick(TObject *Sender);
  void __fastcall btnAddTremRemovidoClick(TObject *Sender);
  void __fastcall btnAddTremDisponivelClick(TObject *Sender);
  void __fastcall btnAddAllTrensRemovidoClick(TObject *Sender);
  void __fastcall btnAddAllTrensDisponiveisClick(TObject *Sender);
  void __fastcall lswTrensDinsponiveisDblClick(TObject *Sender);
  void __fastcall lswTrensRemovidosDblClick(TObject *Sender);
  void __fastcall FormShow(TObject *Sender);
  void __fastcall btnAtualizarOportunidadesClick(TObject *Sender);
  void __fastcall btnAddTipoTremRemovidoClick(TObject *Sender);
  void __fastcall btnAddAllTipoTrensRemovidoClick(TObject *Sender);
  void __fastcall btnAddAllTipoTrensDisponiveisClick(TObject *Sender);
  void __fastcall btnAddTipoTremDisponivelClick(TObject *Sender);


private:	// User declarations
  TTPRestricaoPtr FRestricao_;
  TTPSBListPtr    FListaSBs_;
  void __fastcall CarregarSBsDisponiveis(TTPSB* pSBInicio, TTPSB* pSBFim, int pVia = 0);
  bool FAlterouDataInicio_;
  bool FAlterouDataFim_;
  bool FNovaRestricao_;
  bool isCriandoRetencaoDinamica_;

public:		// User declarations
  __fastcall TFormRestricao(TComponent* Owner);
  __fastcall TFormRestricao(TComponent* Owner, TTPSBListPtr pListaSBs, TTPRestricaoPtr& pRestricao, TTPSBPtr pSBInicio, TTPSBPtr pSBFim);
  bool isSBSelecionada(String nomSB);
  bool isConxSelecionada(String nomConx);
  bool isTremRemovido(String pPrefixoTrem);

  void SetListaTrensRemovidos(TStringList* pListaTrens);
  void SetListaTrensDisponiveis(TStringList* pListaTrens);
  void __fastcall carregarOportunidades(TObject *Sender);
  void __fastcall atualizarOportunidades(TObject *Sender);

  void SetListaTiposTremRemovidos(TStringList* pListaTiposTrem = NULL);



};

//---------------------------------------------------------------------------
extern PACKAGE TFormRestricao *FormRestricao;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFParametrosSistema.h =====
//---------------------------------------------------------------------------

#ifndef UFParametrosSistemaH
#define UFParametrosSistemaH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.ComCtrls.hpp>
#include "cxClasses.hpp"

#include "cxControls.hpp"
#include "cxCustomData.hpp"
#include "cxData.hpp"
#include "cxDataControllerConditionalFormattingRulesManagerDialog.hpp"
#include "cxDataStorage.hpp"
#include "cxDBData.hpp"
#include "cxEdit.hpp"
#include "cxFilter.hpp"
#include "cxGraphics.hpp"
#include "cxGrid.hpp"
#include "cxGridCustomTableView.hpp"
#include "cxGridCustomView.hpp"
#include "cxGridDBTableView.hpp"
#include "cxGridLevel.hpp"
#include "cxGridTableView.hpp"
#include "cxLookAndFeelPainters.hpp"
#include "cxLookAndFeels.hpp"
#include "cxNavigator.hpp"
#include "cxStyles.hpp"
#include <Data.DB.hpp>
#include <Datasnap.DBClient.hpp>
#include <Datasnap.Provider.hpp>
#include "cxGridBandedTableView.hpp"
#include "cxGridLayoutView.hpp"
#include "cxCheckBox.hpp"
#include "cxTextEdit.hpp"
#include "cxLabel.hpp"
#include "cxMemo.hpp"
#include "cxContainer.hpp"
#include "cxCustomListBox.hpp"
#include "cxListBox.hpp"
#include "cxScrollBar.hpp"
#include "cxListBox.hpp"
#include "cxCustomListBox.hpp"
#include "dxDateRanges.hpp"
#include "dxScrollbarAnnotations.hpp"
#include <System.ImageList.hpp>
#include <Vcl.ImgList.hpp>
#include <System.Actions.hpp>
#include <Vcl.ActnList.hpp>
#include "cxDropDownEdit.hpp"
#include <Vcl.Buttons.hpp>
#include "dxUIAClasses.hpp"

namespace domain
{
  class SlotDemandaTerminal;
  class FilaDemandaTerminal;

  struct Slot {
    int sequencia;
    String slot;
    String PID;
    bool indicadorDel;
  };

  struct Fila {
    String patio;
    String PID;
    bool isExportacao;
    bool isAlterado;
    bool isAtivo;
    int  tempoCadenciamento;
    std::vector<Slot> slots;
  };
}

using namespace domain;

class TFormParametrosSistema : public TForm
{
__published:	// IDE-managed Components
  TPanel *Panel5;
  TPanel *Panel6;
  TButton *btnOk;
  TButton *btnCancelar;
  TPageControl *PageControl1;
  TTabSheet *TabSheet1;
  TTabSheet *TabSheet2;
  TGroupBox *GroupBox1;
  TCheckBox *chkAtivarAntialias;
  TCheckBox *chkExibirRealizadoReal;
  TCheckBox *chkExibirDeteccaoConflitos;
  TCheckBox *chkExibirHints;
  TCheckBox *chkExibirCargaDescarga;
	TPanel *pnlFiltros;
  TDataSource *dsGrid;
  TDataSetProvider *dtspGrid;
	TClientDataSet *cdsParam;
	TStringField *cdsParamORIG;
	TStringField *cdsParamGRUPO;
	TStringField *cdsParamcd_parametro;
	TStringField *cdsParamdc_parametro;
	TStringField *cdsParamvalor_parametro;
	TStringField *cdsParamic_tipo_parametro;
	TStringField *cdsParamic_parametro_ativo;
	TStringField *cdsParamcd_usuario;
	TStringField *cdsParamdata_atualizacao;
	TStringField *cdsParamregex_v;
	TcxStyleRepository *cxStyleRepositoryGrids;
	TcxStyle *cxHeader;
	TcxStyle *cxContentEven;
	TcxStyle *cxStyle21;
	TcxStyle *cxSelection;
	TcxStyle *cxBandHeader;
	TcxStyle *cxContent;
	TcxStyle *cxBandHeaderDesabilitado;
	TcxStyle *cxHeaderDesabilitado;
	TcxStyle *cxSLAExtrapoladoContent;
	TcxStyle *cxInterrompidoContent;
	TcxStyle *cxMapaVerde;
	TcxStyle *cxMapaVermelho;
	TcxStyle *cxEmAndamentoContent;
	TcxStyle *cxStyle22;
	TcxStyle *cxStyle23;
	TcxStyle *cxErro;
	TcxStyle *cxDisabled;
	TcxStyle *cxDefault;
	TcxStyle *cxFilaInativa;
	TcxGridBandedTableViewStyleSheet *ssBandedTable;
	TcxGridBandedTableViewStyleSheet *ssBandedTableDesabilitada;
	TcxGridTableViewStyleSheet *ssGridTable;
	TcxGridTableViewStyleSheet *ssGridTableDesabilitada;
	TcxStyle *cxStyle1;
	TcxGridLayoutViewStyleSheet *cxGridLayoutViewStyleSheet1;
	TBooleanField *cdsParamlinha_modificada;
  TStringField *cdsParamcd_prmt_old;
  TStringField *cdsParamrow_id;
  TButton *btnAddNewRowGrid;
  TEdit  * FieldTPCadenciamento;
  TCheckBox *chkDesativarGestaoFilaExportacao;
  TCheckBox *chkDesativarGestaoFilaImportacao;
  TCheckBox *chkCalculoVelocidade;
  TLabel *lblCadenciamento;
  TLabel *lblMinutos;
  TPageControl *PageControl2;
  TTabSheet *TabSheet4;
  TTabSheet *TabSheet5;
  TDataSource *dsExportacaoSlots;
  TClientDataSet *cdsExportacaoSlots;
  TDataSource *dsImportacaoSlots;
  TClientDataSet *cdsImportacaoSlots;
  TImageList *il;
  TClientDataSet *cdsExportacaoPatio;
  TDataSource *dsExportacaoPatio;
  TClientDataSet *cdsImportacaoPatio;
  TDataSource *dsImportacaoPatio;
  TStringField *cdsExportacaoSlotsSequencia;
  TStringField *cdsExportacaoSlotsSlots;
  TStringField *cdsExportacaoPatioDestino;
  TStringField *cdsImportacaoPatioOrigem;
  TStringField *cdsImportacaoSlotsSequencia;
  TStringField *cdsImportacaoSlotsSlots;
  TcxGridDBTableView *cxgExportacaoPatioDBTableView1;
  TcxGridLevel *cxgExportacaoPatioLevel1;
  TcxGrid *cxgExportacaoPatio;
  TcxGridDBColumn *cxgExportacaoPatioDBTableView1Destino;
  TPanel *PanelExportacaoPatio;
  TBitBtn *btnInserirPatioExportacao;
  TBitBtn *btnExcluirPatioExportacao;
  TBitBtn *btnConfirmarPatioExportacao;
  TBitBtn *btnCancelarPatioExportacao;
  TcxGridDBTableView *cxgExportacaoSlotsDBTableView1;
  TcxGridLevel *cxgExportacaoSlotsLevel1;
  TcxGrid *cxgExportacaoSlots;
  TcxGridDBColumn *cxgExportacaoSlotsDBTableView1Sequencia;
  TcxGridDBColumn *cxgExportacaoSlotsDBTableView1Slots;
  TcxGridDBTableView *cxgImportacaoPatioDBTableView1;
  TcxGridLevel *cxgImportacaoPatioLevel1;
  TcxGrid *cxgImportacaoPatio;
  TcxGridDBColumn *cxgImportacaoPatioDBTableView1Origem;
  TcxGridDBTableView *cxgImportacaoSlotsDBTableView1;
  TcxGridLevel *cxgImportacaoSlotsLevel1;
  TcxGrid *cxgImportacaoSlots;
  TcxGridDBColumn *cxgImportacaoSlotsDBTableView1Sequencia;
  TcxGridDBColumn *cxgImportacaoSlotsDBTableView1Slots;
  TPanel *PanelImportacaoPatio;
  TBitBtn *btnInserirPatioImportacao;
  TBitBtn *btnExcluirPatioImportacao;
  TBitBtn *btnConfirmarPatioImportacao;
  TBitBtn *btnCancelarPatioImportacao;
  TPanel *PanelExportacaoSlot;
  TBitBtn *btnInserirSlotExportacao;
  TBitBtn *btnExcluirSlotExportacao;
  TBitBtn *btnConfirmarSlotExportacao;
  TBitBtn *btnCancelarSlotExportacao;
  TPanel *PanelImportacaoSlot;
  TBitBtn *btnInserirSlotImportacao;
  TBitBtn *btnExcluirSlotImportacao;
  TBitBtn *btnConfirmarSlotImportacao;
  TBitBtn *btnCancelarSlotImportacao;
  TStringField *cdsExportacaoPatioPIDFila;
  TStringField *cdsImportacaoPatioPIDFila;
  TcxGridDBColumn *cxgExportacaoPatioDBTableView1PIDFila;
  TcxGridDBColumn *cxgImportacaoPatioDBTableView1PIDFila;
	TPanel *Panel1;
  TcxGrid *cxgGrid;
  TcxGridDBTableView *GDTV;
  TcxGridDBColumn *GDTVlinha_modificada;
  TcxGridDBColumn *GDTVORIG;
  TcxGridDBColumn *GDTVGRUPO;
  TcxGridDBColumn *GDTVcd_parametro;
  TcxGridDBColumn *GDTVdc_parametro;
  TcxGridDBColumn *GDTVvalor_parametro;
  TcxGridDBColumn *GDTVic_tipo_parametro;
  TcxGridDBColumn *GDTVic_parametro_ativo;
  TcxGridDBColumn *GDTVcd_usuario;
  TcxGridDBColumn *GDTVdata_atualizacao;
  TcxGridDBColumn *GDTVregex_v;
  TcxGridDBTableView *cxgGridDBTableView2;
  TcxGridLevel *cxgGridLevel1;
  TPanel *pnlCompart;
  TCheckBox *chkIsCalculoVelocidadeAtivo;
  TPanel *pnlLegado;
  TCheckBox *chkDesativarCalculoFila;
  TCheckBox *chkDesativarCadenciaVazio;
  TCheckBox *chkIsCarregarOrdemGatilho;
  TCheckBox *chkParametroOperacional;
  TPanel *pnlListaFilas;
  TLabel *Label1;
  TLabel *Label2;
  TLabel *lblDesativadas;
  TPanel *pnlSelecaoFila;
  TButton *btnCarregaTodos;
  TButton *btnCarregaUm;
  TButton *btnDescarregaTodos;
  TButton *btnDescarregaUm;
  TListBox *lstbAtivas;
  TListBox *lstbInativas;
  TPanel *pnlParametrosAutomatico;
  TCheckBox *chkAtvOfclzAuto;
  TCheckBox *chkAtvPlnParcial;
  TPanel *pnlTPOfclzAuto;
  TLabel *lblMinutos1;
  TLabel *lblTpPlnAuto;
  TEdit *FieldTPPlnAuto;
  TPanel *pnlTPTimeout;
  TLabel *lblMinutos2;
  TLabel *lblTpTimeout;
  TEdit *FieldTPTimeoutPln;
  TPanel *pnlTPParcial;
  TLabel *lblMinutos3;
  TLabel *lblTpRslMinPlnParcial;
  TEdit *FieldTPPlnRslMin;
	void __fastcall btnCarregaUmClick(TObject *Sender);
	void __fastcall btnCarregaTodosClick(TObject *Sender);
	void __fastcall btnDescarregaUmClick(TObject *Sender);
	void __fastcall btnDescarregaTodosClick(TObject *Sender);
	void __fastcall FormActivate(TObject *Sender);
	void __fastcall lstbAtivasDblClick(TObject *Sender);
	void __fastcall lstbInativasDblClick(TObject *Sender);
	void __fastcall GDTVCustomDrawCell(TcxCustomGridTableView *Sender, TcxCanvas *ACanvas,
          TcxGridTableDataCellViewInfo *AViewInfo, bool &ADone);
	void __fastcall GDTVEditValueChanged(TcxCustomGridTableView *Sender, TcxCustomGridTableItem *AItem);
	void __fastcall btnOkClick(TObject *Sender);
  void __fastcall GDTVCellDblClick(TcxCustomGridTableView *Sender, TcxGridTableDataCellViewInfo *ACellViewInfo,
          TMouseButton AButton, TShiftState AShift,
          bool &AHandled);
  void __fastcall GDTVFocusedRecordChanged(TcxCustomGridTableView *Sender, TcxCustomGridRecord *APrevFocusedRecord,
          TcxCustomGridRecord *AFocusedRecord, bool ANewItemRecordFocusingChanged);
  void __fastcall btnAddNewRowGridClick(TObject *Sender);
  void __fastcall GDTVEditKeyDown(TcxCustomGridTableView *Sender, TcxCustomGridTableItem *AItem,
          TcxCustomEdit *AEdit, WORD &Key, TShiftState Shift);
  void __fastcall GDTVFocusedItemChanged(TcxCustomGridTableView *Sender, TcxCustomGridTableItem *APrevFocusedItem,
          TcxCustomGridTableItem *AFocusedItem);
  void __fastcall PageControl1Change(TObject *Sender);
  void __fastcall chkDesativarCalculoFilaClick(TObject *Sender);
  void __fastcall FormCreate(TObject *Sender);
  void __fastcall btnInserirPatioExportacaoClick(TObject *Sender);
  void __fastcall btnExcluirPatioExportacaoClick(TObject *Sender);
  void __fastcall btnConfirmarPatioExportacaoClick(TObject *Sender);
  void __fastcall btnCancelarPatioExportacaoClick(TObject *Sender);
  void __fastcall btnInserirSlotExportacaoClick(TObject *Sender);
  void __fastcall btnExcluirSlotExportacaoClick(TObject *Sender);
  void __fastcall btnConfirmarSlotExportacaoClick(TObject *Sender);
  void __fastcall btnCancelarSlotExportacaoClick(TObject *Sender);
  void __fastcall btnInserirPatioImportacaoClick(TObject *Sender);
  void __fastcall btnExcluirPatioImportacaoClick(TObject *Sender);
  void __fastcall btnConfirmarPatioImportacaoClick(TObject *Sender);
  void __fastcall btnCancelarPatioImportacaoClick(TObject *Sender);
  void __fastcall btnInserirSlotImportacaoClick(TObject *Sender);
  void __fastcall btnExcluirSlotImportacaoClick(TObject *Sender);
  void __fastcall btnConfirmarSlotImportacaoClick(TObject *Sender);
  void __fastcall btnCancelarSlotImportacaoClick(TObject *Sender);
  void __fastcall cxgExportacaoPatioDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow);
  void __fastcall cxgExportacaoPatioDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cxgExportacaoSlotsDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow);
  void __fastcall cxgExportacaoSlotsDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cxgImportacaoPatioDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow);
  void __fastcall cxgImportacaoPatioDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cxgImportacaoSlotsDBTableView1Editing(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *AItem, bool &AAllow);
  void __fastcall cxgImportacaoSlotsDBTableView1CanFocusRecord(TcxCustomGridTableView *Sender,
          TcxCustomGridRecord *ARecord, bool &AAllow);
  void __fastcall cxgExportacaoPatioDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall cxgExportacaoSlotsDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall cxgImportacaoPatioDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall cxgImportacaoSlotsDBTableView1CellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled);
  void __fastcall chkDesativarGestaoFilaExportacaoClick(TObject *Sender);
  void __fastcall chkDesativarGestaoFilaImportacaoClick(TObject *Sender);
  void __fastcall cdsExportacaoPatioAfterOpen(TDataSet *DataSet);
  void __fastcall chkAtvOfclzAutoClick(TObject *Sender);
  void __fastcall chkAtvPlnParcialClick(TObject *Sender);
  void __fastcall PageControl2Change(TObject *Sender);
	void __fastcall PageControl1Enter(TObject *Sender);
  void __fastcall FormShow(TObject *Sender);













	private:	// User declarations
  public:		// User declarations
	__fastcall TFormParametrosSistema(TComponent* Owner);
	inline __fastcall ~TFormParametrosSistema(void);

 //	void __fastcall CarregarFilas();
  void __fastcall RetornarFilas();
	void __fastcall LimpezaLists();
  void __fastcall CarregarParametrosGrid();
  void __fastcall descarregarTodos();
  void __fastcall monitoraCheckBox();
	TStringList* Filas_;
  TStringList *FlistaFilasAtivas_;
  TStringList *FlistaFilasInativas_;
  TDateTime FdataExpiracao_;
	//void __fastcall CheckFilasAtivas();
  void __fastcall GridRules();
  void  __fastcall carregarListaFilas (TStringList* ativas, TStringList*inativas);

  void __fastcall addNewLine(TcxGridDBTableView *AView);
  void __fastcall  TFormParametrosSistema::AjustarctiveTabSize(TPageControl *PageControl);

  #pragma region Declaraes de variveis
  private:	// User declarations
    bool m_AllowEditingPatioExportacao;
    bool m_AllowEditingSlotExportacao;
    bool m_AllowEditingPatioImportacao;
    bool m_AllowEditingSlotImportacao;

    bool m_editModePatioExportacao;
    bool m_editModeSlotExportacao;
    bool m_editModePatioImportacao;
    bool m_editModeSlotImportacao;
    int  m_tpCdnc;
    bool m_activeExportacao;
    bool m_activeImportacao;
    bool m_AtivoPlnAutomatico;
    bool m_AtivoPlnParcial;
    int m_TPPlnAutomatico;
    int m_TPTimeoutPln;
    int m_PlnTPRslMin;
    algorithm::CoreTMPlanner * m_core;

    PtrQuery m_queryPatio;
    PtrQuery m_querySlots;

    std::vector<Fila> filas;
    std::vector<Fila> filasDeletadas;

    TStringList* listaFilaServer;
    TStringList* listaFilasDeletadasServer;
  #pragma end_region

  #pragma region Enumeraoes
  private:
    enum class BUTTONS_ACTIONS {
      btnInserirPatioExportacao=1,
      btnInserirSlotExportacao,
      btnInserirPatioImportacao,
      btnInserirSlotImportacao,

      btnExcluirPatioExportacao,
      btnExcluirSlotExportacao,
      btnExcluirPatioImportacao,
      btnExcluirSlotImportacao,

      btnConfirmarPatioExportacao,
      btnConfirmarSlotExportacao,
      btnConfirmarPatioImportacao,
      btnConfirmarSlotImportacao,

      btnCancelarPatioExportacao,
      btnCancelarSlotExportacao,
      btnCancelarPatioImportacao,
      btnCancelarSlotImportacao
    };

    enum class GRIDS {
      patioExportacao=1,
      slotExportacao,
      patioImportacao,
      slotImportacao,
    };
  #pragma end_region // Enumeraes

  #pragma region Mtodos Privados
  private:
    typedef void (__fastcall TFormParametrosSistema::*FuncPtr)(bool, bool, bool, bool);

    void __fastcall IniciarDialog();
    void __fastcall AdjustParamAuto();
    void __fastcall VerificaAlteracoesAutomatico();
    void __fastcall SetNavigatorButtonsPatioExportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled);
    void __fastcall SetNavigatorButtonsPatioImportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled);
    void __fastcall SetNavigatorButtonsSlotExportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled);
    void __fastcall SetNavigatorButtonsSlotImportacao(bool addEnabled, bool deleteEnabled, bool confirmEnabled, bool cancelEnabled);

    void __fastcall PreencherComboPatioExportacao();
    void __fastcall PreencherComboPatioImportacao();
    void __fastcall PreencherComboSlotExportacao();
    void __fastcall PreencherComboSlotImportacao();

    void __fastcall PreencherComboBox(PtrQuery query, TcxComboBoxProperties* comboBoxProperties, const String& fieldName);
    bool __fastcall CarregarPatios();
    bool __fastcall CarregarSlots();

    void __fastcall ConfigEditing();
    void __fastcall ConfigEditingSlot();
    void __fastcall ConfigNavigatorButtons();
    void __fastcall ConfigGrids();

    void __fastcall ButtonAction(BUTTONS_ACTIONS action);

    void __fastcall ExportacaoPatioCellClick();
    void __fastcall ExportacaoSlotsCellClick();
    void __fastcall ExportacaoSlotsDoubleCellClick();
    void __fastcall ImportacaoPatioCellClick();
    void __fastcall ImportacaoSlotsCellClick();
    void __fastcall DisableEnableButtonsFila(bool activate);
    void __fastcall IniciarEdicao(FuncPtr navigationButtons, TClientDataSet *cds, bool &editMode, bool &allowEditing);
    void __fastcall Confirmar(FuncPtr navigationButtons, TClientDataSet *cds, bool &editMode, bool &allowEditing, GRIDS grid);
    void __fastcall CancelarEdicao(FuncPtr navigationButtons, TClientDataSet *cds, TcxGridDBTableView *tableView,  bool &editMode, bool &allowEditing);

    void __fastcall LimparGridSlotExportacao();
    void __fastcall LimparGridSlotImportacao();

    int __fastcall inserirSlotEmPatio(std::vector<Fila>& filaToInsert, const String& patio, bool isExportacao, const String& slotName,String PIDFila);
    void __fastcall alterarSlotEmPatio(std::vector<Fila>& filaToAlter, const String& patio, bool isExportacao, const String& slotName, int sequenciaToAlter,String PIDFila);
    bool __fastcall DeletarSlotEmPatio(std::vector<Fila>& filaToDelete, const String& patio, bool isExportacao, const String& slot);
    void __fastcall DeletarPatio(std::vector<Fila>& filaToDelete, const String& patio, bool isExportacao,String PIDFila);

    bool __fastcall ExistePatio(const std::vector<Fila>& filas, const String& patio, bool isExportacao,String PIDFila);
    bool __fastcall ExisteSlotEmFila(const std::vector<Fila>& filas, const String& patio, bool isExportacao, const String& slotName,String PIDFila);
    bool __fastcall VerificaSlotDestinoFila(const std::vector<Fila>& filas, const String& patio, bool isExportacao, const String& slotName,String PIDFila);

    void __fastcall PreencherSlotsPorPatioSelecionado(bool isExportacao);

    void __fastcall SelecionaComboBoxItemPatio(const UnicodeString &itemText, bool isExportacao, Fila fila);
    void __fastcall SelecionaComboBoxItemSlot(const UnicodeString &itemText, bool isExportacao, int sequencia);

    bool __fastcall CarregarFilaServer();
    void __fastcall PreencherGrids();

    void __fastcall InserirItensServer(const std::vector<Fila>& filas, TStringList* listaFilaServer);
    int __fastcall VerificaItemNoServer(const Fila& fila, TStringList* listaFilaServer);

    void __fastcall OcultarLinhaSelecionada(bool isPatio, bool isExportacao, String identificador);
    void __fastcall ExcluirLinhaSelecionada(bool isPatio, bool isExportacao, String identificador);
    void __fastcall ExibirLinhas(bool isPatio, bool isExportacao);
    void __fastcall ExcluirLinhaMarcada(TClientDataSet *cds, const String& identificador, bool isPatio, bool isExportacao);

    void __fastcall AtualizaTPCadenciamento();
    int __fastcall getMaiorSequencialFilaCriado();
    void __fastcall AtualizaFilasAtivas(bool chkBoxFila, bool isExportacao, String paramName, String paramDesc = "");
    void __fastcall AtualizaParamAuto(String paramName, String paramValue, String paramType, String paramDesc = "", String paramGroup = "SISTEMA");
    void __fastcall ResizeFormulario();
    int ResizeComponentByChildSizes(TWinControl *parentControl, int &pMaxWidth);
  #pragma end_region

};
//---------------------------------------------------------------------------
extern PACKAGE TFormParametrosSistema *FormParametrosSistema;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFTestes.cpp =====
//---------------------------------------------------------------------------
#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop

#include "UFTestes.h"
#include "UFormsManager.h"
#include "UTPTipoTrem.h"
#include "UTPTipoRestricao.h"

#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TformTestes *formTestes;
//---------------------------------------------------------------------------
__fastcall TformTestes::TformTestes(TComponent* Owner)
  : TForm(Owner)
{
  memResult->Lines->Clear();
  corDefault = pnlBotoes->Color;
  t_tremTeste = NULL;
}
//---------------------------------------------------------------------------
void TformTestes::PublicarMsg(String pMSG, TipoMensagemExibicao tipoMsgEx, bool pOK)
{
  if(tipoMsgEx == tmeResumo || tipoMsgEx == tmeAmbos)
    lsbTestes->Items->Add(pMSG);
  if(tipoMsgEx == tmeLog || tipoMsgEx == tmeAmbos)
    memResult->Lines->Add(Now().DateTimeString() + " - " + pMSG + (pOK ? " - OK" : ""));

}
//---------------------------------------------------------------------------
void __fastcall TformTestes::btnStartClick(TObject *Sender)
{
  try
  {
    pnlBotoes->Color = corDefault;

    memResult->Lines->Clear();
    PublicarMsg("Iniciando Testes");

    TFormPrincipal *t_formPrincipal = (TFormPrincipal*)TTPFormsManager::getInstance()->FomrsZonas->Objects[0];
    TFormTP *t_FormTP = (TFormTP*)t_formPrincipal->FormsRamais->Objects[0];

    PublicarMsg("Testando CTRL+A");
    t_FormTP->acCarregarExecute(NULL);
    PublicarMsg("Teste CTRL+A", tmeLog, true);

    String pidTrem;
    PublicarMsg("Testando Criao de Trem");
    TesteCriarTrem(t_FormTP, pidTrem);
    PublicarMsg("Teste Criar Trem", tmeLog, true);

    String restr;
    String pidAtiv;
    PublicarMsg("Testando Criao de Restrio");
    TesteCriarRestricao(t_FormTP, restr);
    PublicarMsg("Teste Criar Restrio", tmeLog, true);

    PublicarMsg("Testando Criao de Interdio");
    TesteCriarInterdicao(t_FormTP);
    PublicarMsg("Teste Criar Interdio", tmeLog, true);

    PublicarMsg("Testando Criao de Atividade");
    TesteCriarAtividade(t_FormTP, pidTrem, pidAtiv);
    PublicarMsg("Teste Criar Atividade", tmeLog, true);

    //TESTE DE ERRO
    //throw Exception("Erro antes da atualizar os trens");

    PublicarMsg("Testando AtualizarTrem (F5)");

    PtrQuery qrPrefixos = TDAO::getPrefixosTrensTeste();
    if(qrPrefixos->Eof)
      PublicarMsg("No foram encontrados trens para realizar o teste!", tmeLog);
    else

    while (!qrPrefixos->Eof)
    {
      String prefixo = qrPrefixos->FieldByName("CD_PRFX_DFTV")->Text;
      PublicarMsg("Buscando prefixo " + prefixo, tmeLog);
      t_FormTP->PesquisarPrefixo(prefixo);
      PublicarMsg("Atualizando prefixo " + prefixo, tmeLog);
      t_FormTP->acAtualizarTremExecute(NULL);
      PublicarMsg(prefixo + " atualizado!", tmeLog);
      qrPrefixos->Next();
    }

    PublicarMsg("Testando Edio de Atividade");
    TesteAlterarAtividade(t_FormTP, pidAtiv);
    PublicarMsg("Teste Alterar Atividade", tmeLog, true);

    PublicarMsg("Teste ExcluirAtividade");
    TesteExcluirAtividade(t_FormTP, pidAtiv);
    PublicarMsg("Teste ExcluirAtividade", tmeLog, true);

    PublicarMsg("Teste Editar Restrio");
    TesteAlterarRestricao(t_FormTP, restr);
    PublicarMsg("Teste Alterar Restrio", tmeLog, true);

    PublicarMsg("Teste Excluir Restrio");
    TesteExcluirRestricao(t_FormTP, restr);
    PublicarMsg("Teste Excluir Restrio", tmeLog, true);

    PublicarMsg("Teste AtualizarTrem (F5)", tmeLog, true);

    PublicarMsg("Testando CTRL+P");
    t_FormTP->acProgramarExecute(NULL);
    PublicarMsg("Teste CTRL+P", tmeLog, true);

    PublicarMsg("Testando Disquete");
    t_FormTP->acPublicarEntreMesasExecute(this);
    PublicarMsg("Teste Disquete", tmeLog, true);

    PublicarMsg("Testando Suprimir Trem");
    bool testeSup = TesteSuprimirTrem(t_FormTP);
    PublicarMsg("Teste Suprimir Trem", tmeLog, true);

    PublicarMsg("Testando Oficializao");
    if(algorithm::CoreTMPlanner::getInstance()->DB_INSTANCE.Pos("P14") > 0
        || algorithm::CoreTMPlanner::getInstance()->DB_INSTANCE.Pos("P15") > 0 )
    {
      PublicarMsg("No  recomendado testes de oficializao no ambiente de produo!", tmeLog);
      if(testeSup)
      {
        PublicarMsg("Rodando Disquete ps supresso trem");
        t_FormTP->acPublicarEntreMesasExecute(NULL);
        PublicarMsg("Teste Disquete ps supresso trem", tmeLog, true);
      }
    }
    else
      t_FormTP->acOficializarExecute(NULL);
    PublicarMsg("Teste Oficializao", tmeLog, true);

    PublicarMsg("Fim dos Testes");

    this->BringToFront();
    this->Focused();

    pnlBotoes->Color = clLime;
    pnlBotoes->Refresh();
    Application->ProcessMessages();
    pnlBotoes->Caption = "Oba!!! No houve erros! =)";
  }
  catch(Exception &Ex)
  {
    PublicarMsg("Erro: " + Ex.Message);
    pnlBotoes->Color = clRed;
    pnlBotoes->Refresh();
    Application->ProcessMessages();
    pnlBotoes->Caption = "Xiii, houveram erros! =(";
  }
}
//---------------------------------------------------------------------------

void __fastcall TformTestes::btnFinalizarClick(TObject *Sender)
{
   Application->Terminate();
}
//---------------------------------------------------------------------------

  bool TformTestes::TesteCriarRestricao(TFormTP *t_FormTP, String & pPID)
  {
     using namespace algorithm;
     try
     {

        TTPRestricaoPtr t_Restricao = new TTPRestricao();
        algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
        t_Restricao->SBsRestricao->clear();
        TDateTime t = Now();
        TDateTime t2 = IncHour(t,2);
        //depois ajustar as datas para pegar o dia de hoje sysdate, comear a restrio as duas da tarde at as quatro da tarde
        //t_Restricao->DataInicio = StrToDateTime("dia de hoje no formato 25/11/2021 horario atual mais 10 minutos");
        t_Restricao->DataInicio = t;
        // t_Restricao->DataFim= StrToDateTime("25/11/2021" + " " + hora atual mais 2 horas no formato "13:46");
        t_Restricao->DataFim= t2;

        TStringList *t_listServer = new TStringList();
        TTPSBPtr t_SB_FRN_1 = TTPFormsManager::getInstance()->SBs->get("FRN-1");
        TTPSBPtr t_SB_FRN_2 = TTPFormsManager::getInstance()->SBs->get("FRN-2");

        t_Restricao->SBsRestricao->add("FRN-1", t_SB_FRN_1);
        t_Restricao->SBsRestricao->add("FRN-2", t_SB_FRN_2);

        t_Restricao->ISRestricaoInconsistente = false;
        t_Restricao->ListaConexoes->Clear();
        t_Restricao->ListaTrensDesconsiderar->Clear();
        TTPSBListPtr t_listSB = new TTPSBList();

        //t_listServer->Add("170-FRN-1");
        t_listServer->Add("FRN-1");
        t_listServer->Add("FRN-2");
        //t_listServer->Add("FRN-182-1");
        t_Restricao->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get("ITSI");
        //t_Restricao->Tipo->Codigo = "ITSI";
        t_Restricao->VMA = 10;
        t_Restricao->DataInicioReal = StrToDateTime("30/12/1899");
        t_Restricao->DataFimReal = StrToDateTime("30/12/1899");
        //criando a restricao
        t_Restricao->PID = core->CriarRestricao(
                                      t_Restricao->DataInicio,
                                      t_Restricao->DataFim,
                                      t_listServer,
                                      t_Restricao->Tipo->Codigo,
                                      t_Restricao->VMA,
                                      t_Restricao->DataInicioReal,
                                      t_Restricao->DataFimReal,
                                      t_Restricao->ListaConexoes,
                                      t_Restricao->DataMinInicio,
                                      t_Restricao->DataMaxFim,
                                      3,
                                      t_Restricao->ListaTrensDesconsiderar);

       t_FormTP->AddRestricaoListaLocal(t_Restricao);

       pPID = t_Restricao->PID;
       delete t_listServer;
     }
     catch(Exception &e)
     {
        throw Exception(e.Message);
     }

     return true; //netto Possivel memoryleak
  }


  bool TformTestes::TesteCriarInterdicao(TFormTP *t_FormTP)
  {
     using namespace algorithm;
     try
     {

        TTPRestricaoPtr t_Restricao = new TTPRestricao();
        algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
        t_Restricao->SBsRestricao->clear();
        TDateTime t = Now();
        TDateTime t2 = IncHour(t,2);
        //depois ajustar as datas para pegar o dia de hoje sysdate, comear a restrio as duas da tarde at as quatro da tarde
        //t_Restricao->DataInicio = StrToDateTime("dia de hoje no formato 25/11/2021 horario atual mais 10 minutos");
        t_Restricao->DataInicio = t;
        // t_Restricao->DataFim= StrToDateTime("25/11/2021" + " " + hora atual mais 2 horas no formato "13:46");
        t_Restricao->DataFim= t2;


        TStringList *t_listServer = new TStringList();
        TTPSBPtr t_SB_FRC_1 = TTPFormsManager::getInstance()->SBs->get("FRC1-1");
        TTPSBPtr t_SB_FRN_2 = TTPFormsManager::getInstance()->SBs->get("FRC1-2");

        t_Restricao->SBsRestricao->add("FRC1-1", t_SB_FRC_1);
        t_Restricao->SBsRestricao->add("FRC1-2", t_SB_FRN_2);

        t_Restricao->ISRestricaoInconsistente = false;
        t_Restricao->ListaConexoes->Clear();
        t_Restricao->ListaTrensDesconsiderar->Clear();
        TTPSBListPtr t_listSB = new TTPSBList();


        //t_listServer->Add("170-FRN-1");
        t_listServer->Add("FRC1-1");
        t_listServer->Add("FRC1-2");
        //t_listServer->Add("FRN-182-1");
        t_Restricao->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get("ITMI");
        //t_Restricao->Tipo->Codigo = "ITSI";
        t_Restricao->VMA = NULL;
        t_Restricao->DataInicioReal = StrToDateTime("30/12/1899");
        t_Restricao->DataFimReal = StrToDateTime("30/12/1899");
        //criando a restricao
        t_Restricao->PID = core->CriarRestricao(
                                      t_Restricao->DataInicio,
                                      t_Restricao->DataFim,
                                      t_listServer,
                                      t_Restricao->Tipo->Codigo,
                                      t_Restricao->VMA,
                                      t_Restricao->DataInicioReal,
                                      t_Restricao->DataFimReal,
                                      t_Restricao->ListaConexoes,
                                      t_Restricao->DataMinInicio,
                                      t_Restricao->DataMaxFim,
                                      3,
                                      t_Restricao->ListaTrensDesconsiderar);

       t_FormTP->AddRestricaoListaLocal(t_Restricao);

       delete t_listServer;
     }
     catch(Exception &e)
     {
        throw Exception(e.Message);
     }

     return true; //netto - Possivel memoryleak
  }

  bool TformTestes::TesteCriarAtividade(TFormTP *t_FormTP, String pPIDTrem, String &pPID)
  {
    try
    {
          using namespace algorithm;
          domain::AtividadePlanejamento *tAtividadeServer;
          TTPTremPtr tipoTremTeste = TTPFormsManager::getInstance()->Trens->get(pPIDTrem);
          algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
          //setando os parmetros da atividade  INICIO
          String tPID = tipoTremTeste->PID;
          TDateTime dataMinimaChegada = NULL;
          TDateTime dataFim  = NULL;
          double duracao = 45;
          String codigoPatio = "FMO";
          String pidPatio = TDAO::getPIDPatio(codigoPatio);
          String tIcTipoAtividade = "patio";

          double duracaoPercurso =  0;
          bool isValidarDataSaidaMaximaAtivo = false;
          bool isValidarDataMinimaChegadaAtivo = false;
          TDateTime dataFila = NULL;

          //setando os parmetros da atividade  FIM
          String idTipoAtividade = TDAO::getPIDTipoAtividade("Tecnologia");
          PtrQuery qrTiposAtividade = TDAO::getTiposAtividade();
          idTipoAtividade = "";
          while (!qrTiposAtividade->Eof)
          {
            idTipoAtividade = qrTiposAtividade->FieldByName("ID_TIPO_ATVD_PLJM")->Text;
            break;
          }

          tAtividadeServer = core->CriarAtividade(
          tPID,                             //TREM0
          dataMinimaChegada,               //30/12/1899
          dataFim,                         //30/12/1899
          duracao * 60,                    //45
          NULL, "",                        //
          pidPatio,                        //{ u"PATIO000000004Y" }
          idTipoAtividade,
          duracaoPercurso * 60,            // 0
          NULL,                            // NULL
          0,                         // 30/12/1899
          0,                        //30/12/1899
          0,                        //30/12/1899
          isValidarDataSaidaMaximaAtivo,   //false
          isValidarDataMinimaChegadaAtivo, //false
          true);
          pPID = tAtividadeServer->PID;
          TTPFormsManager::getInstance()->PlotarTrem(&*tipoTremTeste, true);
    }
    catch(Exception &e)
    {
       throw Exception(e.Message);
    }

    return true; //netto - Possivel memoryleak
  }

  bool TformTestes::TesteCriarTrem(TFormTP *t_FormTP, String &pPID)
  {
    using namespace algorithm;
    try
    {
      TTPTipoTremPtr tipoTeste = TTPFormsManager::getInstance()->TiposTrem->get("SERVICO");

      algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
      {
        String prefixo ="TesteA";
        int VMA = 50;
        double velocidade = 60;
        double comprimento = 1.200;
        double pesoTB = 20000;
        String Lotacao = "C";
        TDateTime dtPrevisaoSaida = TTPFormsManager::getInstance()->Data;
        String estadoTrem = "A";
        String CodMercadoria ="";
        String PIDTipoTrem = tipoTeste->PID; //"TREMT000000004C";
        TStringList* SegmentoitinerarioTrem = new TStringList();
        SegmentoitinerarioTrem->Add("FMO");
        SegmentoitinerarioTrem->Add("FOO");
        String PIDGrupoVMP = "GRVMP0000000003";
        String codigoTabela = "";

        String pidTremTeste = core->CriarTrem(prefixo, VMA, velocidade,  comprimento,  pesoTB,
                  Lotacao,  dtPrevisaoSaida,  estadoTrem,  CodMercadoria,  PIDTipoTrem,
                    SegmentoitinerarioTrem,  PIDGrupoVMP,  codigoTabela);

        pPID = pidTremTeste;

        TStringList* t_Lista = core->getTrensCalculados();

        domain::TremMalha *t_Trem = (domain::TremMalha*)t_Lista->Objects[t_Lista->IndexOf(pidTremTeste)];
        TTPFormsManager::getInstance()->CriarTremCliente(t_Trem);

        t_tremTeste = t_FormTP->AddTremListaLocal(t_Trem->PID);

      }
    }
    catch(Exception &ex)
    {
      throw;
    }

    return true; //netto
  }

  bool TformTestes::TesteSuprimirTrem(TFormTP *t_FormTP)
  {
    using namespace algorithm;
    try
    {
      algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
      if(t_tremTeste)
      {
        t_tremTeste->IsSuprimido = true;
        TTPFormsManager::getInstance()->TrensSuprimidos->add(t_tremTeste->PID,t_tremTeste);
        core->ExcluirTrem(t_tremTeste->PID);
        TTPFormsManager::getInstance()->PlotarTrem(&*t_tremTeste);
      }
    }
    catch(Exception &ex)
    {
      throw;
    }

    return true;
  }


bool TformTestes::TesteExcluirAtividade(TFormTP *t_FormTP, String pidAtiv)
{
  using namespace algorithm;

  try
  {

      algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();

      core->ExcluirAtividade(pidAtiv);


  }
  catch(Exception &ex)
  {
   throw;
  }
  return true;
}

bool TformTestes::TesteExcluirRestricao(TFormTP *t_FormTP, String pPID)
{
  using namespace algorithm;
  try
  {
    algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
    core->ExcluirRestricao(pPID);
  }
  catch(Exception &ex)
  {
    throw;
  }
  return true;
}

bool TformTestes::TesteAlterarAtividade(TFormTP *t_FormTP, String pidAtiv)
{
  using namespace algorithm;
  try
  {

      algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
      core->AlterarAtividade(
      pidAtiv,
      NULL, NULL,
      3600,
      18000,
      "atividade0",
      NULL,
      NULL,
      false,
      false,
      500
      );

  }
  catch(Exception &ex)
  {
    throw;
  }
  return true;
}

bool TformTestes::TesteAlterarRestricao(TFormTP *t_FormTP, String pPID)
{
  using namespace algorithm;
  try
  {
    algorithm::CoreTMPlanner *core = CoreTMPlanner::getInstance();
    TStringList *t_listServer = new TStringList();
    TStringList *t_desconsid = new TStringList();

    //t_listServer->Add("170-FRN-1");
    t_listServer->Add("FRC1-1");
    t_listServer->Add("FRC1-2");
    //t_listServer->Add("FRN-182-1");
    core->AlterarRestricao
    (
       Now(),
       IncHour(Now(),5),
       t_listServer,
       pPID,
       200,
       NULL,
       NULL,
       core->getMalha()->listaConexaoSB,
       NULL,
       NULL,
       5000,
       t_desconsid
    );
  }
  catch(Exception &ex)
  {
    throw;
  }
  return true;
}


================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFControleAcesso.h =====
//---------------------------------------------------------------------------

#ifndef UFControleAcessoH
#define UFControleAcessoH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <Vcl.Controls.hpp>
#include <Vcl.StdCtrls.hpp>
#include <Vcl.Forms.hpp>
#include <Vcl.ExtCtrls.hpp>
#include <Vcl.Graphics.hpp>

#include <Vcl.Buttons.hpp>
#include "dxGDIPlusClasses.hpp"

//---------------------------------------------------------------------------
class TFormControleAcesso : public TForm
{
__published:	// IDE-managed Components
  TGroupBox *GroupBox1;
  TLabel *Label1;
  TLabel *Label8;
  TComboBox *cboSegmento;
  TComboBox *cboSB;
  TComboBox *cboPatio;
  TComboBox *cboTipoLocal;
	TImage *Image2;
	TEdit *edtAmbiente;
	TEdit *edtBD;
	TEdit *edtSenha;
	TEdit *edtUsuario;
	TLabel *Label2;
	TLabel *Label3;
	TLabel *Label4;
	TLabel *Label5;
	TShape *Shape1;
	TShape *Shape3;
	TShape *Shape4;
	TLabel *lblLogoSombra;
	TLabel *lblModuloVersaoSombra;
	TLabel *lblLogo;
	TLabel *lblModuloVersao;
	TImage *Image1;
	TLabel *Label6;
	TBitBtn *btnLogin;
	TLabel *Label7;
  void __fastcall btnOkClick(TObject *Sender);
  void __fastcall btnCancelarClick(TObject *Sender);
  void __fastcall FormShow(TObject *Sender);
	void __fastcall Image1Click(TObject *Sender);
private:	// User declarations

public:		// User declarations
  __fastcall TFormControleAcesso(TComponent* Owner, String pBD, String pSchema);
  bool __fastcall VerificarAcessoAD(String pUsuario, String pSenha, String &pNomeUsuario, int  &pNivelAcesso);
  inline __fastcall  ~TFormControleAcesso(void);
  String CodigoUsuario;
  String NomeUsuario;
	int NivelAcessoUsuario;
};
//---------------------------------------------------------------------------
extern PACKAGE TFormControleAcesso *FormControleAcesso;
//---------------------------------------------------------------------------
#endif

================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFFichaTrem.cpp =====
//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

#include "UFFichaTrem.h"
#include "FichaTrem.h"
#include "Equipagem.h"
#include "Composicao.h"
#include "VeiculoAlocado.h"
#include "UFormsManager.h"
#include "UTPItinerarioTrem.h"
#include "UTPTrem.h"
#include "UTPTipoTrem.h"
#include "UTPMovimento.h"
#include "UTPSB.h"
//#include "Segmento.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxControls"
#pragma link "cxCustomData"
#pragma link "cxData"
#pragma link "cxDataControllerConditionalFormattingRulesManagerDialog"
#pragma link "cxDataStorage"
#pragma link "cxDBData"
#pragma link "cxEdit"
#pragma link "cxFilter"
#pragma link "cxGraphics"
#pragma link "cxGrid"
#pragma link "cxGridBandedTableView"
#pragma link "cxGridCustomTableView"
#pragma link "cxGridCustomView"
#pragma link "cxGridDBTableView"
#pragma link "cxGridLevel"
#pragma link "cxGridTableView"
#pragma link "cxLookAndFeelPainters"
#pragma link "cxLookAndFeels"
#pragma link "cxNavigator"
#pragma link "cxStyles"
#pragma link "cxMaskEdit"
#pragma link "dxDateTimeWheelPicker"
#pragma link "cxCalendar"
#pragma link "cxTextEdit"
#pragma link "cxDBTL"
#pragma link "cxInplaceContainer"
#pragma link "cxTL"
#pragma link "cxTLData"
#pragma link "cxPropertiesStore"
#pragma link "dxDateRanges"
#pragma link "dxScrollbarAnnotations"

#pragma link "dxUIAClasses"
#pragma resource "*.dfm"
TFormFichaTrem *FormFichaTrem;

#pragma region Construtores/Destrutores
//---------------------------------------------------------------------------
__fastcall TFormFichaTrem::TFormFichaTrem(TComponent* Owner)
  : TForm(Owner)
{
 FListadeEquipagensFichas_=NULL;
}
//---------------------------------------------------------------------------
__fastcall TFormFichaTrem::TFormFichaTrem(TComponent* Owner, TTPTrem* pTrem, TTPMovimentoSeries* pSerieMovimento, TTPMovimento* pMovimento )
  : TForm(Owner)
{


  // EVENTO FORM CREATE  CHAMADO APOS O CONTRUTOR, POR ISTO O METODO ESTA CHAMNDO NOVAMENTE AQUI
   IniciarDialog();
  this->Caption = "Ficha do Trem: " + pTrem->Prefixo;
  FTrem_ = pTrem;
  using namespace domain;

  m_idTrem = pTrem->PID;

  lblPeso->Caption        = "";
  lblComprimento->Caption = "";
  lblLotacao->Caption     = "";
  lblVMA->Caption         = "";

  domain::FichaTrem* t_fichaTremSrv;
  TTPMovimento* movimento ;

  if (pSerieMovimento)
  {
   movimento =  pSerieMovimento->Movimento;
  }
  else if (pMovimento)
  {
   movimento = pMovimento;
  }
  else
  {
    movimento = &*pTrem->ItinerarioTrem->GetPrimeiroMovimentoPrevisto();
  }

  FMovimento_ =  movimento;
  String sSegmento;
  if (movimento->ServerSegTremPlanejado)
  {
     t_fichaTremSrv = movimento->ServerSegTremPlanejado->fichaTrem;
     sSegmento = movimento->ServerSegTremPlanejado->segmentoOcupado->segmento;
  }
  else if (movimento->ServerSegTremOficializado)
  {
     t_fichaTremSrv = movimento->ServerSegTremOficializado->getFichaTrem();
     sSegmento = movimento->ServerSegTremOficializado->getSB()->segmento->segmento;
  }
  else if (movimento->ServerSegTremRealizado)
  {
    t_fichaTremSrv = ((SegmentoTremBase *)movimento->ServerSegTremRealizado)->fichaTrem;
    sSegmento = ((SegmentoTremBase *)movimento->ServerSegTremRealizado)->segmentoOcupado->segmento;
  }
  pnlLocalEquipagem->Caption = "Equipagem em "+ sSegmento;
  if (t_fichaTremSrv)
  {
    lblPeso->Caption        = FloatToStr(t_fichaTremSrv->pesoTBTrem);
    lblComprimento->Caption = FloatToStr(t_fichaTremSrv->comprimentoTrem);
    lblLotacao->Caption     = t_fichaTremSrv->lotacao == "C" ? "Carregado" : "Vazio";
    lblVMA->Caption         = FloatToStr(t_fichaTremSrv->velocidadeTrem);
  }

  lblLXA->Caption = movimento->getResumoPosicaoEquipamentos();

  CarregarEquipagemFicha(t_fichaTremSrv);
  #ifdef BAIXADA_SANTISTA
  CarregarProdutos();
  CarregarTerminais();
  CarregarNecessidadePorto();
  #else
  Label12->Visible = false;
  lblNecessidadePorto->Visible = false;
  TabSheetProdutoTerminal->TabVisible = false ;
  #endif

  lblPrefixo->Caption        = pTrem->Prefixo;
  lblTipo->Caption           = pTrem->TipoTrem->Nome;
  lblOrigem->Caption         = pTrem->ItinerarioTrem->Movimentos->operator [](0)->SB->CodigoSegmento;
  String DestinoPlano        = pTrem->ItinerarioTrem->Movimentos->operator [](pTrem->ItinerarioTrem->Movimentos->count() -1)->SB->CodigoSegmento;
  String DestinoTrem         = pTrem->Destino!=""?pTrem->Destino:DestinoPlano ;
  lblDestinoPlano->Caption   = DestinoPlano;
  lblDestinoTrem->Caption    = DestinoTrem;
  lblPrevisaoSaida->Caption  = pTrem->ItinerarioTrem->Movimentos->operator [](0)->DataSaida;

  PreencherTodasFichasTrem(pTrem);

}
//---------------------------------------------------------------------------
#pragma end_region

#pragma region Eventos
void __fastcall TFormFichaTrem::FormCreate(TObject *Sender)
{
  IniciarDialog();
}
//---------------------------------------------------------------------------
void __fastcall TFormFichaTrem::cxGridFichasDBTableFichasCellClick(TcxCustomGridTableView *Sender,
          TcxGridTableDataCellViewInfo *ACellViewInfo, TMouseButton AButton,
          TShiftState AShift, bool &AHandled)
{
  FiltrarEquipagemFicha();
}
//---------------------------------------------------------------------------

void __fastcall TFormFichaTrem::cxGridFichasDBTableFichasFocusedItemChanged(TcxCustomGridTableView *Sender,
          TcxCustomGridTableItem *APrevFocusedItem, TcxCustomGridTableItem *AFocusedItem)

{
  FiltrarEquipagemFicha();
}
//---------------------------------------------------------------------------
#pragma end_region

#pragma region Mtodos Privados
void TFormFichaTrem::IniciarDialog()
{
  m_core = algorithm::CoreTMPlanner::getInstance();
}

void TFormFichaTrem::CarregarEquipagemFicha(domain::FichaTrem* pFichaTrem)
{
  using namespace domain;

  cdsGrid->CreateDataSet();
  cdsGrid->Open();
  cdsGrid->DisableControls();
  TStringList* lEquipagemMovimento;
  if(pFichaTrem && pFichaTrem->listaEquipagensFicha)
  {
    lEquipagemMovimento = pFichaTrem->listaEquipagensFicha;
  }
  else
  {
    SegmentoTremBase *stb = (FMovimento_->ServerSegTremRealizado) ? (SegmentoTremBase *)FMovimento_->ServerSegTremRealizado:
                            (FMovimento_->ServerSegTremOficializado) ? (SegmentoTremBase *)FMovimento_->ServerSegTremOficializado:
                            (SegmentoTremBase *)FMovimento_->ServerSegTremPlanejado;

    bool isRealizado =  (FMovimento_->ServerSegTremRealizado);
    if(!stb->trem)
    {
     for (int i = 0; i < FTrem_->ItinerarioTrem->Movimentos->count() && !stb->trem; i++)
     {
       if(!FTrem_->ItinerarioTrem->Movimentos->operator[](i)->IsRealizado && FTrem_->ItinerarioTrem->Movimentos->operator[](i)->PIDRotaOficializada !="")
       {
        stb = (SegmentoTremBase *)FTrem_->ItinerarioTrem->Movimentos->operator[](i)->ServerSegTremOficializado;
       }
     }
    }

    if(!stb->trem)
    return;

    int indexMovimento =  RetornaIndiceApelidoSegmento(FMovimento_->SB->ApelidoSegmento);
    int indexInicioEquipagem;
    lEquipagemMovimento = new TStringList();
    if(indexMovimento>-1 && stb->trem->listaEquipagensTrem)
    {
      for(int i  = 0; i< stb->trem->listaEquipagensTrem->Count ;  i++)
      {
        Equipagem* equipe = (Equipagem*) stb->trem->listaEquipagensTrem->Objects[i];
        String origem = equipe->codPatioOrigem ;
        String destino = equipe->codPatioDestino ;

        int indexOrigem =  RetornaIndiceApelidoSegmento(origem);
        int indexDestino =  RetornaIndiceApelidoSegmento(destino);

        int indexEquipagem =  lEquipagemMovimento->IndexOf(equipe->matricula);

        if(indexOrigem>-1 && indexDestino>-1 && indexEquipagem==-1 &&
          indexMovimento >= indexOrigem && indexMovimento <= indexDestino)
        {
          if(isRealizado && equipe->dataInicioAtividadeTrem.is_not_a_date_time())
          continue;

          lEquipagemMovimento->AddObject(equipe->matricula ,stb->trem->listaEquipagensTrem->Objects[i]);
        }
      }
    }
  }
  if(lEquipagemMovimento->Count>0)
  {
    for(int i=0; i<lEquipagemMovimento->Count; i++)
    {
      Equipagem* equipe = (Equipagem*) lEquipagemMovimento->Objects[i];
      cdsGrid->Append();

      cdsGridPIDEquipagem->Text = equipe->PID;
      cdsGridMatricula->Text = equipe->matricula;
      cdsGridNome->Text = equipe->nome;

      cdsGridCargo->Text = equipe->cargo;
      cdsGridAtividade->Text = equipe->codAtividade;
      cdsGridSede->Text = equipe->codSede;;
      cdsGridOrigem->Text = equipe->codPatioOrigem;
      cdsGridDestino->Text = equipe->codPatioDestino;

      if(!equipe->dataAberturaCaderno.is_not_a_date_time())
        cdsGridAberturaCaderno->AsDateTime = equipe->dataAberturaCaderno.asDateTime();
      if(!equipe->dataInicioAtividadeTrem.is_not_a_date_time())
        cdsGridInicioAtividade->AsDateTime = equipe->dataInicioAtividadeTrem.asDateTime();
      if(!equipe->dataInicioAtividadeServicoTrem.is_not_a_date_time())
        cdsGridInicioServico->AsDateTime = equipe->dataInicioAtividadeServicoTrem.asDateTime();

      cdsGridRealizouIntrajornada->AsBoolean = equipe->realizouIntrajornada;

      cdsGrid->Post();
    }
  }
  cdsGrid->Open();
  cdsGrid->EnableControls();
}

int TFormFichaTrem::RetornaIndiceApelidoSegmento(String pApelidoSegmento)
{
  for (int i = 0; i < FTrem_->ItinerarioTrem->Movimentos->count(); i++)
  {
    if(FTrem_->ItinerarioTrem->Movimentos->operator[](i)->SB->ApelidoSegmento ==  pApelidoSegmento)
    {
     return i;
    }
  }

  return -1;
}

 void TFormFichaTrem::PreencherTodasFichasTrem(TTPTrem* pTrem )
{
  using namespace domain;
  TTPMovimento* movimento ;

  cdsGridFichas->Close();
  cdsGridFichas->CreateDataSet();
  cdsGridFichas->Open();
  cdsGridFichas->Edit();
  cdsGridFichas->DisableControls();

  cdsGridEquipagem->Close();
  cdsGridEquipagem->CreateDataSet();
  cdsGridEquipagem->Open();
  cdsGridEquipagem->Edit();
  cdsGridEquipagem->DisableControls();

  cdsGridComposicao->Close();
  cdsGridComposicao->CreateDataSet();
  cdsGridComposicao->Open();
  cdsGridComposicao->Edit();
  cdsGridComposicao->DisableControls();

  movimento = &*pTrem->ItinerarioTrem->Movimentos->operator [](0);
  domain::FichaTrem* t_fichaTremSrv = NULL;
  domain::FichaTrem*  t_fichaTremSrvAnterior = NULL;
  if (FListadeEquipagensFichas_ == NULL)
  {
    FListadeEquipagensFichas_ = new TStringList();
  }
  else
  {
      FListadeEquipagensFichas_->Clear();
  }
  int count = 0;

  TremMalha* tremSrv = NULL;
  int itemIndex = 0, contFichaAdd = -1;
  while (movimento)
  {

    String sSegmento;
    String tipoMovimento;
    //filtro para no viewr no exibir realizados depois da linha do tempo ao selecionar um movimento oficializado
    if(TTPFormsManager::getInstance()->ShowVisualizador)
    {
      bool exibeRealizado = movimento->IsRealizado && TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewer;
      bool exibeRelizadoLinhaTempo =  exibeRealizado && (!TTPFormsManager::getInstance()->FParametros.ExibirRealizadosViewerLinhaDoTempo || TTPFormsManager::getInstance()->Data > movimento->DataChegada);
      bool pertenceOficializacao = !movimento->IsRealizado && movimento->PIDRotaOficializada == FMovimento_->PIDRotaOficializada;
      if(!((exibeRealizado && exibeRelizadoLinhaTempo) || pertenceOficializacao))
      {
        movimento = movimento->MovimentoPosterior;
        continue;
      }
    }

    count ++;

    if(FMovimento_==movimento)
    {
       itemIndex = contFichaAdd;
    }

    if (movimento->ServerSegTremPlanejado)
    {
       t_fichaTremSrv = movimento->ServerSegTremPlanejado->fichaTrem;
       tremSrv = movimento->ServerSegTremPlanejado->trem;
       sSegmento = movimento->ServerSegTremPlanejado->segmentoOcupado->segmento;
       tipoMovimento = "Prev";
    }
    else if (movimento->ServerSegTremOficializado)
    {
       t_fichaTremSrv = movimento->ServerSegTremOficializado->getFichaTrem();
       tremSrv = movimento->ServerSegTremOficializado->getTrem();
       sSegmento = movimento->ServerSegTremOficializado->getSB()->segmento->segmento;
       tipoMovimento = "Ofic";
    }
    else if (movimento->ServerSegTremRealizado)
    {
      t_fichaTremSrv = ((SegmentoTremBase *)movimento->ServerSegTremRealizado)->fichaTrem;
      tremSrv = movimento->ServerSegTremRealizado->trem;
      sSegmento = ((SegmentoTremBase *)movimento->ServerSegTremRealizado)->segmentoOcupado->segmento;
      tipoMovimento = "Real";
    }

    if (t_fichaTremSrvAnterior != t_fichaTremSrv )
    {
      if(t_fichaTremSrvAnterior && t_fichaTremSrv && t_fichaTremSrv->PID == t_fichaTremSrvAnterior->PID )
      {
        movimento = movimento->MovimentoPosterior;
        continue;
      }
      t_fichaTremSrvAnterior = t_fichaTremSrv;

      if (t_fichaTremSrv)
      {
        TStringList* lEquipagemMovimento = NULL;
        if(t_fichaTremSrv->listaEquipagensFicha)
        {
          lEquipagemMovimento = t_fichaTremSrv->listaEquipagensFicha;
        }
        cdsGridFichas->Append();
        cdsGridFichasContador->Value = count;
        cdsGridFichasOrigem->Value = sSegmento;
        cdsGridFichasTipoMovimento->Value = tipoMovimento;
        cdsGridFichasPeso->Value = t_fichaTremSrv->pesoTBTrem;
        cdsGridFichasComprimento->Value = t_fichaTremSrv->comprimentoTrem;
        cdsGridFichasVMA->Value = t_fichaTremSrv->velocidadeTrem;
        cdsGridFichasLXA->Value = movimento->getResumoPosicaoEquipamentos();
        cdsGridFichasEquipagem->Value = lEquipagemMovimento->CommaText;
        cdsGridFichasPID_Ficha->Value = t_fichaTremSrv->PID;
        cdsGridFichasPidComposicao->Value = t_fichaTremSrv->PIDComposicao;

        if(lEquipagemMovimento)
        for (int i=0; i<lEquipagemMovimento->Count; i++)
        {
          Equipagem* equipe = (Equipagem*) lEquipagemMovimento->Objects[i];

          cdsGridEquipagem->Append();
          cdsGridEquipagemPIDEquipagemFicha->Value =  equipe->PID;
          cdsGridEquipagemPID_Ficha->Value =  t_fichaTremSrv->PID;
          cdsGridEquipagemMatricula->Value = equipe->matricula;
          cdsGridEquipagemNome->Value = equipe->nome;
          cdsGridEquipagemSede->Value = equipe->codSede;
          cdsGridEquipagemCargo->Value = equipe->cargo;
          cdsGridEquipagemOrigem->Value = equipe->codPatioOrigem;
          cdsGridEquipagemDestino->Value = equipe->codPatioDestino;
          if(!equipe->dataAberturaCaderno.is_not_a_date_time())
          cdsGridEquipagemAberturaCaderno->Value = DateTimeToStr(equipe->dataAberturaCaderno.asDateTime());
          if(!equipe->dataInicioAtividadeServicoTrem.is_not_a_date_time())
          cdsGridEquipagemServicoInicio->Value = DateTimeToStr(equipe->dataInicioAtividadeServicoTrem.asDateTime());
          if(!equipe->dataInicioAtividadeTrem.is_not_a_date_time())
          cdsGridEquipagemAtividadeInicio->Value = DateTimeToStr(equipe->dataInicioAtividadeTrem.asDateTime());

          cdsGridEquipagem->Post();
              cdsGridEquipagem->EnableControls();
        }
        cdsGridFichas->Post();
        cdsGridFichas->EnableControls();
        contFichaAdd++;
        if(FMovimento_==movimento)
        {
           itemIndex = contFichaAdd;
        }
      }



    }


    movimento = movimento->MovimentoPosterior;
  }

  if(tremSrv)
  {
    for(int j = 0; j < tremSrv->listaComposicoesTrem->Count; j++)
    {
      Composicao *composicao = (Composicao *) tremSrv->listaComposicoesTrem->Objects[j];
      for (int i=0; i<composicao->getTotalVeiculosComposicao() ; i++)
      {
        VeiculoAlocado *veiculo = composicao->getVeiculoComposicao(i);

        cdsGridComposicao->Append();
        //cdsGridComposicaoPID_FICHA->Value =  t_fichaTremSrv->PID;
        cdsGridComposicaoPIDComposicao->Value =  composicao->PID;
        cdsGridComposicaoIDVeiculo->Value =  veiculo->idVeiculo;
        cdsGridComposicaoPosica->Value =  i+1;
        cdsGridComposicaoLargura->Value = veiculo->largura;
        cdsGridComposicaoAltura->Value = veiculo->altura;
        cdsGridComposicaoComprimento->Value = veiculo->comprimento;
        cdsGridComposicaoNumeroEixos->Value = veiculo->numeroEixos;
        cdsGridComposicaoPeso->Value = veiculo->peso;
        cdsGridComposicaoBitola->Value = veiculo->bitola;

        if(veiculo->potencia>0)
        {
          cdsGridComposicaoPotencia->Value = veiculo->potencia;
        }
        cdsGridComposicao->Post();
      }
    }

  }

  cdsGridComposicao->EnableControls();
  cdsGridFichas->EnableControls();

  cxGridFichasDBTableEquipagem->OptionsView->NoDataToDisplayInfoText = "< Ficha sem Equipagem >";
  cxGridComposicaoDBTableView1->OptionsView->NoDataToDisplayInfoText = "< Ficha sem composio >";

  if(itemIndex<contFichaAdd)
  {
    if(itemIndex>0)
    {
     cdsGridFichas->RecNo = itemIndex+1;
     cxGridFichasDBTableFichas->ViewData->GetRecordByIndex(itemIndex)->Selected = true;
    }
    else
    {
      cdsGridFichas->First();
      cxGridFichasDBTableFichas->ViewData->GetRecordByIndex(itemIndex)->Selected = true;
    }
  }
  FiltrarEquipagemFicha();
}

void TFormFichaTrem::FiltrarEquipagemFicha()
{
  cdsGridComposicao->Close();
  cdsGridComposicao->Filtered = false;
  cdsGridComposicao->Filter = " PIDComposicao = '"+cdsGridFichasPidComposicao->Text+"'";

  cdsGridComposicao->Filtered = true;
  cdsGridComposicao->Open();

  cxGridComposicaoDBTableView1->DataController->Groups->FullExpand();
}

//---------------------------------------------------------------------------
void TFormFichaTrem::CarregarProdutos()
{
  TStringList* produtos = new TStringList();
  produtos->Duplicates = System::Types::dupIgnore;
  produtos->Sorted = true;

  if(m_core->getProdutoPorIDTrem(m_idTrem, produtos))
  {
    for (int i = 0; i < produtos->Count; i++)
    {
      lswProdutos->AddItem(produtos->Strings[i], NULL);
    }
  }
}

//---------------------------------------------------------------------------
void TFormFichaTrem::CarregarTerminais()
{
  TStringList* terminais = new TStringList();
  terminais->Duplicates = System::Types::dupIgnore;
  terminais->Sorted = true;

  if(m_core->getTerminalPorIDTrem(m_idTrem, terminais))
  {
    for (int i = 0; i < terminais->Count; i++)
    {
      lswTerminais->AddItem(terminais->Strings[i],NULL);
    }
  }
}

//---------------------------------------------------------------------------
void TFormFichaTrem::CarregarNecessidadePorto()
{
	//timeTP::TimeTP dataNecessidaPorto = m_core->getDataNecessidadePortoPorIDTrem(m_idTrem);

  timeTP::TimeTP dataNecessidaPorto;
  dataNecessidaPorto = FTrem_->DataNecessidadePorto;

  if( dataNecessidaPorto.is_not_a_date_time() )
    lblNecessidadePorto->Caption = "data no informada";
  else
    lblNecessidadePorto->Caption = dataNecessidaPorto.asString("%D/%M/%Y %h:%m:%s");
}
#pragma end_region



================================================================================


===== Conteúdo de: /Users/edilsonpereiradesouzamelo/Documents/Desenvolvimento/TP_GHP/Classes/Forms/UFRestricao.cpp =====
// ---------------------------------------------------------------------------

#ifndef VCL_H
    #include <vcl.h>
#endif
#pragma hdrstop
#include <list>
#include "UFRestricao.h"
#include "UDModuleMP.h"
#include "UUteis.h"
#include <boost/regex.hpp>
#include "UFormsManager.h"
#include "UTPTrem.h"
#include "UTPTipoTrem.h"
#include "UTPTipoRestricao.h"
#include "UTPSB.h"
#include "UTPMovimento.h"
#include "../domain/RetencaoSB.h"
#include "..\ServerTP\Classes\algorithm\CoreTMPlanner.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "cxClasses"
#pragma link "cxHint"
#pragma link "dxCustomHint"
#pragma link "dxScreenTip"
#pragma link "dxCalloutPopup"
#pragma link "dxScreenTip"
#pragma resource "*.dfm"
TFormRestricao *FormRestricao;

// ---------------------------------------------------------------------------
__fastcall TFormRestricao::TFormRestricao(TComponent* Owner) : TForm(Owner)
{
  FAlterouDataInicio_ = false;
  FAlterouDataFim_    = false;
  FRestricao_         = NULL;
  FNovaRestricao_     = false;

  lblMinInicio->Visible = false;
  medDataMinInicio->Visible = false;
  medHoraMinInicio->Visible = false;
  btnRestauraMinIniOriginal->Visible = false;
  lblMaxFim->Visible = false;
  medDataMaxFim->Visible = false;
  medHoraMaxFim->Visible = false;
  btnRestauraMaxFimOriginal->Visible = false;
  this->Caption = "";
  isCriandoRetencaoDinamica_ = false;
  SetListaTiposTremRemovidos();
}

// ---------------------------------------------------------------------------
__fastcall TFormRestricao::TFormRestricao(TComponent* Owner, TTPSBListPtr pListaSBs, TTPRestricaoPtr& pRestricao,
  TTPSBPtr pSBInicio, TTPSBPtr pSBFim) : TForm(Owner)
{

  isCriandoRetencaoDinamica_ = !pRestricao->RetencaoServer && pRestricao->ListaConexoes->Count > 0;

  FRestricao_       = pRestricao;
  FListaSBs_        = pListaSBs;
  FNovaRestricao_   = FRestricao_->PID.Length() == 0;

  cboTipoRestricao->Items->AddObject(FRestricao_->Tipo->Nome, ((TObject*)&*FRestricao_->Tipo));
  cboTipoRestricao->ItemIndex = 0;

  medVelocidade->Enabled = FRestricao_->Tipo->ISReducaoVelocidade;
  if (medVelocidade->Enabled)
    medVelocidade->Text = FRestricao_->VMA;
  else
    medVelocidade->Text = "";

  String t_Seguimeto    = "";
  int t_SeguimetoInicio = pSBInicio->Seqsegmento;
  int t_SeguimetoFim    = pSBFim->Seqsegmento;

  boost::cmatch nomePatio;
  std::string regexPatio = "^[A-Z]{3}";
  boost::regex getNomePatio(regexPatio);

  for (int i = 0; i < FListaSBs_->count(); i++)
  {
    std::string t_NomePatio = TUteis::narrow(FListaSBs_->operator[](i)->NomeVia.c_str());
    if (boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio))
    {
      std::string strNomePatio = nomePatio[0].str().c_str();

      if (cboPatioInicio->Items->IndexOf(strNomePatio.c_str()) == -1)
      {
        cboPatioInicio->Items->Add(strNomePatio.c_str());
        cboPatioFim->Items->Add(strNomePatio.c_str());
      }
    }

    if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto)
    {
      t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
      cbosegmentoInicio->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
        (TObject*)&*FListaSBs_->operator[](i));
      cbosegmentoFim->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
        (TObject*)&*FListaSBs_->operator[](i));
    }

  }

  bool tSentidoSubindo = false;
  bool tSentidoDescendo = false;

  SetListaTrensRemovidos(FRestricao_->ListaTrensDesconsiderar);
  if(FRestricao_->ListaTiposTremDesconsiderar->Count > 0)
    SetListaTiposTremRemovidos(FRestricao_->ListaTiposTremDesconsiderar);
  else
    SetListaTiposTremRemovidos();


  if(pRestricao->RetencaoServer)
  {
    if(pRestricao->RetencaoServer->listaConexaoSB)
    for (int i = 0; i < pRestricao->RetencaoServer->listaConexaoSB->Count; i++)
    {
      domain::ConexaoSB* con = (domain::ConexaoSB*) pRestricao->RetencaoServer->listaConexaoSB->Objects[i];
      String descCon = con->sbOrigem->sb + "=>" + con->sb->sb;
      lswConxSelecionadas->AddItem(descCon, (TObject*)con);
      if(con->sb->KMInicio >= con->sbOrigem->KMInicio)
        tSentidoSubindo = true;
      if(con->sb->KMInicio < con->sbOrigem->KMInicio)
        tSentidoDescendo = true;
    }
    if(tSentidoSubindo && tSentidoDescendo) // Ambos
      cboSentidoConexoes->ItemIndex = 0;
    else if(tSentidoSubindo && !tSentidoDescendo) // Subindo
      cboSentidoConexoes->ItemIndex = 1;
    else if(!tSentidoSubindo && tSentidoDescendo) // Descendo
      cboSentidoConexoes->ItemIndex = 2;
    if(lswConxSelecionadas->Items->Count > 0)
      pgcDetalhes->ActivePage = TabConexoes;
    else
      pgcDetalhes->ActivePage = TabSBs;
  }
  else
  {
    pgcDetalhes->ActivePage = TabSBs;
  }
  if (!(FRestricao_->Tipo->ISPermiteOcupacao && FRestricao_->Tipo->ISPararTrem))
  {
    TabTrensRemovidos->Enabled = false;
    lswTrensDinsponiveis->Enabled = false;
    lswTrensRemovidos->Enabled = false;
    btnAddAllTrensRemovido->Enabled = false;
    btnAddTremRemovido->Enabled = false;
    btnAddAllTrensDisponiveis->Enabled = false;
    btnAddTremDisponivel->Enabled = false;
  }

  CarregarSBsDisponiveis(&*pSBInicio, &*pSBFim);

  this->Caption = " (" + pRestricao->PID + (pRestricao->IDExterno.Length() > 0 ? String(" | " + pRestricao->IDExterno) : String("")) +   (pRestricao->icComportamentoOperacional == "" ? String(""): " | Cpto.: " + pRestricao->icComportamentoOperacional) + " )";

  //edtPID->Text = pRestricao->PID;
  //edtIDExterno->Text = pRestricao->IDExterno;

  std::string t_NomePatio = TUteis::narrow(pSBInicio->CodigoSegmento.c_str());
  std::string regexPatio2 = "(^|-)[A-Z]{3}";
  boost::regex getNomePatio2(regexPatio2);
  if (boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio2))
  {
    std::string strNomePatio  = nomePatio[0].str().c_str();
    strNomePatio              = strNomePatio.substr(strNomePatio.find("-") + 1, 3);
    cboPatioInicio->ItemIndex = cboPatioInicio->Items->IndexOf(strNomePatio.c_str());
  }

  t_NomePatio = TUteis::narrow(pSBFim->CodigoSegmento.c_str());
  if (boost::regex_search(t_NomePatio.c_str(), nomePatio, getNomePatio2))
  {
    std::string strNomePatio = nomePatio[0].str().c_str();
    strNomePatio             = strNomePatio.substr(strNomePatio.find("-") + 1, 3);
    cboPatioFim->ItemIndex   = cboPatioFim->Items->IndexOf(strNomePatio.c_str());
    if (cboPatioFim->ItemIndex != -1)
      cboPatioFimChange(this);
  }

  if(pRestricao->DataMinInicioOriginal > TDateTime(0))
  {
    medDataInicioOrig->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataMinInicioOriginal.DateTimeString());
    medHoraInicioOrig->Text = FormatDateTime("hh:mm", pRestricao->DataMinInicioOriginal.DateTimeString());
  }
  else
  {
		medDataInicioOrig->Text = "  /  /    ";
		medDataInicioOrig->Text = "  :  ";
  }
  if(pRestricao->DataMaxFimOriginal > TDateTime(0))
  {
    medDataFimOrig->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataMaxFimOriginal.DateTimeString());
    medHoraFimOrig->Text = FormatDateTime("hh:mm", pRestricao->DataMaxFimOriginal.DateTimeString());
  }
  else
  {
    medDataFimOrig->Text = "  /  /    ";
    medHoraFimOrig->Text = "  :  ";
  }

  if(pRestricao->DataMinInicio > TDateTime(0))
  {
    medDataMinInicio->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataMinInicio.DateTimeString());
    medHoraMinInicio->Text = FormatDateTime("hh:mm", pRestricao->DataMinInicio.DateTimeString());
  }
  else
  {
    medDataMinInicio->Text = "  /  /    ";
    medDataMinInicio->Text = "  :  ";
  }
  btnRestauraMinIniOriginal->Enabled =  pRestricao->DataMinInicioOriginal > TDateTime(0);

  medDataInicio->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataInicio.DateTimeString());
  medHoraInicio->Text = FormatDateTime("hh:mm", pRestricao->DataInicio.DateTimeString());

  if(pRestricao->DataMaxFim > TDateTime(0))
  {
    medDataMaxFim->Text     = FormatDateTime("dd/mm/yyyy", pRestricao->DataMaxFim.DateTimeString());
    medHoraMaxFim->Text     = FormatDateTime("hh:mm", pRestricao->DataMaxFim.DateTimeString());
  }
  else
  {
    medDataMaxFim->Text = "  /  /    ";
    medDataMaxFim->Text = "  :  ";
  }

  btnRestauraMaxFimOriginal->Enabled =  pRestricao->DataMaxFimOriginal > TDateTime(0);

  medDataFim->Text    = FormatDateTime("dd/mm/yyyy", pRestricao->DataFim.DateTimeString());
  medHoraFim->Text    = FormatDateTime("hh:mm", pRestricao->DataFim.DateTimeString());

  if (pRestricao->DataInicioReal > TDateTime(0))
  {
    medDataInicio->Enabled  = false;
    medHoraInicio->Enabled  = false;
    medDataInicioReal->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataInicioReal.DateTimeString());
    medHoraInicioReal->Text = FormatDateTime("hh:mm", pRestricao->DataInicioReal.DateTimeString());
  }
  else
  {
    medDataInicio->Enabled = true;
    medHoraInicio->Enabled = true;
  }

  if (pRestricao->DataFimReal > TDateTime(0))
  {
    medDataFimReal->Text = FormatDateTime("dd/mm/yyyy", pRestricao->DataFimReal.DateTimeString());
    medHoraFimReal->Text = FormatDateTime("hh:mm", pRestricao->DataFimReal.DateTimeString());
  }

  cboFiltroLocalAfetado->ItemIndex = pRestricao->FiltroLocalAfetado;
  medFiltroVia->Text = pRestricao->FiltroVia;

  if (pRestricao->Observacao == NULL)
    redObservacao->Text = "";
  else
    redObservacao->Text = pRestricao->Observacao;

  if (cboPatioInicio->ItemIndex != -1 && cboPatioFim->ItemIndex != -1)
  {
    cboPatioInicioChange(this);
  }

  cbosegmentoInicio->ItemIndex = cbosegmentoInicio->Items->IndexOf(pSBInicio->CodigoSegmento);
  cbosegmentoFim->ItemIndex = cbosegmentoFim->Items->IndexOf(pSBFim->CodigoSegmento);
  cbosegmentoInicioChange(this);

  FAlterouDataInicio_ = false;
  FAlterouDataFim_ = false;
  cboTipoRestricao->Enabled = FNovaRestricao_;

  medDataMinInicio->Enabled = !isCriandoRetencaoDinamica_; //true;
  medHoraMinInicio->Enabled = !isCriandoRetencaoDinamica_; // true;
  medDataMaxFim->Enabled = !isCriandoRetencaoDinamica_; // true;
  medHoraMaxFim->Enabled = !isCriandoRetencaoDinamica_; // true;

  // desabilitando campos para edio em registros j iniciados
  if(pRestricao->ISIniciada() || pRestricao->ISEncerrada())
  {
    medVelocidade->Enabled = false;
    cboPatioInicio->Enabled = false;
    cbosegmentoInicio->Enabled = false;
    cboPatioFim->Enabled = false;
    cbosegmentoFim->Enabled = false;
    medDataInicio->Enabled = false;
    medHoraInicio->Enabled = false;
    medDataInicioReal->Enabled = false;
    medHoraInicioReal->Enabled = false;
    medDataFim->Enabled = false;
    medHoraFim->Enabled = false;
    medDataFim->Enabled = false;
    medHoraFim->Enabled = false;
    medDataFimReal->Enabled = false;
    medHoraFimReal->Enabled = false;
    lswViasDisponiveis->Enabled = false;
    lswViasSelecionadas->Enabled = false;
    btnAdd->Enabled = false;
    btnAddAll->Enabled = false;
    btnRemoveAll->Enabled = false;
    brnRemove->Enabled = false;
		redObservacao->ReadOnly = true;
		redObservacao->Font->Color = clGrayText;
  }

  if(pRestricao->Trem != NULL)
  {
    lblMinInicio->Visible = true;
    medDataMinInicio->Visible = true;
    medHoraMinInicio->Visible = true;
    btnRestauraMinIniOriginal->Visible = true;
    lblMaxFim->Visible = true;
    medDataMaxFim->Visible = true;
    medHoraMaxFim->Visible = true;
    btnRestauraMaxFimOriginal->Visible = true;

    String tipoRef = pRestricao->ICComportamentoTremRef;
    if(tipoRef == "CI" && pRestricao->DataMinInicio > TDateTime(0))
    {
      tipoRef = "Data Mn. Incio Ativa";
    }
    else if(tipoRef == "CF" && pRestricao->DataMaxFim > TDateTime(0))
    {
      tipoRef = "Data Max. Fim Ativa";
    }
    else if(tipoRef == "CA" && pRestricao->DataMinInicio > TDateTime(0) && pRestricao->DataMaxFim > TDateTime(0))
    {
      tipoRef = "Datas Min. Incio e Max. Fim Ativas";
    }
    else
    {
      tipoRef = "Datas Min. Incio e Max. Fim DESATIVADAS";
    }

    medDataInicio->Enabled = false;
    medHoraInicio->Enabled = false;
    medDataFim->Enabled = !pRestricao->ISEncerrada();
    medHoraFim->Enabled = !pRestricao->ISEncerrada();

    gbxDatas->Caption = "Ligada ao trem: " + pRestricao->Trem->Prefixo + " | " + tipoRef;
    gbxDatas->Color = clWebPapayaWhip;
    gbxDatas->Refresh();
  }

  if( TTPFormsManager::getInstance()->ShowVisualizador)
  {
    gbxDatas->Enabled = false;
    TabSBs->Enabled = false;
    TabConexoes->Enabled = false;
    TabTrensRemovidos->Enabled = false;
    GroupBox1->Enabled = false;
    GroupBox2->Enabled = false;
    GroupBox4->Enabled = false;
    btnAtualizarOportunidades->Enabled = false;
    btnAtualizarOportunidades->Visible = false;
  }

  if (isCriandoRetencaoDinamica_)
  {
    medDataFim->Text = FormatDateTime("dd/mm/yyyy", TTPFormsManager::getInstance()->Data.DateTimeString());
    medHoraFim->Text = "  :  ";
    medDataInicio->Text = FormatDateTime("dd/mm/yyyy", TTPFormsManager::getInstance()->Data.DateTimeString());
    medHoraInicio->Text = "  :  ";

    if(pRestricao->ListaConexoes)
    for (int i = 0; i < pRestricao->ListaConexoes->Count; i++)
    {
      domain::ConexaoSB* con = (domain::ConexaoSB*) pRestricao->ListaConexoes->Objects[i];
      String descCon = con->sbOrigem->sb + "=>" + con->sb->sb;
      lswConxSelecionadas->AddItem(descCon, (TObject*)con);
      if(con->sb->KMInicio >= con->sbOrigem->KMInicio)
        tSentidoSubindo = true;
      if(con->sb->KMInicio < con->sbOrigem->KMInicio)
        tSentidoDescendo = true;
    }
    if(tSentidoSubindo && tSentidoDescendo) // Ambos
      cboSentidoConexoes->ItemIndex = 0;
    else if(tSentidoSubindo && !tSentidoDescendo) // Subindo
      cboSentidoConexoes->ItemIndex = 1;
    else if(!tSentidoSubindo && tSentidoDescendo) // Descendo
      cboSentidoConexoes->ItemIndex = 2;
    if(lswConxSelecionadas->Items->Count > 0)
      pgcDetalhes->ActivePage = TabConexoes;
    else
      pgcDetalhes->ActivePage = TabSBs;

  }

  // listar Oportunidades
  carregarOportunidades(NULL);

}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnOkClick(TObject *Sender)
{
 String typeForm = "Gerar";
 bool erroentrada = false;

	try
	{

			TDateTime tempDateTime; // Varivel temporria para armazenar o valor convertido

			// Validao de campos de data
			if (!(medDataInicioOrig->Text == "  /  /    ") && !TryStrToDate(medDataInicioOrig->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataMinInicio->Text == "  /  /    ") && !TryStrToDate(medDataMinInicio->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataInicio->Text == "  /  /    ") && !TryStrToDate(medDataInicio->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataInicioReal->Text == "  /  /    ") && !TryStrToDate(medDataInicioReal->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataFimOrig->Text == "  /  /    ") && !TryStrToDate(medDataFimOrig->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataMaxFim->Text == "  /  /    ") && !TryStrToDate(medDataMaxFim->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataFim->Text == "  /  /    ") && !TryStrToDate(medDataFim->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medDataFimReal->Text == "  /  /    ") && !TryStrToDate(medDataFimReal->Text, tempDateTime))
			{
					erroentrada = true;
			}

			// Validao de campos de hora
			if (!(medHoraInicioOrig->Text == "  :  ") && !TryStrToTime(medHoraInicioOrig->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraMinInicio->Text == "  :  ") && !TryStrToTime(medHoraMinInicio->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraInicio->Text == "  :  ") && !TryStrToTime(medHoraInicio->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraInicioReal->Text == "  :  ") && !TryStrToTime(medHoraInicioReal->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraFimOrig->Text == "  :  ") && !TryStrToTime(medHoraFimOrig->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraMaxFim->Text == "  :  ") && !TryStrToTime(medHoraMaxFim->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraFim->Text == "  :  ") && !TryStrToTime(medHoraFim->Text, tempDateTime))
			{
					erroentrada = true;
			}

			if (!(medHoraFimReal->Text == "  :  ") && !TryStrToTime(medHoraFimReal->Text, tempDateTime))
			{
					erroentrada = true;
			}

			// Lana exceo caso algum campo seja invlido
			if (erroentrada)
			{
					throw Exception("Data ou Hora com formato errado. Favor verificar.");
			}
	}
	catch (Exception& e)
	{
			// Exibe mensagem de erro ao usurio
			Alerta(e.Message);
      ModalResult = mrNone;
	}

	if (!erroentrada)
	{
		try
		{
			if( TTPFormsManager::getInstance()->ShowVisualizador)
			return;

			if (FRestricao_ != NULL)
			{
				if(FRestricao_->ISIniciada() || FRestricao_->ISEncerrada())
					throw Exception("Restrio j iniciada ou finalizada. No  possvel a gravao da alterao!");

				if (lswViasSelecionadas->Items->Count == 0)
					throw Exception("Nenhuma via foi selecionada!");

				TTPSBListPtr newList = NULL;

				if (FRestricao_->SBsRestricao == NULL)
				{
					newList                   = TTPSBListPtr(new TTPSBList());
					FRestricao_->SBsRestricao = newList;
				}

				FRestricao_->SBsRestricao->clear();

				std::list<int>listaSeg;
				for (int i = 0; i < lswViasSelecionadas->Items->Count; i++)
				{
					TTPSBPtr t_SB = FListaSBs_->get(lswViasSelecionadas->Items->Item[i]->Caption);
					if (!t_SB)
					{
						t_SB = TTPFormsManager::getInstance()->SBs->get(lswViasSelecionadas->Items->Item[i]->Caption);
						// throw Exception ("No encontrei a SB: "+lswViasSelecionadas->Items->Item[i]->Caption);
					}

					FRestricao_->SBsRestricao->add(t_SB->NomeVia, t_SB);
					listaSeg.push_back(t_SB->Seqsegmento);
				}

				FRestricao_->ListaConexoes->Clear();
				for (int i = 0; i < lswConxSelecionadas->Items->Count; i++)
				{
					domain::ConexaoSB* con = (domain::ConexaoSB*)lswConxSelecionadas->Items->Item[i]->Data;
					FRestricao_->ListaConexoes->Add(con->PIDConexao);
				}

				FRestricao_->ListaTrensDesconsiderar->Clear();
				for (int j = 0; j < lswTrensRemovidos->Items->Count; j++)
				{
					TTPTrem* trem = (TTPTrem*)lswTrensRemovidos->Items->Item[j]->Data;
					FRestricao_->ListaTrensDesconsiderar->Add(trem->PID);
				}

				FRestricao_->ListaTiposTremDesconsiderar->Clear();
				for (int j = 0; j < lswTiposRemovidos->Items->Count; j++)
				{
					TTPTipoTrem* tremTipo = (TTPTipoTrem*)lswTiposRemovidos->Items->Item[j]->Data;
					FRestricao_->ListaTiposTremDesconsiderar->Add(tremTipo->PID);
				}

				listaSeg.sort();
				if(!(FRestricao_->Tipo->ISPararTrem && FRestricao_->Tipo->ISPermiteOcupacao))      //Se for Reteno, no valida segmentos em sequencia
				{
					int tSeg = *(listaSeg.begin());
					for (std::list<int>::iterator it = listaSeg.begin(); it != listaSeg.end(); it++)
					{
						int tSegComp = *it;
						if (tSegComp == tSeg || tSegComp == tSeg + 1)
						{
							tSeg = *it;
						}
						else
						{
							throw Exception("As vias selecionadas esto fora da sequencia de segmentos!");
						}
					}
				}
				if (FRestricao_->Tipo != NULL && FRestricao_->Tipo->ISReducaoVelocidade)
				{
					if (cboTipoRestricao->ItemIndex == -1)
						throw Exception("Tipo restrio invlido!");
					else if(FRestricao_->Tipo == NULL)
					{
						TTPTipoRestricao* tipoRest = (TTPTipoRestricao*)cboTipoRestricao->Items->Objects[cboTipoRestricao->ItemIndex];
						FRestricao_->Tipo = TTPFormsManager::getInstance()->TiposRestricao->get(tipoRest->Codigo);
					}

					int valor;
					if (medVelocidade->Text == "__" || !TryStrToInt(medVelocidade->Text, valor) || valor == 0)
						throw Exception("Velocidade invlida!");
				}
				else if(FRestricao_->Tipo == NULL)
				{
					throw Exception("Tipo Restrio no informado!");
				}

				FRestricao_->IsAlteradoUsuario = true;
				if(medDataMinInicio->Text != "  /  /    ")
					FRestricao_->DataMinInicio = StrToDateTime(medDataMinInicio->Text + " " + medHoraMinInicio->Text);
				if(medDataMaxFim->Text != "  /  /    ")
					FRestricao_->DataMaxFim    = StrToDateTime(medDataMaxFim->Text + " " + medHoraMaxFim->Text);

				FRestricao_->DataInicio = StrToDateTime(medDataInicio->Text + " " + medHoraInicio->Text);
				FRestricao_->DataFim    = StrToDateTime(medDataFim->Text + " " + medHoraFim->Text);

				// Somente para restries novas
				if (FRestricao_->PID.Length() < 12)
				{
					FRestricao_->DataInicioOriginal = FRestricao_->DataInicio;
					FRestricao_->DataFimOriginal    = FRestricao_->DataFim;
				}
				else
				{
					if (FAlterouDataInicio_)
						FRestricao_->DataInicioOriginal = FRestricao_->DataInicio;
					if (FAlterouDataFim_)
						FRestricao_->DataFimOriginal = FRestricao_->DataFim;
				}

				FRestricao_->Observacao = redObservacao->Text;
				FRestricao_->ISRestricaoInconsistente = false;

				FRestricao_->FiltroLocalAfetado = cboFiltroLocalAfetado->ItemIndex;
				FRestricao_->FiltroVia          = medFiltroVia->Text;
				if (FRestricao_->Tipo->ISReducaoVelocidade)
					FRestricao_->VMA = medVelocidade->Text.ToInt();
				else
					FRestricao_->VMA = 0;

				if (FRestricao_->DataInicioReal <= TDateTime(0) && FRestricao_->DataInicio < TTPFormsManager::getInstance()->Data)
				{
					throw Exception("A data Inicio no pode ser inferior a data atual");
				}

				if (FRestricao_->DataFim < FRestricao_->DataInicio)
				{
					throw Exception("A data final no pode ser menor do que a data inicial");
				}

				/*
				if (FRestricao_->DataMaxFim > TDateTime(0) && FRestricao_->DataMaxFim < FRestricao_->DataFim)
				{
					throw Exception("A data mxima final no pode ser menor do que a data final");
				}

				if (FRestricao_->DataMinInicio > TDateTime(0) && FRestricao_->DataMinInicio > FRestricao_->DataInicio)
				{
					throw Exception("A data mnima de incio no pode ser maior do que a data inicial");
				}
				*/
				if (FRestricao_->DataMinInicio > TDateTime(0) && FRestricao_->DataMaxFim > TDateTime(0)
							&& FRestricao_->DataMaxFim < FRestricao_->DataMinInicio)
				{
					throw Exception("A data mxima final no pode ser menor do que a data mnima inicial");
				}

				TStringList *t_listServer = new TStringList();
				for (int z = 0; z < FRestricao_->SBsRestricao->count(); z++)
				{
					t_listServer->Add(FRestricao_->SBsRestricao->operator[](z)->NomeVia);
				}

				algorithm::CoreTMPlanner *core = algorithm::CoreTMPlanner::getInstance();
				if (FNovaRestricao_)
				{
					typeForm = "Criar";
					FRestricao_->PID = core->CriarRestricao(FRestricao_->DataInicio, FRestricao_->DataFim, t_listServer,
						FRestricao_->Tipo->Codigo, FRestricao_->VMA,
						FRestricao_->DataInicioReal, FRestricao_->DataFimReal, FRestricao_->ListaConexoes, FRestricao_->DataMinInicio, FRestricao_->DataMaxFim,3
						,FRestricao_->ListaTrensDesconsiderar, FRestricao_->ListaTiposTremDesconsiderar);
						TUteis::gravarLog("Cria Restrio - Tipo: " + FRestricao_->Tipo->Codigo + " - PID: " + FRestricao_->PID);
					if(FRestricao_->Tipo->ISPararTrem && FRestricao_->Tipo->ISPermiteOcupacao)
					{
						TStringList *t_restricoes = core->getMalha()->restricoesMalha;
						int indexOF = t_restricoes->IndexOf(FRestricao_->PID);
						if(indexOF > -1)
							FRestricao_->RetencaoServer = (domain::RetencaoSB*)t_restricoes->Objects[indexOF];
					}
				}
				else{
					typeForm = "Editar";
							core->AlterarRestricao(FRestricao_->DataInicio, FRestricao_->DataFim, t_listServer, FRestricao_->PID,
											FRestricao_->VMA, FRestricao_->DataInicioReal, FRestricao_->DataFimReal, FRestricao_->ListaConexoes, FRestricao_->DataMinInicio
															, FRestricao_->DataMaxFim,3, FRestricao_->ListaTrensDesconsiderar, FRestricao_->ListaTiposTremDesconsiderar);
							TUteis::gravarLog("Edita Restrio - Tipo: " + FRestricao_->Tipo->Codigo + " - PID: " + FRestricao_->PID);

				}
				delete t_listServer;
			}
		}
		catch (Exception& e)
		{
			Alerta(e.Message);
			TUteis::gravarLog("Falha ao " + typeForm + " Restrio - Tipo: " + FRestricao_->Tipo->Codigo + " - PID: " + FRestricao_->PID);
			ModalResult = mrNone;
		}
	}
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnAddClick(TObject *Sender)
{
  try
  {

    TStringList *t_deletados = new TStringList();

    for (int i = 0; i < lswViasDisponiveis->Items->Count; i++)
    {
      if (lswViasDisponiveis->Items->Item[i]->Selected)
      {
        lswViasSelecionadas->AddItem(lswViasDisponiveis->Items->Item[i]->Caption, lswViasDisponiveis->Items->Item[i]);
        t_deletados->Add(lswViasDisponiveis->Items->Item[i]->Caption);
      }
    }

    // Apaga os item selecinados
    for (int z = 0; z < t_deletados->Count; z++)
    {
      for (int i = 0; i < lswViasDisponiveis->Items->Count; i++)
      {
        if (lswViasDisponiveis->Items->Item[i]->Caption == t_deletados->operator[](z))
        {
          lswViasDisponiveis->Items->Item[i]->Delete();
          break;
        }
      }
    }
    delete t_deletados;
  }
  catch (...)
  {
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnAddAllClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswViasDisponiveis->Items->Count; i++)
    {
      lswViasSelecionadas->AddItem(lswViasDisponiveis->Items->Item[i]->Caption, lswViasDisponiveis->Items->Item[i]);
    }
    lswViasDisponiveis->Items->Clear();
  }
  catch (...)
  {
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnRemoveAllClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswViasSelecionadas->Items->Count; i++)
    {
      lswViasDisponiveis->AddItem(lswViasSelecionadas->Items->Item[i]->Caption, lswViasSelecionadas->Items->Item[i]);
    }
    lswViasSelecionadas->Items->Clear();
  }
  catch (...)
  {
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::brnRemoveClick(TObject *Sender)
{
  try
  {

    TStringList *t_deletados = new TStringList();

    for (int i = 0; i < lswViasSelecionadas->Items->Count; i++)
    {
      if (lswViasSelecionadas->Items->Item[i]->Selected)
      {
        lswViasDisponiveis->AddItem(lswViasSelecionadas->Items->Item[i]->Caption, lswViasSelecionadas->Items->Item[i]);
        t_deletados->Add(lswViasSelecionadas->Items->Item[i]->Caption);
      }
    }

    // Apaga os item selecinados
    for (int z = 0; z < t_deletados->Count; z++)
    {
      for (int i = 0; i < lswViasSelecionadas->Items->Count; i++)
      {
        if (lswViasSelecionadas->Items->Item[i]->Caption == t_deletados->operator[](z))
        {
          lswViasSelecionadas->Items->Item[i]->Delete();
          break;
        }
      }
    }
    delete t_deletados;
  }
  catch (...)
  {
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::cbosegmentoInicioChange(TObject *Sender)
{

  // Revisao 17/08
  btnRemoveAllClick(this);

  lswViasDisponiveis->Clear();
  lswConxDisponiveis->Clear();
  if (cbosegmentoInicio->ItemIndex != -1 && cbosegmentoFim->ItemIndex != -1)
  {
    TTPSB *t_inicio = (TTPSB*)cbosegmentoInicio->Items->Objects[cbosegmentoInicio->ItemIndex];
    TTPSB *t_fim    = (TTPSB*)cbosegmentoFim->Items->Objects[cbosegmentoFim->ItemIndex];
    CarregarSBsDisponiveis(t_inicio, t_fim);
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormRestricao::cbosegmentoFimChange(TObject *Sender)
{

  // Revisao 17/08
  btnRemoveAllClick(this);

  lswViasDisponiveis->Clear();
  if (cbosegmentoInicio->ItemIndex != -1 && cbosegmentoFim->ItemIndex != -1)
  {
    TTPSB *t_inicio = (TTPSB*)cbosegmentoInicio->Items->Objects[cbosegmentoInicio->ItemIndex];
    TTPSB *t_fim    = (TTPSB*)cbosegmentoFim->Items->Objects[cbosegmentoFim->ItemIndex];
    CarregarSBsDisponiveis(t_inicio, t_fim);
  }

}

// ---------------------------------------------------------------------------
void __fastcall TFormRestricao::CarregarSBsDisponiveis(TTPSB* pSBInicio, TTPSB* pSBFim, int pVia)
{

  String t_Seguimeto    = "";
  int t_SeguimetoInicio = pSBInicio->Seqsegmento;
  int t_SeguimetoFim    = pSBFim->Seqsegmento;

  TStringList *TrensDisponiveis = new TStringList();

  if (t_SeguimetoInicio > t_SeguimetoFim)
  {
    int t_troca     = t_SeguimetoInicio;
    t_SeguimetoInicio = t_SeguimetoFim;
    t_SeguimetoFim = t_troca;
  }

  lswConxDisponiveis->Items->Clear();
  lswTrensDinsponiveis->Items->Clear();

  for (int i = 0; i < FListaSBs_->count(); i++)
  {
    if(FListaSBs_->operator[](i)->Ramal != pSBInicio->Ramal && FListaSBs_->operator[](i)->Ramal != pSBFim->Ramal)
      continue;

    if (FListaSBs_->operator[](i)->Seqsegmento >= t_SeguimetoInicio && FListaSBs_->operator[](i)->Seqsegmento <=
      t_SeguimetoFim && (pVia == 0 || pVia != 0 && FListaSBs_->operator[](i)->NumeroLinha == pVia))
    {
      if (FRestricao_->SBsRestricao == NULL || (FRestricao_->SBsRestricao != NULL && FRestricao_->SBsRestricao->IndexOf
        (FListaSBs_->operator[](i)->NomeVia) == -1))
      {
        lswViasDisponiveis->AddItem(FListaSBs_->operator[](i)->NomeVia, (TObject*)&*FListaSBs_->operator[](i));
      }

      for(int l = 0; l < FListaSBs_->operator[](i)->ListaMovimentosSB->Count; l++)
      {
        TTPMovimento *movimento = (TTPMovimento *)FListaSBs_->operator[](i)->ListaMovimentosSB->Objects[l];

        if(!movimento->ServerSegTremRealizado && TrensDisponiveis->IndexOf(movimento->Trem->PID)==-1)
        {
           TrensDisponiveis->AddObject(movimento->Trem->PID, (TObject *)movimento->Trem);
           if(!isTremRemovido(movimento->Trem->Prefixo))
           {
              lswTrensDinsponiveis->AddItem(movimento->Trem->Prefixo, (TObject*)movimento->Trem);
           }
        }
      }

      if(FListaSBs_->operator[](i)->SBServer)
      {
        for (int j=0; j<FListaSBs_->operator[](i)->SBServer->listaConexaoSB->Count; j++)
        {
          domain::ConexaoSB* con = (domain::ConexaoSB*) FListaSBs_->operator[](i)->SBServer->listaConexaoSB->Objects[j];
          if(con)
          {
            String descCon = con->sbOrigem->sb + "=>" + con->sb->sb;
            if(!isConxSelecionada(descCon))
              lswConxDisponiveis->AddItem(descCon, (TObject*)con);
          }
        }
      }
    }
  }

  if (!FRestricao_.isNull() &&  FRestricao_->SBsRestricao != NULL)
  {
    for (int i = 0; i < FRestricao_->SBsRestricao->count(); i++)
    {
      if(!isSBSelecionada(FRestricao_->SBsRestricao->operator[](i)->NomeVia))
        lswViasSelecionadas->AddItem(FRestricao_->SBsRestricao->operator[](i)->NomeVia,
          (TObject*)&*FRestricao_->SBsRestricao->operator[](i));
    }
  }

  delete TrensDisponiveis;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::cboPatioInicioChange(TObject *Sender)
{
  String t_Seguimeto = "";

  // Revisao 17/08
  btnRemoveAllClick(this);

  cbosegmentoInicio->Items->Clear();

  if (cboPatioInicio->Text.Length() < 3)
  {
    for (int i = 0; i < FListaSBs_->count(); i++)
    {
      if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto)
      {
        t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
        cbosegmentoInicio->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
          (TObject*)&*FListaSBs_->operator[](i));
      }
    }
  }
  else
  {
    for (int i = 0; i < FListaSBs_->count(); i++)
    {
      if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto && FListaSBs_->operator[](i)->CodigoSegmento.Pos
        (cboPatioInicio->Text) > 0)
      {
        t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
        cbosegmentoInicio->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
          (TObject*)&*FListaSBs_->operator[](i));
      }
    }
  }
  cbosegmentoInicio->Text = "";
  cbosegmentoInicio->ItemIndex = -1;
  lswViasDisponiveis->Clear();

}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::cboPatioFimChange(TObject *Sender)
{

  String t_Seguimeto = "";
  cbosegmentoFim->Items->Clear();

  // Revisao 17/08
  btnRemoveAllClick(this);

  if (cboPatioFim->Text.Length() < 3)
  {
    for (int i = 0; i < FListaSBs_->count(); i++)
    {
      if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto)
      {
        t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
        cbosegmentoFim->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
          (TObject*)&*FListaSBs_->operator[](i));
      }
    }
  }
  else
  {
    for (int i = 0; i < FListaSBs_->count(); i++)
    {
      if (FListaSBs_->operator[](i)->CodigoSegmento != t_Seguimeto && FListaSBs_->operator[](i)->CodigoSegmento.Pos
        (cboPatioFim->Text) > 0)
      {
        t_Seguimeto = FListaSBs_->operator[](i)->CodigoSegmento;
        cbosegmentoFim->Items->AddObject(FListaSBs_->operator[](i)->CodigoSegmento,
          (TObject*)&*FListaSBs_->operator[](i));
      }
    }
  }

  cbosegmentoFim->Text = "";
  cbosegmentoFim->ItemIndex = -1;
  lswViasDisponiveis->Clear();

}

// ---------------------------------------------------------------------------
void __fastcall TFormRestricao::cboFiltroLocalAfetadoChange(TObject *Sender)
{
  medFiltroVia->Enabled = cboFiltroLocalAfetado->ItemIndex == 2;
  if (cboFiltroLocalAfetado->ItemIndex != 2)
    medFiltroVia->Clear();
  if (cboFiltroLocalAfetado->ItemIndex == 1)
    btnAddAllClick(this);
  else
    btnRemoveAllClick(this);
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medFiltroViaChange(TObject *Sender)
{

  lswViasDisponiveis->Clear();

  if (medFiltroVia->Text.Trim() != "" && medFiltroVia->Text.TrimLeft().TrimRight().ToInt() > 0)
  {
    if (cbosegmentoInicio->ItemIndex != -1 && cbosegmentoFim->ItemIndex != -1)
    {
      TTPSB *t_inicio = (TTPSB*)cbosegmentoInicio->Items->Objects[cbosegmentoInicio->ItemIndex];
      TTPSB *t_fim    = (TTPSB*)cbosegmentoFim->Items->Objects[cbosegmentoFim->ItemIndex];
      CarregarSBsDisponiveis(t_inicio, t_fim,
        medFiltroVia->Text.TrimLeft().TrimRight().ToInt());
      btnAddAllClick(this);
    }
  }
  else
  {
    if (cbosegmentoInicio->ItemIndex != -1 && cbosegmentoFim->ItemIndex != -1)
    {
      TTPSB *t_inicio = (TTPSB*)cbosegmentoInicio->Items->Objects[cbosegmentoInicio->ItemIndex];
      TTPSB *t_fim    = (TTPSB*)cbosegmentoFim->Items->Objects[cbosegmentoFim->ItemIndex];
      CarregarSBsDisponiveis(t_inicio, t_fim);
    }
  }

}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::lswViasDisponiveisDblClick(TObject *Sender)
{
  if (lswViasDisponiveis->Selected)
  {
    lswViasSelecionadas->AddItem(lswViasDisponiveis->Selected->Caption, lswViasDisponiveis->Selected);
    lswViasDisponiveis->Items->Delete(lswViasDisponiveis->ItemIndex);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::lswViasSelecionadasDblClick(TObject *Sender)
{
  if (lswViasSelecionadas->Selected)
  {
    lswViasDisponiveis->AddItem(lswViasSelecionadas->Selected->Caption, lswViasSelecionadas->Selected);
    lswViasSelecionadas->Items->Delete(lswViasSelecionadas->ItemIndex);
  }
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medDataInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)

{
  String temp = TUteis::preencherData(medDataInicio->Text, Key, (TTPTipoFormatacaoCampoDataHora)1);
  if (temp.Length() > 0)
    medDataInicio->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medDataFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)

{
  String temp = TUteis::preencherData(medDataFim->Text, Key, (TTPTipoFormatacaoCampoDataHora)1);
  if (temp.Length() > 0)
    medDataFim->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medHoraInicioKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraInicio->Text, Key, (TTPTipoFormatacaoCampoDataHora)2);
  if (temp.Length() > 0)
    medHoraInicio->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medHoraFimKeyDown(TObject *Sender, WORD &Key, TShiftState Shift)
{
  String temp = TUteis::preencherData(medHoraFim->Text, Key, (TTPTipoFormatacaoCampoDataHora)2);
  if (temp.Length() > 0)
    medHoraFim->Text = temp;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medDataInicioChange(TObject *Sender)
{
  FAlterouDataInicio_ = true;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medHoraInicioChange(TObject *Sender)
{
  FAlterouDataInicio_ = true;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medDataFimChange(TObject *Sender)
{
  FAlterouDataFim_ = true;
}
// ---------------------------------------------------------------------------

void __fastcall TFormRestricao::medHoraFimChange(TObject *Sender)
{
  FAlterouDataFim_ = true;
}
// ---------------------------------------------------------------------------
void __fastcall TFormRestricao::btnRestauraMinIniOriginalClick(TObject *Sender)
{
  if(FRestricao_ && FRestricao_->DataMinInicioOriginal > TDateTime(0))
  {
    medDataMinInicio->Text = FormatDateTime("dd/mm/yyyy", FRestricao_->DataMinInicioOriginal .DateTimeString());
    medHoraMinInicio->Text = FormatDateTime("hh:mm", FRestricao_->DataMinInicioOriginal.DateTimeString());
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnRestauraMaxFimOriginalClick(TObject *Sender)
{
  if(FRestricao_ && FRestricao_->DataMaxFimOriginal > TDateTime(0))
  {
    medDataMaxFim->Text    = FormatDateTime("dd/mm/yyyy", FRestricao_->DataMaxFimOriginal.DateTimeString());
    medHoraMaxFim->Text    = FormatDateTime("hh:mm", FRestricao_->DataMaxFimOriginal.DateTimeString());
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnAddConClick(TObject *Sender)
{
  try
  {

    TStringList *t_deletados = new TStringList();

    for (int i = 0; i < lswConxDisponiveis->Items->Count; i++)
    {
      if (lswConxDisponiveis->Items->Item[i]->Selected)
      {
        lswConxSelecionadas->AddItem(lswConxDisponiveis->Items->Item[i]->Caption, (TObject*)lswConxDisponiveis->Items->Item[i]->Data);
        t_deletados->Add(lswConxDisponiveis->Items->Item[i]->Caption);
      }
    }

    // Apaga os item selecinados
    for (int z = 0; z < t_deletados->Count; z++)
    {
      for (int i = 0; i < lswConxDisponiveis->Items->Count; i++)
      {
        if (lswConxDisponiveis->Items->Item[i]->Caption == t_deletados->operator[](z))
        {
          lswConxDisponiveis->Items->Item[i]->Delete();
          break;
        }
      }
    }
    delete t_deletados;
  }
  catch (...)
  {
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnAddAllConClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswConxDisponiveis->Items->Count; i++)
    {
      lswConxSelecionadas->AddItem(lswConxDisponiveis->Items->Item[i]->Caption, (TObject*)lswConxDisponiveis->Items->Item[i]->Data);
    }
    lswConxDisponiveis->Items->Clear();
  }
  catch (...)
  {
  }

}
//---------------------------------------------------------------------------

void __fastcall TFormRestricao::btnRemoveAllConClick(TObject *Sender)
{
  try
  {
    for (int i = 0; i < lswConxSelecionadas->Items->Count; i++)
    {
      lswConxDisponiveis->AddItem(lswConxSelecionadas->Items->Item[i]->Caption, (TObject*)lswConxSelecionadas->Items->Item[i]->Data);
    }
    lswConxSelecionadas->Items->Clear();
  }
  catch (...)
  {
  }
}
//---------------------------------------------------------------------------

void __fastcall TFormRestricao::brnRemoveConClick(TObject *Sender)
{
  try
  {

    TStringList *t_deletados = new TStringList();

    for (int i = 0; i < lswConxSelecionadas->It